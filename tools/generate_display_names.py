#!/usr/bin/env python3
"""
generate_display_names.py - One-time script to generate ItemDisplayNames.h

This script joins data from:
  1. ItemName.cfg - internal_name -> display_name mapping
  2. GameConfigs.db (items table) - internal_name -> item_id mapping

Output: ItemDisplayNames.h with item_id -> display_name map

Usage:
    python generate_display_names.py

The script expects to be run from the Helbreath-3.82 directory or will
look for files relative to its own location.
"""

import os
import re
import sqlite3
import sys
from pathlib import Path


def find_project_root():
    """Find the Helbreath-3.82 project root directory."""
    # Try from script location
    script_dir = Path(__file__).parent

    # Script is in Tools/, project root is parent
    project_root = script_dir.parent
    if (project_root / "Binaries").exists():
        return project_root

    # Try current working directory
    cwd = Path.cwd()
    if (cwd / "Binaries").exists():
        return cwd

    # Try parent of cwd
    if (cwd.parent / "Binaries").exists():
        return cwd.parent

    raise FileNotFoundError(
        "Could not find project root. Run from Helbreath-3.82 directory "
        "or the Tools subdirectory."
    )


def parse_itemname_cfg(cfg_path):
    """
    Parse ItemName.cfg to get internal_name -> display_name mapping.

    Format: Item=internal_name============display_name=
    The '=' padding is for alignment and should be stripped.
    """
    name_map = {}

    with open(cfg_path, 'r', encoding='utf-8', errors='replace') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or not line.startswith('Item='):
                continue

            # Remove 'Item=' prefix
            content = line[5:]

            # Split on '=' and filter empty parts
            parts = [p for p in content.split('=') if p.strip()]

            if len(parts) >= 2:
                internal_name = parts[0].strip()
                display_name = parts[-1].strip()

                if internal_name and display_name:
                    name_map[internal_name] = display_name
            elif len(parts) == 1:
                # Same name for internal and display
                internal_name = parts[0].strip()
                if internal_name:
                    name_map[internal_name] = internal_name

    return name_map


def get_items_from_db(db_path):
    """
    Query GameConfigs.db to get internal_name -> item_id mapping.
    """
    items = {}

    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute("SELECT item_id, name FROM items ORDER BY item_id")
    for row in cursor.fetchall():
        item_id = row[0]
        internal_name = row[1]
        if internal_name:
            items[internal_name] = item_id

    conn.close()
    return items


def escape_cpp_string(s):
    """Escape a string for use in C++ string literal."""
    result = []
    for c in s:
        if c == '\\':
            result.append('\\\\')
        elif c == '"':
            result.append('\\"')
        elif c == '\n':
            result.append('\\n')
        elif c == '\r':
            result.append('\\r')
        elif c == '\t':
            result.append('\\t')
        elif ord(c) < 32 or ord(c) > 126:
            result.append(f'\\x{ord(c):02x}')
        else:
            result.append(c)
    return ''.join(result)


def generate_header(id_to_name, name_to_display, output_path):
    """Generate ItemDisplayNames.h with the item_id -> display_name map and name-based lookup."""

    # Sort by item_id for consistent output
    sorted_items = sorted(id_to_name.items())
    sorted_names = sorted(name_to_display.items())

    header = '''// ItemDisplayNames.h - Auto-generated item_id -> display_name map
//
// DO NOT EDIT - Generated by Tools/generate_display_names.py
// Source: ItemName.cfg + GameConfigs.db
//
// Regenerate with:
//   cd Helbreath-3.82
//   python Tools/generate_display_names.py
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <unordered_map>
#include <string>

namespace hb {
namespace item {

/**
 * Get the static display name map.
 * Maps item_id (short) to localized display name (string).
 */
inline const std::unordered_map<short, std::string>& GetDisplayNameMap()
{
    static const std::unordered_map<short, std::string> s_displayNames = {
'''

    # Add entries
    entries = []
    for item_id, display_name in sorted_items:
        escaped_name = escape_cpp_string(display_name)
        entries.append(f'        {{ {item_id}, "{escaped_name}" }}')

    header += ',\n'.join(entries)

    header += '''
    };
    return s_displayNames;
}

/**
 * Look up display name by item_id.
 * @param itemId The item ID to look up
 * @return Display name string, or nullptr if not found
 */
inline const char* GetDisplayName(short itemId)
{
    const auto& map = GetDisplayNameMap();
    auto it = map.find(itemId);
    return (it != map.end()) ? it->second.c_str() : nullptr;
}

/**
 * Look up display name by item_id with fallback.
 * @param itemId The item ID to look up
 * @param fallback Value to return if not found
 * @return Display name string, or fallback if not found
 */
inline const char* GetDisplayNameOr(short itemId, const char* fallback)
{
    const char* name = GetDisplayName(itemId);
    return name ? name : fallback;
}

'''

    # Add name-based lookup map
    header += '''
/**
 * Get the internal_name -> display_name map.
 * Used for looking up display names when only the internal name is available.
 */
inline const std::unordered_map<std::string, std::string>& GetDisplayNameByNameMap()
{
    static const std::unordered_map<std::string, std::string> s_nameToDisplay = {
'''

    # Add name -> display entries
    name_entries = []
    for internal_name, display_name in sorted_names:
        escaped_internal = escape_cpp_string(internal_name)
        escaped_display = escape_cpp_string(display_name)
        name_entries.append(f'        {{ "{escaped_internal}", "{escaped_display}" }}')

    header += ',\n'.join(name_entries)

    header += '''
    };
    return s_nameToDisplay;
}

/**
 * Look up display name by internal item name.
 * @param internalName The internal item name (as stored in m_cName)
 * @return Display name string, or nullptr if not found
 */
inline const char* GetDisplayNameByName(const char* internalName)
{
    if (!internalName) return nullptr;
    const auto& map = GetDisplayNameByNameMap();
    auto it = map.find(internalName);
    return (it != map.end()) ? it->second.c_str() : nullptr;
}

/**
 * Look up display name by internal item name with fallback.
 * @param internalName The internal item name
 * @param fallback Value to return if not found (typically internalName itself)
 * @return Display name string, or fallback if not found
 */
inline const char* GetDisplayNameByNameOr(const char* internalName, const char* fallback)
{
    const char* name = GetDisplayNameByName(internalName);
    return name ? name : fallback;
}

} // namespace item
} // namespace hb
'''

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header)

    return len(sorted_items), len(sorted_names)


def main():
    try:
        project_root = find_project_root()
        print(f"Project root: {project_root}")

        # Paths
        cfg_path = project_root / "Binaries" / "Game" / "CONTENTS" / "ItemName.cfg"
        db_path = project_root / "Binaries" / "Server" / "GameConfigs.db"
        output_path = project_root / "Dependencies" / "Shared" / "Item" / "ItemDisplayNames.h"

        # Verify files exist
        if not cfg_path.exists():
            print(f"ERROR: ItemName.cfg not found at {cfg_path}")
            return 1

        if not db_path.exists():
            print(f"ERROR: GameConfigs.db not found at {db_path}")
            return 1

        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Parse ItemName.cfg
        print(f"Parsing {cfg_path}...")
        name_map = parse_itemname_cfg(cfg_path)
        print(f"  Found {len(name_map)} item names")

        # Query database
        print(f"Querying {db_path}...")
        items = get_items_from_db(db_path)
        print(f"  Found {len(items)} items in database")

        # Join: item_id -> display_name and internal_name -> display_name
        id_to_name = {}
        name_to_display = {}
        missing_names = []

        for internal_name, item_id in items.items():
            if internal_name in name_map:
                display_name = name_map[internal_name]
                id_to_name[item_id] = display_name
                name_to_display[internal_name] = display_name
            else:
                # Fallback to internal name if no display name found
                id_to_name[item_id] = internal_name
                name_to_display[internal_name] = internal_name
                missing_names.append(internal_name)

        if missing_names:
            print(f"\nWARNING: {len(missing_names)} items have no display name in ItemName.cfg:")
            for name in missing_names[:10]:
                print(f"  - {name}")
            if len(missing_names) > 10:
                print(f"  ... and {len(missing_names) - 10} more")
            print("  Using internal names as fallback.\n")

        # Generate header
        print(f"Generating {output_path}...")
        id_count, name_count = generate_header(id_to_name, name_to_display, output_path)
        print(f"  Generated map with {id_count} ID entries and {name_count} name entries")

        print("\nDone! ItemDisplayNames.h has been generated.")
        print("Remember to commit this file to the repository.")

        return 0

    except FileNotFoundError as e:
        print(f"ERROR: {e}")
        return 1
    except Exception as e:
        print(f"ERROR: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
