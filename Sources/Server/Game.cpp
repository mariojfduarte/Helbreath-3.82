// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "CommonTypes.h"
#include "Game.h"
#ifdef _WIN32
#include <direct.h>
#endif
#include "LoginServer.h"
#include "EntityManager.h"
#include "AccountSqliteStore.h"
#include "GameConfigSqliteStore.h"
#include "MapInfoSqliteStore.h"
#include "sqlite3.h"
#include "../../Dependencies/Shared/Packet/SharedPackets.h"
#include "SharedCalculations.h"

class CDebugWindow* DbgWnd;

extern void PutLogList(char* cMsg);
extern void PutLogListLevel(int level, const char* cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];

extern void PutLogFileList(char* cStr);
extern void PutAdminLogFileList(char* cStr);
extern void PutItemLogFileList(char* cStr);
extern void PutLogEventFileList(char* cStr);
extern void PutHackLogFileList(char* cStr);
extern void PutPvPLogFileList(char* cStr);

// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE* pLogFile;
extern HWND	G_hWnd;

// Move lock para 640 x 480
int _tmp_iMoveLocX[9][38] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,-1},
	 // 1
	 {0,1,2,3,4,5,6,7,8,9,
	  10,11,12,13,14,15,16,17,18,19,
	  20,-1,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0},
	  // 2
	  {0,1,2,3,4,5,6,7,8,9,
	   10,11,12,13,14,15,16,17,18,19,
	   20,20,20,20,20,20,20,20,20,20,
	   20,20,20,20,20,20,-1,0},
	   // 3
	   {20,20,20,20,20,20,20,20,20,20,
		20,20,20,20,20,20,-1,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0},
		// 4
		{20,20,20,20,20,20,20,20,20,20,
		 20,20,20,20,20,20,19,18,17,16,
		 15,14,13,12,11,10,9,8,7,6,
		 5,4,3,2,1,0,-1,0},
		 // 5
		 {0,1,2,3,4,5,6,7,8,9,
		  10,11,12,13,14,15,16,17,18,19,
		  20,-1,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0,0,0},
		  // 6
		  {0,0,0,0,0,0,0,0,0,0,
		   0,0,0,0,0,0,1,2,3,4,
		   5,6,7,8,9,10,11,12,13,14,
		   15,16,17,18,19,20,-1,0},
		   // 7
		   {0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,-1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0},
			// 8
			{0,1,2,3,4,5,6,7,8,9,
			 10,11,12,13,14,15,16,17,18,19,
			 20,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,-1,0}
};

int _tmp_iMoveLocY[9][38] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,-1},
	 // 1
	 {0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0,
	  0,-1,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0},
	  // 2
	  {0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,
	   0,1,2,3,4,5,6,7,8,9,
	   10,11,12,13,14,15,-1,0},
	   // 3
	   {0,1,2,3,4,5,6,7,8,9,
		10,11,12,13,14,15,-1,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0},
		// 4
		{0,1,2,3,4,5,6,7,8,9,
		 10,11,12,13,14,15,15,15,15,15,
		 15,15,15,15,15,15,15,15,15,15,
		 15,15,15,15,15,15,-1,0},
		 // 5
		 {15,15,15,15,15,15,15,15,15,15,
		  15,15,15,15,15,15,15,15,15,15,
		  15,-1,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0,0,0},
		  // 6
		  {0,1,2,3,4,5,6,7,8,9,
		   10,11,12,13,14,15,15,15,15,15,
		   15,15,15,15,15,15,15,15,15,15,
		   15,15,15,15,15,15,-1,0},
		   // 7
		   {0,1,2,3,4,5,6,7,8,9,
			10,11,12,13,14,15,-1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0},
			// 8
			{0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,0,0,0,0,
			 0,1,2,3,4,5,6,7,8,9,
			 10,11,12,13,14,15,-1,0}
};


char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern bool	G_bIsThread;
extern void ThreadProc(void* ch);

CGame::CGame(HWND hWnd)
{
	int i, x;

	m_bIsGameStarted = false;
	m_hWnd = hWnd;
	/*m_pMainLogSock   = 0;
	m_pGateSock      = 0;
	m_bIsLogSockAvailable   = false;
	m_bIsGateSockAvailable  = false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;

	std::memset(m_cServerName, 0, sizeof(m_cServerName));*/

	_lsock = 0;
	g_login = new LoginServer;

	// Initialize configurable settings with defaults
	// Timing Settings (milliseconds)
	m_iClientTimeout = DEF_CLIENTTIMEOUT;
	m_iStaminaRegenInterval = DEF_SPUPTIME;
	m_iPoisonDamageInterval = DEF_POISONTIME;
	m_iHealthRegenInterval = DEF_HPUPTIME;
	m_iManaRegenInterval = DEF_MPUPTIME;
	m_iHungerConsumeInterval = DEF_HUNGERTIME;
	m_iSummonCreatureDuration = DEF_SUMMONTIME;
	m_iAutosaveInterval = DEF_AUTOSAVETIME;
	m_iLagProtectionInterval = DEF_RAGPROTECTIONTIME;

	// Character/Leveling Settings
	m_iBaseStatValue = 10;
	m_iCreationStatBonus = 4;
	m_iLevelupStatGain = DEF_TOTALLEVELUPPOINT;
	m_iMaxLevel = DEF_PLAYERMAXLEVEL;
	m_iMaxStatValue = 0; // Calculated after config load

	// Combat Settings
	m_iMinimumHitRatio = DEF_MINIMUMHITRATIO;
	m_iMaximumHitRatio = DEF_MAXIMUMHITRATIO;

	// Gameplay Settings
	m_iNighttimeDuration = DEF_NIGHTTIME;
	m_iStartingGuildRank = m_iStartingGuildRank;
	m_iGrandMagicManaConsumption = DEF_GMGMANACONSUMEUNIT;
	m_iMaxConstructionPoints = m_iMaxConstructionPoints;
	m_iMaxSummonPoints = DEF_MAXSUMMONPOINTS;
	m_iMaxWarContribution = m_iMaxWarContribution;
	m_iMaxBankItems = 200; // Default soft cap

	m_bIsDropTableAvailable = false;
	m_DropTables.clear();

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	// Initialize Entity Manager (MUST be before any entity operations)
	m_pEntityManager = new CEntityManager();

	// Get reference to EntityManager's entity array for backward compatibility
	// This allows existing code to access entities via m_pNpcList
	m_pNpcList = m_pEntityManager->GetEntityArray();
	m_pEntityManager->SetMapList(m_pMapList, DEF_MAXMAPS);
	m_pEntityManager->SetGame(this);

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = 0;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;// Crafting
	}

	//	/for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//		m_pTeleportConfigList[i] = 0;

		/*for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
			m_pSubLogSock[i] = 0;
			m_bIsSubLogSockAvailable[i] = false;
		}*/

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		m_pBuildItemList[i] = 0;

	// New 06/05/2004
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for (x = 0; x < DEF_MAXPARTYMEMBERS; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iAutoRebootingCount = 0;
	m_bEnemyKillMode = false;
	m_iEnemyKillAdjust = 1;
	m_sRaidTimeMonday = 0;
	m_sRaidTimeTuesday = 0;
	m_sRaidTimeWednesday = 0;
	m_sRaidTimeThursday = 0;
	m_sRaidTimeFriday = 0;
	m_sRaidTimeSaturday = 0;
	m_sRaidTimeSunday = 0;
	m_sCharPointLimit = 0;
	m_sSlateSuccessRate = 0;
	m_sForceRecallTime = 0;

	//Show Debug Window
	//DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	//DbgWnd->AddEventMsg("CGame Startup");
	// 2002-09-09 #1
	m_bReceivedItemList = false;

	for (i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
		_lclients[i] = nullptr;

	m_pPartyManager = new class PartyManager(this);

}

CGame::~CGame()
{
	//DbgWnd->Shutdown();
	//delete DbgWnd;

	for (int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		if (_lclients[i])
		{
			delete _lclients[i];
			_lclients[i] = nullptr;
		}
	}

	delete m_pPartyManager;

	// Cleanup Entity Manager
	if (m_pEntityManager != NULL) {
		delete m_pEntityManager;
		m_pEntityManager = NULL;
	}
}

bool CGame::bAcceptLogin(XSocket* sock)
{
	if (m_bIsGameStarted == false)
	{
		PutLogList("Closed Connection, not initialized");
		goto CLOSE_ANYWAY;
	}

	for (int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		auto& p = _lclients[i];
		if (!p)
		{
			p = new LoginClient(m_hWnd);
			sock->bAccept(p->_sock);  // MODERNIZED: Removed WM_USER_BOT_ACCEPT message ID
			std::memset(p->_ip, 0, sizeof(p->_ip));
			p->_sock->iGetPeerAddress(p->_ip);
			return true;
		}
	}

CLOSE_ANYWAY:

	// MODERNIZED: Removed m_hWnd parameter
	auto pTmpSock = new XSocket(DEF_SERVERSOCKETBLOCKLIMIT);
	sock->bAccept(pTmpSock);
	delete pTmpSock;

	return false;
}

bool CGame::bAccept(class XSocket* pXSock)
{
	int i, iTotalip = 0, a;
	class XSocket* pTmpSock;
	char cIPtoBan[21];
	FILE* pFile;

	if (m_bIsGameStarted == false)
		goto CLOSE_ANYWAY;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] == 0) {

			m_pClientList[i] = new class CClient(m_hWnd);
			bAddClientShortCut(i);
			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime =
				m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime =
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime =
				m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = GameClock::GetTimeMS();

			pXSock->bAccept(m_pClientList[i]->m_pXSock);  // MODERNIZED: Removed WM_ONCLIENTSOCKETEVENT message ID

			std::memset(m_pClientList[i]->m_cIPaddress, 0, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

			a = i;

			for (int v = 0; v < DEF_MAXBANNED; v++)
			{
				if (strcmp(m_stBannedList[v].m_cBannedIPaddress, m_pClientList[i]->m_cIPaddress) == 0)
				{
					goto CLOSE_CONN;
				}
			}
			//centu: Anti-Downer
			for (int j = 0; j < DEF_MAXCLIENTS; j++) {
				if (m_pClientList[j] != 0) {
					if (strcmp(m_pClientList[j]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++;
				}
			}
			if (iTotalip > 9) {
				std::memset(cIPtoBan, 0, sizeof(cIPtoBan));
				strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
				//opens cfg file
				pFile = fopen("GameConfigs\\BannedList.cfg", "a");
				//shows log
				std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> IP Banned: (%s)", i, cIPtoBan);
				PutLogList(G_cTxt);
				//modifys cfg file
				fprintf(pFile, "banned-ip = %s", cIPtoBan);
				fprintf(pFile, "\n");
				fclose(pFile);

				//updates BannedList.cfg on the server
				for (int x = 0; x < DEF_MAXBANNED; x++)
					if (strlen(m_stBannedList[x].m_cBannedIPaddress) == 0)
						strcpy(m_stBannedList[x].m_cBannedIPaddress, cIPtoBan);

				goto CLOSE_CONN;
			}

			std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);

			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {
				m_iMaxClients = m_iTotalClients;
				//GetLocalTime(&m_MaxUserSysTime);
				//std::snprintf(cTxt, sizeof(cTxt), "Maximum Players: %d", m_iMaxClients);
				//PutLogFileList(cTxt);
			}

			//m_pClientList[iClientH]->m_bIsInitComplete °ªÀ» ÂüÁ¶ÇØ¾ß ÇÑ´Ù.
			return true;
		}

CLOSE_ANYWAY:

	pTmpSock = new class XSocket(DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock);
	delete pTmpSock;

	return false;

CLOSE_CONN:
	delete m_pClientList[a];
	m_pClientList[a] = 0;
	RemoveClientShortCut(a);
	return false;
}


// MODERNIZED: No longer uses window messages, directly polls socket
void CGame::OnClientSocketEvent(int iClientH)
{
	int iRet;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (iClientH <= 0) return;

	if (m_pClientList[iClientH] == 0) return;

	iRet = m_pClientList[iClientH]->m_pXSock->Poll();  // MODERNIZED: Poll() instead of iOnSocketEvent()

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = GameClock::GetTimeMS();
		break;

	case DEF_XSOCKEVENT_BLOCK:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "[WARN] Client %d Socket BLOCKED (send buffer full)", iClientH);
		PutLogList(G_cTxt);
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, false, true);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Client Disconnected! MSGSIZETOOLARGE (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! SOCKETERROR (%s) WSA=%d LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%u CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! SOCKETCLOSED (%s) WSA=%d TimeSinceLastPacket=%dms LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%u CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			dwTime - m_pClientList[iClientH]->m_dwTime,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
			}
			catch (...)
			{
			}
		}

		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! CRITICALERROR (%s) WSA=%d LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%u CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;
	}
}

bool CGame::bInit()
{
	int  i;
	SYSTEMTIME SysTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	//CMisc::Temp();

	PutLogListLevel(LOG_LEVEL_NOTICE, "Initializing game server...");
	//

	for (i = 0; i < DEF_MAXCLIENTS + 1; i++)
		m_iClientShortCut[i] = 0;

	/*if (m_pMainLogSock != 0) delete m_pMainLogSock;
	if (m_pGateSock != 0) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != 0) delete m_pSubLogSock[i];*/

	if (_lsock != 0)
		delete _lsock;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != 0) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != 0) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

	//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = 0;


	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}

	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}

	m_iNpcConstructionPoint[1] = 100; // MS
	m_iNpcConstructionPoint[2] = 100; // MS
	m_iNpcConstructionPoint[3] = 100; // MS
	m_iNpcConstructionPoint[4] = 100; // MS
	m_iNpcConstructionPoint[5] = 100; // MS
	m_iNpcConstructionPoint[6] = 100; // MS

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = false;

	/*m_pMainLogSock  = 0;
	m_pGateSock = 0;
	m_bIsLogSockAvailable   = false;
	m_bIsGateSockAvailable  = false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;

	std::memset(m_cServerName, 0, sizeof(m_cServerName));*/

	_lsock = 0;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = 0;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = 0;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;	// Crafting
	}

	//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//		m_pTeleportConfigList[i] = 0;

		/*for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
			m_pSubLogSock[i] = 0;
			m_bIsSubLogSockAvailable[i] = false;
		}*/

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		m_pBuildItemList[i] = 0;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		std::memset(m_stCrusadeStructures[i].cMapName, 0, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = 0;
		m_stCrusadeStructures[i].dX = 0;
		m_stCrusadeStructures[i].dY = 0;
	}

	for (i = 0; i < DEF_MAXADMINS; i++) {
		std::memset(m_stAdminList[i].m_cGMName, 0, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		std::memset(m_stBannedList[i].m_cBannedIPaddress, 0, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}

	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = 0;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = 0;
		m_stMiddleCrusadeStructureInfo[i].cSide = 0;
		m_stMiddleCrusadeStructureInfo[i].sX = 0;
		m_stMiddleCrusadeStructureInfo[i].sY = 0;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = 0;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex = -1;
	m_iElvineMapIndex = -1;
	m_iGodHMapIndex = -1;
	m_iBTFieldMapIndex = -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iSubLogSockInitIndex = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = false;

	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime = dwTime - ((SysTime.wHour % 2) * 60 * 60 + SysTime.wMinute * 60) * 1000;

	for (i = 0; i < DEF_MAXFIGHTZONE; i++)
		m_iFightZoneReserve[i] = 0;

	m_iFightzoneNoForceRecall = 0;

	for (i = 1; i < 1000; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//std::snprintf(G_cTxt, sizeof(G_cTxt), "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLevelExp20 = m_iLevelExpTable[20];

	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	PutLogListLevel(LOG_LEVEL_NOTICE, "Validating GameConfigs.db...");
	bool configDbReady = EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated);
	if (!configDbReady) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GameConfigs.db unavailable.");
		return false;
	}
	if (configDbCreated) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GameConfigs.db missing configuration data.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!HasGameConfigRows(configDb, "realmlist") || !HasGameConfigRows(configDb, "active_maps") ||
		!LoadRealmConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Program configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!HasGameConfigRows(configDb, "settings") || !LoadSettingsConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	// Calculate m_iMaxStatValue after settings are loaded
	// Formula: base + creation + (levelup * max_level) + angelic_max(16)
	m_iMaxStatValue = m_iBaseStatValue + m_iCreationStatBonus + (m_iLevelupStatGain * m_iMaxLevel) + 16;
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Max stat value calculated: %d", m_iMaxStatValue);
	PutLogList(G_cTxt);

	if (!LoadAdminListConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Admin list unavailable in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!LoadBannedListConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Banned list unavailable in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!LoadAdminSettingsConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Failed to load admin level permissions from GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	srand((unsigned)time(0));
	//m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	//m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	//std::snprintf(cTxt, sizeof(cTxt), "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	//PutLogList(cTxt);
	////Sleep(100);

	//m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	//m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	//m_iGateSockConnRetryTimes = 1;

	//std::snprintf(cTxt, sizeof(cTxt), "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	//PutLogList(cTxt);

	_lsock = new class XSocket(DEF_SERVERSOCKETBLOCKLIMIT);  // MODERNIZED: Removed m_hWnd
	_lsock->bConnect(m_cLoginListenIP, m_iLoginListenPort);  // MODERNIZED: Removed WM_ONLOGSOCKETEVENT
	_lsock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = false;

	m_bOnExitProcess = false;

	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= m_iNighttimeDuration)
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	bReadNotifyMsgListFile("GameConfigs\\notice.txt");
	m_dwNoticeTime = dwTime;

	/*m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;*/

	m_pNoticementData = 0;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount = 0;
	m_bIsCrusadeMode = false;
	m_bIsApocalypseMode = false;
	//m_wServerID_GSS = iDice(1,65535);

	/*std::memset(m_cGateServerStockMsg, 0, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (uint32_t *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (uint16_t *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;*/

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = 0;
	m_iCrusadeWinnerSide = 0;
	m_iLastCrusadeWinner = 0;
	m_sLastHeldenianWinner = 0;
	m_sLastCrusadeDate = -1;
	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = false;
	m_bIsApocalypseStarter = false;
	m_iLatestCrusadeDayOfWeek = -1;

	m_bHeldenianInitiated = false;
	m_cHeldenianType = false;
	m_bIsHeldenianMode = false;
	m_bHeldenianRunning = false;
	m_iHeldenianAresdenLeftTower = 0;
	m_cHeldenianModeType = -1;
	m_sLastHeldenianWinner = -1;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	int dwMsgSize = 0;
	m_bIsItemAvailable = false;
	if (HasGameConfigRows(configDb, "items")) {
		m_bIsItemAvailable = LoadItemConfigs(configDb, m_pItemConfigList, DEF_MAXITEMTYPES);
	}
	if (!m_bIsItemAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Item configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsBuildItemAvailable = false;
	if (HasGameConfigRows(configDb, "builditem_configs")) {
		m_bIsBuildItemAvailable = LoadBuildItemConfigs(configDb, this);
	}
	if (!m_bIsBuildItemAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BuildItem configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsNpcAvailable = false;
	if (HasGameConfigRows(configDb, "npc_configs")) {
		m_bIsNpcAvailable = LoadNpcConfigs(configDb, this);
	}
	if (!m_bIsNpcAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! NPC configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsDropTableAvailable = false;
	if (HasGameConfigRows(configDb, "drop_tables") && HasGameConfigRows(configDb, "drop_entries")) {
		m_bIsDropTableAvailable = LoadDropTables(configDb, this);
	}
	if (!m_bIsDropTableAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Drop tables missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	{
		int missingDrops = 0;
		for (int i = 0; i < DEF_MAXNPCTYPES; i++) {
			const CNpc* npc = m_pNpcConfigList[i];
			if (npc == nullptr) {
				continue;
			}
			if (npc->m_iDropTableId == 0 &&
				(npc->m_iExpDiceMax > 0 || npc->m_iGoldDiceMax > 0)) {
				char logMsg[256] = {};
				std::snprintf(logMsg, sizeof(logMsg),
					"NPC missing drop table: %s (exp %u-%u, gold %u-%u)",
					npc->m_cNpcName,
					static_cast<unsigned int>(npc->m_iExpDiceMin),
					static_cast<unsigned int>(npc->m_iExpDiceMax),
					static_cast<unsigned int>(npc->m_iGoldDiceMin),
					static_cast<unsigned int>(npc->m_iGoldDiceMax));
				PutLogListLevel(LOG_LEVEL_WARNING, logMsg);
				missingDrops++;
			}
		}
		if (missingDrops > 0) {
			char logMsg[128] = {};
			std::snprintf(logMsg, sizeof(logMsg), "NPCs missing drop tables: %d", missingDrops);
			PutLogListLevel(LOG_LEVEL_WARNING, logMsg);
		}
	}

	// Load shop configurations (optional - server works without shops)
	m_bIsShopDataAvailable = false;
	if (HasGameConfigRows(configDb, "npc_shop_mapping") || HasGameConfigRows(configDb, "shop_items")) {
		LoadShopConfigs(configDb, this);
	}
	if (!m_bIsShopDataAvailable) {
		PutLogList("(!) Shop data not configured - NPCs will not have shop inventories.");
	}

	m_bIsMagicAvailable = false;
	if (HasGameConfigRows(configDb, "magic_configs")) {
		m_bIsMagicAvailable = LoadMagicConfigs(configDb, this);
	}
	if (!m_bIsMagicAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Magic configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsSkillAvailable = false;
	if (HasGameConfigRows(configDb, "skill_configs")) {
		m_bIsSkillAvailable = LoadSkillConfigs(configDb, this);
	}
	if (!m_bIsSkillAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Skill configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsQuestAvailable = false;
	if (HasGameConfigRows(configDb, "quest_configs")) {
		m_bIsQuestAvailable = LoadQuestConfigs(configDb, this);
	}
	if (!m_bIsQuestAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Quest configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsPortionAvailable = false;
	if (HasGameConfigRows(configDb, "potion_configs") || HasGameConfigRows(configDb, "crafting_configs")) {
		m_bIsPortionAvailable = LoadPortionConfigs(configDb, this);
	}
	if (!m_bIsPortionAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Potion/Crafting configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	CloseGameConfigDatabase(configDb);

	return true;
}

void CGame::OnClientRead(int iClientH)
{
	char* pData, cKey;
	uint32_t  dwMsgSize;

	if (m_pClientList[iClientH] == 0) return;

	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (header) {
		m_pClientList[iClientH]->m_dwLastMsgId = header->msg_id;
		m_pClientList[iClientH]->m_dwLastMsgTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_dwLastMsgSize = dwMsgSize;
	}

	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}



void CGame::ClientMotionHandler(int iClientH, char* pData)
{
	uint32_t dwClientTime;
	uint16_t wCommand, wTargetObjectID = 0;
	short sX, sY, dX, dY, wType;
	char cDir;
	int   iRet, iTemp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	const auto* base = hb::net::PacketCast<hb::net::PacketCommandMotionBase>(
		pData, sizeof(hb::net::PacketCommandMotionBase));
	if (!base) return;
	/*m_pClientList[iClientH]->m_cConnectionCheck++;
	if (m_pClientList[iClientH]->m_cConnectionCheck > 50) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Hex: (%s) Player: (%s) - removed 03203203h, vital to hack detection.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, true, true);
		return;
	}
	*/
	wCommand = base->header.msg_type;
	sX = base->x;
	sY = base->y;
	cDir = static_cast<char>(base->dir);
	dX = base->dx;
	dY = base->dy;
	wType = base->type;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandMotionAttack>(
			pData, sizeof(hb::net::PacketCommandMotionAttack));
		if (!pkt) return;
		wTargetObjectID = pkt->target_id;
		dwClientTime = pkt->time_ms;
	}
	else {
		const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandMotionSimple>(
			pData, sizeof(hb::net::PacketCommandMotionSimple));
		if (!pkt) return;
		dwClientTime = pkt->time_ms;
	}

	switch (wCommand) {
	case DEF_OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if ((iRet == 1) && (m_pClientList[iClientH] != 0)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, 0, 0, 0);
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, false, true); // v1.4
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		//client hp recorded here ONLY if its less than
		if (iRet == 1) {
			if (m_pClientList[iClientH]->m_bMagicPauseTime == false) {
				m_pClientList[iClientH]->m_bMagicPauseTime = true;
				iTemp = 10;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, 0);
				m_pClientList[iClientH]->m_iSpellCount++;
				bCheckClientMagicFrequency(iClientH, dwClientTime);
			}
			else if (m_pClientList[iClientH]->m_bMagicPauseTime) {
				try
				{
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Cast Delay Hack: (%s) Player: (%s) - player casting too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(iClientH, true, true);
				}
				catch (...)
				{
				}
			}
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	default:
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
{
	char moveMapData[3000];
	class CTile* pTile;
	DWORD dwTime;
	WORD  wObjectID;
	short dX, dY, sTemp, sTemp2, sDOtype, pTopItem;
	int   iRet, iSize, iDamage;
	bool  bRet, bIsBlocked = false;
	hb::net::PacketWriter writer;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	//locobans
	dwTime = timeGetTime();
	/*m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentWalkTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (590)) {
					//wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentRunTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (290)) {
					//wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwRunLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}*/

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
		bRet = false;

	if ((bRet) && (bIsBlocked == false)) {
		if (m_pClientList[iClientH]->m_iQuest != 0) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX = dX;
		m_pClientList[iClientH]->m_sY = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			DEF_OWNERTYPE_PLAYER,
			dX, dY);

		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = iDice(2, 4);

				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

		writer.Reset();
		auto* pkt = writer.Append<hb::net::PacketResponseMotionMoveConfirm>();
		pkt->header.msg_id = MSGID_RESPONSE_MOTION;
		pkt->header.msg_type = DEF_OBJECTMOVE_CONFIRM;
		pkt->x = static_cast<std::int16_t>(dX - 12);
		pkt->y = static_cast<std::int16_t>(dY - 9);
		pkt->dir = static_cast<std::uint8_t>(cDir);
		pkt->stamina_cost = 0;
		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					pkt->stamina_cost = 1;
				}
			}
		}

		pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		pkt->occupy_status = static_cast<std::uint8_t>(pTile->m_iOccupyStatus);
		pkt->hp = m_pClientList[iClientH]->m_iHP;

		iSize = iComposeMoveMapData((short)(dX - 12), (short)(dY - 9), iClientH, cDir, moveMapData);
		writer.AppendBytes(moveMapData, static_cast<std::size_t>(iSize));

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
		/*if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h ) {

			.text:00406037                 mov     [ebp+var_C1C], 0
			.text:0040603E                 xor     edx, edx
			.text:00406040                 mov     [ebp+var_C1B], edx
			.text:00406046                 mov     [ebp+var_C17], edx
			.text:0040604C                 mov     [ebp+var_C13], dx

			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2);
			}
		}*/
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = true;

		if (bIsBlocked) {
			m_pClientList[iClientH]->m_dwAttackLAT = 1050;
		}
		m_pClientList[iClientH]->m_dwAttackLAT = 1010;

		wObjectID = (WORD)iClientH;
		writer.Reset();
		auto* pkt = writer.Append<hb::net::PacketResponseMotionMoveReject>();
		pkt->header.msg_id = MSGID_RESPONSE_MOTION;
		pkt->header.msg_type = DEF_OBJECTMOVE_REJECT;
		pkt->object_id = static_cast<std::uint16_t>(wObjectID);
		pkt->x = m_pClientList[wObjectID]->m_sX;
		pkt->y = m_pClientList[wObjectID]->m_sY;
		pkt->type = m_pClientList[wObjectID]->m_sType;
		pkt->dir = static_cast<std::uint8_t>(m_pClientList[wObjectID]->m_cDir);
		std::memcpy(pkt->name, m_pClientList[wObjectID]->m_cCharName, sizeof(pkt->name));
		pkt->appr1 = m_pClientList[wObjectID]->m_sAppr1;
		pkt->appr2 = m_pClientList[wObjectID]->m_sAppr2;
		pkt->appr3 = m_pClientList[wObjectID]->m_sAppr3;
		pkt->appr4 = m_pClientList[wObjectID]->m_sAppr4;
		pkt->appr_color = m_pClientList[wObjectID]->m_iApprColor;
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp = (sTemp | (sTemp2 << 28));
		pkt->status = sTemp;
		pkt->padding = 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
		// locobans
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		return 0;
	}

	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char* pData, char cKey)
{
	int i;
	char cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
	bool bIsObserverMode;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) return;


	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestInitPlayer>(
		pData, sizeof(hb::net::PacketRequestInitPlayer));
	if (!req) return;

	memcpy(cCharName, req->player, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char 0!");

	memcpy(cAccountName, req->account, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, req->password, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);

	bIsObserverMode = (req->is_observer != 0);

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

				DeleteClient(iClientH, false, false, false);
				return;
			}
		}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

				DeleteClient(iClientH, false, false);
				return;
			}
		}

	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;

	InitPlayerData(iClientH, 0, 0); //bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dieing
void CGame::RequestInitDataHandler(int iClientH, char* pData, char cKey)
{
	char cPlayerName[11], cTxt[120];
	int sSummonPoints;
	int i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;
	hb::net::PacketWriter writer;
	char initMapData[DEF_MSGBUFFERSIZE + 1];

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestInitPlayer>(
		pData, sizeof(hb::net::PacketRequestInitPlayer));
	if (!req) {
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, req->player, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, false, true);
		return;
	}

	writer.Reset();
	auto* char_pkt = writer.Append<hb::net::PacketResponsePlayerCharacterContents>();
	char_pkt->header.msg_id = MSGID_PLAYERCHARACTERCONTENTS;
	char_pkt->header.msg_type = DEF_MSGTYPE_CONFIRM;
	char_pkt->hp = m_pClientList[iClientH]->m_iHP;
	char_pkt->mp = m_pClientList[iClientH]->m_iMP;
	char_pkt->sp = m_pClientList[iClientH]->m_iSP;
	char_pkt->ac = m_pClientList[iClientH]->m_iDefenseRatio;
	char_pkt->thac0 = m_pClientList[iClientH]->m_iHitRatio;
	char_pkt->level = m_pClientList[iClientH]->m_iLevel;
	char_pkt->str = m_pClientList[iClientH]->m_iStr;
	char_pkt->intel = m_pClientList[iClientH]->m_iInt;
	char_pkt->vit = m_pClientList[iClientH]->m_iVit;
	char_pkt->dex = m_pClientList[iClientH]->m_iDex;
	char_pkt->mag = m_pClientList[iClientH]->m_iMag;
	char_pkt->chr = m_pClientList[iClientH]->m_iCharisma;

	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma);

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLevel * 3 - (iStats - 70);
	char_pkt->lu_point = static_cast<std::uint16_t>(m_pClientList[iClientH]->m_iLU_Pool);
	char_pkt->lu_unused[0] = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_cVar);
	char_pkt->lu_unused[1] = 0;
	char_pkt->lu_unused[2] = 0;
	char_pkt->lu_unused[3] = 0;
	char_pkt->lu_unused[4] = 0;
	char_pkt->exp = m_pClientList[iClientH]->m_iExp;
	char_pkt->enemy_kills = m_pClientList[iClientH]->m_iEnemyKillCount;
	char_pkt->pk_count = m_pClientList[iClientH]->m_iPKCount;
	char_pkt->reward_gold = m_pClientList[iClientH]->m_iRewardGold;
	std::memcpy(char_pkt->location, m_pClientList[iClientH]->m_cLocation, sizeof(char_pkt->location));
	std::memcpy(char_pkt->guild_name, m_pClientList[iClientH]->m_cGuildName, sizeof(char_pkt->guild_name));
	char_pkt->guild_rank = m_pClientList[iClientH]->m_iGuildRank;
	char_pkt->super_attack_left = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_iSuperAttackLeft);
	char_pkt->fightzone_number = m_pClientList[iClientH]->m_iFightzoneNumber;
	char_pkt->max_stats = m_iMaxStatValue;
	char_pkt->max_level = m_iMaxLevel;
	char_pkt->max_bank_items = m_iMaxBankItems;

	//hbest
	m_pClientList[iClientH]->isForceSet = false;
	m_pClientList[iClientH]->m_iPartyID = 0;
	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
	m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	writer.Reset();
	auto* item_header = writer.Append<hb::net::PacketResponseItemListHeader>();
	item_header->header.msg_id = MSGID_PLAYERITEMLISTCONTENTS;
	item_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0)
			iTotalItemA++;

	item_header->item_count = static_cast<std::uint8_t>(iTotalItemA);

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			return;
		}
		auto* entry = writer.Append<hb::net::PacketResponseItemListEntry>();
		std::memcpy(entry->name, m_pClientList[iClientH]->m_pItemList[i]->m_cName, sizeof(entry->name));
		entry->count = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		entry->item_type = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		entry->equip_pos = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		entry->is_equipped = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsItemEquipped[i]);
		entry->level_limit = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		entry->gender_limit = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		entry->cur_lifespan = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		entry->weight = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		entry->sprite = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		entry->sprite_frame = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		entry->item_color = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor;
		entry->spec_value2 = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2);
		entry->attribute = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		entry->item_id = m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum;
		entry->max_lifespan = m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan;
	}

	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0)
			iTotalItemB++;

	const auto bank_count = static_cast<std::uint8_t>(iTotalItemB);
	writer.AppendBytes(&bank_count, sizeof(bank_count));

	for (i = 0; i < iTotalItemB; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			return;
		}
		auto* entry = writer.Append<hb::net::PacketResponseBankItemEntry>();
		std::memcpy(entry->name, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, sizeof(entry->name));
		entry->count = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		entry->item_type = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		entry->equip_pos = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		entry->level_limit = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		entry->gender_limit = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		entry->cur_lifespan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		entry->weight = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		entry->sprite = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		entry->sprite_frame = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		entry->item_color = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor;
		entry->spec_value2 = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2);
		entry->attribute = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		entry->item_id = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sIDnum;
		entry->max_lifespan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan;
	}

	writer.AppendBytes(m_pClientList[iClientH]->m_cMagicMastery, DEF_MAXMAGICTYPE);
	writer.AppendBytes(m_pClientList[iClientH]->m_cSkillMastery, DEF_MAXSKILLTYPE);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	writer.Reset();
	auto* init_header = writer.Append<hb::net::PacketResponseInitDataHeader>();
	init_header->header.msg_id = MSGID_RESPONSE_INITDATA;
	init_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	init_header->player_object_id = static_cast<std::int16_t>(iClientH);
	init_header->pivot_x = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sX - 14 - 5);
	init_header->pivot_y = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sY - 12 - 5);
	init_header->player_type = m_pClientList[iClientH]->m_sType;
	init_header->appr1 = m_pClientList[iClientH]->m_sAppr1;
	init_header->appr2 = m_pClientList[iClientH]->m_sAppr2;
	init_header->appr3 = m_pClientList[iClientH]->m_sAppr3;
	init_header->appr4 = m_pClientList[iClientH]->m_sAppr4;
	init_header->appr_color = m_pClientList[iClientH]->m_iApprColor;
	init_header->status = m_pClientList[iClientH]->m_iStatus;
	std::memcpy(init_header->map_name, m_pClientList[iClientH]->m_cMapName, sizeof(init_header->map_name));
	std::memcpy(init_header->cur_location, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sizeof(init_header->cur_location));

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->sprite_alpha = 1;
	else init_header->sprite_alpha = m_cDayOrNight;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->weather_status = 0;
	else init_header->weather_status = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;

	init_header->contribution = m_pClientList[iClientH]->m_iContribution;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
			DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);
	}

	init_header->observer_mode = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsObserverMode);
	init_header->rating = m_pClientList[iClientH]->m_iRating;
	init_header->hp = m_pClientList[iClientH]->m_iHP;
	init_header->discount = 0;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 12, m_pClientList[iClientH]->m_sY - 9, iClientH, initMapData);
	writer.AppendBytes(initMapData, static_cast<std::size_t>(iSize));

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	// v2.13 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		// v2.17 2002-7-15
		SetForceRecallTime(iClientH);
	}
	// v2.13 
	else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		// v2.17 2002-7-15
		SetForceRecallTime(iClientH);
	}
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
		}
		else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20 * 5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;  // 5��
		}

	}
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) &&
		(m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
	}
	else
	{
		m_pClientList[iClientH]->m_bIsWarLocation = false;
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		// 06/11/2004
		SetForceRecallTime(iClientH);
	}

	// v2.17 2002-7-15
	//hbest...
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation) && IsEnemyZone(iClientH)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, 0);
		//wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		//PutLogList(G_cTxt) ;
	}

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
			}
		}
	}
	else {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone &&
			m_iFightzoneNoForceRecall == false &&
			m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		}
		else {
			if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0 ||
				memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = true;
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				}
			}
		}
	}

	/*if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) &&
		(m_pClientList[iClientH]->m_bIsWarLocation )) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, 0);
	}*/

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);

	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
	}

	// Crusade 
	if (m_bIsCrusadeMode) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	}
	else if (m_bIsHeldenianMode) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > m_iMaxSummonPoints) sSummonPoints = m_iMaxSummonPoints;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		}
		else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, 0, 0, 0, 0);
			if (m_bHeldenianInitiated == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			UpdateHeldenianStatus();
		}
	}
	else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	if (m_bIsHeldenianMode) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0, 0);
	if (m_bHeldenianInitiated) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0, 0);

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);
	//Fix Sprite Bug
	//			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	//Gizon point lefT???
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	if ((m_bIsApocalypseMode) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap)) {
		RequestTeleportHandler(iClientH, "1   ");
	}

	if (m_bIsApocalypseMode) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0, 0);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);

	RequestNoticementHandler(iClientH); // send noticement when log in

	bSendClientItemConfigs(iClientH);

}

bool CGame::bSendClientItemConfigs(int iClientH)
{
	if (m_pClientList[iClientH] == 0) {
		return false;
	}

	// Calculate how many items per packet (leave room for header)
	constexpr size_t maxPacketSize = 30000;
	constexpr size_t headerSize = sizeof(hb::net::PacketItemConfigHeader);
	constexpr size_t entrySize = sizeof(hb::net::PacketItemConfigEntry);
	constexpr size_t maxEntriesPerPacket = (maxPacketSize - headerSize) / entrySize;

	// First count total items
	int totalItems = 0;
	for (int i = 0; i < DEF_MAXITEMTYPES; i++) {
		if (m_pItemConfigList[i] != 0) {
			totalItems++;
		}
	}

	// Send items in packets
	int itemsSent = 0;
	int packetIndex = 0;

	while (itemsSent < totalItems) {
		// Build packet
		std::memset(G_cData50000, 0, sizeof(G_cData50000));

		auto* pktHeader = reinterpret_cast<hb::net::PacketItemConfigHeader*>(G_cData50000);
		pktHeader->header.msg_id = MSGID_ITEMCONFIGURATIONCONTENTS;
		pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
		pktHeader->totalItems = static_cast<uint16_t>(totalItems);
		pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

		auto* entries = reinterpret_cast<hb::net::PacketItemConfigEntry*>(G_cData50000 + headerSize);

		uint16_t entriesInPacket = 0;
		int configIndex = 0;
		int skipped = 0;

		// Find items for this packet
		for (int i = 0; i < DEF_MAXITEMTYPES && entriesInPacket < maxEntriesPerPacket; i++) {
			if (m_pItemConfigList[i] == 0) {
				continue;
			}

			// Skip items already sent in previous packets
			if (skipped < itemsSent) {
				skipped++;
				continue;
			}

			const class CItem* item = m_pItemConfigList[i];
			auto& entry = entries[entriesInPacket];

			entry.itemId = item->m_sIDnum;
			std::memset(entry.name, 0, sizeof(entry.name));
			std::strncpy(entry.name, item->m_cName, sizeof(entry.name) - 1);
			entry.itemType = item->m_cItemType;
			entry.equipPos = item->m_cEquipPos;
			entry.effectType = item->m_sItemEffectType;
			entry.effectValue1 = item->m_sItemEffectValue1;
			entry.effectValue2 = item->m_sItemEffectValue2;
			entry.effectValue3 = item->m_sItemEffectValue3;
			entry.effectValue4 = item->m_sItemEffectValue4;
			entry.effectValue5 = item->m_sItemEffectValue5;
			entry.effectValue6 = item->m_sItemEffectValue6;
			entry.maxLifeSpan = item->m_wMaxLifeSpan;
			entry.specialEffect = item->m_sSpecialEffect;
			entry.sprite = item->m_sSprite;
			entry.spriteFrame = item->m_sSpriteFrame;
			entry.price = item->m_bIsForSale ? static_cast<int32_t>(item->m_wPrice) : -static_cast<int32_t>(item->m_wPrice);
			entry.weight = item->m_wWeight;
			entry.apprValue = item->m_cApprValue;
			entry.speed = item->m_cSpeed;
			entry.levelLimit = item->m_sLevelLimit;
			entry.genderLimit = item->m_cGenderLimit;
			entry.specialEffectValue1 = item->m_sSpecialEffectValue1;
			entry.specialEffectValue2 = item->m_sSpecialEffectValue2;
			entry.relatedSkill = item->m_sRelatedSkill;
			entry.category = item->m_cCategory;
			entry.itemColor = item->m_cItemColor;

			entriesInPacket++;
		}

		pktHeader->itemCount = entriesInPacket;
		size_t packetSize = headerSize + (entriesInPacket * entrySize);

		int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, static_cast<int>(packetSize));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			std::snprintf(G_cTxt, sizeof(G_cTxt),
				"Failed to send item configs: Client(%d) Packet(%d)",
				iClientH, packetIndex);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, true, true);
			delete m_pClientList[iClientH];
			m_pClientList[iClientH] = 0;
			return false;
		}

		itemsSent += entriesInPacket;
		packetIndex++;
	}

	return true;
}

const DropTable* CGame::GetDropTable(int id) const
{
	if (id <= 0) {
		return nullptr;
	}
	auto it = m_DropTables.find(id);
	if (it == m_DropTables.end()) {
		return nullptr;
	}
	return &it->second;
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char* pData)
{
	int* ip, ix, iy, iSize, iTileExists;
	class CTile* pTile;
	unsigned char ucHeader;
	short* sp, * pTotal;
	int     sTemp, sTemp2;
	uint16_t* wp;
	char* cp;
	uint32_t* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short*)pData;
	cp = (char*)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	for (iy = 0; iy < 19; iy++)
		for (ix = 0; ix < 25; ix++) {

			if (((sX + ix) == 100) && ((sY + iy) == 100))
				sX = sX;

			pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX + ix) + (sY + iy) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

			//If player not same side and is invied (Beholder Hack)
			/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
				if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
					(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
					((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
					continue;
				}*/

			if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
				(pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0)) {
				iTileExists++;
				sp = (short*)cp;
				*sp = ix;
				cp += 2;
				sp = (short*)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				ucHeader = 0;
				if (pTile->m_sOwner != 0) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
						else {
							// ###debugcode
							std::snprintf(G_cTxt, sizeof(G_cTxt), "Empty player handle: %d", pTile->m_sOwner);
							//PutLogFileList(G_cTxt);
							//
							pTile->m_sOwner = 0;
						}
					}

					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = 0;
					}
				}
				if (pTile->m_sDeadOwner != 0) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
				}
				if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
				if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;
				//
				*cp = ucHeader;
				cp++;
				iSize++;

				if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:
						// Object ID number(Player) : 1~10000
						sp = (short*)cp;
						*sp = pTile->m_sOwner;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance1
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
						cp += 2;
						iSize += 2;
						// Appearance2
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;
						// Appearance3
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
						cp += 2;
						iSize += 2;
						// Appearance4
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
						cp += 2;
						iSize += 2;
						// v1.4 ApprColor
						ip = (int*)cp;
						*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
						cp += 4;
						iSize += 4;

						// Status
						ip = (int*)cp;

						// sStatus
						sTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp;
						sTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
						sTemp = (sTemp | (sTemp2 << 28));//Original : 12
						*ip = sTemp;
						//*sp = DEF_TEST;
						cp += 4;//Original 2
						iSize += 4;//Original 2
						// Name
						memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						// Object ID number(NPC) : 10000~
						sp = (short*)cp;
						*sp = pTile->m_sOwner + 10000;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;
						// Appr2
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;
						// Status
						ip = (int*)cp;

						sTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
						sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
						sTemp2 = m_pEntityManager->iGetNpcRelationship(pTile->m_sOwner, iClientH);
						sTemp = (sTemp | (sTemp2 << 28));//Original : 12
						*ip = sTemp;
						//*sp = DEF_TEST;
						cp += 4;//Original 2
						iSize += 4;//Original 2
						// Name
						memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
						break;
					}
				}

				if ((ucHeader & 0x02) != 0) {
					switch (pTile->m_cDeadOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:
						// Object ID number : 1~10000
						sp = (short*)cp;
						*sp = pTile->m_sDeadOwner;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance1
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
						cp += 2;
						iSize += 2;
						// Appearance2
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;
						// Appearance3
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
						cp += 2;
						iSize += 2;
						// Appearance4
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
						cp += 2;
						iSize += 2;
						// v1.4 ApprColor
						ip = (int*)cp;
						*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
						cp += 4;
						iSize += 4;

						// Status
						ip = (int*)cp;

						// sStatus
						sTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp;
						sTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
						sTemp = (sTemp | (sTemp2 << 28));//Original : 12
						*ip = sTemp;
						//*sp = DEF_TEST;
						cp += 4;//Original 2
						iSize += 4;//Original 2
						// Name
						memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						// Object ID number : 10000	~
						sp = (short*)cp;
						*sp = pTile->m_sDeadOwner + 10000;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;
						// Appr2
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;
						// Status
						ip = (int*)cp;

						sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
						sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
						sTemp2 = m_pEntityManager->iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
						sTemp = (sTemp | (sTemp2 << 28));//Original : 12
						*ip = sTemp;
						//*sp = DEF_TEST;
						cp += 4;//Original 2
						iSize += 4;//Original 2
						// Name
						memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
						break;
					}
				}

				if (pTile->m_pItem[0] != 0) {
					// Centu - id num
					sp = (short*)cp;
					*sp = pTile->m_pItem[0]->m_sIDnum;
					cp += 2;
					iSize += 2;

					*cp = pTile->m_pItem[0]->m_cItemColor;
					cp++;
					iSize++;

					// Centu - attribute
					dwp = (uint32_t*)cp;
					*dwp = pTile->m_pItem[0]->m_dwAttribute;
					cp += 4;
					iSize += 4;
				}

				if (pTile->m_sDynamicObjectType != 0) {
					wp = (uint16_t*)cp;
					*wp = pTile->m_wDynamicObjectID;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = pTile->m_sDynamicObjectType;
					cp += 2;
					iSize += 2;
				}
			} // Big if
		} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

void CGame::DeleteClient(int iClientH, bool bSave, bool bNotify, bool bCountLogout, bool bForceCloseConn)
{
	int i, iExH;
	char* cp, cData[120], cTmpMap[30];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_bIsExchangeMode) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != 0) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0))
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iWhisperPlayerIndex == iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(0, i, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);
			}

		/*std::memset(cData, 0, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_DISCONNECT;
		cp++;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 11);*/

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);

		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
	}

	if ((bSave) && (m_pClientList[iClientH]->m_bIsOnServerChange == false)) {

		if (m_pClientList[iClientH]->m_bIsKilled) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}
					else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}
					else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10 * 60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 4;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			//if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == false) LocalSavePlayerData(iClientH);
		}
		g_login->LocalSavePlayerData(iClientH); //else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == false) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 4;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			//bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 7;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = 0;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			//bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, false); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
	DC_LOOPBREAK1:
		for (i = 0; i < DEF_MAXPARTYMEMBERS - 1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] = 0;
			}
	}


	m_iTotalClients--;

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = 0;

	RemoveClientShortCut(iClientH);
}



void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, uint32_t dwMsgID, uint16_t wMsgType, short sV1, short sV2, short sV3)
{
	int i, iRet, iShortCutIndex;
	bool bFlag;
	int sRange;
	short sX, sY;
	int iTemp, iTemp2, iTemp3;
	bool cOwnerSend;

	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) ||
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == 0) return;

		sX = m_pClientList[sOwnerH]->m_sX;
		sY = m_pClientList[sOwnerH]->m_sY;

		switch (wMsgType) {
		case DEF_OBJECTNULLACTION:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDYING:
		case DEF_MSGTYPE_CONFIRM:
			cOwnerSend = true;
			break;
		default:
			cOwnerSend = false;
			break;
		}

		hb::net::PacketEventMotionPlayer base_all{};
		base_all.header.msg_id = dwMsgID;
		base_all.header.msg_type = wMsgType;
		base_all.object_id = static_cast<std::uint16_t>(sOwnerH);
		base_all.x = sX;
		base_all.y = sY;
		base_all.type = m_pClientList[sOwnerH]->m_sType;
		base_all.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		std::memcpy(base_all.name, m_pClientList[sOwnerH]->m_cCharName, sizeof(base_all.name));
		base_all.appr1 = m_pClientList[sOwnerH]->m_sAppr1;
		base_all.appr2 = m_pClientList[sOwnerH]->m_sAppr2;
		base_all.appr3 = m_pClientList[sOwnerH]->m_sAppr3;
		base_all.appr4 = m_pClientList[sOwnerH]->m_sAppr4;
		base_all.appr_color = m_pClientList[sOwnerH]->m_iApprColor;
		base_all.status = m_pClientList[sOwnerH]->m_iStatus;
		base_all.loc = 0;
		if (wMsgType == DEF_OBJECTNULLACTION) {
			base_all.loc = m_pClientList[sOwnerH]->m_bIsKilled ? 1 : 0;
		}

		hb::net::PacketEventMotionShort pkt_short{};
		pkt_short.header.msg_id = dwMsgID;
		pkt_short.header.msg_type = wMsgType;
		pkt_short.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_short.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_short.v1 = static_cast<std::uint8_t>(sV1);
		pkt_short.v2 = static_cast<std::uint8_t>(sV2);

		hb::net::PacketEventMotionMove pkt_move{};
		pkt_move.header.msg_id = dwMsgID;
		pkt_move.header.msg_type = wMsgType;
		pkt_move.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_move.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_move.v1 = static_cast<std::uint8_t>(sV1);
		pkt_move.v2 = static_cast<std::uint8_t>(sV2);
		pkt_move.x = sX;
		pkt_move.y = sY;

		hb::net::PacketEventMotionAttack pkt_attack{};
		pkt_attack.header.msg_id = dwMsgID;
		pkt_attack.header.msg_type = wMsgType;
		pkt_attack.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_attack.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_attack.v1 = static_cast<std::int8_t>(sV1 - sX);
		pkt_attack.v2 = static_cast<std::int8_t>(sV2 - sY);
		pkt_attack.v3 = static_cast<std::int16_t>(sV3);

		hb::net::PacketEventMotionDirOnly pkt_dir{};
		pkt_dir.header.msg_id = dwMsgID;
		pkt_dir.header.msg_type = wMsgType;
		pkt_dir.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_dir.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);

		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;

		const char cKey = static_cast<char>((rand() % 255) + 1);

		bFlag = true;
		iShortCutIndex = 0;

		while (bFlag) {
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;

			if ((bFlag) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete))
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - DEF_VIEWRANGE_X - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + DEF_VIEWRANGE_X + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - DEF_VIEWRANGE_Y - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + DEF_VIEWRANGE_Y + sRange)) {

					iTemp = m_pClientList[sOwnerH]->m_iStatus;
					if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
						if (m_pClientList[i]->m_iAdminUserLevel > 0) {
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}
						else if (i != sOwnerH) {
							iTemp = iTemp3;
						}
						else {
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}
					}

					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
					iTemp = (iTemp | (iTemp2 << 28));

					auto pkt_all = base_all;
					pkt_all.status = iTemp;

					auto send_packet = [&](const void* packet, std::size_t size) -> int {
						return m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(const_cast<void*>(packet)), static_cast<int>(size), cKey);
						};

					const bool is_near = (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 11) &&
						(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 11) &&
						(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 9) &&
						(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 9);

					if (is_near) {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTDYING:
							if (cOwnerSend)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						default:
							if (cOwnerSend)
								iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							break;
						}
					}
					else {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTDYING:
							if (cOwnerSend)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						default:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;
						}

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarn = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarn > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA: client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarn = dwNow;
							}
						}
					}
				}
		}
	}
	else {
		if (m_pNpcList[sOwnerH] == 0) return;

		sX = m_pNpcList[sOwnerH]->m_sX;
		sY = m_pNpcList[sOwnerH]->m_sY;

		hb::net::PacketEventMotionNpc base_all{};
		base_all.header.msg_id = dwMsgID;
		base_all.header.msg_type = wMsgType;
		base_all.object_id = static_cast<std::uint16_t>(sOwnerH + 10000);
		base_all.x = sX;
		base_all.y = sY;
		base_all.type = m_pNpcList[sOwnerH]->m_sType;
		base_all.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		std::memcpy(base_all.name, m_pNpcList[sOwnerH]->m_cName, sizeof(base_all.name));
		base_all.appr2 = m_pNpcList[sOwnerH]->m_sAppr2;
		base_all.status = m_pNpcList[sOwnerH]->m_iStatus;
		base_all.loc = 0;
		if (wMsgType == DEF_OBJECTNULLACTION) {
			base_all.loc = m_pNpcList[sOwnerH]->m_bIsKilled ? 1 : 0;
		}

		hb::net::PacketEventMotionShort pkt_short{};
		pkt_short.header.msg_id = dwMsgID;
		pkt_short.header.msg_type = wMsgType;
		pkt_short.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_short.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_short.v1 = static_cast<std::uint8_t>(sV1);
		pkt_short.v2 = static_cast<std::uint8_t>(sV2);

		hb::net::PacketEventMotionMove pkt_move{};
		pkt_move.header.msg_id = dwMsgID;
		pkt_move.header.msg_type = wMsgType;
		pkt_move.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_move.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_move.v1 = static_cast<std::uint8_t>(sV1);
		pkt_move.v2 = static_cast<std::uint8_t>(sV2);
		pkt_move.x = sX;
		pkt_move.y = sY;

		hb::net::PacketEventMotionAttack pkt_attack{};
		pkt_attack.header.msg_id = dwMsgID;
		pkt_attack.header.msg_type = wMsgType;
		pkt_attack.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_attack.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_attack.v1 = static_cast<std::int8_t>(sV1 - sX);
		pkt_attack.v2 = static_cast<std::int8_t>(sV2 - sY);
		pkt_attack.v3 = static_cast<std::int16_t>(sV3);

		hb::net::PacketEventMotionDirOnly pkt_dir{};
		pkt_dir.header.msg_id = dwMsgID;
		pkt_dir.header.msg_type = wMsgType;
		pkt_dir.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_dir.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);

		const char cKey = static_cast<char>((rand() % 255) + 1);

		bFlag = true;
		iShortCutIndex = 0;

		while (bFlag) {

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;

			if ((bFlag) && (m_pClientList[i] != 0))

				if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - DEF_VIEWRANGE_X - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + DEF_VIEWRANGE_X + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - DEF_VIEWRANGE_Y - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + DEF_VIEWRANGE_Y + sRange)) {

					iTemp = base_all.status;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = m_pEntityManager->iGetNpcRelationship(sOwnerH, i);
					iTemp = (iTemp | (iTemp2 << 28));

					auto pkt_all = base_all;
					pkt_all.status = iTemp;

					auto send_packet = [&](const void* packet, std::size_t size) -> int {
						return m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(const_cast<void*>(packet)), static_cast<int>(size), cKey);
						};

					const bool is_near = (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 11) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 11) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 9) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 9);

					if (is_near) {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTSTOP:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTDYING:
							iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMOVE:
						case DEF_OBJECTRUN:
							// Send full position data to prevent desync for nearby players
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						default:
							iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							break;

						}

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarnNpc = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarnNpc > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA(NPC): client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarnNpc = dwNow;
							}
						}
					}
					else {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTDYING:
							iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						default:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						} //Switch

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarnNpcFar = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarnNpcFar > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA(NPC-far): client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarnNpcFar = dwNow;
							}
						}
					}
				}
		}
	} // else - NPC
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char* pData)
{
	int* ip, ix, iy, iSize, iTileExists, iIndex;
	class CTile* pTile;
	unsigned char ucHeader;
	short* sp, * pTotal;
	int iTemp, iTemp2;
	uint16_t* wp;
	char* cp;
	uint32_t* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short*)pData;
	cp = (char*)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	iIndex = 0;

	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;

		iIndex++;

		pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX + ix) + (sY + iy) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
//xxxxxx
		/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}*/

		if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
			(pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0)) {

			iTileExists++;

			sp = (short*)cp;
			*sp = ix;
			cp += 2;
			sp = (short*)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			ucHeader = 0;

			if (pTile->m_sOwner != 0) {
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
			}
			if (pTile->m_sDeadOwner != 0) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sDeadOwner] != 0)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
			}

			if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;

			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					sp = (short*)cp;
					*sp = pTile->m_sOwner;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;

					ip = (int*)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					ip = (int*)cp;

					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide) {
						if (iClientH != pTile->m_sOwner) {
							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
						}
						else {
							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						}
					}
					else {
						iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					}

					//iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;

					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:
					sp = (short*)cp;
					*sp = pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;

					ip = (int*)cp;
					iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = m_pEntityManager->iGetNpcRelationship(pTile->m_sOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;

					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp += 5;
					iSize += 5;
				}//end switch
			}// if ((ucHeader & 0x01) != 0)

			if ((ucHeader & 0x02) != 0) {
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:

					sp = (short*)cp;
					*sp = pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;

					ip = (int*)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					ip = (int*)cp;

					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide) {
						if (iClientH != pTile->m_sDeadOwner) {
							iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
						}
						else {
							iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						}
					}
					else {
						iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					}

					//iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;

					iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;

					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:
					sp = (short*)cp;
					*sp = pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;

					ip = (int*)cp;

					iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = m_pEntityManager->iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;

					cp += 4;
					iSize += 4;

					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp += 5;
					iSize += 5;
					break;
				}//End Switch
			}// if ((ucHeader & 0x02) != 0)

			if (pTile->m_pItem[0] != 0) {
				sp = (short*)cp;
				*sp = pTile->m_pItem[0]->m_sIDnum;
				cp += 2;
				iSize += 2;

				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;

				dwp = (uint32_t*)cp;
				*dwp = pTile->m_pItem[0]->m_dwAttribute;
				cp += 4;
				iSize += 4;
			}

			if (pTile->m_sDynamicObjectType != 0) {

				wp = (uint16_t*)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;

				sp = (short*)cp;
				*sp = pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			} //(pTile->m_sDynamicObjectType != 0)

		} //(pTile->m_sOwner != 0)
	} // end While(1)
	*pTotal = iTileExists;
	return iSize;
}

void CGame::CheckClientResponseTime()
{
	int i, iPlusTime, iMaxSuperAttack, iValue;
	short sTemp;
	uint32_t dwTime;
	short sItemIndex;
	static uint32_t s_dwLastIdleLog = 0;
	//locobans
	//int iMapside, iMapside2;
	//SYSTEMTIME SysTime;

	   /*
	   GetLocalTime(&SysTime);
	   switch (SysTime.wDayOfWeek) {
	   case 1:	iWarPeriod = 30; break; //¿ù¿äÀÏ
	   case 2:	iWarPeriod = 30; break; //È­¿äÀÏ
	   case 3:	iWarPeriod = 60; break; //¼ö¿äÀÏ
	   case 4:	iWarPeriod = 60*2;  break; //¸ñ¿äÀÏ
	   case 5:	iWarPeriod = 60*5;  break; //±Ý¿äÀÏ
	   case 6:	iWarPeriod = 60*10; break; //Åä¿äÀÏ
	   case 0:	iWarPeriod = 60*20; break; //ÀÏ¿äÀÏ
	   }
	   */

	dwTime = GameClock::GetTimeMS();

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {

			if ((dwTime - m_pClientList[i]->m_dwTime) > (uint32_t)m_iClientTimeout) {
				if (m_pClientList[i]->m_bIsInitComplete) {
					//Testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, true, true);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > (uint32_t)m_iClientTimeout) {
					DeleteClient(i, false, false);
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete) {
				uint32_t dwIdle = dwTime - m_pClientList[i]->m_dwTime;
				if (dwIdle > 5000 && (dwTime - m_pClientList[i]->m_dwLastMsgTime) > 5000 &&
					(dwTime - s_dwLastIdleLog) > 5000) {
					std::snprintf(G_cTxt, sizeof(G_cTxt),
						"[NET] IDLE slot=%d idle=%ums lastmsg=0x%08X lastage=%ums size=%u char=%s ip=%s",
						i, dwIdle, m_pClientList[i]->m_dwLastMsgId,
						dwTime - m_pClientList[i]->m_dwLastMsgTime,
						m_pClientList[i]->m_dwLastMsgSize,
						m_pClientList[i]->m_cCharName,
						m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);
					s_dwLastIdleLog = dwTime;
				}

				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;

				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > (uint32_t)m_iHungerConsumeInterval) && (m_pClientList[i]->m_bIsKilled == false)) {
					if (m_pClientList[i]->m_iAdminUserLevel < 1) {
						m_pClientList[i]->m_iHungerStatus--;
					}
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;

					SendNotifyMsg(0, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, 0, 0, 0);
				}

				if (_bCheckCharacterData(i) == false) {
					DeleteClient(i, true, true);
					break;
				}

				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0))
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus) * 1000;
				else iPlusTime = 0;

				iPlusTime = abs(iPlusTime);

				// HP
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (uint32_t)(m_iHealthRegenInterval + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}

				// MP
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (uint32_t)(m_iManaRegenInterval + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}

				// SP
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (uint32_t)(m_iStaminaRegenInterval + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}

				if ((m_pClientList[i]->m_bIsPoisoned) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > (uint32_t)m_iPoisonDamageInterval)) {
					PoisonEffect(i, 0);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}

				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == false) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (uint32_t)m_iAutosaveInterval)) {
					g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}

				// ExpStock
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (uint32_t)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i);
				}

				// AutoExe
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (uint32_t)DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel / 2);
					if (iValue <= 0) iValue = 1;
					uint32_t iValueDw = static_cast<uint32_t>(iValue);
					if (m_pClientList[i]->m_iAutoExpAmount < iValueDw) {
						if ((m_pClientList[i]->m_iExp + iValueDw) < m_iLevelExpTable[m_pClientList[i]->m_iLevel + 1]) {
							//m_pClientList[i]->m_iExpStock += iValue;
							GetExp(i, iValueDw, false);
							CalcExpStock(i);
						}
					}

					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}

				// v1.432
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
					// New 25/05/2004
					// After the time up, add magic back
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if ((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99) {
								m_pClientList[i]->m_cMagicMastery[94] = true;
								SendNotifyMsg(0, i, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;

				// v1.432
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled) {
					uint32_t elapsedSec = (dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime) / 1000;
					if (elapsedSec > static_cast<uint32_t>(m_pClientList[i]->m_iSpecialAbilityLastSec)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = false;
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					std::memset(m_pClientList[i]->m_cLockedMapName, 0, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}

				// v2.04
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if ((m_pClientList[i]->m_bIsWarLocation) && IsEnemyZone(i) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					// Crusade
					if (m_bIsCrusadeMode == false)
						if (m_pClientList[i]->m_bIsInsideOwnTown == false)
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = false;

						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "1   ");
					}
				}

				if ((m_bIsHeldenianMode) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != 0)) {
					if (bCheckHeldenianMap(i, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, true);
					}
					else {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, false);
					}
				}

				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ¼Óµµ Á¶ÀÛ", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == 0) break;
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					if ((m_pClientList[i]->m_cSide == 1) &&
						(m_pClientList[i]->m_iAdminUserLevel == 0)) {
						RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
					}
					else if ((m_pClientList[i]->m_cSide == 2) &&
						(m_pClientList[i]->m_iAdminUserLevel == 0)) {
						RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
					}
				}

				if (m_pClientList[i] == 0) break;
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) &&
					(m_pClientList[i]->m_iLevel >= 20) &&
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}

				if (m_pClientList[i] == 0) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap) &&
					(m_bIsApocalypseMode == false) &&
					(m_pClientList[i]->m_iAdminUserLevel == 0))
				{
					RequestTeleportHandler(i, "1   ");
				}

				//(m_bIsCrusadeMode )
				/*
				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "aresden",7) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvine",6) == 0)) ) {
					iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
					if (iMapside > 3) iMapside2 = iMapside - 2;
					else iMapside2 = iMapside;

					if ((m_pClientList[i]->m_cSide != iMapside2) && (iMapside != 0)) {
						if ((iMapside <= 2) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
							if (m_pClientList[i]->m_cSide != 0) {
								m_pClientList[i]->m_dwWarBeginTime = GameClock::GetTimeMS();
								m_pClientList[i]->m_bIsWarLocation = true;
								m_pClientList[i]->m_iTimeLeft_ForceRecall = 1;

								RequestTeleportHandler(i, "1   ");
								SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
							}
						}
					}
				}*/

				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "arehunter", 9) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvhunter", 9) == 0)) &&
					((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0))) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "1   ");
				}

				if (m_bIsApocalypseMode) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0)
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, 0, m_pClientList[i]->m_cMapName);
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0)
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 89, 31, 0, m_pClientList[i]->m_cMapName);
				}

				if (m_pClientList[i] == 0) break;
				if ((m_bIsApocalypseMode) &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) &&
					((m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 31) ||
						(m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 32) ||
						(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 31) ||
						(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 32))) {
					RequestTeleportHandler(i, "2   ", "druncncity", -1, -1);
				}

				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0)
					&& (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0) &&
					(m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if ((m_pClientList[i]->m_bInRecallImpossibleMap) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bInRecallImpossibleMap = false;
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "0   ");
					}
				}

				if (m_pClientList[i] == 0) break;
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39

					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;

					// v1.12
					SendNotifyMsg(0, i, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
				}

				// v1.42
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	/*int   iRet;

	   if (m_pMainLogSock == 0) return;

	   iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	   switch (iRet) {
	   case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		   PutLogList("(!!!) Main-log-socket connected!");
		   bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, 0);
		   break;

	   case DEF_XSOCKEVENT_READCOMPLETE:
		   OnMainLogRead();
		   break;

	   case DEF_XSOCKEVENT_BLOCK:
		   PutLogList("(!!!) Main-log-socket BLOCKED!");
		   break;

	   case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	   case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	   case DEF_XSOCKEVENT_SOCKETERROR:
	   case DEF_XSOCKEVENT_SOCKETCLOSED:
		   delete m_pMainLogSock;
		   m_pMainLogSock = 0;
		   PutLogList("(!!!) Main-log-socket connection lost!");
		   m_bIsLogSockAvailable = false;

		   if (m_bOnExitProcess == false) {
			   m_cShutDownCode      = 3;
			   m_bOnExitProcess     = true;
			   m_dwExitProcessTime  = GameClock::GetTimeMS();
			   PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		   }
		   break;
	   }*/
}

void CGame::OnMainLogRead()
{
	uint32_t dwMsgSize;
	char* pData, cKey;

	pData = _lsock->pGetRcvDataPointer(&dwMsgSize, &cKey); //m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, 0, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


bool CGame::bSendMsgToLS(uint32_t dwMsg, int iClientH, bool bFlag, char* pData)
{
	char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21];
	char    cGuildLoc[11];


	/*
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	iCnt = 0;
	bLoopFlag = false;
	while (bLoopFlag == false) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != 0)
			 bLoopFlag = true;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			if (m_bOnExitProcess == false) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = true;
				m_dwExitProcessTime  = GameClock::GetTimeMS();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return false;
		}
	}
	*/


	// v1.41
	std::memset(G_cData50000, 0, sizeof(G_cData50000));
	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cAccountName, 0, sizeof(cAccountName));
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));
	std::memset(cAddress, 0, sizeof(cAddress));
	std::memset(cGuildName, 0, sizeof(cGuildName));
	std::memset(cGuildLoc, 0, sizeof(cGuildLoc));

	char cFn[112] = {};
	SYSTEMTIME SysTime;
	FILE* pFile;

	GetLocalTime(&SysTime);
	std::memset(cFn, 0, sizeof(cFn));

	switch (dwMsg) {
		// New 07/05/2004
		//case MSGID_GAMEMASTERLOG:
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;

		//	if (m_pClientList[iClientH] == 0) return false;
		//	if (pData == 0) return false ;


		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_GAMEMASTERLOG;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	iSize =  strlen(pData) ;
		//	memcpy((char *)cp, pData, iSize);

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		//	iSendSize = 6 + iSize;
		//	break;
		//	// v2.15 

		//case MSGID_GAMEITEMLOG:
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;

		//	//		if (m_pClientList[iClientH] == 0) return false;
		//	if (pData == 0) return false ;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_GAMEITEMLOG;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	iSize =  strlen(pData) ;
		//	memcpy((char *)cp, pData, iSize);

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		//	iSendSize = 6 + iSize;
		//	break;

		//case MSGID_SENDSERVERSHUTDOWNMSG:
		//	if (m_pMainLogSock == 0) return false;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;
		//	
		//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		//	break;
		//
		//case MSGID_GAMESERVERSHUTDOWNED:
		//	if (m_pMainLogSock == 0) return false;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_GAMESERVERSHUTDOWNED;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;
		//	
		//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		//	return true;

		//case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
		//case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = dwMsg;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;
		//	
		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		//	cp += 10;

		//	ip = (int *)cp;
		//	*ip = m_pClientList[iClientH]->m_iLevel;
		//	cp += 4;
		//
		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		//	iSendSize = 16;
		//	break;

		//case MSGID_ENTERGAMECONFIRM:
		//	
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_ENTERGAMECONFIRM;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;
		//	
		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		//	cp += 10;

		//	memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		//	cp += 10;

		//	memcpy(cp, m_cServerName, 10);
		//	cp += 10;

		//	std::memset(cTxt, 0, sizeof(cTxt));
		//	m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		//	memcpy(cp, cTxt, 16);
		//	cp += 16;

		//	ip = (int *)cp;
		//	*ip = m_pClientList[iClientH]->m_iLevel;
		//	cp += 4;

		//	//testcode
		//	std::snprintf(G_cTxt, sizeof(G_cTxt), "Confirmed. Account: (%s) Name: (%s) Level: (%d)", m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
		//	PutLogList(G_cTxt);



		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		//	iSendSize = 56;
		//	if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		//	break;
		//	}
		//	else
		//	m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;


		//	break;
		//
		//case MSGID_REQUEST_REGISTERGAMESERVER:
		//	if (m_pMainLogSock == 0) return false;
		//			
		//	std::snprintf(cTxt, sizeof(cTxt), "(!) Try to register game server(%s)", m_cServerName);
		//	PutLogList(cTxt);
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;
		//	
		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cAccountName, m_cServerName, 10);
		//	if (m_iGameServerMode == 1)
		//	{
		//		memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		//	}
		//	if (m_iGameServerMode == 2)
		//	{
		//		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		//	}
		//	memcpy(cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy(cp, cAddress, 16);
		//	cp += 16;

		//	wp  = (uint16_t *)cp;
		//	*wp = m_iGameServerPort;
		//	cp += 2;

		//	*cp = m_iTotalMaps;
		//	cp++;

		//	for (i = 0; i < m_iTotalMaps; i++) {
		//		memcpy(cp, m_pMapList[i]->m_cName, 11);
		//		cp += 11;
		//	}

		//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11); 

		//	return true;

		//case MSGID_REQUEST_PLAYERDATA:
		//	
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;

		//	if (m_pClientList[iClientH] == 0) return false;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_PLAYERDATA;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	//testcode
		//	if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName 0!");

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountPassword, 10);
		//	cp += 10;

		//	std::memset(cTemp, 0, sizeof(cTemp));
		//	iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		//	memcpy((char *)cp, cTemp, 15);
		//	cp += 15;
		//	
		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		//	iSendSize = 52;
		//	break;

		//case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
		//case MSGID_REQUEST_SAVEPLAYERDATA:
		//case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = dwMsg;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountPassword, 10);
		//	cp += 10;

		//	*cp = (char)bFlag;
		//	cp++;
		//	
		//	
		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		//	iSendSize = 37 + iSize;
		//	break;

		//case MSGID_REQUEST_NOSAVELOGOUT:

		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountPassword, 10);
		//	cp += 10;
		//	
		//	*cp = (char)bFlag;
		//	cp++;
		//	
		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		//	iSendSize = 37;
		//	break;
		//
		//case MSGID_REQUEST_CREATENEWGUILD:

		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_CREATENEWGUILD;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		//	memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountPassword, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cGuildName, 20);
		//	cp += 20;
		//	memcpy((char *)cp, cGuildLoc, 10);
		//	cp += 10;

		//	ip = (int *)cp;
		//	*ip = m_pClientList[iClientH]->m_iGuildGUID;
		//	cp += 4;

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		//	iSendSize = 75;
		//	break;

		//case MSGID_REQUEST_DISBANDGUILD:
		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_DISBANDGUILD;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cAccountPassword, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cGuildName, 20);
		//	cp += 20;
		//	
		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		//	iSendSize = 56;
		//	break;

		//case MSGID_REQUEST_HELDENIAN_WINNER:
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	if (m_cHeldenianVictoryType == 1)
		//		memcpy(cp, "aresden", 7);
		//	else if (m_cHeldenianVictoryType == 2)
		//		memcpy(cp, "elvine", 6);
		//	else 
		//		memcpy(cp, "draw", 4);

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
		//	iSendSize = 21;
		//	break;
		//
		//case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;
		//	
		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cGuildName, 20);
		//	cp += 20;

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		//	iSendSize = 36;
		//	break;

		//case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		//	// Sub-log-socket
		//	if (_bCheckSubLogSocketIndex() == false) return false;
		//	
		//	if (m_pClientList[iClientH] == 0) return false;

		//	dwp  = (uint32_t *)(G_cData50000 + DEF_INDEX4_MSGID);
		//	*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		//	wp   = (uint16_t *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		//	*wp  = DEF_MSGTYPE_CONFIRM;

		//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		//	memcpy((char *)cp, cCharName, 10);
		//	cp += 10;

		//	memcpy((char *)cp, cGuildName, 20);
		//	cp += 20;

		//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		//	iSendSize = 36;
		//	break;
	case MSGID_GAMEMASTERLOG:
		std::snprintf(cFn, sizeof(cFn), "GameLogs\\MasterLog-%d-%d-%d.txt", SysTime.wYear, SysTime.wMonth, SysTime.wDay);
		pFile = fopen(cFn, "at");
		if (pFile == 0) return false;
		fwrite(pData, 1, strlen(pData), pFile);
		fclose(pFile);
		break;
	case MSGID_GAMEITEMLOG:
		std::snprintf(cFn, sizeof(cFn), "GameLogs\\ItemLog-%d-%d-%d.txt", SysTime.wYear, SysTime.wMonth, SysTime.wDay);
		pFile = fopen(cFn, "at");
		if (pFile == 0) return false;
		fwrite(pData, 1, strlen(pData), pFile);
		fclose(pFile);
		break;
	}

	//switch (iRet) {
	//case DEF_XSOCKEVENT_QUENEFULL:
	//case DEF_XSOCKEVENT_SOCKETERROR:
	//case DEF_XSOCKEVENT_CRITICALERROR:
	//case DEF_XSOCKEVENT_SOCKETCLOSED:
	//	// Sub-log-socket
	//	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
	//	PutLogList(G_cTxt);
	//	PutLogFileList(G_cTxt);

	//	delete m_pSubLogSock[m_iCurSubLogSockIndex];
	//	m_pSubLogSock[m_iCurSubLogSockIndex] = 0;
	//	m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = false;
	//	m_iSubLogSockActiveCount--;
	//			
	//	m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

	//	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
	//	PutLogList(G_cTxt);
	//	
	//	// v1.41 sub-log-socket
	//	m_iSubLogSockFailCount++;

	//	// v1.41
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

	//	return false;
	//}

	return true;
}

void CGame::ResponsePlayerDataHandler(char* pData, uint32_t dwSize)
{
	char* cp, cCharName[11], cTxt[120];
	int  i;

	std::memset(cCharName, 0, sizeof(cCharName));
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				switch (header->msg_type) {
				case DEF_LOGRESMSGTYPE_CONFIRM:
					InitPlayerData(i, pData, dwSize);
					break;

				case DEF_LOGRESMSGTYPE_REJECT:
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
					PutLogList(G_cTxt);
					//PutLogFileList(G_cTxt); // v1.4

					DeleteClient(i, false, false);
					break;

				default:
					break;
				}

				return;
			}
		}

	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

bool CGame::LoadPlayerDataFromDb(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return false;

	sqlite3* db = nullptr;
	std::string dbPath;
	if (!EnsureAccountDatabase(m_pClientList[iClientH]->m_cAccountName, &db, dbPath)) {
		return false;
	}

	AccountDbCharacterState state = {};
	if (!LoadCharacterState(db, m_pClientList[iClientH]->m_cCharName, state)) {
		CloseAccountDatabase(db);
		return false;
	}

	std::memset(m_pClientList[iClientH]->m_cProfile, 0, sizeof(m_pClientList[iClientH]->m_cProfile));
	std::snprintf(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile), "%s", state.profile);

	std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
	std::snprintf(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation), "%s", state.location);

	std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
	std::snprintf(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName), "%s", state.guildName);
	m_pClientList[iClientH]->m_iGuildGUID = state.guildGuid;
	m_pClientList[iClientH]->m_iGuildRank = state.guildRank;

	std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
	std::snprintf(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName), "%s", state.mapName);
	m_pClientList[iClientH]->m_cMapIndex = -1;
	for (int i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != 0) && (memcmp(m_pMapList[i]->m_cName, m_pClientList[iClientH]->m_cMapName, 10) == 0)) {
			m_pClientList[iClientH]->m_cMapIndex = (char)i;
			break;
		}
	}
	if (m_pClientList[iClientH]->m_cMapIndex == -1) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
		PutLogList(G_cTxt);
		CloseAccountDatabase(db);
		return false;
	}

	m_pClientList[iClientH]->m_sX = (short)state.mapX;
	m_pClientList[iClientH]->m_sY = (short)state.mapY;
	m_pClientList[iClientH]->m_iHP = state.hp;
	m_pClientList[iClientH]->m_iMP = state.mp;
	m_pClientList[iClientH]->m_iSP = state.sp;
	m_pClientList[iClientH]->m_iLevel = state.level;
	m_pClientList[iClientH]->m_iRating = state.rating;
	m_pClientList[iClientH]->m_iStr = state.str;
	m_pClientList[iClientH]->m_iInt = state.intl;
	m_pClientList[iClientH]->m_iVit = state.vit;
	m_pClientList[iClientH]->m_iDex = state.dex;
	m_pClientList[iClientH]->m_iMag = state.mag;
	m_pClientList[iClientH]->m_iCharisma = state.chr;
	m_pClientList[iClientH]->m_iLuck = state.luck;
	m_pClientList[iClientH]->m_iExp = state.exp;
	m_pClientList[iClientH]->m_iLU_Pool = state.luPool;
	m_pClientList[iClientH]->m_iEnemyKillCount = state.enemyKillCount;
	m_pClientList[iClientH]->m_iPKCount = state.pkCount;
	m_pClientList[iClientH]->m_iRewardGold = state.rewardGold;
	m_pClientList[iClientH]->m_iDownSkillIndex = state.downSkillIndex;
	m_pClientList[iClientH]->m_sCharIDnum1 = (short)state.idnum1;
	m_pClientList[iClientH]->m_sCharIDnum2 = (short)state.idnum2;
	m_pClientList[iClientH]->m_sCharIDnum3 = (short)state.idnum3;
	m_pClientList[iClientH]->m_cSex = (char)state.sex;
	m_pClientList[iClientH]->m_cSkin = (char)state.skin;
	m_pClientList[iClientH]->m_cHairStyle = (char)state.hairStyle;
	m_pClientList[iClientH]->m_cHairColor = (char)state.hairColor;
	m_pClientList[iClientH]->m_cUnderwear = (char)state.underwear;
	m_pClientList[iClientH]->m_iHungerStatus = state.hungerStatus;
	m_pClientList[iClientH]->m_iTimeLeft_ShutUp = state.timeleftShutup;
	m_pClientList[iClientH]->m_iTimeLeft_Rating = state.timeleftRating;
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = state.timeleftForceRecall;
	m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = state.timeleftFirmStaminar;
	m_pClientList[iClientH]->m_iAdminUserLevel = state.adminUserLevel;
	m_pClientList[iClientH]->m_iPenaltyBlockYear = state.penaltyBlockYear;
	m_pClientList[iClientH]->m_iPenaltyBlockMonth = state.penaltyBlockMonth;
	m_pClientList[iClientH]->m_iPenaltyBlockDay = state.penaltyBlockDay;
	m_pClientList[iClientH]->m_iQuest = state.questNumber;
	m_pClientList[iClientH]->m_iQuestID = state.questId;
	m_pClientList[iClientH]->m_iCurQuestCount = state.currentQuestCount;
	m_pClientList[iClientH]->m_iQuestRewardType = state.questRewardType;
	m_pClientList[iClientH]->m_iQuestRewardAmount = state.questRewardAmount;
	m_pClientList[iClientH]->m_iContribution = state.contribution;
	m_pClientList[iClientH]->m_iWarContribution = state.warContribution;
	m_pClientList[iClientH]->m_bIsQuestCompleted = (state.questCompleted != 0);
	m_pClientList[iClientH]->m_iSpecialEventID = state.specialEventId;
	m_pClientList[iClientH]->m_iSuperAttackLeft = state.superAttackLeft;
	m_pClientList[iClientH]->m_iFightzoneNumber = state.fightzoneNumber;
	m_pClientList[iClientH]->m_iReserveTime = state.reserveTime;
	m_pClientList[iClientH]->m_iFightZoneTicketNumber = state.fightzoneTicketNumber;
	m_pClientList[iClientH]->m_iSpecialAbilityTime = state.specialAbilityTime;
	std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
	std::snprintf(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName), "%s", state.lockedMapName);
	m_pClientList[iClientH]->m_iLockedMapTime = state.lockedMapTime;
	m_pClientList[iClientH]->m_iCrusadeDuty = state.crusadeJob;
	m_pClientList[iClientH]->m_dwCrusadeGUID = state.crusadeGuid;
	m_pClientList[iClientH]->m_iConstructionPoint = state.constructPoint;
	m_pClientList[iClientH]->m_iDeadPenaltyTime = state.deadPenaltyTime;
	m_pClientList[iClientH]->m_iPartyID = state.partyId;
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = state.gizonItemUpgradeLeft;
	m_pClientList[iClientH]->m_sAppr1 = state.appr1;
	m_pClientList[iClientH]->m_sAppr2 = state.appr2;
	m_pClientList[iClientH]->m_sAppr3 = state.appr3;
	m_pClientList[iClientH]->m_sAppr4 = state.appr4;
	m_pClientList[iClientH]->m_iApprColor = state.apprColor;

	for (int i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			delete m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = 0;
		}
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
	}

	for (int i = 0; i < DEF_MAXBANKITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0) {
			delete m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
		}
	}

	std::vector<AccountDbIndexedValue> positionsX;
	std::vector<AccountDbIndexedValue> positionsY;
	LoadCharacterItemPositions(db, m_pClientList[iClientH]->m_cCharName, positionsX, positionsY);
	for (size_t i = 0; i < positionsX.size(); i++) {
		int slot = positionsX[i].index;
		if (slot >= 0 && slot < DEF_MAXITEMS) {
			m_pClientList[iClientH]->m_ItemPosList[slot].x = positionsX[i].value;
			m_pClientList[iClientH]->m_ItemPosList[slot].y = positionsY[i].value;
		}
	}

	std::vector<AccountDbItemRow> items;
	LoadCharacterItems(db, m_pClientList[iClientH]->m_cCharName, items);
	for (const auto& item : items) {
		if (item.slot < 0 || item.slot >= DEF_MAXITEMS) {
			continue;
		}
		if (m_pClientList[iClientH]->m_pItemList[item.slot] != 0) {
			delete m_pClientList[iClientH]->m_pItemList[item.slot];
		}
		m_pClientList[iClientH]->m_pItemList[item.slot] = new class CItem;
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[item.slot], item.itemId) == false) {
			delete m_pClientList[iClientH]->m_pItemList[item.slot];
			m_pClientList[iClientH]->m_pItemList[item.slot] = 0;
			continue;
		}
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwCount = item.count;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectType = item.touchEffectType;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue1 = item.touchEffectValue1;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue2 = item.touchEffectValue2;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue3 = item.touchEffectValue3;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_cItemColor = item.itemColor;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue1 = item.specEffectValue1;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue2 = item.specEffectValue2;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue3 = item.specEffectValue3;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan = (short)item.curLifeSpan;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwAttribute = item.attribute;

		if ((m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwAttribute & 0x00000001) != 0) {
			m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue1;
		}
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[item.slot]);
		if (m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan) {
			m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan;
		}
		bCheckAndConvertPlusWeaponItem(iClientH, item.slot);
	}

	std::vector<AccountDbBankItemRow> bankItems;
	LoadCharacterBankItems(db, m_pClientList[iClientH]->m_cCharName, bankItems);
	for (const auto& item : bankItems) {
		if (item.slot < 0 || item.slot >= DEF_MAXBANKITEMS) {
			continue;
		}
		if (m_pClientList[iClientH]->m_pItemInBankList[item.slot] != 0) {
			delete m_pClientList[iClientH]->m_pItemInBankList[item.slot];
		}
		m_pClientList[iClientH]->m_pItemInBankList[item.slot] = new class CItem;
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[item.slot], item.itemId) == false) {
			delete m_pClientList[iClientH]->m_pItemInBankList[item.slot];
			m_pClientList[iClientH]->m_pItemInBankList[item.slot] = 0;
			continue;
		}
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwCount = item.count;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectType = item.touchEffectType;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue1 = item.touchEffectValue1;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue2 = item.touchEffectValue2;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue3 = item.touchEffectValue3;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_cItemColor = item.itemColor;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue1 = item.specEffectValue1;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue2 = item.specEffectValue2;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue3 = item.specEffectValue3;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan = (short)item.curLifeSpan;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwAttribute = item.attribute;
		if ((m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwAttribute & 0x00000001) != 0) {
			m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue1;
		}
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[item.slot]);
		if (m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan) {
			m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan;
		}
	}

	std::vector<AccountDbIndexedValue> equips;
	LoadCharacterItemEquips(db, m_pClientList[iClientH]->m_cCharName, equips);
	for (const auto& equip : equips) {
		if (equip.index >= 0 && equip.index < DEF_MAXITEMS) {
			m_pClientList[iClientH]->m_bIsItemEquipped[equip.index] = (equip.value != 0);
		}
	}

	int packedIndex = 0;
	for (int i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
			continue;
		}
		if (i != packedIndex) {
			m_pClientList[iClientH]->m_pItemList[packedIndex] = m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = 0;
			m_pClientList[iClientH]->m_ItemPosList[packedIndex] = m_pClientList[iClientH]->m_ItemPosList[i];
			m_pClientList[iClientH]->m_bIsItemEquipped[packedIndex] = m_pClientList[iClientH]->m_bIsItemEquipped[i];
		}
		packedIndex++;
	}
	for (int i = packedIndex; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
	}

	packedIndex = 0;
	for (int i = 0; i < DEF_MAXBANKITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			continue;
		}
		if (i != packedIndex) {
			m_pClientList[iClientH]->m_pItemInBankList[packedIndex] = m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
		}
		packedIndex++;
	}
	for (int i = packedIndex; i < DEF_MAXBANKITEMS; i++) {
		m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
	}

	for (int i = 0; i < DEF_MAXITEMEQUIPPOS; i++) {
		m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;
	}

	for (int i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && m_pClientList[iClientH]->m_bIsItemEquipped[i]) {
			if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) {
				if (bEquipItemHandler(iClientH, i) == false) {
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
				}
			}
			else {
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
			}
		}
	}

	for (int i = 0; i < DEF_MAXMAGICTYPE; i++) {
		m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
	}
	std::vector<AccountDbIndexedValue> magicMastery;
	LoadCharacterMagicMastery(db, m_pClientList[iClientH]->m_cCharName, magicMastery);
	for (const auto& entry : magicMastery) {
		if (entry.index >= 0 && entry.index < DEF_MAXMAGICTYPE) {
			m_pClientList[iClientH]->m_cMagicMastery[entry.index] = (char)entry.value;
		}
	}

	for (int i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_cSkillMastery[i] = 0;
		m_pClientList[iClientH]->m_iSkillSSN[i] = 0;
	}
	std::vector<AccountDbIndexedValue> skillMastery;
	LoadCharacterSkillMastery(db, m_pClientList[iClientH]->m_cCharName, skillMastery);
	for (const auto& entry : skillMastery) {
		if (entry.index >= 0 && entry.index < DEF_MAXSKILLTYPE) {
			m_pClientList[iClientH]->m_cSkillMastery[entry.index] = (unsigned char)entry.value;
		}
	}

	std::vector<AccountDbIndexedValue> skillSsn;
	LoadCharacterSkillSSN(db, m_pClientList[iClientH]->m_cCharName, skillSsn);
	for (const auto& entry : skillSsn) {
		if (entry.index >= 0 && entry.index < DEF_MAXSKILLTYPE) {
			m_pClientList[iClientH]->m_iSkillSSN[entry.index] = entry.value;
		}
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) {
		m_pClientList[iClientH]->m_iAdminUserLevel = 0;
	}

	short sTmpType = 0;
	if (m_pClientList[iClientH]->m_cSex == 1) {
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		sTmpType = 4;
	}
	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) {
		sTmpType = (short)m_pClientList[iClientH]->m_iAdminUserLevel;
	}
	short sTmpAppr1 = (short)((m_pClientList[iClientH]->m_cHairStyle << 8) |
		(m_pClientList[iClientH]->m_cHairColor << 4) |
		(m_pClientList[iClientH]->m_cUnderwear));
	m_pClientList[iClientH]->m_sType = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		int temp1 = 1;
		int temp2 = 1;
		for (int i = 0; i < 10; i++) {
			temp1 += m_pClientList[iClientH]->m_cCharName[i];
			temp2 += abs(m_pClientList[iClientH]->m_cCharName[i] ^ m_pClientList[iClientH]->m_cCharName[i]);
		}
		m_pClientList[iClientH]->m_sCharIDnum1 = (short)GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_sCharIDnum2 = (short)temp1;
		m_pClientList[iClientH]->m_sCharIDnum3 = (short)temp2;
	}

	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	CloseAccountDatabase(db);
	return true;
}

void CGame::InitPlayerData(int iClientH, char* pData, uint32_t dwSize)
{
	char cTxt[256], cQuestRemain;
	int     iRet, i, iTotalPoints;
	bool    bRet, bGuildStatus;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) return; // ÀÌ¹Ì ÃÊ±âÈ­ µÈ Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍÀÌ´Ù. ÀÌ·±ÀÏÀÌ ÀÖÀ» ¼ö ÀÖÀ»±î?

	// Log Server
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	//std::memset(cName, 0, sizeof(cName));
	//memcpy(cName, cp, 10);
	//cp += 10;

	////m_pClientList[iClientH]->m_cAccountStatus = *cp;
	//cp++;

	//cGuildStatus = *cp;
	//cp++;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide = 0;

	bRet = LoadPlayerDataFromDb(iClientH);
	if (bRet == false) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, false, true); //!!!
		return;
	}

	___RestorePlayerCharacteristics(iClientH);

	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil)
			ForceChangePlayMode(iClientH, false);

	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	CalcTotalItemEffect(iClientH, -1, true); //false
	iCalcTotalWeight(iClientH);

	// New 23/05/2004
	//GM Invi comes here
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
	}

	iTotalPoints = 0;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
	if ((iTotalPoints - 21 > DEF_MAXSKILLPOINTS) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	CheckSpecialEvent(iClientH);
	bCheckMagicInt(iClientH);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);

	if (strcmp(m_pClientList[iClientH]->m_cGuildName, "NONE") != 0) {
		char cFn[112] = {};
		std::memset(cFn, 0, sizeof(cFn));
		std::snprintf(cFn, sizeof(cFn), "Guilds\\AscII%d\\%s.txt", m_pClientList[iClientH]->m_cGuildName[0], m_pClientList[iClientH]->m_cGuildName);
		HANDLE  hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		auto dwFileSize = GetFileSize(hFile, 0);

		bGuildStatus = !(hFile == INVALID_HANDLE_VALUE);
		CloseHandle(hFile);
		// GuildName
		if ((!bGuildStatus) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
			std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
			m_pClientList[iClientH]->m_iGuildRank = -1;
			m_pClientList[iClientH]->m_iGuildGUID = -1;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0, m_pClientList[iClientH]->m_cGuildName);
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
		_bCheckIsQuestCompleted(iClientH);
	}


	if (m_pClientList[iClientH] == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	hb::net::PacketResponseInitPlayer pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_INITPLAYER;
	pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ## BUG POINT!!!
		std::snprintf(cTxt, sizeof(cTxt), "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, false, true); //!!!!!
		return;
	}


	m_pClientList[iClientH]->m_bIsInitComplete = true;
}

void CGame::GameProcess()
{
	// MODERNIZED: Socket polling moved to EventLoop (wmain.cpp) for continuous responsiveness
	// This function now handles only game logic processing
	NpcProcess();
	MsgProcess();
	ForceRecallProcess();
	DelayEventProcess();
}


void CGame::_ClearItemConfigList()
{
	for (int i = 0; i < DEF_MAXITEMTYPES; i++) {
		if (m_pItemConfigList[i] != 0) {
			delete m_pItemConfigList[i];
			m_pItemConfigList[i] = 0;
		}
	}
}



// Helper function to normalize item name for comparison (removes spaces and underscores)
static void NormalizeItemName(const char* src, char* dst, size_t dstSize)
{
	size_t j = 0;
	for (size_t i = 0; src[i] && j < dstSize - 1; ++i) {
		if (src[i] != ' ' && src[i] != '_') {
			dst[j++] = src[i];
		}
	}
	dst[j] = '\0';
}

bool CGame::_bInitItemAttr(class CItem* pItem, const char* pItemName)
{
	int i;
	char cTmpName[21];
	char cNormalizedInput[21];
	char cNormalizedConfig[21];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	// Normalize the input name for comparison (client may send "MagicStaff" while DB has "Magic Staff")
	NormalizeItemName(cTmpName, cNormalizedInput, sizeof(cNormalizedInput));

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) {
			// Normalize the config name for comparison
			NormalizeItemName(m_pItemConfigList[i]->m_cName, cNormalizedConfig, sizeof(cNormalizedConfig));
			if (_stricmp(cNormalizedInput, cNormalizedConfig) == 0) {
				std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
				strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
				pItem->m_cItemType = m_pItemConfigList[i]->m_cItemType;
				pItem->m_cEquipPos = m_pItemConfigList[i]->m_cEquipPos;
				pItem->m_sItemEffectType = m_pItemConfigList[i]->m_sItemEffectType;
				pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
				pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
				pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
				pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
				pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
				pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
				pItem->m_wMaxLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
				pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;					// ÃÖÃÊ·Î »ý¼ºµÈ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀº ÃÖ´ëÄ¡ÀÌ´Ù.
				pItem->m_sSpecialEffect = m_pItemConfigList[i]->m_sSpecialEffect;

				pItem->m_sSprite = m_pItemConfigList[i]->m_sSprite;
				pItem->m_sSpriteFrame = m_pItemConfigList[i]->m_sSpriteFrame;
				pItem->m_wPrice = m_pItemConfigList[i]->m_wPrice;
				pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
				pItem->m_cApprValue = m_pItemConfigList[i]->m_cApprValue;
				pItem->m_cSpeed = m_pItemConfigList[i]->m_cSpeed;
				pItem->m_sLevelLimit = m_pItemConfigList[i]->m_sLevelLimit;
				pItem->m_cGenderLimit = m_pItemConfigList[i]->m_cGenderLimit;

				pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
				pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

				pItem->m_sRelatedSkill = m_pItemConfigList[i]->m_sRelatedSkill;
				pItem->m_cCategory = m_pItemConfigList[i]->m_cCategory;
				pItem->m_sIDnum = m_pItemConfigList[i]->m_sIDnum;

				pItem->m_bIsForSale = m_pItemConfigList[i]->m_bIsForSale;
				pItem->m_cItemColor = m_pItemConfigList[i]->m_cItemColor;

				return true;
			}
		}

	return false;
}

bool CGame::_bInitItemAttr(class CItem* pItem, int iItemID)
{
	if (iItemID < 0 || iItemID >= DEF_MAXITEMTYPES) return false;
	if (m_pItemConfigList[iItemID] == nullptr) return false;

	CItem* pConfig = m_pItemConfigList[iItemID];

	std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
	strcpy(pItem->m_cName, pConfig->m_cName);
	pItem->m_cItemType = pConfig->m_cItemType;
	pItem->m_cEquipPos = pConfig->m_cEquipPos;
	pItem->m_sItemEffectType = pConfig->m_sItemEffectType;
	pItem->m_sItemEffectValue1 = pConfig->m_sItemEffectValue1;
	pItem->m_sItemEffectValue2 = pConfig->m_sItemEffectValue2;
	pItem->m_sItemEffectValue3 = pConfig->m_sItemEffectValue3;
	pItem->m_sItemEffectValue4 = pConfig->m_sItemEffectValue4;
	pItem->m_sItemEffectValue5 = pConfig->m_sItemEffectValue5;
	pItem->m_sItemEffectValue6 = pConfig->m_sItemEffectValue6;
	pItem->m_wMaxLifeSpan = pConfig->m_wMaxLifeSpan;
	pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
	pItem->m_sSpecialEffect = pConfig->m_sSpecialEffect;
	pItem->m_sSprite = pConfig->m_sSprite;
	pItem->m_sSpriteFrame = pConfig->m_sSpriteFrame;
	pItem->m_wPrice = pConfig->m_wPrice;
	pItem->m_wWeight = pConfig->m_wWeight;
	pItem->m_cApprValue = pConfig->m_cApprValue;
	pItem->m_cSpeed = pConfig->m_cSpeed;
	pItem->m_sLevelLimit = pConfig->m_sLevelLimit;
	pItem->m_cGenderLimit = pConfig->m_cGenderLimit;
	pItem->m_sSpecialEffectValue1 = pConfig->m_sSpecialEffectValue1;
	pItem->m_sSpecialEffectValue2 = pConfig->m_sSpecialEffectValue2;
	pItem->m_sRelatedSkill = pConfig->m_sRelatedSkill;
	pItem->m_cCategory = pConfig->m_cCategory;
	pItem->m_sIDnum = pConfig->m_sIDnum;
	pItem->m_bIsForSale = pConfig->m_bIsForSale;
	pItem->m_cItemColor = pConfig->m_cItemColor;

	return true;
}

bool CGame::_bGetIsStringIsNumber(char* pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}


bool CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == false) {
		return false;
	}

	return true;
}




int CGame::bCreateNewNpc(char* pNpcName, char* pName, char* pMapName, short sClass, char cSA, char cMoveType, int* poX, int* poY, char* pWaypointList, RECT* pArea, int iSpotMobIndex, char cChangeSide, bool bHideGenMode, bool bIsSummoned, bool bFirmBerserk, bool bIsMaster, int iGuildGUID)
{
	if (m_pEntityManager == 0)
		return false;

	return (m_pEntityManager->CreateEntity(
		pNpcName, pName, pMapName, sClass, cSA, cMoveType,
		poX, poY, pWaypointList, pArea, iSpotMobIndex, cChangeSide,
		bHideGenMode, bIsSummoned, bFirmBerserk, bIsMaster, iGuildGUID) > 0);
}

int CGame::SpawnMapNpcsFromDatabase(sqlite3* db, int iMapIndex)
{
	if (db == nullptr || m_pMapList[iMapIndex] == nullptr)
		return 0;

	const char* sql =
		"SELECT npc_name, move_type, waypoint_list, name_prefix"
		" FROM map_npcs WHERE map_name = ? COLLATE NOCASE;";

	sqlite3_stmt* stmt = nullptr;
	if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
		return 0;
	}

	sqlite3_bind_text(stmt, 1, m_pMapList[iMapIndex]->m_cName, -1, SQLITE_STATIC);

	int npcCount = 0;
	char cNpcName[24];
	char cNpcWaypointIndex[12];
	char cNamePrefix;
	char cNpcMoveType;
	char cName[8];
	int iNamingValue;

	while (sqlite3_step(stmt) == SQLITE_ROW) {
		// Get NPC name
		const char* npcName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
		if (npcName == nullptr) continue;
		std::memset(cNpcName, 0, sizeof(cNpcName));
		strncpy(cNpcName, npcName, sizeof(cNpcName) - 1);

		// Get move type
		cNpcMoveType = static_cast<char>(sqlite3_column_int(stmt, 1));

		// Get waypoint list (comma-separated string like "0,0,0,0,0,0,0,0,0,0")
		std::memset(cNpcWaypointIndex, 0, sizeof(cNpcWaypointIndex));
		const char* waypointList = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
		if (waypointList != nullptr && strlen(waypointList) > 0) {
			// Parse comma-separated waypoints
			char waypointCopy[64];
			strncpy(waypointCopy, waypointList, sizeof(waypointCopy) - 1);
			waypointCopy[sizeof(waypointCopy) - 1] = '\0';

			char* token = strtok(waypointCopy, ",");
			int wpIndex = 0;
			while (token != nullptr && wpIndex < 10) {
				cNpcWaypointIndex[wpIndex] = static_cast<char>(atoi(token));
				token = strtok(nullptr, ",");
				wpIndex++;
			}
		}

		// Get name prefix
		const char* prefix = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3));
		cNamePrefix = (prefix != nullptr && strlen(prefix) > 0) ? prefix[0] : '_';

		// Get a naming value for this NPC
		iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// No more naming values available for this map
			continue;
		}

		// Construct the NPC instance name
		std::memset(cName, 0, sizeof(cName));
		std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
		cName[0] = cNamePrefix;
		cName[1] = static_cast<char>(iMapIndex + 65);

		// Spawn the NPC
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, 0, 0, cNpcWaypointIndex, 0, 0, -1, false) == false) {
			// Failed, release the naming value
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
		else {
			npcCount++;
		}
	}

	sqlite3_finalize(stmt);

	if (npcCount > 0) {
		char cTxt[128];
		std::snprintf(cTxt, sizeof(cTxt), "  - Spawned %d static NPCs for map: %s", npcCount, m_pMapList[iMapIndex]->m_cName);
		PutLogList(cTxt);
	}

	return npcCount;
}

void CGame::NpcProcess()
{
	if (m_pEntityManager != 0)
		m_pEntityManager->ProcessEntities();
}


// 05/29/2004 - Hypnotoad - GM chat tweak
void CGame::ChatMsgHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	int i, iRet;
	uint16_t* wp;
	char* cp;
	char   cBuffer[256], cTemp[256], cSendMode = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (dwMsgSize > 83 + 30) return;

	auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandChatMsgHeader>(pData, sizeof(hb::net::PacketCommandChatMsgHeader));
	if (!pkt) return;
	char* payload = reinterpret_cast<char*>(header) + sizeof(hb::net::PacketHeader);
	char* message = payload + 15;

	// v1.41 ShutUp Time
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;

	if (memcmp(pkt->name, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;

	if ((m_pClientList[iClientH]->m_bIsObserverMode) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

	// v1.432-2
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	cp = message;

	switch (m_bLogChatOption) {
		// Chat Logs of only players
	case 1:
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			std::memset(cTemp, 0, sizeof(cTemp));
			pData[dwMsgSize - 1] = 0;
			std::snprintf(cTemp, sizeof(cTemp), "Loc(%s) IP(%s) PC(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
		}
		break;
		// Chat Logs of only GM
	case 2:
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
			std::memset(cTemp, 0, sizeof(cTemp));
			pData[dwMsgSize - 1] = 0;
			std::snprintf(cTemp, sizeof(cTemp), "Loc(%s) IP(%s) GM(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
		}
		break;
		// Chat logs of all
	case 3:
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
			std::memset(cTemp, 0, sizeof(cTemp));
			pData[dwMsgSize - 1] = 0;
			std::snprintf(cTemp, sizeof(cTemp), "Loc(%s) IP(%s) GM(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
		}
		else {
			std::memset(cTemp, 0, sizeof(cTemp));
			pData[dwMsgSize - 1] = 0;
			std::snprintf(cTemp, sizeof(cTemp), "Loc(%s) IP(%s) PC(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
		}
		break;
		// Chat logs of none
	case 4:

		break;
	}

	/*	// New 08/05/2004
	// Log GM Chats
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
		std::memset(cTemp, 0, sizeof(cTemp));
		pData[dwMsgSize-1] = 0;
		std::snprintf(cTemp, sizeof(cTemp),"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp);
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
	}*/

	switch (*cp) {
	case '@':
		*cp = 32;

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) {
			std::memset(cTemp, 0, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (uint16_t *)cp2;
			*wp = (uint16_t)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
			(m_pClientList[iClientH]->m_iSP >= 3)) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 1;
		}
		else cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		break;

		// New 08/05/2004
		// Party chat
	case '$':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 4;
		}
		else {
			cSendMode = 0;
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) {
			cSendMode = 0;
		}
		break;

	case '^':
		*cp = 32;

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			std::memset(cTemp, 0, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = 0;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (uint16_t *)cp2;
			*wp = (uint16_t)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			std::memset(cTemp, 0, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (uint16_t *)cp2;
			*wp = (uint16_t)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) &&
			(m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 1;
		}
		else cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;

		// v1.4334
		if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = 0;

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '!':
		*cp = 32;

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			std::memset(cTemp, 0, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = 0;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (uint16_t *)cp2;
			*wp = (uint16_t)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) &&
			(m_pClientList[iClientH]->m_iSP >= 5)) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 2;
		}
		else cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;

		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~':
		*cp = 32;
		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
			(m_pClientList[iClientH]->m_iSP >= 3)) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 3;
		}
		else cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;
		break;

	case '/':
		// Chat commands disabled - will be reimplemented later
		return;
	}

	pData[dwMsgSize - 1] = 0;

	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] == 1) && (iDice(1, 3) != 2)) {
		// Confuse Language
		cp = message;

		while (*cp != 0) {
			if ((cp[0] != 0) && (cp[0] != ' ') && (cp[1] != 0) && (cp[1] != ' ')) {
				switch (iDice(1, 3)) {
				case 1:	memcpy(cp, "¿ö", 2); break;
				case 2:	memcpy(cp, "¿ì", 2); break;
				case 3:	memcpy(cp, "¿ù", 2); break;
				}
				cp += 2;
			}
			else cp++;
		}
	}

	cp = message;

	if ((cSendMode == 0) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		cSendMode = 20;

		if (*cp == '#') cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
	}

	header->msg_type = (uint16_t)iClientH;
	cp = payload + 14;
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				switch (cSendMode) {
				case 0:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
						(m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 12) &&
						(m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 12) &&
						(m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 9) &&
						(m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 9)) {

						// Crusade
						if (m_bIsCrusadeMode) {
							if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
								(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
							}
							else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					break;

				case 1:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
						(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {

						// Crusade
						if (m_bIsCrusadeMode) {
							if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
								(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
							}
							else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					break;

				case 2:
				case 10:
					// Crusade
					if (m_bIsCrusadeMode) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;

				case 3:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;

				case 4:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;
					if ((m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID))
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;
				}

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//DeleteClient(i, true, true);
					break;
				}
			}
	}
	else {
		// New 16/05/2004
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			std::memset(cBuffer, 0, sizeof(cBuffer));
			cp = (char*)cBuffer;
			*cp = GSM_WHISFERMSG;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (uint16_t*)cp;
			*wp = (uint16_t)dwMsgSize;
			cp += 2;
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;
			//bStockMsgToGateServer(cBuffer, dwMsgSize+13);

			//testcode
			//std::snprintf(G_cTxt, sizeof(G_cTxt), "Sending Whisper Msg: %s %d", m_pClientList[iClientH]->m_cWhisperPlayerName, (13 +dwMsgSize));
			//PutLogList(G_cTxt);
		}
		else {
			if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex] != 0 &&
				strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_cCharName) == 0) {
				iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);
				switch (m_bLogChatOption) {

				case 1:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						std::snprintf(cTemp, sizeof(cTemp), "GM Whisper   (%s):\"%s\"\tto Player(%s)", m_pClientList[iClientH]->m_cCharName, message, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
					}
					break;

				case 2:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						std::snprintf(cTemp, sizeof(cTemp), "GM Whisper   (%s):\"%s\"\tto GM(%s)", m_pClientList[iClientH]->m_cCharName, message, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
					}
					break;

				case 3:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						std::snprintf(cTemp, sizeof(cTemp), "GM Whisper   (%s):\"%s\"\tto GM(%s)", m_pClientList[iClientH]->m_cCharName, message, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
					}
					else {
						std::memset(cTemp, 0, sizeof(cTemp));
						std::snprintf(cTemp, sizeof(cTemp), "Player Whisper   (%s):\"%s\"\tto Player(%s)", m_pClientList[iClientH]->m_cCharName, message, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
					}
					break;

				case 4:
					break;
				}
			}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, true, true);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char* pName, char* pData, uint32_t dwMsgSize)
{
	int i, iRet;
	short* sp;
	char* cp, cTemp[256], cSendMode = 0;

	std::memset(cTemp, 0, sizeof(cTemp));

	{
		auto* header = reinterpret_cast<hb::net::PacketHeader*>(cTemp);
		header->msg_id = MSGID_COMMAND_CHATMSG;
		header->msg_type = 0;
	}
	cp = (char*)(cTemp + sizeof(hb::net::PacketHeader));
	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				if (m_pClientList[i]->m_bIsInitComplete == false) break;
				if ((m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
				}
			}
		break;

	case 2:
	case 10:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
			}
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, uint16_t wTargetObjectID, bool bResponse, bool bIsDash)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse, m_bIsInsideWizardTower, m_bIsInsideOwnTown 
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
/////////////////////////////////////////////////////////////////////////////////////
// Incomplete: 
//			- Direction Bow damage disabled
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, uint16_t wTargetObjectID, bool bResponse, bool bIsDash)
{
	uint32_t dwTime, iExp;
	int     iRet, tdX = 0, tdY = 0, i;
	short   sOwner, sAbsX, sAbsY;
	char    cOwnerType;
	bool    bNearAttack = false, var_AC = false;
	short sItemIndex;
	int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;

	dwTime = GameClock::GetTimeMS();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (3500)) {
				DeleteClient(iClientH, true, true, true);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}

	if ((wTargetObjectID != 0) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != 0) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS))) {
			if (m_pNpcList[wTargetObjectID - 10000] != 0) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if (sOwner == (wTargetObjectID - 10000)) {
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = false;
			var_AC = true;
		}
		if (var_AC != true) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = false;
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = true;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == false) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else {
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else {
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else {
			cDir = CMisc::cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(
				sX, static_cast<char>(sY), cDir, sOwner)))
				wType = 0;
		}
	}

	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

	if (sOwner != 0) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == false) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == false)
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == false) && (m_pClientList[iClientH]->m_bIsInsideOwnTown == false)) {

				uint32_t dwType1 = 0, dwType2, dwValue1, dwValue2;
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				}
				else if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				}
				else sItemIndex = -1;

				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
						dwType1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
						dwValue1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
						dwType2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
						dwValue2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
					}

					if (dwType1 == 2) {
						// Centuu - fix for poison
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwner]->m_iAdminUserLevel < 1 && !m_pClientList[sOwner]->m_bIsPoisoned && !bCheckResistingPoisonSuccess(sOwner, cOwnerType))
							{
								m_pClientList[sOwner]->m_bIsPoisoned = true;
								m_pClientList[sOwner]->m_iPoisonLevel = dwValue1 * 5;
								m_pClientList[sOwner]->m_dwPoisonTime = dwTime;
								SetPoisonFlag(sOwner, cOwnerType, true);
								SendNotifyMsg(0, sOwner, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwner]->m_iPoisonLevel, 0, 0);
							}
							break;
						case DEF_OWNERTYPE_NPC:
							break;
						}
					}
				}

				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874) { // Directional bow
						for (i = 2; i < 10; i++) {
							iErr = 0;
							CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, true); // 1
							if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
							}
						}
					}
					else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) { // Firebow
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
							if (m_bHeldenianInitiated != 1) {
								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1, 7) + 3) * 1000, 8);
							}
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
						}
					}
					else {
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
					}
				}
				else {
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
				}
			}
			else {
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
			}
			if (m_pClientList[iClientH] == 0) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, true);
	}

	if (bResponse) {
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_ATTACK_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int* pError)
{
	char  cDir, cTmpDir;
	int   aX, aY, dX, dY;
	int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else CMisc::GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = CMisc::cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for (i = cDir; i <= cDir + 7; i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY)) return cTmpDir;
		}

	if (cTurn == 1)
		for (i = cDir; i >= cDir - 7; i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY)) return cTmpDir;
		}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

bool CGame::bGetEmptyPosition(short* pX, short* pY, char cMapIndex)
{
	int i;
	short sX, sY;

	for (i = 0; i < 25; i++)
		if ((m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i])) &&
			(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == false)) {
			sX = *pX + _tmp_cEmptyPosX[i];
			sY = *pY + _tmp_cEmptyPosY[i];
			*pX = sX;
			*pY = sY;
			return true;
		}


	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return false;
}










void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
	int i;
	uint32_t dwTime = GameClock::GetTimeMS();

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_iGuildGUID != 0) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
				(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

				if (m_pNpcList[i]->m_cActionLimit == 0) {
					m_pNpcList[i]->m_bIsSummoned = true;
					m_pNpcList[i]->m_dwSummonedTime = dwTime;
				}
			}

			if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) &&
				(m_pNpcList[i]->m_cTargetType == cTargetType)) {

				switch (iCode) {
				case DEF_MAGICTYPE_INVISIBILITY:
					if (m_pNpcList[i]->m_cSpecialAbility == 1) {
					}
					else {
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
						m_pNpcList[i]->m_iTargetIndex = 0;
						m_pNpcList[i]->m_cTargetType = 0;
					}
					break;

				default:
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = 0;
					m_pNpcList[i]->m_cTargetType = 0;
					break;
				}
			}
		}
}



int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
	int ix, iy, iDangerValue;
	short sOwner, sDOType;
	char  cOwnerType;
	uint32_t dwRegisterTime;

	if (m_pNpcList[iNpcH] == 0) return false;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
		for (iy = dY - 2; iy <= dY + 2; iy++) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sDOType, &dwRegisterTime);

			if (sDOType == 1) iDangerValue++;

			switch (cOwnerType) {
			case 0:
				break;
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == 0) break;
				if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide)
					iDangerValue++;
				else iDangerValue--;
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == 0) break;
				if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide)
					iDangerValue++;
				else iDangerValue--;
				break;
			}
		}

	return iDangerValue;
}




void CGame::MsgProcess()
{
	char* pData, cFrom, cKey;
	uint32_t    dwMsgSize;
	int      i, iClientH;
	uint32_t dwTime = GameClock::GetTimeMS();

	if ((m_bF5pressed) && (m_bF1pressed)) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
			}
		bInit();
	}

	if ((m_bF1pressed) && (m_bF4pressed) && (m_bOnExitProcess == false)) {
		m_cShutDownCode = 2;
		m_bOnExitProcess = true;
		m_dwExitProcessTime = GameClock::GetTimeMS();
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		//bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);


		return;
	}

	std::memset(m_pMsgBuffer, 0, DEF_MSGBUFFERSIZE + 1);
	pData = (char*)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey)) {

		//v1.31
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
			//case DEF_MSGFROM_GATESERVER:
			//	dwpMsgID   = (uint32_t *)(pData + DEF_INDEX4_MSGID);
			//	wpMsgType  = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE);

			//	switch (*dwpMsgID) {
			//	// New 07/05/2004
			//	case MSGID_PARTYOPERATION:
			//		PartyOperationResultHandler(pData);
			//		break;

			//	case MSGID_SERVERSTOCKMSG:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SERVERSTOCKMSG");
			//		ServerStockMsgHandler(pData);
			//		break;
			//							
			//	case MSGID_SENDSERVERSHUTDOWNMSG:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SENDSERVERSHUTDOWNMSG");
			//		wp = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE + 2);
			//		switch (*wp) {
			//		case 1:
			//			PutLogList("(!) Send server shutdown announcement - 1.");
			//			for (i = 1; i < DEF_MAXCLIENTS; i++)
			//			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			//				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, 0, 0, 0);
			//			}
			//			break;
			//		
			//		case 2:
			//			PutLogList("(!) Send server shutdown announcement - 2.");
			//			for (i = 1; i < DEF_MAXCLIENTS; i++)
			//			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			//				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, 0, 0, 0);
			//			}
			//			break;
			//		}

			//		// WLS
			//		bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, 0, 0); 
			//		break;
			//	
			//	case MSGID_GAMESERVERSHUTDOWNED:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_GAMESERVERSHUTDOWNED");
			//		m_cShutDownCode      = 1;
			//		m_bOnExitProcess     = true;
			//		m_dwExitProcessTime  = GameClock::GetTimeMS();
			//		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
			//		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
			//		
			//		break;
			//	
			//	case MSGID_TOTALGAMESERVERCLIENTS:
			//		wp = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE + 2);
			//		m_iTotalGameServerClients = (int)*wp;
			//		if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
			//			m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
			//		break;
			//	
			//	case MSGID_RESPONSE_REGISTERGAMESERVER:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER");
			//		switch (*wpMsgType) {
			//		case DEF_MSGTYPE_CONFIRM:
			//			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
			//			PutLogList("(!) Game Server registration to Gate Server - Success!");
			//			m_bIsGateSockAvailable = true;
			//			//50Cent - HG start process fix
			//			bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, 0);
			//			break;

			//		case DEF_MSGTYPE_REJECT:
			//			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
			//			PutLogList("(!) Game Server registration to Gate Server - Fail!");
			//			PutLogList(" ");
			//			PutLogList("(!!!) STOPPED!");
			//			break;
			//		}
			//		
			//		//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
			//		//PutLogList(G_cTxt);

			//		/*
			//		if ((m_bIsGameStarted == false) && (m_bIsItemAvailable ) && 
			//			(m_bIsNpcAvailable ) && (m_bIsGateSockAvailable ) &&
			//			(m_bIsLogSockAvailable ) && (m_bIsMagicAvailable ) &&
			//			(m_bIsSkillAvailable ) && (m_bIsPortionAvailable ) &&
			//			(m_bIsQuestAvailable ) ) {
			//			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0); 
			//			m_bIsGameStarted = true;
			//		}
			//		*/
			//		break;
			//	}
			//	break;

		case DEF_MSGFROM_CLIENT: {
			/*m_pClientList[iClientH]->m_cConnectionCheck++;
			if (m_pClientList[iClientH]->m_cConnectionCheck > 3) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Client Hex Edit: (%s) Player: (%s) - has removed 3203203 (check connection handler).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
				break;
			}*/

			const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
				pData, sizeof(hb::net::PacketHeader));
			if (!header) break;
			switch (header->msg_id) { // 84148741

			case DEF_REQUEST_ANGEL: // Angels by Snoopy...
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, true);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, false);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				//RequestNoticementHandler(iClientH, pData);
				break;

			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;

			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;

			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;

			case MSGID_ADMINUSER:
				RequestAdminUserMode(iClientH, pData);
				break;

			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;

			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				// Anti Bump 
				if (m_pClientList[iClientH]->m_bIsClientConnected) {
					if (m_pClientList[iClientH] == 0) break;
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Client (%s) connection closed!. Sniffer suspect!.", m_pClientList[iClientH]->m_cCharName);
					PutLogList(G_cTxt);
					/*std::memset(cData, 0, sizeof(cData));
					cp = (char*)cData;
					*cp = GSM_DISCONNECT;
					cp++;
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;
					bStockMsgToGateServer(cData, 11);*/
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
					g_login->LocalSavePlayerData(iClientH); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, false);
					if ((dwTime - m_dwGameTime2) > 3000) { // 3 segs
						m_pClientList[iClientH]->m_bIsClientConnected = false;
						DeleteClient(iClientH, true, true, true, true);
					}
					break;
				}
				else {
					m_pClientList[iClientH]->m_bIsClientConnected = true;
					RequestInitDataHandler(iClientH, pData, cKey);
				}
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIANTELEPORT:
				RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
				break;


			case MSGID_REQUEST_CITYHALLTELEPORT:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
					RequestTeleportHandler(iClientH, "2   ", "dglv2", 263, 258);
				}
				else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
					RequestTeleportHandler(iClientH, "2   ", "dglv2", 209, 258);
				}
				break;

			case MSGID_REQUEST_SHOP_CONTENTS:
				RequestShopContentsHandler(iClientH, pData);
				break;

			default:
				if (m_pClientList[iClientH] != 0)  // Snoopy: Anti-crash check !
				{
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received: (0x%.8X) PC(%s) - (Delayed). \tIP(%s)"
						, header->msg_id
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					//DelayedDeleteClient(iClientH, true, true, true, true);
				}
				else
				{
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received: (0x%.8X) PC(unknown).", header->msg_id);
				}
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);
				PutHackLogFileList(m_pMsgBuffer);
				break;
			}
			break;
		}

		case DEF_MSGFROM_LOGSERVER: {
			const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
				pData, sizeof(hb::net::PacketHeader));
			if (!header) break;
			//wpMsgType  = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE);

			switch (header->msg_id) {
				//case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_CHECKACCOUNTPASSWORD");
				//	RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				//	break;
				//
				//case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");
				//	wpMsgType  = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE);
				//	ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				//	break;
				//
				//case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
				//	ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				//	break;
				//
				//case MSGID_GUILDNOTIFY:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_GUILDNOTIFY");
				//	GuildNotifyHandler(pData, dwMsgSize);
				//	break;
				//
				//case MSGID_RESPONSE_DISBANDGUILD:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_DISBANDGUILD");
				//	ResponseDisbandGuildHandler(pData, dwMsgSize);
				//	break;

				//case MSGID_RESPONSE_CREATENEWGUILD:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_CREATENEWGUILD");
				//	ResponseCreateNewGuildHandler(pData, dwMsgSize);
				//	break;
				//
				//case MSGID_RESPONSE_REGISTERGAMESERVER:
				//	switch (*wpMsgType) {
				//	case DEF_MSGTYPE_CONFIRM:
				//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
				//		PutLogList("(!) Game Server registration to Log Server - Success!");
				//		m_bIsLogSockAvailable = true;
				//		break;

				//	case DEF_MSGTYPE_REJECT:
				//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
				//		PutLogList("(!) Game Server registration to Log Server - Fail!");
				//		break;
				//	}

				//	if (m_bIsBuildItemAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				//	}
				//					
				//	if (m_bIsItemAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! Item configuration error.");
				//	}
				//	
				//	if (m_bIsNpcAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! Npc configuration error.");
				//	}

				//	if (m_bIsMagicAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				//	}

				//	if (m_bIsSkillAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! SKILL configuration error.");
				//	}

				//	if (m_bIsQuestAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! QUEST configuration error.");
				//	}

				//	if (m_bIsPortionAvailable == false) {
				//		PutLogList(" ");
				//		PutLogList("(!!!) STOPPED! PORTION configuration error.");
				//	}

				//	//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//	//PutLogList(G_cTxt);

				//	/*
				//	if ((m_bIsGameStarted == false) && (m_bIsItemAvailable ) && 
				//		(m_bIsNpcAvailable ) && (m_bIsGateSockAvailable ) &&
				//		(m_bIsLogSockAvailable ) && (m_bIsMagicAvailable ) &&
				//		(m_bIsSkillAvailable ) && (m_bIsPortionAvailable ) &&
				//		(m_bIsQuestAvailable ) ) {
				//		SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0); 
				//		m_bIsGameStarted = true;
				//	}
				//	*/
				//	break;

				//case MSGID_RESPONSE_PLAYERDATA:
				//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
				//	ResponsePlayerDataHandler(pData, dwMsgSize);
				//	break;

			case MSGID_REQUEST_CREATENEWACCOUNT:
				g_login->CreateNewAccount(iClientH, pData);
				break;
			case MSGID_REQUEST_LOGIN:
				g_login->RequestLogin(iClientH, pData);
				break;
			case MSGID_REQUEST_CREATENEWCHARACTER: //message from client
				g_login->ResponseCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_DELETECHARACTER:
				g_login->DeleteCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_CHANGEPASSWORD:
				g_login->ChangePassword(iClientH, pData);
				break;
			case MSGID_REQUEST_ENTERGAME:
				g_login->RequestEnterGame(iClientH, pData);
				break;
			default:
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown login message received! (0x%.8X) Delete Client", header->msg_id);
				PutLogList(G_cTxt);
				break;
			}
			DeleteLoginClient(iClientH);
		}
								  break;
		}

	}
}

bool CGame::bPutMsgQuene(char cFrom, char* pData, uint32_t dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cRealmName);
	if (hMutex != 0) return false; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ

	hMutex = CreateMutex(0, false, m_cRealmName);
	*/
	if (m_pMsgQuene[m_iQueneTail] != 0) return false;

	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == 0) return false;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == false) return false;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	//ReleaseMutex(hMutex);

	return true;
}


bool CGame::bGetMsgQuene(char* pFrom, char* pData, uint32_t* pMsgSize, int* pIndex, char* pKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cRealmName);
	if (hMutex != 0) return false;

	hMutex = CreateMutex(0, false, m_cRealmName);
	*/
	if (m_pMsgQuene[m_iQueneHead] == 0) return false;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = 0;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	//ReleaseMutex(hMutex);

	return true;
}


void CGame::ClientCommonHandler(int iClientH, char* pData)
{
	uint16_t wCommand;
	short sX, sY;
	int iV1, iV2, iV3, iV4;
	char cDir;
	const char* pString;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketCommandCommonWithString>(
		pData, sizeof(hb::net::PacketCommandCommonWithString));
	if (!req) return;
	wCommand = req->base.header.msg_type;
	sX = req->base.x;
	sY = req->base.y;
	cDir = static_cast<char>(req->base.dir);
	iV1 = req->v1;
	iV2 = req->v2;
	iV3 = req->v3;
	pString = req->text;
	iV4 = req->v4;
	switch (wCommand) {

		//50Cent - Repair All
	case DEF_COMMONTYPE_REQ_REPAIRALL:
		RequestRepairAllItemsHandler(iClientH);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLDELETE:
		RequestRepairAllItemsDeleteHandler(iClientH, iV1);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLCONFIRM:
		RequestRepairAllItemsConfirmHandler(iClientH);
		break;

		// Crafting
	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;

		// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

		// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> MSGID_REQUEST_CIVILRIGHT");
		RequestChangePlayMode(iClientH);
		break;
		//

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case DEF_COMMONTYPE_GUILDTELEPORT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
		RequestGuildTeleportHandler(iClientH);
		break;

	case DEF_COMMONTYPE_SUMMONWARUNIT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;

	case DEF_COMMONTYPE_REQUEST_HELP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
		RequestHelpHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
		CancelQuestHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
		ActivateSpecialAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
		JoinPartyHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_GETMAGICABILITY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
		BuildItemHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_QUESTACCEPTED:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
		QuestAcceptedHandler(iClientH);
		break;

	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
		CancelExchangeItem(iClientH);
		break;

	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
		ConfirmExchangeItem(iClientH);
		break;

	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
		SetExchangeItem(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
		// works for client, but for npc it returns middleland
		// if ((m_pMapList[m_pNpcList[iV1]->m_cMapIndex]->m_cName) != (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) break;
		NpcTalkHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
		ReqCreatePortionHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
		ReqGetFishThisTimeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;

	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;

	case DEF_COMMONTYPE_REQ_SELLITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;

	case DEF_COMMONTYPE_REQ_USESKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;

	case DEF_COMMONTYPE_REQ_USEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;

	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
		DropItemHandler(iClientH, iV1, iV2, pString, true);
		break;

	case DEF_COMMONTYPE_EQUIPITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
		// ¿©±â¼­´Â Æ¯¼ºÄ¡ º¯È­¸¸À» ´Ù·é´Ù.
		bEquipItemHandler(iClientH, iV1);
		// ¹Ù²ï ¿ÜÇü¿¡ ´ëÇÑ Á¤º¸¸¦ ¿©±â¼­ Àü¼ÛÇÑ´Ù.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		RequestPurchaseItemHandler(iClientH, pString, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
		JoinGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
		ReleaseItemHandler(iClientH, iV1, true);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
		GetFightzoneTicketHandler(iClientH);
		break;

		// Upgrade Item
	case DEF_COMMONTYPE_UPGRADEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_UPGRADEITEM");
		RequestItemUpgradeHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY");
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

		//50Cent - HP Bar
	case DEF_COMMONTYPE_REQ_GETNPCHP:
		if ((iV1 - 10000 <= 0) || (iV1 - 10000 >= DEF_MAXNPCS)) return;
		if (m_pNpcList[iV1 - 10000] == 0) return;
		if (m_pNpcList[iV1 - 10000]->m_iHP > m_pNpcList[iV1 - 10000]->m_iMaxHP) m_pNpcList[iV1 - 10000]->m_iMaxHP = m_pNpcList[iV1 - 10000]->m_iHP;
		SendNotifyMsg(0, iClientH, DEF_SEND_NPCHP, m_pNpcList[iV1 - 10000]->m_iHP, m_pNpcList[iV1 - 10000]->m_iMaxHP, 0, 0);
		break;

	default:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received! (0x%.8X)", wCommand);
		PutLogList(G_cTxt);
		break;
	}
}

// New 07/05/2004
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, const char* pItemName, bool bByPlayer)
{
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(iAmount == -1))
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0)) {
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
			delete pItem;
			return;
		}
		else {
			if (iAmount <= 0) {
				delete pItem;
				return;
			}
			pItem->m_dwCount = (uint32_t)iAmount;
		}

		if ((uint32_t)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// v1.41 !!!
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItem);

		// v1.411 
		// v2.17 2002-7-31
		if (bByPlayer)
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
		else
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem, true);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, 0);
	}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, true);

		// v2.17
		if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex])
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41
			// v2.17 2002-7-31
			if (bByPlayer)
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex], true);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
				0,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); //v1.4 color
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);

		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
	char  cRemainItemColor;
	int   iRet, iEraseReq;
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	short sIDNum;
	uint32_t dwAttribute;
	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sIDNum, &cRemainItemColor, &dwAttribute);
	if (pItem != 0) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, 0, pItem);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
		else
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
	}

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

bool CGame::_bAddClientItemList(int iClientH, class CItem* pItem, int* pDelReq)
{
	int i;

	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;

	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > _iCalcMaxLoad(iClientH))
			return false;
	}
	else {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > _iCalcMaxLoad(iClientH))
			return false;
	}

	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] != 0) &&
				(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0)) {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
				//delete pItem;
				*pDelReq = 1;

				iCalcTotalWeight(iClientH);

				return true;
			}
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {

			m_pClientList[iClientH]->m_pItemList[i] = pItem;
			m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
			m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

			*pDelReq = 0;

			if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

			iCalcTotalWeight(iClientH);

			return true;
		}

	return false;
}

bool CGame::bEquipItemHandler(int iClientH, short sItemIndex, bool bNotify)
{
	char  cEquipPos, cHeroArmorType;
	short   sSpeed;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return false;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return false;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == 0) &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return false;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return false;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return false;
			break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 100) return false;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
		(cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str
			if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		case 11: // Dex
			if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		case 13: // Int
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		case 14: // Mag
			if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], true);
				return false;
			}
			break;
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// Stormbringer
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, sItemIndex, true);
				return false;
			}
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 99 && (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 99 && m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
			}
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], true);
			}
		}
	}


	if (cEquipPos == DEF_EQUIPPOS_NONE) return false;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], false);
		else {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND], false);
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND], false);
		}
	}
	else {
		if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND], false);
		}

		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], false);
	}


	if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) {
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK], false);
		}
	}
	else {
		if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
			cEquipPos == DEF_EQUIPPOS_LEGGINGS || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RELEASEALL] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RELEASEALL], false);
			}
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], false);
	}


	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = true;

	switch (cEquipPos) {

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF0;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8);
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFF0FF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFF0F;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFF0FFFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFFF; // New 09/05/2004
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xF0FFFFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
		iTemp = iTemp | (int)sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
		iTemp = iTemp | (int)sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF;
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1:
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;
			break;

		case 2:
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;
			break;

		case 3:
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0:
			break;
		case 50:
		case 51:
		case 52:
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
			break;
		default:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0)
				m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
			// m_sAppr4
			// 0x0001 GM	
			// 0x0002 Green	
			// 0x0003 ice element
			// 0x0004 sparkle
			// 0x0005 sparkle green gm
			// 0x0006 sparkle green
			break;
		}
	}

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return true;

}

void CGame::SendEventToNearClient_TypeB(uint32_t dwMsgID, uint16_t wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
	int i, iRet, iShortCutIndex;
	bool bFlag;

	// OPTIMIZATION FIX #2: Early exit if no clients online
	if (m_iClientShortCut[0] == 0) return;

	// OPTIMIZATION FIX #2: Pre-check if any clients are in range before building packet
	bool bHasNearbyClients = false;
	iShortCutIndex = 0;
	while (m_iClientShortCut[iShortCutIndex] != 0) {
		i = m_iClientShortCut[iShortCutIndex];
		if ((m_pClientList[i] != 0) &&
			(m_pClientList[i]->m_cMapIndex == cMapIndex) &&
			(m_pClientList[i]->m_sX >= sX - 12) &&
			(m_pClientList[i]->m_sX <= sX + 12) &&
			(m_pClientList[i]->m_sY >= sY - 10) &&
			(m_pClientList[i]->m_sY <= sY + 10)) {
			bHasNearbyClients = true;
			break;
		}
		iShortCutIndex++;
	}

	// TEMPORARILY DISABLED FOR TESTING - Early exit if no clients in range
	if (false && !bHasNearbyClients) return;

	hb::net::PacketEventNearTypeBShort pkt{};
	pkt.header.msg_id = dwMsgID;
	pkt.header.msg_type = wMsgType;
	pkt.x = sX;
	pkt.y = sY;
	pkt.v1 = sV1;
	pkt.v2 = sV2;
	pkt.v3 = sV3;
	pkt.v4 = sV4;

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag) {
		// DEF_MAXCLIENTS 
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag) && (m_pClientList[i] != 0)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				(m_pClientList[i]->m_sX >= sX - 12) &&
				(m_pClientList[i]->m_sX <= sX + 12) &&
				(m_pClientList[i]->m_sY >= sY - 10) &&
				(m_pClientList[i]->m_sY <= sY + 10)) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
		}
	}
}

void CGame::SendEventToNearClient_TypeB(uint32_t dwMsgID, uint16_t wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, uint32_t dwV4)
{
	int i, iRet, iShortCutIndex;
	bool bFlag;

	hb::net::PacketEventNearTypeBDword pkt{};
	pkt.header.msg_id = dwMsgID;
	pkt.header.msg_type = wMsgType;
	pkt.x = sX;
	pkt.y = sY;
	pkt.v1 = sV1;
	pkt.v2 = sV2;
	pkt.v3 = sV3;
	pkt.v4 = dwV4;

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag) {
		// DEF_MAXCLIENTS 
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag) && (m_pClientList[i] != 0)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				(m_pClientList[i]->m_sX >= sX - 12) &&
				(m_pClientList[i]->m_sX <= sX + 12) &&
				(m_pClientList[i]->m_sY >= sY - 10) &&
				(m_pClientList[i]->m_sY <= sY + 10)) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
	int     iRet;
	short   sOwnerH;
	char    cOwnerType;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (sOwnerH != 0) {
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char* pData, int iType)
{
	int i;
	uint16_t wResult;
	char cCharName[11], cTxt[120];
	int iRet;

	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå »ý¼º ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	std::memset(cCharName, 0, sizeof(cCharName));
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, pData, 10);
	//cp += 10;

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
			(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {

			//wp = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE);
			switch (iType) {
			case 1: // DEF_LOGRESMSGTYPE_CONFIRM
				// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù. 
				wResult = DEF_MSGTYPE_CONFIRM;
				// ±æµå ÀÌ¸§Àº ÀÌ¹Ì ÀúÀåµÇ¾î ÀÖÀ¸¹Ç·Î ·©Å©¸¦ 0À¸·Î ¹Ù²ã À¯È¿È­ ÇÑ´Ù.
				m_pClientList[i]->m_iGuildRank = 0;	// ±æµå ·©Å©´Â 0. ±æµå¸¶½ºÅÍÀÓ 
				std::snprintf(cTxt, sizeof(cTxt), "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;

			case 0: // DEF_LOGRESMSGTYPE_REJECT
				// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ½ÇÆÐÇÏ¿´´Ù.
				// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù "NONE".
				wResult = DEF_MSGTYPE_REJECT;
				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;
				std::snprintf(cTxt, sizeof(cTxt), "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_CREATENEWGUILD;
			pkt.msg_type = wResult;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(i, true, true);
				return;
			}

			return;
		}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char* cp;
	char cGuildName[21], cTxt[120], cData[100];
	int     iRet;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_bIsCrusadeMode) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestGuildAction>(
		pData, sizeof(hb::net::PacketRequestGuildAction));
	if (!pkt) return;
	std::memset(cGuildName, 0, sizeof(cGuildName));
	memcpy(cGuildName, pkt->guild, sizeof(pkt->guild));

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// ÀÌ Ä³¸¯ÅÍ´Â ÀÌ¹Ì ±æµå¿¡ °¡ÀÔÇÏ¿© ÀÖÀ¸¹Ç·Î ±æµå¸¦ ¸¸µé ¼ö ¾ø´Ù.
		std::snprintf(cTxt, sizeof(cTxt), "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ((m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0)) { // v1.4
			// ÀÚ°Ý¿ä°ÇÀÌ ¸ÂÁö ¾Ê´Â´Ù. Æ¯¼ºÄ¡°¡ ³·°Å³ª ¸¶À»ÀÇ À§Ä¡°¡ ´Ù¸£°Å³ª ½Ã¹ÎÀÌ ¾Æ´Ñ °æ¿ì  
			std::memset(cData, 0, sizeof(cData));

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_CREATENEWGUILD;
			pkt.msg_type = DEF_MSGTYPE_REJECT;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			// ±æµå ÀÌ¸§À» ÀÓ½Ã·Î ÀúÀåÇÑ´Ù. -> ¾îÂ÷ÇÇ ±æµå ÀÌ¸§Àº Rank°¡ -1ÀÏ¶§ ¹«ÀÇ¹ÌÇÏ¹Ç·Î .
			std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// ±æµåÀÇ ¼Ò¼Ó ¸¶À» ÀÌ¸§À» ÀúÀåÇÑ´Ù.
			std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// ±æµåÀÇ GUID¸¦ »ý¼ºÇÏ¿© ÀÔ·ÂÇÑ´Ù. 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + GameClock::GetTimeMS());

			// ±æµå »ý¼º¿äÃ» ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
			//bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);

			char cData[512];
			std::memset(cData, 0, sizeof(cData));
			uint32_t* dwp;

			cp = (char*)cData;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
			cp += 10;

			dwp = (uint32_t*)cp;
			*dwp = (uint32_t)m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;

			RequestCreateNewGuild(iClientH, cData);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char* cp;
	char cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestGuildAction>(
		pData, sizeof(hb::net::PacketRequestGuildAction));
	if (!pkt) return;
	std::memset(cGuildName, 0, sizeof(cGuildName));

	memcpy(cGuildName, pkt->guild, sizeof(pkt->guild));

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// ±æµå¸¶½ºÅÍ°¡ ¾Æ´Ï°Å³ª ±æµåÀÇ ÀÌ¸§ÀÌ ´Ù¸£¹Ç·Î ±æµåÇØ»êÀÇ ±ÇÇÑÀÌ ¾ø´Ù.
		std::snprintf(cTxt, sizeof(cTxt), "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		// ±æµå ÇØ»ê ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
		//bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);

		char cData[512];

		cp = (char*)(cData);

		memcpy((char*)cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		memcpy((char*)cp, m_pClientList[iClientH]->m_cGuildName, 20);
		cp += 20;

		RequestDisbandGuild(iClientH, cData);
	}
}

void CGame::ResponseDisbandGuildHandler(char* pData, int iType)
{
	int i;
	uint16_t wResult;
	char cCharName[11], cTxt[120];
	int iRet;

	// �α� �����κ��� ��� �ػ� ��û�� ���� ���䵥���Ͱ� �����ߴ�. 
	std::memset(cCharName, 0, sizeof(cCharName));
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, pData, 10);
	//cp += 10;

	// �̸��� ��ġ�ϴ� Ŭ���̾�Ʈ�� ã�´�.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			//wp = (uint16_t *)(pData + DEF_INDEX2_MSGTYPE);
			switch (iType) {
			case 1: // DEF_LOGRESMSGTYPE_CONFIRM
				// Ŭ���̾�Ʈ�� ��� �ػ� �䱸�� �����Ͽ���. 
				wResult = DEF_MSGTYPE_CONFIRM;
				std::snprintf(cTxt, sizeof(cTxt), "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);

				// �������� �����鿡�� ��尡 �ػ�Ǿ����� �˸��� �޽����� �����Ѵ�. 
				SendGuildMsg(i, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0);

				// ����̸� Ŭ����
				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
				m_pClientList[i]->m_iGuildRank = -1;		// ��� ��ũ�� -1. ������ �ƴϴ�. 
				m_pClientList[i]->m_iGuildGUID = -1;
				break;

			case 0: // DEF_LOGRESMSGTYPE_REJECT
				// Ŭ���̾�Ʈ�� ��� �ػ� �䱸�� �����Ͽ���.
				wResult = DEF_MSGTYPE_REJECT;
				std::snprintf(cTxt, sizeof(cTxt), "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_DISBANDGUILD;
			pkt.msg_type = wResult;

			// ��� �ػ� �䱸 ���� �޽����� Ŭ���̾�Ʈ���� ����
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(i, true, true);
				return;
			}
			return;
		}

	// �̸��� ��ġ�ϴ� Ŭ���̾�Ʈ�� ã�� �� ����.
	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, const char* pItemName, int iNum, int iItemId)
{
	class CItem* pItem;
	char cItemName[21];
	uint32_t dwGoldCount, dwItemCount;
	uint16_t wTempPrice;
	int   i, iRet, iEraseReq, iGoldWeight;
	int   iCost, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	// ¸¸¾à ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é ±¸ÀÔÇÒ ¼ö ¾ø´Ù.
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}


	// ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÑ´Ù.
	std::memset(cItemName, 0, sizeof(cItemName));

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	// Determine item ID and count
	// Priority: 1) iItemId parameter (from client), 2) special item names, 3) name lookup
	short sItemID = 0;
	dwItemCount = 1;

	// If client sent a valid item ID, use it directly
	if (iItemId > 0 && iItemId < DEF_MAXITEMTYPES) {
		sItemID = static_cast<short>(iItemId);
	}
	// Handle special item requests by converting internal names to item IDs
	else if (memcmp(pItemName, "10Arrows", 8) == 0) {
		sItemID = hb::item::ItemId::Arrow;
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, "100Arrows", 9) == 0) {
		sItemID = hb::item::ItemId::Arrow;
		dwItemCount = 100;
	}
	else if (memcmp(pItemName, "GuildAdmissionTicket", 20) == 0) {
		sItemID = hb::item::ItemId::GuildAdmissionTicket;
	}
	else if (memcmp(pItemName, "GuildSecessionTicket", 20) == 0) {
		sItemID = hb::item::ItemId::GuildSecessionTicket;
	}
	else {
		// Fall back to name-based lookup
		memcpy(cItemName, pItemName, 20);
	}

	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		bool bInitOk = (sItemID > 0) ? _bInitItemAttr(pItem, sItemID) : _bInitItemAttr(pItem, cItemName);
		if (bInitOk == false) {
			delete pItem;
		}
		else {

			if (pItem->m_bIsForSale == false) {
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			iCost = pItem->m_wPrice * pItem->m_dwCount;


			dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma - 10) / 4);

			// 2.03 Discount Method
			// Charisma
			// iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			// if (iDiscountRatio == 0) iDiscountRatio = 1;

			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;

			if (iDiscountCost >= (iCost / 2)) iDiscountCost = (iCost / 2) - 1;

			if (dwGoldCount < (uint32_t)(iCost - iDiscountCost)) {
				delete pItem;

				{
					hb::net::PacketNotifyNotEnoughGold pkt{};
					pkt.header.msg_id = MSGID_NOTIFY;
					pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
					pkt.item_index = -1;
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
				}
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				// ¾ÆÀÌÅÛ »ò´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				wTempPrice = (iCost - iDiscountCost);
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMPURCHASED, pItem, wTempPrice);
				if (iEraseReq == 1) delete pItem;

				// GoldÀÇ ¼ö·®À» °¨¼Ò½ÃÅ²´Ù. ¹Ýµå½Ã ¿©±â¼­ ¼¼ÆÃÇØ¾ß ¼ø¼­°¡ ¹Ù²îÁö ¾Ê´Â´Ù.
				iGoldWeight = SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - wTempPrice);
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
			else
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16_t wObjectID, const char* pItemName)
{
	int iRet, iEraseReq;
	short sOwnerH;
	char cOwnerType, cCharName[21];
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½ÃµÈ´Ù.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	std::memset(cCharName, 0, sizeof(cCharName));

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (uint32_t)iAmount)) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é 

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸ 
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		// ¼ö·® °¨¼Ò: 0º¸´Ù Å©´Ù.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!! ¾ÆÀÌÅÛ ÀÌ¸§¿¡¼­ ÀÎµ¦½º·Î º¯°æµÇ¾ú´Ù. 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((uint16_t)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}

		if (sOwnerH == 0) {
			// ÁÖ°íÀÚ ÇÏ´Â À§Ä¡¿¡ ¾Æ¹«µµ ¾ø´Ù.
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color
		}
		else {
			// ¾ÆÀÌÅÛÀ» ÁØ´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ÇÃ·¹ÀÌ¾î¿¡°Ô ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// ¸¸¾à ÀÚ±â ÀÚ½Å¿¡°Ô ÁÖ´Â °Å¶ó¸é ¹«½ÃÇÑ´Ù. ÇØÅ·ÀÇ ¼ÒÁö°¡ ÀÖ´Ù.
					delete pItem;
					return;
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq)) {
					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					// v1.4
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, cCharName);
				}
				else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					{
						iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
					}


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, true, true);
						break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´Þ¿¡ ½ÇÆÐÇßÀ½À» ¾Ë¸°´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, 0, cCharName);
				}

			}
			else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù. 
					if (bSetItemToBankItem(iClientH, pItem) == false) {
						// ¹°°ÇÀ» ¸Ã±â´Âµ¥ ½ÇÆÐÇÏ¿´´Ù.	
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);

						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
					}
				}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
				}
			}
		}
	}
	else {
		// ¾ÆÀÌÅÛ ÀüºÎ¸¦ ÁÖ¾ú´Ù.

		// ÀåÂøÁßÀÎ ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù¸é ¾ÆÀÌÅÛ ÀåÂøÈ¿°ú¸¦ ÇØÁ¦ÇØ¾ß ÇÏ¹Ç·Î.
		ReleaseItemHandler(iClientH, sItemIndex, true);

		// Ã³¸®µµÁß ¿¡·¯°¡ ¹ß»ýÇÒ¶§¸¦ ´ëºñÇØ¼­ -1·Î ÇÒ´çÇØ ³õ´Â´Ù.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = -1;

		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // ¾ÆÀÌÅÛÀ» dX, dY¿¡ ÀÖ´Â Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. ¸¸¾à ¹ÞÀ» Ä³¸¯ÅÍ°¡ ¾ÆÀÌÅÛÀ» ¹ÞÁö ¸øÇÒ »óÈ²ÀÌ¶ó¸é ¶¥¿¡ ¶³¾îÁø´Ù.  

		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((uint16_t)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}

		if (sOwnerH == 0) {
			// ¾ÆÀÌÅÛÀ» ÁÖ°íÀÚ ÇÏ´Â Àå¼Ò¿¡ Ä³¸¯ÅÍ°¡ ¾ø´Ù. 
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
				0,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀÌ ¶³¾îÁ³À¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);
		}
		else {
			// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ĳ���Ϳ��� �������� �־���.	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];

				// v2.03 ũ�缼�̵� ����ΰ�쵵 ��� ������ �����ϴ�.

				// v2.17 2002-7-31 �������� ������ ������ȣ�� ������ �� �ְ� �Ѵ�.
				if (pItem->m_sIDnum == 88) {

					// �÷��̾� iClientH �� sOwnerH���� ��尡�� ��û���� �־���. ���� 
					// sOwnerH�� ��帶���Ͷ�� �������� �޴� ���� �ƴ϶� Ȯ���� �� �־�� �Ѵ�.
								// v2.17 2002-7-31 �������� ������ ������ȣ�� ������ �� �ְ� �Ѵ�.
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						// ��� �������̴�.	��� �����Ϳ��Դ� ����Ȯ�� ��û �޽����� �����Ѵ�.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, 0, 0, 0, 0);
						// ���� �������� �� ���ο��� �������� �־����Ƿ� ����Ʈ���� �����Ұ��� �뺸�Ѵ�.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31 �������� ������ ������ȣ�� ������ �� �ְ� �Ѵ�.
				if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// �÷��̾� iClientH �� sOwnerH���� ���Ż�� ��û���� �־���. ���� 
					// sOwnerH�� ��帶�����̰� iClientH�� ��� �̸��� ���� iClientH�� �����̶�� 
					// �������� �޴� ���� �ƴ϶� Ȯ���� �� �־�� �Ѵ�.
					if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
						(m_pClientList[iClientH]->m_iGuildRank != -1) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						// ��� �������̴�.	��� �����Ϳ��Դ� Ż��Ȯ�� ��û �޽����� �����Ѵ�.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, 0, 0, 0, 0);
						// ���� �������� �� ���ο��� �������� �־����Ƿ� ����Ʈ���� �����Ұ��� �뺸�Ѵ�.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// ÀÏ¹ÝÀûÀÎ °æ¿ì ¾ÆÀÌÅÛÀ» ±×Àú ¹ÞÀ» »Ó...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq)) {

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}
				}
				else {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
						0,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					{
						iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
					}


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					std::memset(cCharName, 0, sizeof(cCharName));
				}
			}
			else {
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					if (bSetItemToBankItem(iClientH, sItemIndex) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
							0,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);

							std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
						}

						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					}
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
							0,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

						// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
						std::memset(cCharName, 0, sizeof(cCharName));

					}
				}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
						0,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
					std::memset(cCharName, 0, sizeof(cCharName));
				}
			}

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, cCharName);
		}

	REMOVE_ITEM_PROCEDURE:

		// ³×Æ®¿öÅ© ¿À·ù·Î Ã³¸®µµÁß Å¬¶óÀÌ¾ðÆ®°¡ Á¦°ÅµÇ¾ú´Ù¸é ´õÀÌ»ó ÁøÇàÇÒ ¼ö ¾ø´Ù. 
		if (m_pClientList[iClientH] == 0) return;

		// ¾ÆÀÌÅÛÀ» ÁÖ°Å³ª ¹ö·ÈÀ¸¹Ç·Î Áö¿î´Ù. deleteÇØ¼­´Â ¾ÈµÈ´Ù! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

		// È­»ì ÀÎµ¦½º¸¦ Àç ÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, uint16_t wMsgType, uint32_t sV1, uint32_t sV2, uint32_t sV3, char* pString, uint32_t sV4, uint32_t sV5, uint32_t sV6, uint32_t sV7, uint32_t sV8, uint32_t sV9, char* pString2)
{
	int iRet = 0, i;

	if (m_pClientList[iToH] == 0) return;

	// !!! sV1, sV2, sV3´Â DWORDÇüÀÓÀ» ¸í½ÉÇÏ¶ó.
	switch (wMsgType) {
	case DEF_NOTIFY_CURLIFESPAN:
	{
		hb::net::PacketNotifyCurLifeSpan pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int32_t>(sV1);
		pkt.cur_lifespan = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_SEND_NPCHP: //50Cent - HP Bar
	{
		hb::net::PacketNotifyNpcHp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.hp = static_cast<int32_t>(sV1);
		pkt.max_hp = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_HELDENIANCOUNT:
	{
		hb::net::PacketNotifyHeldenianCount pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.aresden_tower_left = static_cast<int16_t>(sV1);
		pkt.elvine_tower_left = static_cast<int16_t>(sV2);
		pkt.aresden_flags = static_cast<int16_t>(sV3);
		pkt.elvine_flags = static_cast<int16_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 18/05/2004
	case DEF_NOTIFY_SPAWNEVENT:
	{
		hb::net::PacketNotifySpawnEvent pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.monster_id = static_cast<uint8_t>(sV3);
		pkt.x = static_cast<int16_t>(sV1);
		pkt.y = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUESTCOUNTER:
	{
		hb::net::PacketNotifyQuestCounter pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.current_count = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
	{
		hb::net::PacketNotifyApocGateOpen pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.gate_x = static_cast<int32_t>(sV1);
		pkt.gate_y = static_cast<int32_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.map_name, pString, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ABADDONKILLED:
	{
		hb::net::PacketNotifyAbaddonKilled pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.killer_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.killer_name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_FORCERECALLTIME:
	{
		hb::net::PacketNotifyForceRecallTime pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.seconds_left = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 16/05/2004
	//0xB4E2, 0xBEB
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		if (wMsgType == DEF_NOTIFY_MONSTERCOUNT) {
			hb::net::PacketNotifyMonsterCount pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.count = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

		//0x0BE5, 0x0BE7, 0x0BE8, 0x0BEA
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SLATE_CREATEFAIL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
	{
		hb::net::PacketNotifySimpleInt pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 07/05/2004
	// Party Notify Msg's
	case DEF_NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
		{
			hb::net::PacketNotifyPartyName pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.type = static_cast<int16_t>(sV1);
			pkt.v2 = static_cast<int16_t>(sV2);
			pkt.v3 = static_cast<int16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			break;
		}
		case 5:
		{
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketNotifyPartyList) + (sV3 * 11));

			auto* pkt = writer.Append<hb::net::PacketNotifyPartyList>();
			pkt->header.msg_id = MSGID_NOTIFY;
			pkt->header.msg_type = wMsgType;
			pkt->type = static_cast<int16_t>(sV1);
			pkt->v2 = static_cast<int16_t>(sV2);
			pkt->count = static_cast<int16_t>(sV3);

			if (pString != 0 && sV3 > 0) {
				writer.AppendBytes(pString, sV3 * 11);
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
			break;
		}
		default:
		{
			hb::net::PacketNotifyPartyBasic pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.type = static_cast<int16_t>(sV1);
			pkt.v2 = static_cast<int16_t>(sV2);
			pkt.v3 = static_cast<int16_t>(sV3);
			pkt.v4 = static_cast<int16_t>(sV4);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			break;
		}
		}
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
	{
		hb::net::PacketNotifyReqGuildNameAnswer pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.guild_rank = static_cast<int16_t>(sV1);
		pkt.index = static_cast<int16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.guild_name, pString, sizeof(pkt.guild_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 06/05/2004
	// Upgrade Notify Msg's
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
	{
		hb::net::PacketNotifyItemUpgradeFail pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
	{
		hb::net::PacketNotifyItemAttributeChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.attribute = sV2;
		pkt.spec_value1 = sV3;
		pkt.spec_value2 = sV4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_GIZONITEMCANGE:
	{
		hb::net::PacketNotifyGizonItemChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.item_type = static_cast<uint8_t>(sV2);
		pkt.cur_lifespan = static_cast<int16_t>(sV3);
		pkt.sprite = static_cast<int16_t>(sV4);
		pkt.sprite_frame = static_cast<int16_t>(sV5);
		pkt.item_color = static_cast<uint8_t>(sV6);
		pkt.spec_value2 = static_cast<uint8_t>(sV7);
		pkt.attribute = sV8;
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// 2.06 - by KLKS
	case DEF_NOTIFY_CHANGEPLAYMODE:
	{
		hb::net::PacketNotifyChangePlayMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.location, pString, sizeof(pkt.location));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	//

	case DEF_NOTIFY_TCLOC:
	{
		hb::net::PacketNotifyTCLoc pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dest_x = static_cast<int16_t>(sV1);
		pkt.dest_y = static_cast<int16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.teleport_map, pString, sizeof(pkt.teleport_map));
		}
		pkt.construct_x = static_cast<int16_t>(sV4);
		pkt.construct_y = static_cast<int16_t>(sV5);
		if (pString2 != 0) {
			memcpy(pkt.construct_map, pString2, sizeof(pkt.construct_map));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	//New 11/05/2004
	case DEF_NOTIFY_GRANDMAGICRESULT:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketNotifyGrandMagicResultHeader) + (sV9 * 2));

		auto* pkt = writer.Append<hb::net::PacketNotifyGrandMagicResultHeader>();
		pkt->header.msg_id = MSGID_NOTIFY;
		pkt->header.msg_type = wMsgType;
		pkt->crashed_structures = static_cast<uint16_t>(sV1);
		pkt->structure_damage = static_cast<uint16_t>(sV2);
		pkt->casualities = static_cast<uint16_t>(sV3);
		if (pString != 0) {
			memcpy(pkt->map_name, pString, sizeof(pkt->map_name));
		}
		pkt->active_structure = static_cast<uint16_t>(sV4);
		pkt->value_count = static_cast<uint16_t>(sV9);

		if (sV9 > 0 && pString2 != 0) {
			writer.AppendBytes(pString2 + 2, sV9 * 2);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_MAPSTATUSNEXT:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketHeader) + sV1);

		auto* pkt = writer.Append<hb::net::PacketHeader>();
		pkt->msg_id = MSGID_NOTIFY;
		pkt->msg_type = wMsgType;

		if (pString != 0 && sV1 > 0) {
			writer.AppendBytes(pString, sV1);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_MAPSTATUSLAST:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketHeader) + sV1);

		auto* pkt = writer.Append<hb::net::PacketHeader>();
		pkt->msg_id = MSGID_NOTIFY;
		pkt->msg_type = wMsgType;

		if (pString != 0 && sV1 > 0) {
			writer.AppendBytes(pString, sV1);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_LOCKEDMAP:
	{
		hb::net::PacketNotifyLockedMap pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.seconds_left = static_cast<int16_t>(sV1);
		if (pString != 0) {
			memcpy(pkt.map_name, pString, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
	{
		hb::net::PacketNotifyBuildItemResult pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (sV1 >= 0) {
			pkt.item_id = static_cast<int16_t>(sV1);
		}
		else {
			pkt.item_id = static_cast<int16_t>(sV1 + 10000);
		}
		pkt.item_count = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
	{
		hb::net::PacketNotifyQuestReward pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.who = static_cast<int16_t>(sV1);
		pkt.flag = static_cast<int16_t>(sV2);
		pkt.amount = static_cast<int32_t>(sV3);
		if (pString != 0) {
			memcpy(pkt.reward_name, pString, sizeof(pkt.reward_name));
		}
		pkt.contribution = static_cast<int32_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTCONSTRUCT:
	{
		hb::net::PacketNotifyCannotConstruct pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_METEORSTRIKECOMING:
	{
		hb::net::PacketNotifyMeteorStrikeComing pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.phase = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_OBSERVERMODE:
	{
		hb::net::PacketNotifyObserverMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.enabled = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		if (wMsgType == DEF_NOTIFY_FORCEDISCONN) {
			hb::net::PacketNotifyForceDisconn pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.seconds = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_QUESTCONTENTS:
	{
		hb::net::PacketNotifyQuestContents pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.who = static_cast<int16_t>(sV1);
		pkt.quest_type = static_cast<int16_t>(sV2);
		pkt.contribution = static_cast<int16_t>(sV3);
		pkt.target_type = static_cast<int16_t>(sV4);
		pkt.target_count = static_cast<int16_t>(sV5);
		pkt.x = static_cast<int16_t>(sV6);
		pkt.y = static_cast<int16_t>(sV7);
		pkt.range = static_cast<int16_t>(sV8);
		pkt.is_completed = static_cast<int16_t>(sV9);
		if (pString2 != 0) {
			memcpy(pkt.target_name, pString2, sizeof(pkt.target_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ENERGYSPHERECREATED:
	{
		hb::net::PacketNotifyEnergySphereCreated pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.x = static_cast<int16_t>(sV1);
		pkt.y = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	case DEF_NOTIFY_ITEMCOLORCHANGE:
	{
		hb::net::PacketNotifyItemColorChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.item_color = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SETEXCHANGEITEM:
	{
		hb::net::PacketNotifyExchangeItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<int16_t>(sV1);
		pkt.sprite = static_cast<int16_t>(sV2);
		pkt.sprite_frame = static_cast<int16_t>(sV3);
		pkt.amount = static_cast<int32_t>(sV4);
		pkt.color = static_cast<uint8_t>(sV5);
		pkt.cur_life = static_cast<int16_t>(sV6);
		pkt.max_life = static_cast<int16_t>(sV7);
		pkt.performance = static_cast<int16_t>(sV8);
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		memcpy(pkt.char_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.char_name));
		pkt.attribute = static_cast<uint32_t>(sV9);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
	{
		hb::net::PacketNotifyExchangeItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<int16_t>(sV1);
		pkt.sprite = static_cast<int16_t>(sV2);
		pkt.sprite_frame = static_cast<int16_t>(sV3);
		pkt.amount = static_cast<int32_t>(sV4);
		pkt.color = static_cast<uint8_t>(sV5);
		pkt.cur_life = static_cast<int16_t>(sV6);
		pkt.max_life = static_cast<int16_t>(sV7);
		pkt.performance = static_cast<int16_t>(sV8);
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		memcpy(pkt.char_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.char_name));
		pkt.attribute = static_cast<uint32_t>(sV9);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_NOTFLAGSPOT:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMPOSLIST:
	{
		hb::net::PacketNotifyItemPosList pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			pkt.positions[i * 2] = static_cast<int16_t>(m_pClientList[iToH]->m_ItemPosList[i].x);
			pkt.positions[i * 2 + 1] = static_cast<int16_t>(m_pClientList[iToH]->m_ItemPosList[i].y);
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ENEMYKILLS:
	{
		hb::net::PacketNotifyEnemyKills pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.count = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CRUSADE:
	{
		hb::net::PacketNotifyCrusade pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.crusade_mode = static_cast<int32_t>(sV1);
		pkt.crusade_duty = static_cast<int32_t>(sV2);
		pkt.v3 = static_cast<int32_t>(sV3);
		pkt.v4 = static_cast<int32_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	{
		hb::net::PacketNotifyConstructionPoint pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.construction_point = static_cast<int16_t>(sV1);
		pkt.war_contribution = static_cast<int16_t>(sV2);
		pkt.notify_type = static_cast<int16_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	{
		hb::net::PacketNotifySpecialAbilityStatus pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.status_type = static_cast<int16_t>(sV1);
		pkt.ability_type = static_cast<int16_t>(sV2);
		pkt.seconds_left = static_cast<int16_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_DAMAGEMOVE:
	{
		hb::net::PacketNotifyDamageMove pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<uint8_t>(sV1);
		pkt.amount = static_cast<int16_t>(sV2);
		pkt.weapon = static_cast<uint8_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		if (wMsgType == DEF_NOTIFY_RESPONSE_CREATENEWPARTY) {
			hb::net::PacketNotifyResponseCreateNewParty pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.result = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyDownSkillIndexSet pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.skill_index = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
		{
			hb::net::PacketNotifyAdminInfo pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.v1 = m_pNpcList[sV2]->m_iHP;
			pkt.v2 = m_pNpcList[sV2]->m_iDefenseRatio;
			pkt.v3 = m_pNpcList[sV2]->m_bIsSummoned;
			pkt.v4 = m_pNpcList[sV2]->m_cActionLimit;
			pkt.v5 = m_pNpcList[sV2]->m_iHitDice;
			pkt.v6 = static_cast<int32_t>(m_pNpcList[sV2]->m_dwDeadTime);
			pkt.v7 = static_cast<int32_t>(m_pNpcList[sV2]->m_dwRegenTime);
			pkt.v8 = static_cast<int32_t>(m_pNpcList[sV2]->m_bIsKilled);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
	{
		hb::net::PacketNotifyNpcTalk pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.type = static_cast<int16_t>(sV1);
		pkt.response = static_cast<int16_t>(sV2);
		pkt.amount = static_cast<int16_t>(sV3);
		pkt.contribution = static_cast<int16_t>(sV4);
		pkt.target_type = static_cast<int16_t>(sV5);
		pkt.target_count = static_cast<int16_t>(sV6);
		pkt.x = static_cast<int16_t>(sV7);
		pkt.y = static_cast<int16_t>(sV8);
		pkt.range = static_cast<int16_t>(sV9);
		if (pString != 0) {
			memcpy(pkt.reward_name, pString, sizeof(pkt.reward_name));
		}
		if (pString2 != 0) {
			memcpy(pkt.target_name, pString2, sizeof(pkt.target_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// Crafting
	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
	{
		hb::net::PacketNotifyCraftingFail pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CRAFTING_SUCCESS:		//reversed by Snoopy: 0x0BF0
	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// ÀÏÄ¡ÇÏ´Â Æ÷¼Ç Á¶ÇÕÀÌ ¾ø´Ù.
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SUPERATTACKLEFT:
	{
		hb::net::PacketNotifySuperAttackLeft pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.left = static_cast<int16_t>(m_pClientList[iToH]->m_iSuperAttackLeft);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SAFEATTACKMODE:
	{
		hb::net::PacketNotifySafeAttackMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.enabled = m_pClientList[iToH]->m_bIsSafeAttackMode ? 1 : 0;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		if (wMsgType == DEF_NOTIFY_QUERY_JOINPARTY) {
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketHeader) + 11);

			auto* pkt = writer.Append<hb::net::PacketHeader>();
			pkt->msg_id = MSGID_NOTIFY;
			pkt->msg_type = wMsgType;

			std::size_t name_len = 0;
			if (pString != 0) {
				name_len = std::strlen(pString);
				if (name_len > 10) {
					name_len = 10;
				}
				writer.AppendBytes(pString, name_len);
			}
			writer.AppendBytes("", 1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		}
		else {
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketHeader) + 510);

			auto* pkt = writer.Append<hb::net::PacketHeader>();
			pkt->msg_id = MSGID_NOTIFY;
			pkt->msg_type = wMsgType;

			std::size_t text_len = 0;
			if (pString != 0) {
				text_len = std::strlen(pString);
				if (text_len >= 509) {
					text_len = 509;
				}
				writer.AppendBytes(pString, text_len);
			}
			writer.AppendBytes("", 1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		}
		break;

	case DEF_NOTIFY_REWARDGOLD:
	{
		hb::net::PacketNotifyRewardGold pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.gold = static_cast<uint32_t>(m_pClientList[iToH]->m_iRewardGold);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SERVERSHUTDOWN:
	{
		hb::net::PacketNotifyServerShutdown pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.mode = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		if (wMsgType == DEF_NOTIFY_GLOBALATTACKMODE) {
			hb::net::PacketNotifyGlobalAttackMode pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.mode = static_cast<uint8_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyWhetherChange pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.status = static_cast<uint8_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		if (wMsgType == DEF_NOTIFY_FISHCANCELED) {
			hb::net::PacketNotifyFishCanceled pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.reason = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_DEBUGMSG:
	{
		hb::net::PacketNotifySimpleShort pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_FISHCHANCE:
	{
		hb::net::PacketNotifyFishChance pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.chance = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		if (wMsgType == DEF_NOTIFY_ENERGYSPHEREGOALIN) {
			hb::net::PacketNotifyEnergySphereGoalIn pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.result = static_cast<int16_t>(sV1);
			pkt.side = static_cast<int16_t>(sV2);
			pkt.goal = static_cast<int16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyEventFishMode pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.price = static_cast<uint16_t>(sV1);
			pkt.sprite = static_cast<uint16_t>(sV2);
			pkt.sprite_frame = static_cast<uint16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_NOTICEMSG:
	{
		hb::net::PacketNotifyNoticeMsg pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		std::size_t msg_len = 0;
		if (pString != 0) {
			msg_len = std::strlen(pString);
			if (msg_len >= sizeof(pkt.text)) {
				msg_len = sizeof(pkt.text) - 1;
			}
			memcpy(pkt.text, pString, msg_len);
		}
		pkt.text[msg_len] = '\0';
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt),
			static_cast<int>(sizeof(hb::net::PacketHeader) + msg_len + 1));
		break;
	}

	case DEF_NOTIFY_CANNOTRATING:
	{
		hb::net::PacketNotifyCannotRating pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.time_left = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_RATINGPLAYER:
	{
		hb::net::PacketNotifyRatingPlayer pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<uint8_t>(sV1);
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		pkt.rating = m_pClientList[iToH]->m_iRating;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_PLAYERSHUTUP:
	{
		hb::net::PacketNotifyPlayerShutUp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.time = static_cast<uint16_t>(sV1);
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_TIMECHANGE:
	{
		hb::net::PacketNotifyTimeChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.sprite_alpha = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_TOBERECALLED:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_HUNGER:
	{
		hb::net::PacketNotifyHunger pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.hunger = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_PLAYERPROFILE:
	{
		hb::net::PacketNotifyPlayerProfile pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		std::size_t send_len = 0;
		if (pString != 0) {
			send_len = std::strlen(pString);
			if (send_len >= sizeof(pkt.text)) {
				send_len = sizeof(pkt.text) - 1;
			}
			std::size_t copy_len = send_len;
			if (copy_len > 100) {
				copy_len = 100;
			}
			memcpy(pkt.text, pString, copy_len);
		}
		pkt.text[send_len] = '\0';
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt),
			static_cast<int>(sizeof(hb::net::PacketHeader) + send_len + 1));
		break;
	}

	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
	{
		hb::net::PacketNotifyPlayerNotOnGame pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		std::memset(pkt.filler, ' ', sizeof(pkt.filler));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 15/05/2004 Changed
	case DEF_NOTIFY_PLAYERONGAME:
	{
		hb::net::PacketNotifyPlayerOnGame pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		if (pString != 0 && pString[0] != 0 && pString2 != 0) {
			memcpy(pkt.map_name, pString2, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 06/05/2004
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
	{
		hb::net::PacketNotifyItemRepaired pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_id = static_cast<uint32_t>(sV1);
		pkt.life = static_cast<uint32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	// New 06/05/2004
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
	{
		if (wMsgType == DEF_NOTIFY_REPAIRITEMPRICE) {
			hb::net::PacketNotifyRepairItemPrice pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.v1 = static_cast<uint32_t>(sV1);
			pkt.v2 = static_cast<uint32_t>(sV2);
			pkt.v3 = static_cast<uint32_t>(sV3);
			pkt.v4 = static_cast<uint32_t>(sV4);
			if (pString != 0) {
				memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySellItemPrice pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.v1 = static_cast<uint32_t>(sV1);
			pkt.v2 = static_cast<uint32_t>(sV2);
			pkt.v3 = static_cast<uint32_t>(sV3);
			pkt.v4 = static_cast<uint32_t>(sV4);
			if (pString != 0) {
				memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;
	}

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		if (wMsgType == DEF_NOTIFY_CANNOTREPAIRITEM) {
			hb::net::PacketNotifyCannotRepairItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.reason = static_cast<uint16_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyCannotSellItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.reason = static_cast<uint16_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_SHOWMAP:
	{
		hb::net::PacketNotifyShowMap pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.map_id = static_cast<uint16_t>(sV1);
		pkt.map_type = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SKILLUSINGEND:
	{
		hb::net::PacketNotifySkillUsingEnd pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_TOTALUSERS:
	{
		hb::net::PacketNotifyTotalUsers pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.total = static_cast<uint16_t>(m_iTotalGameServerClients);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
	{
		hb::net::PacketNotifyMagicEffect pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.magic_type = static_cast<uint16_t>(sV1);
		pkt.effect = static_cast<uint32_t>(sV2);
		pkt.owner = static_cast<uint32_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTITEMTOBANK:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SERVERCHANGE:
	{
		hb::net::PacketNotifyServerChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.map_name, m_pClientList[iToH]->m_cMapName, sizeof(pkt.map_name));
		memcpy(pkt.log_server_addr, m_cLoginListenIP, sizeof(pkt.log_server_addr));
		pkt.log_server_port = m_iLoginListenPort;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SKILL:
	{
		hb::net::PacketNotifySkill pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.skill_index = static_cast<uint16_t>(sV1);
		pkt.skill_value = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_SETITEMCOUNT:
	{
		hb::net::PacketNotifySetItemCount pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.count = static_cast<uint32_t>(sV2);
		pkt.notify = static_cast<uint8_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
	{
		hb::net::PacketNotifyItemDepletedEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.use_result = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
	{
		hb::net::PacketNotifyDropItemFinCountChanged pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
	{
		hb::net::PacketNotifyDropItemFinEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		if (wMsgType == DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED) {
			hb::net::PacketNotifyGiveItemFinCountChanged pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.amount = static_cast<int32_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyCannotGiveItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.amount = static_cast<int32_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
	{
		hb::net::PacketNotifyGiveItemFinEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ENEMYKILLREWARD:
	{
		hb::net::PacketNotifyEnemyKillReward pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.kill_count = static_cast<uint32_t>(m_pClientList[iToH]->m_iEnemyKillCount);
		memcpy(pkt.killer_name, m_pClientList[sV1]->m_cCharName, sizeof(pkt.killer_name));
		memcpy(pkt.killer_guild, m_pClientList[sV1]->m_cGuildName, sizeof(pkt.killer_guild));
		pkt.killer_rank = static_cast<int16_t>(m_pClientList[sV1]->m_iGuildRank);
		pkt.war_contribution = static_cast<int16_t>(m_pClientList[iToH]->m_iWarContribution);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_PKCAPTURED:
	{
		hb::net::PacketNotifyPKcaptured pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.pk_count = static_cast<uint16_t>(sV1);
		pkt.victim_pk_count = static_cast<uint16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.victim_name, pString, sizeof(pkt.victim_name));
		}
		pkt.reward_gold = static_cast<uint32_t>(m_pClientList[iToH]->m_iRewardGold);
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_PKPENALTY:
	{
		hb::net::PacketNotifyPKpenalty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.str = static_cast<uint32_t>(m_pClientList[iToH]->m_iStr);
		pkt.vit = static_cast<uint32_t>(m_pClientList[iToH]->m_iVit);
		pkt.dex = static_cast<uint32_t>(m_pClientList[iToH]->m_iDex);
		pkt.intel = static_cast<uint32_t>(m_pClientList[iToH]->m_iInt);
		pkt.mag = static_cast<uint32_t>(m_pClientList[iToH]->m_iMag);
		pkt.chr = static_cast<uint32_t>(m_pClientList[iToH]->m_iCharisma);
		pkt.pk_count = static_cast<uint32_t>(m_pClientList[iToH]->m_iPKCount);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_REPAIRALLPRICES:
	{
		hb::net::PacketNotifyRepairAllPricesHeader header{};
		header.header.msg_id = MSGID_NOTIFY;
		header.header.msg_type = wMsgType;
		int total = m_pClientList[iToH]->totalItemRepair;
		if (total < 0) total = 0;
		header.total = static_cast<int16_t>(total);

		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketNotifyRepairAllPricesHeader) +
			(total * sizeof(hb::net::PacketNotifyRepairAllPricesEntry)));
		writer.AppendBytes(&header, sizeof(header));

		for (int i = 0; i < total; i++) {
			hb::net::PacketNotifyRepairAllPricesEntry entry{};
			entry.index = static_cast<uint8_t>(m_pClientList[iToH]->m_stRepairAll[i].index);
			entry.price = static_cast<int16_t>(m_pClientList[iToH]->m_stRepairAll[i].price);
			writer.AppendBytes(&entry, sizeof(entry));
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
	{
		hb::net::PacketNotifySimpleInt pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int32_t>(m_pClientList[iToH]->m_iExp);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ITEMRELEASED:
	{
		hb::net::PacketNotifyItemReleased pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.equip_pos = static_cast<int16_t>(sV1);
		pkt.item_index = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_ITEMLIFESPANEND:
	{
		hb::net::PacketNotifyItemLifeSpanEnd pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.equip_pos = static_cast<int16_t>(sV1);
		pkt.item_index = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_KILLED:
	{
		hb::net::PacketNotifyKilled pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.attacker_name, pString, sizeof(pkt.attacker_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_EXP:
	{
		hb::net::PacketNotifyExp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.rating = static_cast<int32_t>(m_pClientList[iToH]->m_iRating);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_HP:
	{
		hb::net::PacketNotifyHP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.hp = static_cast<uint32_t>(m_pClientList[iToH]->m_iHP);
		pkt.hunger = static_cast<uint32_t>(m_pClientList[iToH]->m_iHungerStatus);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_MP:
	{
		hb::net::PacketNotifyMP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.mp = static_cast<uint32_t>(m_pClientList[iToH]->m_iMP);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_SP:
	{
		hb::net::PacketNotifySP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.sp = static_cast<uint32_t>(m_pClientList[iToH]->m_iSP);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CHARISMA:
	{
		hb::net::PacketNotifyCharisma pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.charisma = static_cast<uint32_t>(m_pClientList[iToH]->m_iCharisma);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// State change failures
	case DEF_NOTIFY_STATECHANGE_FAILED:
	case DEF_NOTIFY_SETTING_FAILED:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¼º°ø.. wtf korean junk
	{
		int i;
		hb::net::PacketNotifyStateChangeSuccess pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;

		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			pkt.magic_mastery[i] = static_cast<uint8_t>(m_pClientList[iToH]->m_cMagicMastery[i]);
		}

		for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
			pkt.skill_mastery[i] = static_cast<uint8_t>(m_pClientList[iToH]->m_cSkillMastery[i]);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
	{
		hb::net::PacketNotifyLevelUp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.level = m_pClientList[iToH]->m_iLevel;
		pkt.str = m_pClientList[iToH]->m_iStr;
		pkt.vit = m_pClientList[iToH]->m_iVit;
		pkt.dex = m_pClientList[iToH]->m_iDex;
		pkt.intel = m_pClientList[iToH]->m_iInt;
		pkt.mag = m_pClientList[iToH]->m_iMag;
		pkt.chr = m_pClientList[iToH]->m_iCharisma;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	{
		hb::net::PacketNotifyQueryDismissGuildPermission pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	{
		hb::net::PacketNotifyQueryJoinGuildPermission pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
	{
		hb::net::PacketNotifyCannotJoinMoreGuildsMan pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
	{
		hb::net::PacketNotifyJoinGuildApprove pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (m_pClientList[iFromH] != 0) {
			memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
		}
		else {
			memcpy(pkt.guild_name, "?", 1);
		}
		pkt.rank = m_iStartingGuildRank;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (wMsgType == DEF_COMMONTYPE_JOINGUILDREJECT) {
			hb::net::PacketNotifyJoinGuildReject pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else if (wMsgType == DEF_COMMONTYPE_DISMISSGUILDAPPROVE) {
			hb::net::PacketNotifyDismissGuildApprove pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyDismissGuildReject pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
	{
		hb::net::PacketNotifyGuildDisbanded pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.guild_name, pString, sizeof(pkt.guild_name));
		}
		memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// v1.4311-3 Ãß°¡ Å¬¶óÀÌ¾ðÆ®¿¡°Ô »çÅõÀå ¿¹¾àÀÌ Ãë¼ÒµÇ¾ú´Ù°í ¾Ë¸² ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
	{
		hb::net::PacketNotifyFightZoneReserve pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// v1.4311-3 Ãß°¡ ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ñ°æ¿ì .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// v1.4311-3 Ãß°¡ ÀÚ½ÅÀÇ ±æµå¿øÀÌ  ¾Æ´Ñ°æ¿ì 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		// Ã³¸® µµÁß ¿À·ù°¡ ¹ß»ýÇÏ´Â °ÍÀ» ¸·±â À§ÇØ Áö¿ìÁö ¾Ê´Â´Ù. Time OutÀ¸·Î »èÁ¦µÉ °ÍÀÓ. 
		//DeleteClient(iToH, true, true);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, const char* pName)
{
	int i;
	bool bIsExist = false;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
			// v1.4 ¼Ò¼Ó ¸¶À»ÀÌ ´Þ¶óµµ ¹«½ÃµÈ´Ù.
			if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;

			// ±æµåÀÇ ÀÌ¸§À» º¹»çÇÏ°í ¼öÄ¡¸¦ ÃÊ±âÈ­ÇØ ÁØ´Ù.
			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

			// ±æµå GUIDº¹»çÇÑ´Ù.
			m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

			// ±æµåÀÇ »ý¼ºÀ§Ä¡¸¦ ÃÊ±âÈ­ÇÑ´Ù.
			std::memset(m_pClientList[i]->m_cLocation, 0, sizeof(m_pClientList[i]->m_cLocation));
			strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

			m_pClientList[i]->m_iGuildRank = m_iStartingGuildRank; //@@@  GuildRankÀÇ ½ÃÀÛÀº DEF_GUILDSTARTRANK

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, 0, 0, 0, 0);

			// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

			// ´Ù¸¥ ±æµå¿øµé¿¡°Ô »õ ±æµå¿øÀÌ ÀÖÀ½À» ¾Ë¸°´Ù.
			SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, 0, 0, 0);

			// ±æµåÁ¤º¸È­ÀÏ¿¡ »õ ±æµå¿øÀÇ ÀÌ¸§À» ±â·ÏÇÑ´Ù.
			//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
			return;
		}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::JoinGuildRejectHandler(int iClientH, const char* pName)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, 0, 0, 0, 0);
			return;
		}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::DismissGuildApproveHandler(int iClientH, const char* pName)
{
	int i;


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
			//_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)0,0) ;
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);

			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			return;
		}

}

void CGame::DismissGuildRejectHandler(int iClientH, const char* pName)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ Å»Åð ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô Å»Åð°¡ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, 0, 0, 0, 0);
			return;
		}

	// Å»Åð¸¦ ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}


uint32_t CGame::dwGetItemCount(int iClientH, char* pName)
{
	int i;
	char cTmpName[21];

	if (m_pClientList[iClientH] == 0) return 0;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}

	return 0;
}

int CGame::SetItemCount(int iClientH, char* pItemName, uint32_t dwCount)
{
	int i;
	char cTmpName[21];
	uint16_t wWeight;

	if (m_pClientList[iClientH] == 0) return -1;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

			// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, false);
			}
			else {
				// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)true, 0);
			}

			return wWeight;
		}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, uint32_t dwCount)
{
	uint16_t wWeight;

	if (m_pClientList[iClientH] == 0) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return -1;

	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, false);
	}
	else {
		// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)true, 0);
	}

	return wWeight;
}

uint32_t CGame::dwGetItemCountByID(int iClientH, short sItemID)
{
	if (m_pClientList[iClientH] == nullptr) return 0;

	for (int i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != nullptr &&
		    m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == sItemID) {
			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}
	}

	return 0;
}

int CGame::SetItemCountByID(int iClientH, short sItemID, uint32_t dwCount)
{
	if (m_pClientList[iClientH] == nullptr) return -1;

	for (int i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != nullptr &&
		    m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == sItemID) {

			uint16_t wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);

			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, false);
			}
			else {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)true, 0);
			}

			return wWeight;
		}
	}

	return -1;
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
	char cAttackerName[21];
	short sAttackerWeapon;
	int i, iExH;
	bool  bIsSAattacked = false;


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	// �������� ��� �ð��� �Է��Ѵ�.
	// 2002-7-4 �������� ������ �ø� �� �ֵ��� 
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = GameClock::GetTimeMS();
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = true;
	// HP�� 0�̴�.
	m_pClientList[iClientH]->m_iHP = 0;

	// Snoopy: Remove all magic effects and flags
	for (i = 0; i < DEF_MAXMAGICEFFECTS; i++)
		m_pClientList[iClientH]->m_cMagicEffectStatus[i] = 0;

	SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);
	SetHasteFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

	// ���� ��ȯ ����� ��ȯ�� ����Ѵ�.
	if (m_pClientList[iClientH]->m_bIsExchangeMode) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ���� �� NPC�� ���ݴ������ ����ִ� ��ü���� �����Ѵ�.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != 0)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != 0)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC �̸� �߹�ȭ�� ���� ���� 
			std::snprintf(cAttackerName, sizeof(cAttackerName), "NPCNPCNPC@%d", m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break;
	default:
		break;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_KILLED, 0, 0, 0, cAttackerName);
	// �ٸ� Ŭ���̾�Ʈ���� �״� ���� ����.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap) {
		if (m_pClientList[iClientH]->m_cSide == 1) {
			m_iHeldenianAresdenDead++;
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus();
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// Ư�� �ɷ��� �ִ� ����� ������ ���ߴ�.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = true;
			break;
		}

		if (iAttackerH == iClientH) return; // �����̴�.
		// �÷��̾ �÷��̾ �׿��ٸ� PK���� ������ �¸������� �Ǻ��Ͽ� ����ġ�� �ø���. 
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			// ����ڰ� �������̴�. 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				// ������ �����ڿ���. �����ڴ� PK �������� �޴´�.
				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {

				// ���˸� ������ �����ڿ���. �����ڴ� PK�� �����Ϳ� ���� ������ �޴´�. 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		}
		else {
			// ����ڰ� �����ڰ� �ƴ϶� �� ���� �Ҽ��̴�. 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// ����ڴ� �ù��̴�.
				// �����ڰ� ������, ���� ���� �ù�, ���� ���� ���� -> PK�� ��. �ٸ� ���� �ù�, ���� -> ������ ����
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// �����ڰ� �������̴�. 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ������ �ù��� �����ڰ� �׿���. �����ڴ� PK�� �ȴ�.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// �����ڴ� PK�� ��Ƶ� ������ ���� ���Ѵ�.

					}
				}
				else {
					// �����ڰ� �ù�, Ȥ�� ���� -> ������ ������ PK, �ٸ� �����̶�� ������ ���� 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// ���� ���� �ù��� �������� �ù� Ȥ�� ������ ������ ���̴�.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ����ڰ� ������ ����. PK�̴�.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// �����ڸ� ��Ҵ�. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// �����ڰ� �ٸ� ���� �Ҽ�. ������ ��������
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// ����ڴ� �����̴�. 
				// ������ �ڰ� ������, �ù�, ������°� �ƴ� ����-> PK / ������������ ���� -> ������ ��������
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// �����ڰ� �������̴�.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ������ ������ �����ڰ� �׿���. �����ڴ� PK�� �ȴ�.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// �����ڴ� PK�� ��Ƶ� ������ ���� ���Ѵ�.

					}
				}
				else {
					// �����ڴ� �ù� Ȥ�� ���� -> ������ ������ PK, �ٸ� �����̶�� ������ ���� 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// ���� ���� ������ �������� �ù� Ȥ�� ������ ������ ���̴�.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ����ڰ� ������ ����. PK�̴�.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// �����ڸ� ��Ҵ�. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// �����ڰ� �ٸ� ���� �Ҽ�. ������ ��������
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		// ������� �÷��̾��� ��޿� �´� ���Ƽ�� ���Ѵ�. 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//�����ڿ��� ���ݹ޾� �׾���. 
				//PK�������Ƿ� ����ġ�� ���� �ʴ´�.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//���� ���� �ù� Ȥ�� �������� �׾���. 
					//PK�������Ƿ� �������� ���� �ʴ´�. 
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
				}
				else {
					// �ٸ� ���� �ù� Ȥ�� �������� �׾���. ������ �׾����Ƿ� ����ġ�� �������� ��������. 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		char cTxt[128];
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s killed %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
		for (int Killedi = 0; Killedi < DEF_MAXCLIENTS; Killedi++) {
			if (m_pClientList[Killedi] != 0 && Killedi != iAttackerH) {
				SendNotifyMsg(0, Killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s(%s) killed %s(%s) in %s(%d,%d)", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		PutPvPLogFileList(cTxt); // Centu : log pvp
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC, iClientH, 0, cAttackerName);

		// �÷��̾ ������ �׾���. ������� �÷��̾��� ��޿� �´� ���Ƽ�� ���Ѵ�.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		// ���� ������ NPC�� ����� ����Ʈ��� ���ְ����� �Ǽ� ����Ʈ �ΰ�
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != 0) {

			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// ����� ������ Ȥ�� ����Ʈ�� �� �÷��̾ �׿���. �ٷ� �뺸�Ѵ�.
				// ���� ������ ���ְ��� �ִٸ� ��ٷ� �뺸. ������ �ٸ� ������ �˷���.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

						if (m_pClientList[i]->m_iConstructionPoint > m_iMaxConstructionPoints)
							m_pClientList[i]->m_iConstructionPoint = m_iMaxConstructionPoints;

						//testcode
						std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
						PutLogList(G_cTxt);
						// ���ְ����� �ٷ� �뺸.
						SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
						return;
					}

				// ���� ������ ����. �ٸ� ������ ���ְ����� �˷��� �Ѵ�.
				/*std::memset(cData, 0, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);*/
			}
		}
		char cTxt[128];
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s killed %s", m_pNpcList[iAttackerH]->m_cNpcName, m_pClientList[iClientH]->m_cCharName);
		for (int Killedi = 0; Killedi < DEF_MAXCLIENTS; Killedi++) {
			if (m_pClientList[Killedi] != 0) {
				SendNotifyMsg(0, Killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER, iClientH, 0, 0);
		// �÷��̾ �׾����� �����ڰ� �������̴�. �ƹ��� ������ ����.
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, bool bNotice)
{
	char cEquipPos, cHeroArmorType;
	short  sTemp;
	int   iTemp;

	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;

	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == false) return;

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = false;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
			}
		}
	}

	// ¾ÆÀÌÅÛÀÇ ÇØÁ¦À§Ä¡¿¡ ¸Â°Ô Apprº¯¼ö¸¦ Á¶Á¤ÇÑ´Ù.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3 ¹«±â¼Óµµ Àç°è»ê <- ¸Ç¼ÕÀÌ´Ï±ñ 0
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xF0FFFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// ¾ç¼Õ¿¡ ÀåÂøÇÑ´ÙÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡¸¸ µé°í ÀÖ´Ù. ¿Þ¼ÕÀº ºñ¾îÀÖ´Â »óÅÂ.
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFF0FFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFF0FFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFF0FF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFF0F; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFFF0; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	//v1.432 Æ¯¼ö ´É·ÂÀÌ ºÎ¿©µÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇÃ·¡±× ¼³Á¤ 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// ¹æ¾î±¸ Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;

	// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» ¾Ë¸°´Ù.
	if (bNotice)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	// ÀÌ ¾ÆÀÌÅÛÀ» ÇØÁ¦ÇÏ´Â °Í¿¡ µû¸£´Â Æ¯¼ºÄ¡ÀÇ º¯È­¸¦ °è»êÇÑ´Ù. 
	CalcTotalItemEffect(iClientH, sItemIndex, true);
}


bool CGame::_bInitNpcAttr(class CNpc* pNpc, char* pNpcName, short sClass, char cSA)
{
	int i, iTemp;
	char cTmpName[21];
	int sTemp;
	double dV1, dV2, dV3;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) {
			if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø NPC ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ¸·Î ÃÊ±âÈ­ÇÑ´Ù.
				std::memset(pNpc->m_cNpcName, 0, sizeof(pNpc->m_cNpcName));
				memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);

				pNpc->m_sType = m_pNpcConfigList[i]->m_sType;

				// HitDice¿¡ µû¶ó °ø½ÄÀÌ ´Ù¸£´Ù. ¸÷°£ÀÇ Â÷º°À» µÎ±â À§ÇÔ.
				if (m_pNpcConfigList[i]->m_iHitDice <= 5)
					pNpc->m_iHP = (iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
				else pNpc->m_iHP = ((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
				// v1.4 È®ÀÎÄÚµå
				if (pNpc->m_iHP == 0) pNpc->m_iHP = 1;

				//50Cent - HP Bar
				pNpc->m_iMaxHP = pNpc->m_iHP;

				pNpc->m_iExpDiceMin = m_pNpcConfigList[i]->m_iExpDiceMin;
				pNpc->m_iExpDiceMax = m_pNpcConfigList[i]->m_iExpDiceMax;
				pNpc->m_iGoldDiceMin = m_pNpcConfigList[i]->m_iGoldDiceMin;
				pNpc->m_iGoldDiceMax = m_pNpcConfigList[i]->m_iGoldDiceMax;
				pNpc->m_iDropTableId = m_pNpcConfigList[i]->m_iDropTableId;
				pNpc->m_iExp = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

				pNpc->m_iHitDice = m_pNpcConfigList[i]->m_iHitDice;
				pNpc->m_iDefenseRatio = m_pNpcConfigList[i]->m_iDefenseRatio;
				pNpc->m_iHitRatio = m_pNpcConfigList[i]->m_iHitRatio;
				pNpc->m_iMinBravery = m_pNpcConfigList[i]->m_iMinBravery;
				pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
				pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
				pNpc->m_cSize = m_pNpcConfigList[i]->m_cSize;
				pNpc->m_cSide = m_pNpcConfigList[i]->m_cSide;
				pNpc->m_cActionLimit = m_pNpcConfigList[i]->m_cActionLimit;
				pNpc->m_dwActionTime = m_pNpcConfigList[i]->m_dwActionTime;
				pNpc->m_dwRegenTime = m_pNpcConfigList[i]->m_dwRegenTime;
				pNpc->m_cResistMagic = m_pNpcConfigList[i]->m_cResistMagic;
				pNpc->m_cMagicLevel = m_pNpcConfigList[i]->m_cMagicLevel;
				pNpc->m_iMaxMana = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
				pNpc->m_iMana = m_pNpcConfigList[i]->m_iMaxMana;
				pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
				pNpc->m_cDayOfWeekLimit = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
				pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;

				switch (sClass) {
				case 43:
				case 44:
				case 45:
				case 46:
				case 47: // ÀüÀï¿ë À¯´ÖÀÇ °æ¿ì ¹«Á¶°Ç °ø°Ý¸¸ ÇÏ´Â Àü·«À» ±¸»ç.
					pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
					break;

				default:
					pNpc->m_iAttackStrategy = iDice(1, 10);
					break;
				}

				pNpc->m_iAILevel = iDice(1, 3);
				pNpc->m_iAbsDamage = m_pNpcConfigList[i]->m_iAbsDamage;
				pNpc->m_iMagicHitRatio = m_pNpcConfigList[i]->m_iMagicHitRatio;
				pNpc->m_iAttackRange = m_pNpcConfigList[i]->m_iAttackRange;
				pNpc->m_cSpecialAbility = cSA;
				pNpc->m_iBuildCount = m_pNpcConfigList[i]->m_iMinBravery;

				// v1.411 NPCÀÇ Æ¯¼ö È¿°ú °è»ê. °æÇèÄ¡ °¡Áß 
				switch (pNpc->m_cSpecialAbility) {
				case 1:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 25.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 2:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 30.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 3: // Absorbing Physical Damage
					if (pNpc->m_iAbsDamage > 0) {
						// ±âº»ÀûÀ¸·Î ¸¶¹ý ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¹°¸® ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
						pNpc->m_cSpecialAbility = 0;
						cSA = 0;
					}
					else {
						iTemp = 20 + iDice(1, 60);
						pNpc->m_iAbsDamage -= iTemp;
						if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
					}

					dV2 = (double)pNpc->m_iExp;
					dV3 = (double)abs(pNpc->m_iAbsDamage) / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 4: // Absorbing Magical Damage
					if (pNpc->m_iAbsDamage < 0) {
						// ±âº»ÀûÀ¸·Î ¹°¸® ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¸¶¹ý ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
						pNpc->m_cSpecialAbility = 0;
						cSA = 0;
					}
					else {
						iTemp = 20 + iDice(1, 60);
						pNpc->m_iAbsDamage += iTemp;
						if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
					}

					dV2 = (double)pNpc->m_iExp;
					dV3 = (double)(pNpc->m_iAbsDamage) / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 5:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 15.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 6:
				case 7:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 20.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 8:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 25.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;
				}

				// v1.411 À§Ä¡ ¿Å±è 
				pNpc->m_iNoDieRemainExp = (pNpc->m_iExp) - (pNpc->m_iExp / 3);

				// v1.411 NPCÀÇ Æ¯¼ö ´É·Â »ðÀÔ 
				pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFF0FF;
				sTemp = cSA;
				sTemp = sTemp << 8;
				pNpc->m_iStatus = pNpc->m_iStatus | sTemp;

				// v1.41 NPCÀÇ Class»ðÀÔ.
				pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFFFF0;
				pNpc->m_iStatus = pNpc->m_iStatus | (sClass);

				return true;
			}
		}

	// NPC¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù. 
	return false;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
uint32_t CGame::iDice(uint32_t iThrow, uint32_t iRange)
{
	uint32_t iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (uint32_t i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}


void CGame::TimeManaPointsUp(int iClientH)
{
	int iMaxMP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	iMaxMP = iGetMaxMP(iClientH); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;

		if (m_pClientList[iClientH]->m_iMP > iMaxMP)
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{
	int iMaxSP, iTotal = 0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return; // v1.4 ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«ÃÃŸÂ¿Â¡Â´Ã‚ Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÃ€Â½.

	iMaxSP = iGetMaxSP(iClientH);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit / 3)); // Staminar Point´Â 10ÃÊ¸¶´Ù 1D(Vit/3)¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		// v2.03 ·¹º§ 60 ÀÌÇÏ´Â Á¤±âÀûÀ¸·Î ½ºÅ×¹Ì³ª°¡ ¸¹ÀÌ Âù´Ù.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		}
		else if (m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}
		else if (m_pClientList[iClientH]->m_iLevel <= 60) {
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP)
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, uint16_t wNotifyMsgType, short sV1, short sV2, char* pString)
{
	int i, iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) &&
			(memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0)) {

			switch (wNotifyMsgType) {
			case DEF_NOTIFY_GUILDDISBANDED:
				if (i == iClientH) break;
				{
					hb::net::PacketNotifyGuildDisbanded pkt{};
					pkt.header.msg_id = MSGID_NOTIFY;
					pkt.header.msg_type = wNotifyMsgType;
					memcpy(pkt.guild_name, m_pClientList[iClientH]->m_cGuildName, sizeof(pkt.guild_name));
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
				}
				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;
				break;

			case DEF_NOTIFY_EVENTMSGSTRING:
			{
				hb::net::PacketWriter writer;
				writer.Reserve(sizeof(hb::net::PacketHeader) + 256);

				auto* header = writer.Append<hb::net::PacketHeader>();
				header->msg_id = MSGID_NOTIFY;
				header->msg_type = wNotifyMsgType;

				if (pString != 0) {
					const std::size_t len = std::strlen(pString);
					writer.AppendBytes(pString, len);
				}
				writer.AppendBytes("", 1);

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
			}
			break;

			case DEF_NOTIFY_NEWGUILDSMAN:
			{
				hb::net::PacketNotifyNewGuildsMan pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = wNotifyMsgType;
				memcpy(pkt.name, m_pClientList[iClientH]->m_cCharName, 10);
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			break;

			case DEF_NOTIFY_DISMISSGUILDSMAN:
			{
				hb::net::PacketNotifyDismissGuildsMan pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = wNotifyMsgType;
				memcpy(pkt.name, m_pClientList[iClientH]->m_cCharName, 10);
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			break;
			}

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}
		}

}


void CGame::GuildNotifyHandler(char* pData, uint32_t dwMsgSize)
{
	// ´Ù¸¥ °ÔÀÓ¼­¹ö·ÎºÎÅÍ ±æµå ÀÌº¥Æ®°¡ µµÂøÇß´Ù. 
	char* cp, cCharName[11], cGuildName[21];

	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// ¾ÆÁ÷ ±¸ÇöµÇÁö ¾Ê¾Ò´Ù. 
}

void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	// Á×ÀºÃ´ÇÏ±â³ª Á×Àº »óÅÂ¿¡¼­´Â º¯È¯ÇÒ ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = true; // v2.172


	if (sAppr2 == 0) {
		// ºñÀüÅõ ¸ðµå¿´´Ù. ÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// ÀüÅõ ¸ðµå¿´´Ù. ºñÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÀÌ ¹Ù²î¾úÀ¸¹Ç·Î ÀÌº¥Æ®¸¦ Àü´ÞÇÑ´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	//int   iRet;
	   //
	   //if (m_pGateSock == 0) return;

	   //iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	   //switch (iRet) {
	   //case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
	   //	PutLogList("(!!!) Gate-socket connected!");
	   //	SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, 0);
	   //	break;
	   //case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
	   //	// °ÔÀÌÆ®¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³À¸¹Ç·Î °ÔÀÓ¼­¹ö µî·Ï ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
	   //	// v1.41 gate-socketÀ» Àç¿¬°áÇÒ ¶§ Ä«¿îÆÃ ÇÏ´Â º¯¼ö. ¼­¹ö ÀÛµ¿ µµÁß gate-socketÀÌ ¼ÒÄÏ¿¡·¯·Î ²÷±â¸é °ð¹Ù·Î ÀçÁ¢¼ÓÀ» 
	   //	// ½ÃµµÇÏ¸ç ÀÌ °ªÀÌ ÀÏÁ¤Ä¡ ÀÌ»óÀÌ µÇ¸é ¿¬°á ½ÇÆÐ·Î °£ÁÖµÇ¾î ÀÚµ¿ ¼­¹ö ¼Ë´Ù¿î ¸ðµå(4)·Î µé¾î°£´Ù. 
	   //	m_iGateSockConnRetryTimes = 0;
	   //	break;
	   //
	   //case DEF_XSOCKEVENT_READCOMPLETE:
	   //	// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù.
	   //	OnGateRead();
	   //	break;
	   //
	   //case DEF_XSOCKEVENT_BLOCK:
	   //	break;
	   //
	   //case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	   //	// È®ÀÎÄÚµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.
	   //case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	   //	// ¼ö½ÅÇØ¾ß ÇÒ ¸Þ½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	   //case DEF_XSOCKEVENT_SOCKETERROR:
	   //	// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	   //case DEF_XSOCKEVENT_SOCKETCLOSED:
	   //	// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
	   //	delete m_pGateSock;
	   //	m_pGateSock = 0;
	   //	PutLogList("(!!!) Gate-socket connection lost!");
	   //	m_bIsGateSockAvailable = false;

	   //	// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ 
	   //	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	   //	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	   //	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	   //	// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
	   //	m_iGateSockConnRetryTimes = 1;

	   //	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	   //	PutLogList(G_cTxt);

	   //	break;
	   //}
}

void CGame::OnGateRead()
{
	//uint32_t dwMsgSize;
	//char * pData, cKey;

	   //pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	   //if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, 0, cKey) == false) {
	   //	// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
	   //	PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	   //}	
}

void CGame::SendMsgToGateServer(uint32_t dwMsg, int iClientH, char* pData)
{
	//uint32_t * dwp;
	//uint16_t  * wp;
	//int     iRet, i;
	//char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	   //if (m_pGateSock == 0) {
	   //	PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
	   //	return;
	   //}

	   //std::memset(cData, 0, sizeof(cData));
	   //std::memset(cCharName, 0, sizeof(cCharName));
	   //std::memset(cAccountName, 0, sizeof(cAccountName));
	   //std::memset(cAccountPassword, 0, sizeof(cAccountPassword));
	   //std::memset(cAddress, 0, sizeof(cAddress));
	   //std::memset(cGuildName, 0, sizeof(cGuildName));

	   //switch (dwMsg) {
	   //// New 07/05/2004
	   //case MSGID_PARTYOPERATION:
	   //	iRet = m_pGateSock->iSendMsg(pData, 50);
	   //	break;

	   //case MSGID_SERVERSTOCKMSG:
	   //	iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
	   //	break;
	   //
	   //case MSGID_ITEMLOG:
	   //	// ¾ÆÀÌÅÛ Àü´Þ ·Î±×´Ù. »ç¿ëÇÏÁö ¾ÊÀ½.
	   //	dwp  = (uint32_t *)(cData + DEF_INDEX4_MSGID);
	   //	*dwp = MSGID_ITEMLOG;
	   //	wp   = (uint16_t *)(cData + DEF_INDEX2_MSGTYPE);
	   //	*wp  = DEF_MSGTYPE_CONFIRM;
	   //	
	   //	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	   //	memcpy(cp, pData, 47);
	   //	cp += 47;

	   //	iRet = m_pGateSock->iSendMsg(cData, 53);
	   //	break;
	   //
	   //case MSGID_REQUEST_REGISTERGAMESERVER:
	   //	// °ÔÀÌÆ® ¼­¹ö¿¡°Ô °ÔÀÓ¼­¹ö µî·ÏÀ» ¿äÃ»ÇÑ´Ù.
	   //	std::snprintf(cTxt, sizeof(cTxt), "(!) Try to register game server(%s) - GateServer", m_cServerName);
	   //	PutLogList(cTxt);
	   //	
	   //	dwp  = (uint32_t *)(cData + DEF_INDEX4_MSGID);
	   //	*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
	   //	wp   = (uint16_t *)(cData + DEF_INDEX2_MSGTYPE);
	   //	*wp  = DEF_MSGTYPE_CONFIRM;
	   //	
	   //	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	   //	memcpy(cAccountName, m_cServerName, 10);
	   //	if (m_iGameServerMode == 1)
	   //	{
	   //		memcpy(cAddress, m_cGameServerAddrInternal, strlen(m_cGameServerAddrInternal));
	   //	}
	   //	if (m_iGameServerMode == 2)
	   //	{
	   //		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
	   //	}

	   //	memcpy(cp, cAccountName, 10);
	   //	cp += 10;

	   //	memcpy(cp, cAddress, 16);
	   //	cp += 16;

	   //	wp  = (uint16_t *)cp;
	   //	*wp = m_iGameServerPort;
	   //	cp += 2;

	   //	*cp = m_iTotalMaps;
	   //	cp++;

	   //	for (i = 0; i < m_iTotalMaps; i++) {
	   //		memcpy(cp, m_pMapList[i]->m_cName, 11);
	   //		cp += 11;
	   //	}
	   //	
	   //	dwp = (uint32_t *)cp;
	   //	*dwp = (uint32_t)GetCurrentProcessId();	 // ÇÁ·Î¼¼½º ÇÚµéÀ» ±â·ÏÇÑ´Ù.

	   //	cp += 4;
	   //	dwp = (uint32_t *)cp;
	   //	*dwp = DEF_BUILDDATE;

	   //	iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
	   //	break;

	   //case MSGID_GAMESERVERALIVE:
	   //	// Á¤±âÀûÀ¸·Î °ÔÀÓ ¼­¹öÀÇ Á¤º¸¸¦ Àü¼Û 
	   //	// ¸¸¾à ·Î±× ¼­¹ö¿ÍÀÇ ¼ÒÄÏ ¿¬°áÀÌ ²÷¾îÁ³´Ù¸é ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê¾Æ ¼­¹ö¿¡ ÀÌ»óÀÌ »ý°åÀ½À» ¾Ë¸®°Ô À¯µµÇÑ´Ù.
	   //	if (m_bIsLogSockAvailable == false) return;
	   //	
	   //	dwp  = (uint32_t *)(cData + DEF_INDEX4_MSGID);
	   //	*dwp = MSGID_GAMESERVERALIVE;
	   //	wp   = (uint16_t *)(cData + DEF_INDEX2_MSGTYPE);
	   //	*wp  = DEF_MSGTYPE_CONFIRM;

	   //	cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	   //	wp  = (uint16_t *)cp;
	   //	*wp = m_iTotalClients;
	   //	cp += 2;
	   //	
	   //	iRet = m_pGateSock->iSendMsg(cData, 8);
	   //	break;
	   //}

	   //switch (iRet) {
	   //case DEF_XSOCKEVENT_QUENEFULL:
	   //case DEF_XSOCKEVENT_SOCKETERROR:
	   //case DEF_XSOCKEVENT_CRITICALERROR:
	   //case DEF_XSOCKEVENT_SOCKETCLOSED:
	   //	// °ÔÀÌÆ® ¼­¹ö·Î ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù.
	   //	PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
	   //	delete m_pGateSock;
	   //	m_pGateSock = 0;
	   //	m_bIsGateSockAvailable = false;

	   //	// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ: ¼­¹ö¸¦ ¼Ë´Ù¿î ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù. 
	   //	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	   //	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	   //	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	   //	// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
	   //	m_iGateSockConnRetryTimes = 1;	

	   //	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	   //	PutLogList(G_cTxt);

	   //	return;
	   //}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
	int     iRet;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[] = { 0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40 };
int  _tmp_iMLevelPenalty[] = { 0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40 };
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)
{
	short sX, sY, sOwnerH, sMagicCircle, rx, ry, sLevelMagic, sTemp;
	char cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr;
	class  CItem* pItem;
	uint32_t dwTime;
	uint16_t wWeaponType;
	short sEqStatus;
	int iMapSide = 0;
	short sIDNum;
	uint32_t dwAttr;

	dwTime = GameClock::GetTimeMS();
	m_pClientList[iClientH]->m_bMagicConfirm = true;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) && (bItemEffect == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == 0) return;

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == 0) return;

	if ((bItemEffect == false) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	//if ((var_874 ) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap ) && (m_pMagicConfigList[sType]->m_sType != 8)) return;

	if (((m_pClientList[iClientH]->m_iStatus & 0x100000) != 0) && (bItemEffect != true)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		}
		else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == false)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
		return;
	}

	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == false)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, 0,
			0, 0, 0, 0, 0, 0);
		return;
	}*/

	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != 0)) {
			if ((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = true;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) - 50) / 2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
			dV4 = (dV1 / dV3) * dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode) &&
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)) {
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;

		if (iManaCost <= 0) iManaCost = 1;
	}

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 34) {
		iManaCost += 20;
	}

	if (iResult < 100) {
		iDiceRes = iDice(1, 100);
		if (iResult < iDiceRes) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
			return;
		}
	}

	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1, 1000) <= 100)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		return;
	}

	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) - 50);

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
			dV4 = (dV1 / dV3) * dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	iResult += m_pClientList[iClientH]->m_iAddAR;
	if (iResult <= 0) iResult = 1;

	if (sType >= 80) iResult += 10000;

	if (m_pMagicConfigList[sType]->m_sType == 28) {
		iResult += 10000;
	}

	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}

	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
	}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if ((m_bIsCrusadeMode == false) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		if ((m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil)) {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
		}
		else if ((m_pClientList[iClientH]->m_bIsPlayerCivil) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == false)) {
			switch (m_pMagicConfigList[sType]->m_sType) {
			case 1:  // DEF_MAGICTYPE_DAMAGE_SPOT
			case 4:  // DEF_MAGICTYPE_SPDOWN_SPOT 4
			case 8:  // DEF_MAGICTYPE_TELEPORT 8
			case 10: // DEF_MAGICTYPE_CREATE 10
			case 11: // DEF_MAGICTYPE_PROTECT 11
			case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
			case 16: // DEF_MAGICTYPE_CONFUSE
			case 17: // DEF_MAGICTYPE_POISON
			case 32: // DEF_MAGICTYPE_RESURRECTION
			case DEF_MAGICTYPE_HASTE:
				return;
			}
		}
	}

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_HASTE:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (sOwnerH == iClientH) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HASTE] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HASTE] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetHasteFlag(sOwnerH, cOwnerType, true);
					break;

				case DEF_OWNERTYPE_NPC:
					goto MAGIC_NOEFFECT;
					break;
				}
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HASTE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HASTE, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case DEF_MAGICTYPE_SPDOWN_SPOT:
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			break;

		case DEF_MAGICTYPE_POLYMORPH:
			// ÂºÂ¯Â½Ã… Â¸Â¶Â¹Ã½. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					break;
				}

				// ÂºÂ¯Â½Ã… ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			}
			break;

			// 05/20/2004 - Hypnotoad - Cancellation
		case DEF_MAGICTYPE_CANCELLATION:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) {

				// Removes Invisibility Flag 0x0010
				SetInvisibilityFlag(sOwnerH, cOwnerType, false);

				// Removes Illusion Flag 0x01000000
				SetIllusionFlag(sOwnerH, cOwnerType, false);

				// Removes Defense Shield Flag 0x02000000
				// Removes Great Defense Shield Flag 0x02000000
				SetDefenseShieldFlag(sOwnerH, cOwnerType, false);

				// Removes Absolute Magic Protection Flag 0x04000000	
				// Removes Protection From Magic Flag 0x04000000
				SetMagicProtectionFlag(sOwnerH, cOwnerType, false);

				// Removes Protection From Arrow Flag 0x08000000
				SetProtectionFromArrowFlag(sOwnerH, cOwnerType, false);

				// Removes Illusion Movement Flag 0x00200000
				SetIllusionMovementFlag(sOwnerH, cOwnerType, false);

				// Removes Berserk Flag 0x0020
				SetBerserkFlag(sOwnerH, cOwnerType, false);

				//Removes ice-added 
				SetIceFlag(sOwnerH, cOwnerType, false);

				//Remove paralyse

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				// Update Client
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
			// ������ ó������ �ʴ´�.
			// �ֺ� ���� ȿ�� 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// �ڽŵ� ������ �� ������ ����.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
				}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
			}
			break;

			// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ 
		case DEF_MAGICTYPE_ICE_LINEAR:
			// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â¾Ã³Â¸Â®Â¸Ã§ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
							}
							//
						}
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
				// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
							SetIceFlag(sOwnerH, cOwnerType, true);
							// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
								sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
						}
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
							SetIceFlag(sOwnerH, cOwnerType, true);
							// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
								sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
						}
					}
					break;
				}
				//
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
					//
				}
			}
			break;


		case DEF_MAGICTYPE_INHIBITION:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INHIBITION] != 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) goto MAGIC_NOEFFECT;
				if (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
				//if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
				m_pClientList[sOwnerH]->m_bInhibition = true;
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;


		case DEF_MAGICTYPE_TREMOR: // v1.4 ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°ÃºÂ¿Â¡ Ã€ÃŒÂ¾Ã® Ã€ÃœÂ·Ã¹ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}

			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// ÃÃ·Â°ÃÃ€Âº ÃƒÂ³Â¸Â®Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// SpÂ°Â¡ Â»Ã³Â½Ã‚Ã‡Ã‘Â´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤Â¾Ã¸Â´Ã™. 
			Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					// Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤ Â¾Ã¸Â´Ã™.
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			break;

			// v2.16 2002-5-23 °í±¤Çö 
		case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
			// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ðµÎ ¾ó¸®¸ç °ø°ÝÇÑ´Ù.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// ÁÖº¯ °ø°Ý È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
								}
								break;
							}
							//
						}
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
				// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
					break;
				}
				//
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);

						}
						break;
					}
					//
				}
			}
			break;

		case DEF_MAGICTYPE_TELEPORT:
			// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Â¶Â¹Ã½. sValue 4Â¿Â¡ ÂµÃ»Â¶Ã³Â¼Â­ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Ã±Ã€Ã»ÃÃ¶Â°Â¡ Â°Ã¡ÃÂ¤ÂµÃˆÂ´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Ã€ÃšÂ½Ã…Ã€ÃŒ Â¼Ã’Â¼Ã“ÂµÃˆ Â¸Â¶Ã€Â»Â·ÃŽ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â®. RecallÃ€ÃŒÂ´Ã™.
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH)) {
					// Ã€ÃšÂ½Ã…Â¿ÃœÂ¿Â¡Â´Ã‚ RecallÃ‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
					RequestTeleportHandler(iClientH, "1   ");
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_SUMMON:
			// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½ 

			// Â»Ã§Ã…ÃµÃ€Ã¥ Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) return;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// ÃÃ¶ÃÂ¤ÂµÃˆ OwnerÂ°Â¡ MasterÂ°Â¡ ÂµÃˆÂ´Ã™. 
			if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
				// MasterÂ·ÃŽ ÃÃ¶ÃÂ¤ÂµÃˆ Â´Ã«Â»Ã³Ã€Â» ÂµÃ»Â¶Ã³Â´Ã™Â´ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Â´ÃƒÂ¼ Â¼Ã¶Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€Â» CastingÃ‡Ã‘ Ã€ÃšÃ€Ã‡ Magery/20 Â¸Â¸Ã…Â­Ã€Ã‡ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Â¼Ã’ÃˆÂ¯Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã™.
				if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4] / 20)) break;

				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
					// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
				}
				else {
					// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
					std::memset(cName, 0, sizeof(cName));
					std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

					// MageryÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã’ÃˆÂ¯ÂµÃ‡Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÂµÃ®Â±ÃžÃ€ÃŒ Â´ÃžÂ¶Ã³ÃÃ¸Â´Ã™.
					std::memset(cNpcName, 0, sizeof(cNpcName));

					switch (iV1) {
					case 0: // Ã€ÃÂ¹ÃÃ€Ã»Ã€ÃŽ Â°Ã¦Â¿Ã¬ 
						iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

						// v1.42 ÃƒÃ–Ã€Ãº Â¸Ã· Â·Â¹ÂºÂ§Ã€Â» Ã€Ã”Â·Ã‚ 
						if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20)
							iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

						switch (iResult) {
						case 1: strcpy(cNpcName, "Slime"); break;
						case 2: strcpy(cNpcName, "Giant-Ant"); break;
						case 3: strcpy(cNpcName, "Amphis"); break;
						case 4: strcpy(cNpcName, "Orc"); break;
						case 5: strcpy(cNpcName, "Skeleton"); break;
						case 6:	strcpy(cNpcName, "Clay-Golem"); break;
						case 7:	strcpy(cNpcName, "Stone-Golem"); break;
						case 8: strcpy(cNpcName, "Orc-Mage"); break;
						case 9:	strcpy(cNpcName, "Hellbound"); break;
						case 10:strcpy(cNpcName, "Cyclops"); break;
						}
						break;

					case 1:	strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Cyclops"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					}

					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, 0, 0, m_pClientList[iClientH]->m_cSide, false, true) == false) {
						// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·ÃŽ Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						std::memset(cName_Master, 0, sizeof(cName_Master));
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
							break;
						case DEF_OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName, cName_Master, cOwnerType);
					}
				}
			}
			break;

		case DEF_MAGICTYPE_CREATE:
			// Â¹Â«Â¾Ã°Â°Â¡Â¸Â¦ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â°Â´Ã‚ Â¸Â¶Â¹Ã½ 

			// Ã€Â§Ã„Â¡Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã·Â¿Â¡Â´Ã‚ Â»Ã½Â±Ã¢ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == false)
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Food
				if (iDice(1, 2) == 1)
					std::snprintf(cItemName, sizeof(cItemName), "Meat");
				else std::snprintf(cItemName, sizeof(cItemName), "Baguette");
				break;
			}

			_bInitItemAttr(pItem, cItemName);

			// v2.15 Â¸Â¶Â¹Ã½Ã€Â¸Â·ÃŽ Â»Ã½Â±Ã¤ Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â°Ã­Ã€Â¯Â¹Ã¸ÃˆÂ£ Ã€ÃºÃ€Ã¥ 
			pItem->m_sTouchEffectType = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue3 = (short)GameClock::GetTimeMS();

			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

			// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃŽÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);

			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				dX, dY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
			break;

		case DEF_MAGICTYPE_PROTECT:
			// ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½ 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			// ÂºÂ¸ÃˆÂ£ Â»Ã³Ã…Ã‚Â¶Ã³Â´Ã‚ Â°ÃÃ€Â» Â¼Â³ÃÂ¤Ã‡ÃÂ±Ã¢ Ã€Ã¼Â¿Â¡ Ã€ÃŒÂ¹ÃŒ Ã‡Ã˜Â´Ã§ ÂºÂ¸ÃˆÂ£Â°Â¡ Â°Ã‰Â·ÃÃ€Ã–Â´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃŽÃ‡ÃÂ°Ã­ Â°Ã‰Â·ÃÃ€Ã–Â´Ã™Â¸Ã© Â¸Â¶Â¹Ã½Ã€Âº Â¹Â«Â½ÃƒÂµÃˆÂ´Ã™. 
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0) goto MAGIC_NOEFFECT;
				// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Â¸Â¶Â¹Ã¦Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

				m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0) goto MAGIC_NOEFFECT;
				// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½ Ã€Ã»Â¿Ã« Â¾ÃˆÂµÃŠ.				
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
				m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = (char)m_pMagicConfigList[sType]->m_sValue4;

				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				}
				break;
			}

			// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
				sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

			// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			break;

		case DEF_MAGICTYPE_SCAN:
			std::memset(cScanMessage, 0, sizeof(cScanMessage));
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					std::snprintf(cScanMessage, sizeof(cScanMessage), " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
					ShowClientMsg(iClientH, cScanMessage);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					std::snprintf(cScanMessage, sizeof(cScanMessage), " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
					ShowClientMsg(iClientH, cScanMessage);
					break;
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, (short)10);
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// Â¿Ã€ÂºÃªÃÂ§Ã†Â®Ã€Ã‡ Â¿Ã²ÃÃ·Ã€Ã“Ã€Â» ÂºÃ€Â¼Ã¢Ã‡Ã‘Â´Ã™. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
					// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Ã†ÃÂ·Â²Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
					// 2002-09-10 #2 Â¾ÃˆÃ€Ã¼ÃÃ¶Â´Ã«(No-Attack-Area) Ã†ÃÂ·Â² Â¸Â¶Â¹Ã½ Â¾ÃˆÂµÃ‡Â°Ã” Ã‡Ã”
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {

						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					}

					// 2002-09-10 #3 Ã€Ã¼Â¸Ã©Ã€Ã¼Â½ÃƒÂ¿Ã Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥Â¿Â¡Â¼Â­Â¸Â¦ ÃÂ¦Â¿ÃœÃ‡ÃÂ°Ã­ Â°Â°Ã€Âº Ã†Ã­Â¿Â¡Â°Ã”Â´Ã‚ Ã†ÃÂ·Â² Â¾ÃˆÂµÃŠ
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
						m_bIsCrusadeMode == false &&
						m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)
						goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 Â¸Â¶Â¹Ã½ Â·Â¹ÂºÂ§ 6Ã€ÃŒÂ»Ã³Ã€ÃŽ Â¸Â®Ã„Â¡Â±Ãž Ã€ÃŒÂ»Ã³Ã€Ã‡ Â¸Â¶Â¹Ã½ Â¸Ã³Â½ÂºÃ…ÃÂ¿Â¡Â°Ã”Â´Ã‚ Â¸Â¶ÂºÃ± Â¸Â¶Â¹Ã½ Ã…Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}

				// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			}
			break;

		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if ((sOwnerH != iClientH) && ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) && ((memcmp(m_pClientList[sOwnerH]->m_cLocation, "elvhunter", 9) != 0) || (memcmp(m_pClientList[sOwnerH]->m_cLocation, "arehunter", 9) != 0))) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto MAGIC_NOEFFECT;
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, true);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto MAGIC_NOEFFECT;

					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						// Ã€ÃŒÂµÂ¿Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ NPCÂ´Ã‚ Ã…ÃµÂ¸Ã­ Â¸Â¶Â¹Ã½Ã€Â» Â°Ã‰ Â¼Ã¶ Â¾Ã¸Â´Ã™.
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, true);
						// Ã€ÃŒ NPCÂ¸Â¦ ÃƒÃŸÃ€Ã»Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã¸ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
					}
					break;
				}

				// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;

			case 2:
				// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
				if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) goto MAGIC_NOEFFECT;

				// dX, dY Â¹ÃÂ°Ã¦ 8 ÃÃ–ÂºÂ¯Ã€Ã‡ Invisibility Â»Ã³Ã…Ã‚Ã€ÃŽ ObjectÂ°Â¡ Ã€Ã–Ã€Â¸Â¸Ã© Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
				for (ix = dX - 8; ix <= dX + 8; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
								break;
							}
						}
					}
				break;
			}
			break;

		case DEF_MAGICTYPE_CREATE_DYNAMIC:
			// Dynamic ObjectÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡ÃÂ°Ã­ ÃˆÂ¿Â·Ã‚Ã€ÃŒ ÃÃ¶Â¼Ã“ÂµÃ‡Â´Ã‚ Ã…Â¸Ã€Ã”.

			// v2.1 Â¸Â¶Ã€Â» Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Ã‡ÃŠÂµÃ¥ Â¸Â¶Â¹Ã½ Â±ÃÃÃ¶(Ã€Ã¼Â¸Ã©Ã€Ã¼Â½Ãƒ ÃÂ¦Â¿Ãœ)
			if (m_bIsCrusadeMode == false) {
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
				// v2.14
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
			}

			switch (m_pMagicConfigList[sType]->m_sValue10) {
			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // ÂµÂ¶Â±Â¸Â¸Â§

			case DEF_DYNAMICOBJECT_FIRE:   // Fire Ã€ÃŒÂ´Ã™.
			case DEF_DYNAMICOBJECT_SPIKE:  // Spike

#ifdef DEF_TAIWANLOG 
				short sTemp_X, sTemp_Y;
				// v2.15 Â¸Â¶Â¹Ã½Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Â§Ã„Â¡Â¸Â¦ Ã‡Â¥Â½ÃƒÃ‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã‘ ÂºÂ¯Â¼Ã¶
				sTemp_X = m_pClientList[iClientH]->m_sX;
				sTemp_Y = m_pClientList[iClientH]->m_sY;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD, iClientH, m_pMagicConfigList[sType]->m_cName, 0);

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif

				switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1:
					// wall - type
					cDir = CMisc::cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000);

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
							dX + i * rx, dY + i * ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
						bAnalyzeCriminalAction(iClientH, dX + i * rx, dY + i * ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
							dX - i * rx, dY - i * ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
						bAnalyzeCriminalAction(iClientH, dX - i * rx, dY - i * ry);
					}
					break;

				case 2:
					// Field - Type
					bool bFlag = false;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime * 1000, m_pMagicConfigList[sType]->m_sValue5);

							// Â¸Â¸Â¾Ã  Â¸Â¶Ã€Â»Â¿Â¡Â¼Â­ Ã‡ÃŠÂµÃ¥Â¸Â¦ Â±Ã± Â°Ã·Â¿Â¡ Â¹Â«Â°Ã­Ã‡Ã‘ Ã€ÃšÂ°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã¸Â°ÃÃ€ÃšÂ´Ã‚ Â°Â¡ÂµÃ¥Ã€Ã‡ Â°Ã¸Â°ÃÃ€Â» Â¹ÃžÂ°Ã” ÂµÃˆÂ´Ã™. 
							if (bAnalyzeCriminalAction(iClientH, ix, iy, true)) {
								bFlag = true;
								cx = ix;
								cy = iy;
							}
						}
					// Ã‡ÃŠÂµÃ¥Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â°Ã¦ÂºÃ±Â¸Â¦ 1Â¸Ã­Â¸Â¸ Â¼Ã’ÃˆÂ¯Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
					if (bFlag) bAnalyzeCriminalAction(iClientH, cx, cy);
					break;
				}
				//
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
				// Ice-Storm Dynamic Object 
				iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
					dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
					m_pClientList[iClientH]->m_cSkillMastery[4]);
				break;

			default:
				break;
			}
			break;

		case DEF_MAGICTYPE_POSSESSION:
			// Â¿Ã¸Â°Ã…Â¸Â®Â¿Â¡ Â¶Â³Â¾Ã®ÃÂ® Ã€Ã–Â´Ã‚ Â¹Â°Â°Ã‡Ã€Â» ÃÃ½Â¾Ã®Â¿Ã€Â´Ã‚ Â¸Â¶Â¹Ã½Ã€ÃŒÂ´Ã™. 
			// v2.12 ÃÃŸÂ¸Â³Ã€Âº Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½ Â»Ã§Â¿Ã« ÂºÃ’Â°Â¡ 
			if (m_pClientList[iClientH]->m_cSide == 0) goto MAGIC_NOEFFECT;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (sOwnerH != 0) break; // v1.41 Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½Ã€Âº Â»Ã§Â¶Ã·Ã€ÃŒ Â¼Â­ Ã€Ã–Â´Ã‚ Ã€Â§Â¿Â¡Â´Ã‚ ÃˆÂ¿Â·Ã‚Ã€ÃŒ Â¾Ã¸Â´Ã™. 

			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sIDNum, &cRemainItemColor, &dwAttr);
			if (pItem != 0) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃÂ¿Â´Â´Ã™. 
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.

					// v1.411 Â·ÃŽÂ±Ã— Â³Â²Â±Ã¤Â´Ã™.
					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

					iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(iClientH, true, true);
						return;
					}
				}
				else
				{
					// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃŽÃÂ·Ã‡ÃÂ°Ã…Â³Âª Ã‡Ã‘Â°Ã¨ÃÃŸÂ·Â®Ã€Â» ÃƒÃŠÂ°ÃºÃ‡ÃŸÂ´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.

					// Â°Â¡ÃÂ®Â¿Ã”Â´Ã¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¿Ã¸Â»Ã³ÃˆÂ¸ÂºÂ¹Â½ÃƒÃ…Â²Â´Ã™. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

					iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(iClientH, true, true);
						return;
					}
				}
			}
			//
			break;

		case DEF_MAGICTYPE_CONFUSE:
			// if the caster side is the same as the targets side, no effect occurs
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1: // confuse LanguageÃ¬ÂÂ´Ã«â€¹Â¤. 
			case 2: // Confusion, Mass Confusion 	
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;

								// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
							}
						}
					}
				break;

			case 3: // Ilusion, Mass-Ilusion
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;

								switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 3:
									SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
									break;
								}

								// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
							}
						}
					}
				break;

			case 4: // Ilusion Movement
				if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;
								switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 4:
									SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
									break;
								}

								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
							}
						}
					}
			}
			break;


		case DEF_MAGICTYPE_POISON:
			// ÃÃŸÂµÂ¶ Â¸Â¶Â¹Ã½. Â¸Ã•Ã€Ãº Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Â» Â±Â¼Â¸Â®Â°Ã­ Â´Ã™Ã€Â½Ã€Â¸Â·ÃŽ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Ã‡Ã‘Â¹Ã¸ Â´Ãµ Â±Â¼Â¸Â°Â´Ã™. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
				// ÃÃŸÂµÂ¶Ã€Â» Â°Ã…Â´Ã‚ Â¸Â¶Â¹Ã½ 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

					// Â¹Ã¼ÃÃ‹Ã‡Ã Ã€Â§Â¶Ã³Â¸Ã© 
					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {
							// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.
							m_pClientList[sOwnerH]->m_bIsPoisoned = true;
							m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
							SetPoisonFlag(sOwnerH, cOwnerType, true);
							// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, 0, 0);
#ifdef DEF_TAIWANLOG
							_bItemLog(DEF_ITEMLOG_POISONED, sOwnerH, (char*)0, 0);
#endif
						}
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {
							// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.

						}
					}
					break;
				}
			}
			else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
				// ÃÃŸÂµÂ¶Ã€Â» Ã‡ÂªÂ´Ã‚ Â¸Â¶Â¹Ã½ 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_bIsPoisoned) {
						// ÃÃŸÂµÂ¶ÂµÃˆ Â»Ã³Ã…Ã‚Â¿Â´Â´Ã™Â¸Ã© ÃÃŸÂµÂ¶Ã€Â» Ã‡Â¬Â´Ã™.
						m_pClientList[sOwnerH]->m_bIsPoisoned = false;
						// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
						SetPoisonFlag(sOwnerH, cOwnerType, false);
						// ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â·ÃˆÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case DEF_MAGICTYPE_BERSERK:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Â¹Ã¶Â¼Â­Ã„Â¿ Â¸Ã°ÂµÃ¥Â·ÃŽ Ã€Ã¼ÃˆÂ¯ÂµÃˆÂ´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, true);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) goto MAGIC_NOEFFECT;
					// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº Â±Â¤ÂºÃ Â¾ÃˆÂµÃŠ				
					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
					// 2002-09-11 #3 Ã€Ã» Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ Â±Â¤ÂºÃÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â½
					if (m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;

					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, true);
					break;
				}

				// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;

			// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ Â¼Ã¶ÃÂ¤
		case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
			// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃŽÂ´Ã™.
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃŽÂ´Ã™.
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
					}
				}
			break;

			// Resurrection Magic. 
		case DEF_MAGICTYPE_RESURRECTION:
			// 10 Mins once
			if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC / 2;
			// Get the ID of the dead Player/NPC on coords dX, dY. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			switch (cOwnerType) {
				// For Player. 
			case DEF_OWNERTYPE_PLAYER:
				// The Player has to exist. 
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				// Resurrection is not for alive Players. 
				if (m_pClientList[sOwnerH]->m_bIsKilled == false) goto MAGIC_NOEFFECT;
				// Set Deadflag to Alive. 
				m_pClientList[sOwnerH]->m_bIsKilled = false;
				// Player's HP becomes half of the Max HP. 
				m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + ((m_pClientList[sOwnerH]->m_iStr + m_pClientList[sOwnerH]->m_iAngelicStr) / 2)) / 2;
				// Send new HP to Player. 
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				// Make Player stand up. (Currently, by a fake damage). 
				m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY);
				m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY);
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, 0, 0);
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				break;
				// Resurrection is not for NPC's. 
			case DEF_OWNERTYPE_NPC:
				goto MAGIC_NOEFFECT;
				break;
			}
			break;

		case DEF_MAGICTYPE_ICE:
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						// Â´Ã«Â¹ÃŒÃÃ¶Â¿Ã Ã‡Ã”Â²Â²
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}

					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

							//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº. ÃÃ—ÃÃ¶ Â¾ÃŠÂ¾Ã’Ã€Â¸Â¸Ã© Ã€Ã»Â¿Ã« 
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
								}
							}
						}
					}
				}
			break;

		default:
			break;
		}
	}
	else {
		// Casting ÃˆÃ„ ÂµÃ´Â·Â¹Ã€ÃŒÂ°Â¡ Â°Ã‰Â¸Â®Â´Ã‚ Â¸Â¶Â¹Ã½
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)

		if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
			//Check if player has resurrection wand
			if (m_pClientList[iClientH] != 0 && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
				m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == false) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (m_pClientList[sOwnerH] != 0) {
					// GM's can ressurect ne1, and players must be on same side to ressurect

					if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
						(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						return;
					}
					if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != 0 &&
						m_pClientList[sOwnerH]->m_iHP <= 0) {
						m_pClientList[sOwnerH]->m_bIsBeingResurrected = true;
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, 0, 0, 0, 0);
						if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
							m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = true;
							m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
							m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
							m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

							sTemp = m_pClientList[iClientH]->m_sAppr4;
							sTemp = 0xFF0F & sTemp;
							sTemp = sTemp | 0x40;
							m_pClientList[iClientH]->m_sAppr4 = sTemp;
						}
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
						SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}
			}
		}
	}

MAGIC_NOEFFECT:

	if (m_pClientList[iClientH] == 0) return;

	//Mana Slate
	if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
		iManaCost = 0;
	}

	// ManaÂ¸Â¦ Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
	m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1Ã€ÃŒ Mana Cost
	if (m_pClientList[iClientH]->m_iMP < 0)
		m_pClientList[iClientH]->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, 4, 1);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);

	// Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°ÃºÂ¸Â¦ Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™. Â¸Â¶Â¹Ã½Â¹Ã¸ÃˆÂ£ + 100Ã€ÃŒ Â¿Â¡Ã†Ã¥Ã†Â® Â¹Ã¸ÃˆÂ£ 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType + 100), m_pClientList[iClientH]->m_sType);

}





void CGame::RequestTeleportHandler(int iClientH, char* pData, char* cMapName, int dX, int dY)
{
	char cTempMapName[21];
	char cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short sX, sY, sSummonPoints;
	int i, iRet, iSize, iDestX, iDestY, iExH, iMapSide;
	bool    bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
		(m_pClientList[iClientH]->m_bIsKilled == false) && (m_bIsApocalypseMode) && (m_pClientList[iClientH]->m_iHP > 0)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NORECALL, 0, 0, 0, 0);
		return;
	}
	// v2.16 2002-6-2 ���� ���������� ������ ���� �ʴ´�.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1') || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == false)) return;

	// v2.16 2002-6-2 ���� ���������� ������ ���� �ʴ´�.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1') || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == false)) return;

	bIsLockedMapNotify = false;

	// ë§Œì•½ êµí™˜ ëª¨ë“œë¼ë©´ êµí™˜ì„ ì·¨ì†Œí•œë‹¤.
	if (m_pClientList[iClientH]->m_bIsExchangeMode) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ì¤‘ë¦½ì´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ë©´ íˆ¬ëª…í•˜ê²Œ ë˜ëŠ” ë²„ê·¸ ìˆ˜ì • 
	// ì¤‘ë¦½ì´ë©´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ ëœë‹¤. 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	// í˜„ìž¬ ì´ í”Œë ˆì´ì–´ë¥¼ ëª©í‘œë¡œ ì‚¼ê³  ìžˆëŠ” ëª¹ë“¤ì˜ ê³µê²©í–‰ë™ì„ ë©ˆì¶”ê²Œ í•œë‹¤. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// í˜„ìž¬ ë§µ ìœ„ì¹˜ì—ì„œ ì§€ìš´ë‹¤.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER,
		m_pClientList[iClientH]->m_sX,
		m_pClientList[iClientH]->m_sY);

	// ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ í”Œë ˆì´ì–´ê°€ í˜„ ìœ„ì¹˜ì—ì„œ ì‚¬ë¼ì§ì„ ì•Œë¦°ë‹¤. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

	// í˜„ìž¬ í…”ë ˆí¬íŠ¸ê°€ ë§ˆë²•ì— ì˜í•œ ê²ƒì¸ì§€, ì•„ë‹ˆë©´ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì¸ì§€ë¥¼ ì²´í¬í•œë‹¤. 
	// ë§Œì•½ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì´ë¼ë©´ í…”ë ˆí¬íŠ¸í•  ìœ„ì¹˜ì˜ ë§µì´ë¦„, ì¢Œí‘œë¥¼ êµ¬í•´ì™€ì„œ 
	// ê·¸ ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ë¥¼ ê²€ìƒ‰í•œë‹¤. ë§Œì•½ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ 
	// ë‹¤ë¥¸ ì„œë²„ë¡œì˜ ì ‘ì†ì„ ì‹œë„í•˜ë¼ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤. 

	// ë¨¼ì € í”Œë ˆì´ì–´ê°€ ì„œìžˆëŠ” ìœ„ì¹˜ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì¸ì§€ ì•Œì•„ë‚¸ë‹¤. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	std::memset(cDestMapName, 0, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
		// ë§Œì•½ ê°ˆ ë§µì´ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´  
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2; // New 18/05/2004
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
			// ë“¤ì–´ê°€ê³ ìž í•˜ëŠ” ë§µì´ ê°™ì€ íŽ¸ì˜ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´ ë“¤ì–´ê°ˆ ìˆ˜ ìžˆë‹¤.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = true;
			std::memset(cDestMapName, 0, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet) && (cMapName == 0)) {
		// í”Œë ˆì´ì–´ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ ìœ„ì— ì„œ ìžˆë‹¤. í…”ë ˆí¬íŠ¸ í•  ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ ê²€ìƒ‰í•œë‹¤. ë¬¼ë¡  ëª©ì ì§€ê°€ ì§€ì •ë˜ì§€ ì•Šì€ í…”ë ˆí¬íŠ¸ì—¬ì•¼í•œë‹¤.
		for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != 0) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
					m_pClientList[iClientH]->m_sX = iDestX;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
					m_pClientList[iClientH]->m_sY = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
					std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
					goto RTH_NEXTSTEP;
				}
			}

		// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
		m_pClientList[iClientH]->m_sX = iDestX;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
		m_pClientList[iClientH]->m_sY = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

		// New 18/05/2004
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], 0, 0);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

		// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì €ìž¥í–ˆë‹¤ëŠ” ì‘ë‹µì´ ì˜¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì ‘ì†ì„ ë‹¤ì‹œ í• ê²ƒì„ ì•Œë ¤ì¤€ë‹¤.
		//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false);  // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
		// !!!!
		m_pClientList[iClientH]->m_bIsOnServerChange = true;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
		return;
	}
	else {
		// ë§ˆë²•ì— ì˜í•œ í…”ë ˆí¬íŠ¸ì´ë‹¤. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// ë ˆë²¨ ì œí•œì´ ìžˆëŠ” ë§µì— ë“¤ì–´ê°”ì„ë•Œ ì¼ì–´ë‚œë‹¤. 
			std::memset(cTempMapName, 0, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) {
				strcpy(cTempMapName, "arefarm");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) {
				strcpy(cTempMapName, "elvfarm");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
						std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
						goto RTH_NEXTSTEP;
					}
				}

			// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
			m_pClientList[iClientH]->m_sX = -1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
			m_pClientList[iClientH]->m_sY = -1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

			// New 18/05/2004
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], 0, 0);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

			// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
			//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.

			m_pClientList[iClientH]->m_bIsOnServerChange = true;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
			return;

		case '1':
			// Recall.í”Œë ˆì´ì–´ê°€ ì†Œì†ëœ ë§ˆì„ì˜ ì§„ìž… í¬ì¸íŠ¸ë¡œ ê°„ë‹¤.
			// ë§Œì•½ ë¶€í™œì¡´ì´ë¼ë©´ ë¦¬ì½œë˜ì§€ ì•ŠëŠ”ë‹¤.
			// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

			std::memset(cTempMapName, 0, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else {
				// v2.14 ·¹º§ 80 ÀÌÇÏ´Â ¸®ÄÝ½Ã ³ó°æÁö·Î °£´Ù.
				if (m_pClientList[iClientH]->m_iLevel > 80)
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
						strcpy(cTempMapName, "aresden");
					else strcpy(cTempMapName, "elvine");
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
						strcpy(cTempMapName, "arefarm");
					else strcpy(cTempMapName, "elvfarm");
				}
			}
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.

						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
						std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
						goto RTH_NEXTSTEP;
					}
				}

			// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
			m_pClientList[iClientH]->m_sX = -1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
			m_pClientList[iClientH]->m_sY = -1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

			// New 18/05/2004
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], 0, 0);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

			// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
			//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
			// !!!
			m_pClientList[iClientH]->m_bIsOnServerChange = true;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
			return;

		case '2':
			// ëª©ì ì§€ê°€ ì§€ì •ëœ í…”ë ˆí¬íŠ¸.

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// í˜„ìž¬ ì„œë²„ì— ëª©ì ì§€ê°€ ì—†ë‹¤. 
				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX = dX; //-1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY = dY; //-1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.

				// New 18/05/2004
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], 0, 0);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

				//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange = true;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
				return;
			}

			m_pClientList[iClientH]->m_sX = dX;
			m_pClientList[iClientH]->m_sY = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);
			break;
		}
	}

RTH_NEXTSTEP:

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// Crusade
	if (bIsLockedMapNotify) SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);

	hb::net::PacketWriter writer;
	char initMapData[DEF_MSGBUFFERSIZE + 1];

	writer.Reset();
	auto* init_header = writer.Append<hb::net::PacketResponseInitDataHeader>();
	init_header->header.msg_id = MSGID_RESPONSE_INITDATA;
	init_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	init_header->player_object_id = static_cast<std::int16_t>(iClientH);
	init_header->pivot_x = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sX - 14 - 5);
	init_header->pivot_y = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sY - 12 - 5);
	init_header->player_type = m_pClientList[iClientH]->m_sType;
	init_header->appr1 = m_pClientList[iClientH]->m_sAppr1;
	init_header->appr2 = m_pClientList[iClientH]->m_sAppr2;
	init_header->appr3 = m_pClientList[iClientH]->m_sAppr3;
	init_header->appr4 = m_pClientList[iClientH]->m_sAppr4;
	init_header->appr_color = m_pClientList[iClientH]->m_iApprColor;
	init_header->status = m_pClientList[iClientH]->m_iStatus;
	std::memcpy(init_header->map_name, m_pClientList[iClientH]->m_cMapName, sizeof(init_header->map_name));
	std::memcpy(init_header->cur_location, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sizeof(init_header->cur_location));

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->sprite_alpha = 1;
	else init_header->sprite_alpha = m_cDayOrNight;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->weather_status = 0;
	else init_header->weather_status = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;

	init_header->contribution = m_pClientList[iClientH]->m_iContribution;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
			DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);
	}

	init_header->observer_mode = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsObserverMode);
	init_header->rating = m_pClientList[iClientH]->m_iRating;
	init_header->hp = m_pClientList[iClientH]->m_iHP;
	init_header->discount = 0;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 12, m_pClientList[iClientH]->m_sY - 9, iClientH, initMapData);
	writer.AppendBytes(initMapData, static_cast<std::size_t>(iSize));

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) &&
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	}
	else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) &&
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	}
	else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) {
		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		SetForceRecallTime(iClientH);

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 20 * 60 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;

	}
	else {
		m_pClientList[iClientH]->m_bIsWarLocation = false;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		SetForceRecallTime(iClientH);
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
			}
		}
	}
	else {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone &&
			m_iFightzoneNoForceRecall == false &&
			m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		}
		else {
			if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0 ||
				memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = true;
					m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				}
			}
		}
	}

	// ì¶”ê°€ë¡œ ë³´ë‚´ì¤˜ì•¼ í•  ì •ë³´ë¥¼ ë³´ë‚¸ë‹¤. v1.1
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
	// v1.3
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
	// V1.3
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);

	// Crusade íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ CrusadeGUIDì§¸ì§• 0 íšŠì§š?ì¨˜ íš‰ì² ?ì±Œì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ì±• íš„ì¨€?ì© íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì¨ˆíš‚ ì§¸íš’?íš‘ì¨ˆíš¢. íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
	if (m_bIsCrusadeMode) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• 0?íš‘ì¨‹ì²œ ì§¸íš’?ì¨˜ íš„ì¨€?ì© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì©”ì§• ì¨‰ì±•ì©ì±¤ì©”íššì¨ˆíš¢ì¨ˆíš‚ ?íš‰ì¨”íš‘. ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©íšˆ?íš‘ì¨‰ì±¨ì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ˆíš‚ ì§¸íš’?ì¨˜ ?ì²¬ì¨”ì²©ì©”ì§• ì¨”ì²¬ì©ì±¤íšì¨€ì¨ˆì²© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…?íš‰ ì§¸ì°¼ì§¸ì²¬?íš‘ì¨ˆíš¢.
			// ?íš‘ì¨Œì§¹ ì§¸ì±ˆì©”ì±™ ?ì²´ì§¸ì²©ì©”ì§• ì¨‰ì²­ì¨ì§œ íšˆì²¨ì¨©ì²˜?ì¨© íš‰íš˜ ì©Œì²  ì©ì²©ì¨ˆíš¢. íš„íšœì©Œíš˜íš‰íš— íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì§¸ì§• íšì©ì¨Œì°¼ì¨‰íšŠ ì¨ˆíš¢?ì© ì¨ˆíš¢?ì© ?ì²´ì¨ì±•?ì²´?íš‘ ì©íš„?íš¤ì¨‰íš‰ì§¹ì°½ ?ì²´ì©”ì§• íšì§–ì©Œíš™?ì¨© íš‰íš ì©íš© íšˆì²¨ì¨©ì²˜?ì¨© ì©ì±µ?ì¨© ì©Œì²  ?íšœì¨ˆíš¢.
			// ?íš‘?ì²´ì©”ì§• íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì©ì²¬ì¨ˆì²© ì©”ì§§íš‰íš˜, ì§¸íš‰ì©Œì¨€ íšˆì²¨?íš“íšˆì§°, ?ì²´?ì±¦ ì§¸ì²©íš‰ì±…ì¨‰ì¨‰ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… GUIDì§¸ì§• ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢. íšˆì²¨ì¨©ì²˜ ì¨˜íš˜ì§¸ì§•.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	}
	else if (m_bIsHeldenianMode) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > m_iMaxSummonPoints) sSummonPoints = m_iMaxSummonPoints;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		}
		else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
		}
		if (m_bHeldenianInitiated) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
		UpdateHeldenianStatus();
	}
	else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
			}
		}
		else {
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4 Â»Ã§Ã…ÃµÃ€Ã¥Ã€Ã‡ Â°Â¹Â¼Ã¶Â¸Â¦ Â´ÃƒÂ¸Â± Â¼Ã¶ Ã€Ã–ÂµÂµÂ·Ã 
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);

	// v2.15
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	if (m_bIsHeldenianMode) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
		if (m_bHeldenianInitiated) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
		}
		else {
			UpdateHeldenianStatus();
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
		_bCheckIsQuestCompleted(iClientH);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
	int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
		if ((i != sOwnerH) && (m_pNpcList[i] != 0)) {
			if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

				m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			}
		}
}

void CGame::RequestStudyMagicHandler(int iClientH, const char* pName, bool bIsPurchase)
{
	char cMagicName[31];
	uint32_t dwGoldCount;
	int iReqInt, iCost, iRet;
	bool bMagic = true;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// ������ ����. 

	std::memset(cMagicName, 0, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);

	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// �̷� �̸��� ������ �������� �ʴ´�. �����Ѵ�. 

	}
	else {
		if (bIsPurchase) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = false; // �Ϲ������� ���� ���� �����̶��(������ ����) ��� �� ����.
			dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);
			if ((uint32_t)iCost > dwGoldCount)  bMagic = false; // ���� �����ص� ��� �� ����.
		}
		//wizard remove
		//if (m_pClientList[iClientH]->m_bIsInsideWizardTower == false && bIsPurchase) return;
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) && (bMagic)) {

			// ���� ��������� �˸���.
			if (bIsPurchase) SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - iCost);

			// ����ǰ �� �߷� �� ��� 
			iCalcTotalWeight(iClientH);

			// ���� ��� �ɷ� ǥ�� .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

			// ������ ����ٴ� �޽����� �����Ѵ�.
			{

				hb::net::PacketNotifyMagicStudySuccess pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_MAGICSTUDYSUCCESS;
				pkt.magic_id = static_cast<uint8_t>(iRet);
				memcpy(pkt.magic_name, cMagicName, sizeof(pkt.magic_name));
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			// ������ �������� �ʾ� ������ ��� �� ����.
			// ������ ���� �����ٴ� �޽����� �����Ѵ�.
			{

				hb::net::PacketNotifyMagicStudyFail pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_MAGICSTUDYFAIL;
				pkt.result = 1;
				pkt.magic_id = static_cast<uint8_t>(iRet);
				memcpy(pkt.magic_name, cMagicName, sizeof(pkt.magic_name));
				pkt.cost = static_cast<int32_t>(iCost);
				pkt.req_int = static_cast<int32_t>(iReqInt);
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char* pMagicName, int* pReqInt, int* pCost)
{
	int i;
	char cTmpName[31];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) {
			if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø ¸¶¹ý ¼³Á¤À» Ã£¾Ò´Ù. ¸¶¹ý ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
				*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
				*pCost = (int)m_pMagicConfigList[i]->m_iGoldCost;

				return i;
			}
		}

	return -1;
}

void CGame::TrainSkillResponse(bool bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{

	int   iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((iSkillNum < 0) || (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess) {
		// �̹� ����� ���� ���¶�� �ҿ��� ����.
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;

		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// ��� �� ���� �� ����Ѵ�.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		// ����� ����ٴ� �޽����� �����Ѵ�.
		{

			hb::net::PacketNotifySkillTrainSuccess pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = DEF_NOTIFY_SKILLTRAINSUCCESS;
			pkt.skill_num = static_cast<uint8_t>(iSkillNum);
			pkt.skill_level = static_cast<uint8_t>(iSkillLevel);
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
	else {


	}

}









bool CGame::__bReadMapInfo(int iMapIndex)
{
	char* pContents, * token, * pTile, cTxt[250], cFn[255];
	char seps[] = "= \t\r\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iTeleportLocIndex = 0;
	int  iWayPointCfgIndex = 0;
	int  iTotalNpcSetting = 0;
	int  iMGARCfgIndex = 0;
	int  iSMGRCfgIndex = 0;
	int  iNMRCfgIndex = 0;
	int  iFishPointIndex = 0;
	int  iMineralPointIndex = 0;
	int  iStrategicPointIndex = 0;
	int  iIndex = 0;

	int  iNamingValue;
	HANDLE hFile;
	uint32_t  dwFileSize, dwReadSize;
	FILE* pFile;

	char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
	short sIPindex, dX, dY;

	// »çÅõÀåÀÎÁö¸¦ ÆÇ´Ü.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0)
		m_pMapList[iMapIndex]->m_bIsFightZone = true;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0)
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = true;

	std::memset(cFn, 0, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	dwFileSize = GetFileSize(hFile, 0);
	CloseHandle(hFile);


	pContents = new char[dwFileSize + 1];
	std::memset(pContents, 0, dwFileSize + 1);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// ¸Ê Á¤º¸ÆÄÀÏÀ»  ÀÐÀ» ¼ö ¾ø´Ù.
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return false;
	}
	else {
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ X  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ Y 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö ¸Ê ÀÌ¸§ 
					std::memset(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 0, sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ X 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ Y 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// ÅÚ·¹Æ÷Æ® ÈÄ ¹æÇâ  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint ¹øÈ£   
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					// waypoint ÁýÇÕ Á¤ÀÇ X  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint ÁýÇÕ Á¤ÀÇ Y  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc¸¦ Æ¯Á¤À§Ä¡¿¡ À§Ä¡½ÃÅ²´Ù.
				switch (cReadModeB) {
				case 1:
					// NPCÀÇ ÀÌ¸§. 
					std::memset(cNpcName, 0, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcWaypointIndex[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// ÀÌÁ¦ ÀÌ°÷¿¡¼­ NPC¸¦ »ý¼ºÇÑ´Ù. 

					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
					}
					else {
						// NPC¸¦ »ý¼ºÇÑ´Ù.
						std::memset(cName, 0, sizeof(cName));
						std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex + 65;

						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, 0, 0, cNpcWaypointIndex, 0, 0, -1, false) == false) {
							// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						}
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator »ç¿ë ¿©ºÎ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// Ä³¸¯ÅÍ ·£´ý »ý¼º ±ÝÁö ±¸¿ª : ¸¶À» Áß½ÉºÎ °°Àºµ¥¼­ ¸÷ÀÌ ¹ß»ýµÇ¸é °ï¶õÇÏ¹Ç·Î 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 7:
				// Æ¯Á¤Áö¿ª ¸÷ »ý¼º 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â ¸÷ Á¦³Ê·¹ÀÌÅÍ ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = true;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT°¡ ¾Æ´Ï¶ó WaypointÁýÇÕÀ» ÀÐ¾î¾ß ÇÑ´Ù.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
					break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 8:
				// ¸ÊÀÌ ¼ÓÇÑ Àå¼Ò ÀÌ¸§ 
				std::memset(m_pMapList[iMapIndex]->m_cLocationName, 0, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 10:
				// °ø°Ý ¹«È¿È­ ¿µ¿ª RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â No-Magic-Rect ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (bool)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode)
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = false;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Fish Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// ±¤¹° Á¦³×·¹ÀÌÅÍÀÇ Á¸ÀçÀ¯¹«¿Í µî±Þ 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Mineral Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Strategic Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Creation Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Goal Point ¹øÈ£ÀÌ´Ù.
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â  Point ¹øÈ£ÀÌ´Ù.
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

					cReadModeB = 15;
					break;

				case 15:
					std::memset(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, 0, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != 0) {
						// �̹� �Ҵ�Ǿ��ִ� Item-Event ��ȣ�̴�.
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;

				case 2:
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 25: //mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: //ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX1 = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX2 = atoi(token);
					cReadModeB = 5;
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY2 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = static_cast<bool>(atoi(token));
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 32: // CitizenLimit // 32
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = static_cast<bool>(atoi(token));
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					dX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					dY = atoi(token);
					pTile = 0;
					pTile = (char*)(m_pMapList[iMapIndex]->m_pTile + dX + dY * m_pMapList[iMapIndex]->m_sSizeY);
					if (pTile == 0) {
						std::snprintf(cTxt, sizeof(cTxt), "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
						PutLogList(cTxt);
						delete[] pContents;
						return false;
					}
					//pTile->m_iAttribute = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0)
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = true;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = strtok(NULL, seps);
	}

RMI_SKIPDECODING:

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return false;
	}

	PutLogList(cTxt);

	// Crusade °ø°Ý ºÒ°¡´É ¿µ¿ªÀ» Å¸ÀÏ¿¡ Ç¥½ÃÇÑ´Ù.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return true;

}

void CGame::Quit()
{
	int i;

	// ¾²·¹µå¸¦ Á×ÀÎ´Ù.
	G_bIsThread = false;
	Sleep(300);

	/*if (m_pMainLogSock != 0) delete m_pMainLogSock;
	if (m_pGateSock != 0) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != 0) delete m_pSubLogSock[i];*/

	if (_lsock != 0) delete _lsock;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != 0) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != 0) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

	//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	if (m_pNoticementData != 0) delete m_pNoticementData;

}

uint32_t CGame::iGetLevelExp(int iLevel)
{
	return CalculateLevelExp(iLevel);
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
	int iRet;

	if (iLevel < 1) return 1;

	if (iLevel <= 50)
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = (iLevel * 2);
	}

	return iRet;
}

/*****************************************************************
**---------------------------FUNCTION---------------------------**
**             void Game::CheckLevelUp(int iClientH)            **
**-------------------------DESCRIPTION--------------------------**
** Level-Up                                                     **
**  - Level +1                                                  **
**  - +3 Level Up Points                                        **
**  - Reset Next Level EXP                                      **
**  - Civilian Level Limit                                      **
**      Player mode switches to Combatant                       **
**      when the limit is reached                               **
**  - Majestic Points +1                                        **
**  - Reset Next Level EXP                                      **
**------------------------CREATION DATE-------------------------**
**                January 30, 2007; 3:06 PM; Dax                **
*****************************************************************/
bool CGame::bCheckLevelUp(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	while (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp)
	{
		if (m_pClientList[iClientH]->m_iLevel < m_iMaxLevel)
		{
			// ·¹º§ÀÌ ¿Ã¶ú´Ù.
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;
			// ·¹º§ÀÌ ¿À¸¥°Í¿¡ ´ëÇÑ Æ¯¼ºÄ¡ Æ÷ÀÎÆ®¸¦ Áõ°¡½ÃÄÑ¾ß ÇÑ´Ù. 
//			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
//	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {
				// ·¹º§ ¾÷ ¼¼ÆÃÀÌ 3º¸´Ù °°°Å³ª ÀÛ¾Æ¾ß À¯È¿ÇÏ´Ù. 

//			}

			// ¼³Á¤Ä¡¸¦ È®ÀÎÇÑ´Ù. 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// New 17/05/2004
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil)
					ForceChangePlayMode(iClientH, true);

			// centu - max hp,mp,sp when level up
			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
			m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);

			// ·¹º§ÀÌ ¿À¸¥°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_LEVELUP, 0, 0, 0, 0);

			// ´ÙÀ½ ·¹º§·ÎÀÇ °æÇèÄ¡°ª °è»ê, ÇÒ´ç.
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

			// Æ¯¼ºÄ¡ Àç °è»ê. 
			CalcTotalItemEffect(iClientH, -1, false);

			//v1.4 ´ÙÀ½ ·¹º§ 
			//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Level up: Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			//PutLogFileList(G_cTxt);
		}
		else {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iMaxLevel + 1];
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iMaxLevel];
			//addon
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, 0, 0);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}

	return false;
}
// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, uint32_t dwMsgSize)
//  desc		 :: ÁöÁ¸Æ÷ÀÎÆ®¸¦ ·¹º§¾÷ Æ÷ÀÎÆ®·Î µ¹¸°´Ù...
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char cStateChange1, cStateChange2, cStateChange3;
	char cStr, cVit, cDex, cInt, cMag, cChar;
	char cStateTxt[512];
	int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestStateChange>(
		pData, sizeof(hb::net::PacketRequestStateChange));
	if (!pkt) return;
	cStr = cVit = cDex = cInt = cMag = cChar = 0;
	cStateChange1 = static_cast<char>(pkt->change1);
	cStateChange2 = static_cast<char>(pkt->change2);
	cStateChange3 = static_cast<char>(pkt->change3);

	iOldStr = m_pClientList[iClientH]->m_iStr;
	iOldVit = m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;

	try
	{
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
		PutLogList(G_cTxt);
	}
	catch (...)
	{
	}

	if (!bChangeState(cStateChange1, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}
	if (!bChangeState(cStateChange2, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}
	if (!bChangeState(cStateChange3, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	try
	{
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Char(%s) St1(%d) St2(%d) St3(%d) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, cStateChange1, cStateChange2, cStateChange3, cStr, cVit, cDex, cInt, cMag, cChar);
		PutLogList(G_cTxt);
	}
	catch (...)
	{
	}

	//±æµå ¸¶½ºÅÍ¸é cChar¸¦ ¸ø ³»¸°´Ù..
	if (m_pClientList[iClientH]->m_iGuildRank == 0)
	{
		if (m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{
			//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
			return;
		}
	}

	//Æ¯¼ºÄ¡ °ªÀÌ ·¹º§°ú ¸ÂÁö ¾Ê´Ù¸é ³»¸±¼ö ¾ø´Ù..
	if (iOldStr + iOldVit + iOldDex + iOldInt + iOldMag + iOldChar != (179 * 3 + 70))
	{
		//ÇØÅ·ÀÌ´Ù... Å¬¶óÀÌ¾ðÆ®¿¡¼­ ¸øº¸³»°Ô µÇ¾î ÀÖ´Ù ±Ùµ¥ ¿Ô´Ù¸é ÇØÅ·...
		return;
	}


	if (cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	// Æ¯¼ºÄ¡°ªÀÌ 10ÀÌÇÏ·Î ¸ø³»·Á °£´Ù... Á¦ÇÑÀ» ³ÑÀ»¼öµµ ¾ø´Ù...
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iStr - cStr < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iDex - cDex < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iInt - cInt < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iVit - cVit < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iMag - cMag < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		|| (m_pClientList[iClientH]->m_iCharisma - cChar < 10))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.
	//m_pClientList[iClientH]->m_iLU_Pool += 3;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	//HBest uuendus, hp,mp,sp lowering, skillcheck
	m_pClientList[iClientH]->m_iHP -= (cStr + 3 * cVit);
	m_pClientList[iClientH]->m_iMP -= (cInt + 2 * cMag);
	m_pClientList[iClientH]->m_iSP -= (2 * cStr);
	m_pClientList[iClientH]->m_iStr -= cStr;
	m_pClientList[iClientH]->m_iVit -= cVit;
	m_pClientList[iClientH]->m_iDex -= cDex;
	m_pClientList[iClientH]->m_iInt -= cInt;
	//2003-04-22ÀÏ ¸¶¹ýÀ» »èÁ¦ ½ÃÅ²´Ù.... ÀÎÆ®°¡ ³»·Á°¡°í ³ª¼­ µ¹¾Æ°¡¾ß ÇÑ´Ù...
	if (cInt > 0)
		bCheckMagicInt(iClientH);
	m_pClientList[iClientH]->m_iMag -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;
	//SkillCheck(iClientH);

	try
	{
		std::memset(cStateTxt, 0, sizeof(cStateTxt));

		std::snprintf(cStateTxt, sizeof(cStateTxt), "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
			iOldStr, m_pClientList[iClientH]->m_iStr,
			iOldVit, m_pClientList[iClientH]->m_iVit,
			iOldDex, m_pClientList[iClientH]->m_iDex,
			iOldInt, m_pClientList[iClientH]->m_iInt,
			iOldMag, m_pClientList[iClientH]->m_iMag,
			iOldChar, m_pClientList[iClientH]->m_iCharisma
		);
	}
	catch (...)
	{

	}

	//_bCustomLog(DEF_ITEMLOG_CUSTOM,iClientH,0,cStateTxt);

	//2003-04-22ÀÏ ½ºÅ³À» ³»·Á°¡°Ô ÇÑ´Ù... 
	//bCheckSkillState(iClientH);

	//¼º°ø..!!!
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
}

// 2003-04-21 ÀÎÆ®¿¡ µû¸¥ ¸¶¹ýÀ» »èÁ¦ ½ÃÄÑÁØ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bool CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 :: ÀÎÆ®°¡ ³»·Á°¬À»¶§ »èÁ¦ÇÒ ¸¶¹ýÀ» Ã³¸®ÇÑ´Ù... Ã¼Å©¸¸...
//	return value :: ¹«Á¶°Ç true   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
bool CGame::bCheckMagicInt(int iClientH)
{

	for (int i = 0; i < DEF_MAXMAGICTYPE; i++)
	{
		if (m_pMagicConfigList[i] != 0)
			if (m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt))
			{
				m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
			}
	}

	return true;
}

// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 :: ÁöÁ¸ Æ÷ÀÎÆ®·Î Æ¯¼º°ª ¹Ù²Üƒ”À» ´õÇØ ÁØ´Ù...
//	return value :: BOOLÇü 0(FASLE) ¿¡·¯ ·¹º§ ¼öÁ¤ ºÒ°¡...
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
bool CGame::bChangeState(char cStateChange, char* cStr, char* cVit, char* cDex, char* cInt, char* cMag, char* cChar)
{
	if (cStateChange == DEF_STR)
	{
		*cStr += 1;
	}
	else if (cStateChange == DEF_VIT)
	{
		*cInt += 1;
		//		if(m_pClientList[iClientH]->m_iStr - cVit < 10 || m_pClientList[iClientH]->cVit - cVit < DEF_CHARPOINTLIMIT )
		//			return 0;
	}
	else if (cStateChange == DEF_DEX)
	{
		*cVit += 1;
	}
	else if (cStateChange == DEF_INT)
	{
		*cDex += 1;
	}
	else if (cStateChange == DEF_MAG)
	{
		*cMag += 1;
	}
	else if (cStateChange == DEF_CHR)
	{
		*cChar += 1;
	}
	else
	{
		//Å¬¶óÀÌ¾ðÆ®°¡ Àß¸øµÈ °ªÀ» º¸³» ¿Ô´Ù..
//		::MessageBox(0, "Å¬¶óÀÌ¾ðÆ® ¹ö±×? - 클라이언트 버그?","debug", MB_ICONEXCLAMATION | MB_YESNO) ;
		return 0;
	}

	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	int iTotalSetting = 0;

	uint16_t cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestLevelUpSettings>(pData, sizeof(hb::net::PacketRequestLevelUpSettings));
	if (!req) return;

	cStr = req->str;
	cVit = req->vit;
	cDex = req->dex;
	cInt = req->intel;
	cMag = req->mag;
	cChar = req->chr;

	if ((cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	// Check if adding points would exceed the stat limit
	if (m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT)
		return;

	if (m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT)
		return;

	if (m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT)
		return;

	if (m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT)
		return;

	if (m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT)
		return;

	if (m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT)
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ Æ÷ÀÎÆ® > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)¸é ºñÁ¤»óÀÌ´Ù.. Ã³¸® ºÒ°¡.. ·¹º§¾÷ Æ÷ÀÎÆ®¸¦ Á¤»óÄ¡·Î ¸¶Ãß°í Ã³¸® ºÒ°¡..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool - 3 > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70))
	{

		m_pClientList[iClientH]->m_iLU_Pool = /*m_cLU_Str ÃÊ±â°ª*/3 + (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70 - iTotalSetting;

		//iTotalSetting°ªÀÌ Àß¸øµÈ °æ¿ì´Ù...
		if (m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ ½ÃÅ³ Æ÷ÀÎÆ® ÁD > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)ÀÌ¸é Ã³¸® ºÒ°¡..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar) > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	m_pClientList[iClientH]->m_iStr += cStr;
	m_pClientList[iClientH]->m_iVit += cVit;
	m_pClientList[iClientH]->m_iDex += cDex;
	m_pClientList[iClientH]->m_iInt += cInt;
	m_pClientList[iClientH]->m_iMag += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);

}

//}

// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à ÇÔ¼ö FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	int iFightzoneNum, iEnableReserveTime;
	uint32_t dwGoldCount;
	uint16_t wResult;
	int     iRet, iResult = 1, iCannotReserveDay;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	GetLocalTime(&SysTime);

	// ¿¹¾à °¡´ÉÇÑ ½Ã°£ : µÎ½Ã°£ °£°ÝÀ¸·Î ¿¹¾àÀÌ °¡´ÉÇÏ¸ç »ç¿ë¿Ï·á 5ºÐÀü¿¡´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
	iEnableReserveTime = 2 * 20 * 60 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 5 * 20;

	dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestFightzoneReserve>(
		pData, sizeof(hb::net::PacketRequestFightzoneReserve));
	if (!pkt) return;
	// ¿¹¾àÀ» ¿øÇÏ´Â »çÅõÀå ¹øÈ£¸¦ ¹Þ´Â´Ù.
	iFightzoneNum = pkt->fightzone;

	// Àß¸øµÈ fightzone ¹øÈ£¸¦ °É·¯³½´Ù.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// »çÅõÀåÀÌ Áßº¹µÇÁö ¾Ê°Ô ÇÏ±â À§ÇØ ¿äÀÏ¿¡ µû¶ó »ç¿ëÇÒ¼ö ÀÖ´Â »çÅõÀåÀÌ ´Ù¸£°Ô ÇÏ±â À§ÇÑ º¯¼ö´Ù.
	// È¦¼ö³¯¿¡´Â ¾Æ·¹½ºµ§ 2 4 6 8 ¿¤¹ÙÀÎÀÌ 1 3 5 7  »çÅõÀåÀÌ »ç¿ë°¡´ÉÇÏ´Ù 
	//             ex) 1ÀÏÀÎ°æ¿ì => {1 + 1 (¾Æ·¹½ºµ§) + 1 (»çÅõÀå ¹øÈ£ )} %2 == 1 ÀÌ¹Ç·Î 
	//                            ¾Æ·¹½ºµ§Àº È¦¼ö³¯ È¦¼ö »çÅõÀåÀ»  ¿¹¾à ÇÒ¼ö ¾ø´Ù. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum) % 2;
	if (iEnableReserveTime <= 0) {
		// ¿¹¾à¿¡ ½ÇÆÐÇß´Ù. 
		// ¸¸¾à ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ ¾Æ´Ï¸é 0 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³»°í 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0;
	}
	else if (m_iFightZoneReserve[iFightzoneNum - 1] != 0) {
		// »çÅõÀåÀÌ ¿¹¾à µÇ¾î ÀÖÀ¸¸é  -1 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1;
	}
	else if (dwGoldCount < 1500) {
		// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ÀÔÀå±Ç °¡°Ý¿¡ ºñÇØ Àû´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2;	           // µ·ÀÌ ÀûÀ¸¸é -2 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô º¸³½´Ù.
	}
	else if (iCannotReserveDay) {
		// ¿À´ÃÀº ¿¹¾àÇÒ ¼ö ¾ø´Â ³¯ÀÌ´Ù. ÀÌ¶§´Â -3 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3;
	}
	else if (m_pClientList[iClientH]->m_iFightzoneNumber != 0) {
		// ÀÌ¹Ì ´Ù¸¥ »çÅõÀåÀ» ¿¹¾àÇß´Ù. ÀÌ¶§´Â -4 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4;
	}
	else {
		// »ç¿ëÀÚ°¡ °í¸¥ »çÅõÀåÀÌ ¿¹¾àÀÌ µÇ¾î ÀÖÁö ¾Ê°í 
		// ¿¹¾à¿¡ ÇÊ¿äÇÑ ±Ý¾×µµ °¡Áö°í ÀÖ°í
		// ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ¸é  ¿¹¾àÇÑ´Ù.

		// ¿¹¾à¿¡ ¼º°ø Çß´Ù. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// »çÅõÀå ¿¹¾àÀ» À§ÇÑ ±Ý¾×À» °¨¼Ò ½ÃÅ²´Ù.
		SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);

		// »çÅõÀåÀ» ¿¹¾àÇÑ Å¬¶óÀÌ¾ðÆ®ÀÇ ID¸¦ ³Ö´Â´Ù.
		m_iFightZoneReserve[iFightzoneNum - 1] = iClientH;

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneNum;
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour;

		if (SysTime.wHour % 2)	m_pClientList[iClientH]->m_iReserveTime += 1;	// È¦¼ö ½Ã°£´ëÀÌ¸é ÇÑ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		else					m_pClientList[iClientH]->m_iReserveTime += 2;    // Â¦¼ö ½Ã°£´ëÀÌ¸é µÎ ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 50;
		iResult = 1;
	}

	hb::net::PacketResponseFightzoneReserve resp{};
	resp.header.msg_id = MSGID_RESPONSE_FIGHTZONE_RESERVE;
	resp.header.msg_type = wResult;
	resp.result = iResult;

	// »çÅõÀå ¿¹¾à ÀÀ´ä ¸Þ¼¼Áö  Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&resp), sizeof(resp));

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
}



bool CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return false;

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) &&
		(m_pClientList[iClientH]->m_iExp >= m_iLevelExp20)) {
		// ¿©ÇàÀÚ°¡ ·¹º§ 20 °æÇèÄ¡¸¦ ¾ò¾ú´Ù¸é 19¼öÁØÀ¸·Î È¯¿ø. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, 0, 0, 0, 0);
		return true;
	}


	return false;
}

void CGame::RequestCivilRightHandler(int iClientH, char* pData)
{
	uint16_t wResult;
	int  iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// ?횑쨔횑 횉횗 쨍쨋?쨩?횉 쩌횘쩌횙?횑 ?횜쨈횢쨍챕 쩍횄쨔횓짹횉?쨩 째징횁첬 쩌철 쩐첩쨈횢. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// 쨌쨔쨘짠?횑 5 ?횑횉횕쨋처쨉쨉 쩍횄쨔횓짹횉?쨩 쩐챵?쨩 쩌철 쩐첩쨈횢. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;

	if (wResult == 1) {
		// 횉철?챌 쨍횎?횉 ?횑쨍짠?쨩 횉횘쨈챌횉횗쨈횢.
		std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side 횉횘쨈챌
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;

	hb::net::PacketResponseCivilRight pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_CIVILRIGHT;
	pkt.header.msg_type = wResult;
	std::memset(pkt.location, 0, sizeof(pkt.location));
	memcpy(pkt.location, m_pClientList[iClientH]->m_cLocation, sizeof(pkt.location));

	// ???? ???????? ?????????????? ????
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 쨍횧쩍횄횁철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔횩쨩첵횉횩쨈횢쨍챕 횁짝째횇횉횗쨈횢.
		DeleteClient(iClientH, true, true);
		return;
	}
	// 횈짱쩌쨘?횑 쨔횢짼챤쨔횉쨌횓 쩔횥쩐챌?쨩 쨩천쨌횓 쨘쨍쨀쩍쨈횢. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}



void CGame::RequestRetrieveItemHandler(int iClientH, char* pData)
{
	char cBankItemIndex;
	int i, j, iRet, iItemWeight;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestRetrieveItem>(
		pData, sizeof(hb::net::PacketRequestRetrieveItem));
	if (!pkt) return;
	cBankItemIndex = static_cast<char>(pkt->item_slot);
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == 0) {
		// Bank item missing.
		hb::net::PacketResponseRetrieveItem pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
		pkt.header.msg_type = DEF_MSGTYPE_REJECT;
		pkt.bank_index = 0;
		pkt.item_index = 0;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	else {
		// Áß·®°è»ê 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

		if ((iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// ÇÑ°èÁß·® ÃÊ°ú, ¾ÆÀÌÅÛÀ» Ã£À» ¼ö ¾ø´Ù. 
			// ½ÇÆÐ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		// Notify cannot carry more items.
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				break;
			}
			return;
		}

		//!!!
		if ((m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// Áßº¹ÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ¶ó¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù.	
			for (i = 0; i < DEF_MAXITEMS; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != 0) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) &&
					(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0)) {
					// °°Àº Çü½ÄÀÇ ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ¼ö·®À» Áõ°¡½ÃÅ²´Ù.
					// v1.41 !!! 
					SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

					// ¹ðÅ© ¾ÆÀÌÅÛ »èÁ¦ 
					delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;

					// ºó °ø°£À» ¾ø¾Ø´Ù. 
					for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = 0;
						}
					}

					// Send retrieve confirmation.
					hb::net::PacketResponseRetrieveItem pkt{};
					pkt.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
					pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;
					pkt.bank_index = cBankItemIndex;
					pkt.item_index = static_cast<int8_t>(i);

					iCalcTotalWeight(iClientH);
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));

					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, true, true);
						return;
					}
					return;
				}

			// °°Àº ÀÌ¸§À» °®°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¾ø´Ù. »õ·Î Ãß°¡ÇØ¾ß ÇÑ´Ù. 
			goto RRIH_NOQUANTITY;
		}
		else {
		RRIH_NOQUANTITY:
			// ¼ö·®°³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ 
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
					// ºó °ø°£À» Ã£¾Ò´Ù. 
					// ¸ÕÀú ÁÖ¼Ò¸¦ ¿Å±ä´Ù. 
					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					// v1.3 1-27 12:22
					m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
					m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;

					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;

					// ºó °ø°£À» ¾ø¾Ø´Ù. 
					for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = 0;
						}
					}

					// Send retrieve confirmation.
					hb::net::PacketResponseRetrieveItem pktConfirm{};
					pktConfirm.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
					pktConfirm.header.msg_type = DEF_MSGTYPE_CONFIRM;
					pktConfirm.bank_index = cBankItemIndex;
					pktConfirm.item_index = static_cast<int8_t>(i);

					iCalcTotalWeight(iClientH);
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pktConfirm), sizeof(pktConfirm));
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, true, true);
						return;
					}
					return;
				}
			// No empty inventory slot.
			hb::net::PacketResponseRetrieveItem pktReject{};
			pktReject.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
			pktReject.header.msg_type = DEF_MSGTYPE_REJECT;
			pktReject.bank_index = 0;
			pktReject.item_index = 0;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pktReject), sizeof(pktReject));
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
	int i, iRet;
	class CItem* pItem;

	// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀ» º¸°üÇÑ´Ù.
	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			// ºñ¾îÀÖ´Â À§Ä¡¸¦ Ã£¾Ò´Ù.

			m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
			pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
			// !!! ¾ÆÀÌÅÛÀÇ Æ÷ÀÎÅÍ¸¦ ÀÌµ¿ÇßÀ¸´Ï ±âÁ¸ÀÇ Æ÷ÀÎÅÍ´Â NULL°ªÀ¸·Î ÇÒ´ç. 
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;

			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);

			{
				hb::net::PacketNotifyItemToBank pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_ITEMTOBANK;
				pkt.bank_index = static_cast<uint8_t>(i);
				pkt.is_new = 1;
				memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
				pkt.count = pItem->m_dwCount;
				pkt.item_type = pItem->m_cItemType;
				pkt.equip_pos = pItem->m_cEquipPos;
				pkt.is_equipped = 0;
				pkt.level_limit = pItem->m_sLevelLimit;
				pkt.gender_limit = pItem->m_cGenderLimit;
				pkt.cur_lifespan = pItem->m_wCurLifeSpan;
				pkt.weight = pItem->m_wWeight;
				pkt.sprite = pItem->m_sSprite;
				pkt.sprite_frame = pItem->m_sSpriteFrame;
				pkt.item_color = pItem->m_cItemColor;
				pkt.item_effect_value2 = pItem->m_sItemEffectValue2;
				pkt.attribute = pItem->m_dwAttribute;
				pkt.spec_effect_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
				pkt.item_id = pItem->m_sIDnum;
				pkt.max_lifespan = pItem->m_wMaxLifeSpan;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
				// DeleteClient(iClientH, true, true);
				return true; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
			}

			return true;
		}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return false;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	uint32_t iV1, iV2;

	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0) return;
	// ¾ÈÀü °ø°Ý ¸ðµå°¡ ÄÑÁø »óÅÂ¿¡¼­ °ø°ÝÀ¸·Î ÀÎÇØ °°Àº ÆíÀÌ Á×À»¼ö´Â ¾øÁö¸¸ ¸¸¾à ÀÖÀ»°æ¿ì ¹«½Ã 
	// ´Ü °ø°ÝÀÚ°¡ ¹üÁËÀÚ°¡ ¾Æ´Ï¾î¾ß¸¸ ÇØ´çµÈ´Ù.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return;
	if ((strcmp(m_pClientList[sVictumH]->m_cLocation, "aresden") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvine") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvhunter") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "arehunter") != 0)) {
		return;
	}

	// PK Count Áõ°¡  
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, 0);

	// °æÇèÄ¡ °¨¼Ò 
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel / 2) + 1, 50);
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel / 2) + 1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1;
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// Æä³ÎÆ¼¸¦ ¸Ô¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);

	// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	// v1.4 ·Î±× ÆÄÀÏ¿¡ ±â·Ï 
	//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) PK-penalty: °ø°ÝÀÚ(%s) ¼Õ½Ç °æÇèÄ¡(%d) °æÇèÄ¡(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 Å©¶óÀÓ È½¼ö Áõ°¡ 
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating ÇÏ¶ô 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating = 10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;


	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

			// ¾Æ·¹½ºµ§ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			// v2.16 ¼ºÈÄ´Ï ¼öÁ¤
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60 * 3;
			RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
			return;
		}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

			// ¿¤¹ÙÀÎ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60 * 3;
			RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			return;
		}
	}
}


// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER, sAttackerH, sVictumH, 0);

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK¸¦ ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.

	}
	else {
		// Æ÷»ó±Ý¸¸ ´©Àû. °æÇèÄ¡´Â ¿À¸£Áö ¾Ê´Â´Ù. 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0)
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, 0, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iEK_Level;
	uint32_t iRewardExp;

	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == 0) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == 0)   return;

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, 0);

	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
				&& (m_bEnemyKillMode == false)) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}

			if (m_bEnemyKillMode) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
		}
		// Æ÷»ó±Ý ´©Àû 
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿ 
		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// ÀûÀ» ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.
	}
	else {
		// Èñ»ýÀÚÀÇ ½Ã¹Î, ±æµå¿ø ¿©ºÎ¿¡ µû¶ó Æ÷»óÀÌ ´Þ¶óÁø´Ù. 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// ±æµå¿øÀÌ ¾Æ´Ï¹Ç·Î ½Ã¹Î. (¿©ÇàÀÚÀÇ °æ¿ì¿¡´Â ÀÌ ÇÔ¼ö°¡ È£ÃâµÇÁö ¾ÊÀ¸¹Ç·Î)
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ 
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			if (m_bIsCrusadeMode) {
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ (1/3)*3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 6¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3) * 4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3)) * 12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[iAttackerH]->m_iWarContribution = m_iMaxWarContribution;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[iAttackerH]->m_iConstructionPoint = m_iMaxConstructionPoints;

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3)) * 6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					if (m_bEnemyKillMode) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ 
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			// ±æµå¿øÀÌ´Ù.
			if (m_bIsCrusadeMode) {
				// Å©·ç¼¼ÀÌµå ¸ðµå.
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ 1/3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 2¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3) * 4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3)) * 12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[iAttackerH]->m_iWarContribution = m_iMaxWarContribution;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[iAttackerH]->m_iConstructionPoint = m_iMaxConstructionPoints;

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3)) * 6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿ 
		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);

		if (bCheckLimitedUser(iAttackerH) == false) {
			// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
			SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
		}
		// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
		bCheckLevelUp(iAttackerH);

		//v1.4 ±³Àü¿¡¼­ ÀÌ±ä Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, bool bIsSAattacked)
{
	uint32_t iExp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// Crusade
	if (m_bIsCrusadeMode) {
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÎ °æ¿ì ÀüÀïÁß¿¡ Á×¾îµµ ¾Æ¹«·± Æä³ÎÆ¼°¡ ¾ø´Ù.
		// PKcount¸¸ °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, 0, iClientH, 0);

		}
		return;
	}
	else {
		// PKcount °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, 0, iClientH, 0);
		}

		// ÇÃ·¹ÀÌ¾î·ÎºÎÅÍÀÇ °ø°ÝÀ» ¹Þ°í ÀüÀïÁß »ç¸ÁÇß´Ù.
		iExp = iDice(1, (5 * cPenaltyLevel * m_pClientList[iClientH]->m_iLevel));

		// Áß¸³ÀÎ °æ¿ì Á×¾úÀ» ¶§ ¶³¾îÁö´Â °æÇèÄ¡´Â 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral) iExp = iExp / 3;

		// v2.17 2002-7-31 ÃÖ°í·¾Àº Á×¾úÀ»¶§ °æÄ¡°¡ ¶³¾îÁöÁö ¾Ê´Â´Ù. ¼öÁ¤ 
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);

		// v1.41 Áß¸³Àº ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_bIsNeutral != true) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// ·¹º§ 80 ¹Ì¸¸Àº ¾ÆÀÌÅÛÀÌ ÇÏ³ª Àû°Ô ¶³¾îÁø´Ù.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, bool bIsSAattacked)
{
	int i, j, iRemainItem;
	char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != 0)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04 ½ºÅæ ¿Àºê »õÅ©¸®ÆÄÀÌ½º°¡ ¸Â´ÂÁö È®ÀÎ
			// ´ëÃ¼ÀûÀ¸·Î ¶³¾îÁö´Â ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ´Ù¸¥ ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê°í ÀÌ ¾ÆÀÌÅÛ¸¸ ¶³¾îÁø´Ù. 
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
			}
			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			// ´Ù½Ã °Ë»ö 
			for (i = 0; i < DEF_MAXITEMS; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
					if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
						m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
					}
					DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
					m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
					return;
				}

			// ¿À·ù¹ß»ý! Èñ»ý¼®ÀÌ ¾ø´Ù. 
			goto PID_DROP;
		}
		return;
	}

PID_DROP:

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		std::memset(cItemIndexList, 0, sizeof(cItemIndexList));

		for (j = 0; j < DEF_MAXITEMS; j++)
			if (m_pClientList[iClientH]->m_pItemList[j] != 0) {
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
			}

		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[iDice(1, iRemainItem) - 1];


		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// °³ÀÎ¿¡°Ô ¼ÓÇÑ ¾ÆÀÌÅÛÀ¸·Î ¶³¾îÁöÁö ¾Ê´Â´Ù. ¸ÁÅä°°Àº °³ÀÎ¿ë ¾ÆÀÌÅÛ 
		}

		else if (
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		}

		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			(bIsSAattacked == false)) {
			// Æ¯¼ö ´É·ÂÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Æ¯¼ö °ø°ÝÀ» ¹ÞÀº°Ô ¾Æ´Ï¶ó¸é ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}

		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect) && (iDice(1, 10) == 5)) {
			// Ä³¸¯ÅÍ¿¡°Ô Çà¿îÈ¿°ú°¡ ÀÖÀ¸¸é 10% È®·ü·Î ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}

		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)
{
	int iRet, iEraseReq, iWeightLeft;
	uint32_t iRewardGoldLeft;
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;


	// ³²Àº Áß·®À» °è»êÇÑ´Ù. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

	if (iWeightLeft <= 0) return;
	// Áß·®À» ¹ÝÀ¸·Î ³ª´«´Ù. <- Ã£Àº µ·À¸·Î ¾ÆÀÌÅÛÀ» »ì °ø°£Àº ¸¶·ÃÇØ µÖ¾ß ÇÏ¹Ç·Î.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	_bInitItemAttr(pItem, hb::item::ItemId::Gold);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;

	// (iWeightLeft / pItem->m_wWeight)°¡ ÃÖ´ë ¹ÞÀ» ¼ö ÀÖ´Â Gold°¹¼ö. °®°íÀÖ´Â Æ÷»ó±Ý°ú ºñ±³ÇÑ´Ù. 
	uint32_t maxGold = static_cast<uint32_t>(iWeightLeft / iGetItemWeight(pItem, 1));
	if (maxGold >= m_pClientList[iClientH]->m_iRewardGold) {
		// Æ÷»ó±ÝÀ» ¸ðµÎ ¹ÞÀ» ¼ö ÀÖ´Ù. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)¸¸ ¹Þ´Â´Ù.
		pItem->m_dwCount = maxGold;
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - maxGold;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.

		// ³²Àº Æ÷»ó±Ý ³»¿ª °è»ê.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}

		// ±× ´ÙÀ½ ³²Àº Æ÷»ó±ÝÀ» ¾Ë·ÁÁØ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REWARDGOLD, 0, 0, 0, 0);
	}
	else {
		// ¹ÞÀ» ¼ö ¾ø´Â °æ¿ì´Â ¾Æ¹«·± Ã³¸®¸¦ ÇÏÁö ¾Ê´Â´Ù. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel * 500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, uint32_t dwLastTime, int iV1)
{
	int i;
	short sPreType;
	uint32_t dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != 0) return 0;

	switch (sType) {
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == false)
			return 0;
		if (dwLastTime != 0) {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == 0) dwLastTime = 1000;
		}
		break;

	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false)
			return 0;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == false)
			return 0;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, false);
		break;

	}

	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] == 0) {
			dwTime = GameClock::GetTimeMS();

			if (dwLastTime != 0)
				dwLastTime += (iDice(1, 4) * 1000);

			m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
			m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, 0, (short)0);

			return i;
		}
	return 0;
}

void CGame::CheckDynamicObjectList()
{
	int i;
	uint32_t dwTime = GameClock::GetTimeMS(), dwRegisterTime;
	short sType;

	// ³¯¾¾ È¿°ú¿¡ µû¸¥ µ¿Àû °´Ã¼ÀÇ Áö¼Ó½Ã°£ ´ÜÃàÀ» °è»êÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0)) {

			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				// ºÒÀÇ °æ¿ì ºñ°¡ ¿ÈÀ¸·Î ÀÎÇØ ¼ö¸íÀÌ ±Þ°ÝÈ÷ ´ÜÃàµÈ´Ù.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1:
				case 2:
				case 3:
					// (³²Àº ½Ã°£/10)*ºñ¿À´Â »óÅÂ ¸¸Å­ ½Ã°£À» »«´Ù.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime -
						(m_pDynamicObjectList[i]->m_dwLastTime / 10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// ½Ã°£ÀÌ ¸¸·áµÈ °´Ã¼¸¦ Á¾·á½ÃÅ²´Ù. Áö¼Ó½Ã°£ÀÌ NULLÀÌ¸é ¿µ¿øÈ÷ ³²¾ÆÀÖ´Â µ¿Àû °´Ã¼ÀÌ´Ù.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0) &&
			((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime)) {

			// Áö¼Ó½Ã°£ÀÌ °æ°úÇÑ µ¿Àû °´Ã¼¸¦ Ã£¾Ò´Ù.
			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime);
			// µî·Ï½Ã°£ÀÌ ÀÏÄ¡ÇÑ´Ù¸é °´Ã¼°¡ »ç¶óÁø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»Áà¾ß ÇÑ´Ù.

			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, 0, (short)0);
				// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// ¹°°í±â ¿ÀºêÁ§Æ®°¡ »ç¶óÁ³À¸¹Ç·Î Ã³¸®ÇÑ´Ù.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // ½Ã°£ÀÌ Áö³ª¼­ ¹°°í±â°¡ »ç¶óÁø´Ù.
				break;
			}

			// ¸®½ºÆ®¸¦ »èÁ¦ÇÑ´Ù.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = 0;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
	short sSkillIndex;
	int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;

		switch (sSkillIndex) {
		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15: // ����óġ
		case 19: // Pretend-Corpse
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}

		// ���� ����� �����ִ� ��ų�� �ö��� ���� �� ���⸦ ��� ���̶�� ���� ���߷��� 1�� ���Ѵ�. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// ī��Ʈ�� 0�̸� ��ų�� ���������� �ö��ٴ� �ǹ�. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
				// ��չ��Ⱑ �����Ǿ� �־���. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Ȱ���� ��뿡 ���� ��ų�� ����̾���. ���߷��� 1 �ø���. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
				// ���Ⱑ �����Ǿ� �־���. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// ���̳� Mace���� ��뿡 ���� ��ų�� ����̾���. ���߷��� 1 �ø���. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill�� ������ 600�� ������ �ٸ� ��ų�� �ϳ��� 1 ������. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill�� �ö��ٴ� ���� Ŭ���̾�Ʈ���� �˷��ش�.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}

void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
	int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	// ±â¼ú ¼öÁØÀÌ 0ÀÌ¶ó¸é ½ºÅ³Àº ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù. 
	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// ¸¶¹ý ÀúÇ×Àº ÃÖ´ë Level*2¸¸Å­ ¿À¸¥´Ù.
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 18: // Crafting
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:
		case 12:
		case 14:
		case 15:
		case 19:
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // µ¶¼º ÀúÇ× 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}

		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 700À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);

			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}






void CGame::RequestFullObjectData(int iClientH, char* pData)
{
	uint16_t wObjectID;
	int sTemp, sTemp2;
	int iRet;
	uint32_t dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wObjectID = header->msg_type;
	dwTime = GameClock::GetTimeMS();

	if ((wObjectID != m_pClientList[iClientH]->m_dwLastFullObjectId) ||
		(dwTime - m_pClientList[iClientH]->m_dwLastFullObjectTime) > 1000) {
		m_pClientList[iClientH]->m_dwLastFullObjectId = wObjectID;
		m_pClientList[iClientH]->m_dwLastFullObjectTime = dwTime;
	}

	if (wObjectID < 10000) {
		if ((wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS)) return;
		if (m_pClientList[wObjectID] == 0) return;

		hb::net::PacketEventMotionPlayer pkt{};
		pkt.header.msg_id = MSGID_EVENT_MOTION;
		pkt.header.msg_type = DEF_OBJECTSTOP;
		pkt.object_id = wObjectID;
		pkt.x = m_pClientList[wObjectID]->m_sX;
		pkt.y = m_pClientList[wObjectID]->m_sY;
		pkt.type = m_pClientList[wObjectID]->m_sType;
		pkt.dir = static_cast<uint8_t>(m_pClientList[wObjectID]->m_cDir);
		memcpy(pkt.name, m_pClientList[wObjectID]->m_cCharName, sizeof(pkt.name));
		pkt.appr1 = m_pClientList[wObjectID]->m_sAppr1;
		pkt.appr2 = m_pClientList[wObjectID]->m_sAppr2;
		pkt.appr3 = m_pClientList[wObjectID]->m_sAppr3;
		pkt.appr4 = m_pClientList[wObjectID]->m_sAppr4;
		pkt.appr_color = m_pClientList[wObjectID]->m_iApprColor;

		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp = (sTemp | (sTemp2 << 28));
		pkt.status = sTemp;
		pkt.loc = m_pClientList[wObjectID]->m_bIsKilled ? 1 : 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	else {
		if (((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS)) return;
		if (m_pNpcList[wObjectID - 10000] == 0) return;

		const uint16_t objectId = wObjectID;
		wObjectID -= 10000;

		hb::net::PacketEventMotionNpc pkt{};
		pkt.header.msg_id = MSGID_EVENT_MOTION;
		pkt.header.msg_type = DEF_OBJECTSTOP;
		pkt.object_id = objectId;
		pkt.x = m_pNpcList[wObjectID]->m_sX;
		pkt.y = m_pNpcList[wObjectID]->m_sY;
		pkt.type = m_pNpcList[wObjectID]->m_sType;
		pkt.dir = static_cast<uint8_t>(m_pNpcList[wObjectID]->m_cDir);
		memcpy(pkt.name, m_pNpcList[wObjectID]->m_cName, sizeof(pkt.name));
		pkt.appr2 = m_pNpcList[wObjectID]->m_sAppr2;

		sTemp = m_pNpcList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = m_pEntityManager->iGetNpcRelationship(wObjectID, iClientH);
		sTemp = (sTemp | (sTemp2 << 28));
		pkt.status = sTemp;
		pkt.loc = m_pNpcList[wObjectID]->m_bIsKilled ? 1 : 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}


int CGame::_iGetArrowItemIndex(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == 0) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			// Arrow ¾ÆÀÌÅÛÀÌ 1°³ ÀÌ»ó ÀÖÀ¸¸é ÀÎµ¦½º °ªÀ» ¹ÝÈ¯ÇÑ´Ù.
			if ((m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
				(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0))
				return i;
		}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, bool bIsUseItemResult)
{
	// ¼Ò¸ð¼º ¾ÆÀÌÅÛÀÇ Ä«¿îÆ®°¡ 0ÀÌ¸é »èÁ¦ÇÑ´Ù. È¤Àº Áß°í ¾ÆÀÌÅÛÀ» ÆÈ¾Æ¹ö¸° °Ï¿ì  

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;

	// v1.411 ·Î±×¸¦ ³²±ä´Ù. 
	_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù. ÀÌ·± °æ¿ì´Â °ÅÀÇ ¾øÀ» µí 
	ReleaseItemHandler(iClientH, sItemIndex, true);

	// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, 0, 0);

	// ¾ÆÀÌÅÛÀ» ¸Þ¸ð¸®¿¡¼­ »èÁ¦ 
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

	// !!! BUG POINT
	// ¾ÆÀÌÅÛÀÇ ÀÎµ¦½º°¡ ¹Ù²ï »óÈ²ÀÌ´Ù. ArrowIndex¿Í °°Àº °ÍÀº ´Ù½Ã ÇÒ´çÇØ¾ß ÇÑ´Ù. 
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}





void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
	int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
	uint32_t dwTime;
	short sTemp, sTmpType, sTmpAppr1;
	char cSlateType[20];

	dwTime = GameClock::GetTimeMS();
	std::memset(cSlateType, 0, sizeof(cSlateType));

	//testcode
	//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)) {
	}
	else return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT)) {

		// ¾ÆÀÌÅÛÀÇ È¿°ú¿¡ ¸Â´Â Ã³¸®¸¦ ÇÑ´Ù. 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 �ص� �þ�. 

			// �õ� ������ ��� �ص� �Ǿ��ٴ� �޼����� �����ش�. 
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 1) {
				//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

				// ȿ���� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1 * 1000),
					iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);


				//				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, 0, 0, 0);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case DEF_ITEMEFFECTTYPE_LOTTERY:
			// º¹±Ç ¾ÆÀÌÅÛ EV1(È®·ü: ÃÖÀú 100) EV2(»óÇ° Á¾·ù) EV3(»óÇ° ¼ö·®)
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// ´çÃ·!

			}
			else {
				// ²Î!

			}
			break;

		case DEF_ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
				// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
					// Slates dont work on Heldenian Map
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
					case 2: // Bezerk slate
						m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = true;
						SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
							iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, 0, 0);
						strcpy(cSlateType, "Berserk");
						break;

					case 1: // Invincible slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Invincible");
						}
					case 3: // Mana slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Mana");
						}
					case 4: // Exp slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Exp");
						}
						SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, true);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2,
							dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
						case 1:
							iEffectResult = 4;
							break;
						case 3:
							iEffectResult = 5;
							break;
						case 4:
							iEffectResult = 6;
							break;
						}
					}
					if (strlen(cSlateType) > 0)
						_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				}
			}
			break;
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = iGetMaxMP(iClientH);

			if (m_pClientList[iClientH]->m_iMP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iMP > iMax)
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;
		case DEF_ITEMEFFECTTYPE_CRITKOMM:
			//CritInc(iClientH);
			break;
		case DEF_ITEMEFFECTTYPE_SP:
			iMax = iGetMaxSP(iClientH);

			if (m_pClientList[iClientH]->m_iSP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iSP > iMax)
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned) {
				// Áßµ¶µÈ »óÅÂ¿´´Ù¸é Áßµ¶À» Ç¬´Ù.
				m_pClientList[iClientH]->m_bIsPoisoned = false;
				// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // removes poison aura when using a revitalizing potion
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;

			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			// ¹è°íÇÄÀ» ÇØ°áÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			// ±â¼úÀ» ¹è¿î´Ù.	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1Àº ¹è¿ï Skill ¹øÈ£. iV2´Â ±â¼ú ¼öÁØ, iSEV1Àº »ç¿ëÀÚ Á¤ÀÇ ±â¼ú ¼öÁØ(¿ì¼±¼øÀ§) 
			if (iSEV1 == 0) {
				// »ç¿ëÀÚ Á¤ÀÇ ±â¼ú¼öÁØÀÌ 0ÀÌ¶ó¸é Ç¥ÁØ ±â¼ú¼öÁØ¿¡ µû¶ó ±â¼úÀ» ¹è¿ì°Ô µÈ´Ù. 
				TrainSkillResponse(true, iClientH, iV1, iV2);
			}
			else {
				TrainSkillResponse(true, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1Àº ¹è¿ï ¸¶¹ý ¹øÈ£.
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != 0)
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, false);
			break;

			/*case DEF_ITEMEFFECTTYPE_LOTTERY:
				iLottery = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->
				break;*/

				// New 15/05/2004 Changed
		case DEF_ITEMEFFECTTYPE_MAGIC:
			// Åõ¸í ¸ðµå¿´´Ù¸é ¸¶¹ý È¿°ú ¾ÆÀÌÅÛ »ç¿ë½Ã¿¡ ÇØÁ¦µÈ´Ù.
			if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
				}
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall ¸¶¹ý È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				// testcode
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				// Åõ¸í ¸¶¹ýÈ¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, true);
				break;

			case 3:
				// Åõ¸í ¸¶¹ý Ã£±â. »çÅõÀå ³»ºÎ¸é ¼Ò¿ë¾ø´Ù. 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, true);
				break;

			case 4:
				// fixed location teleportation: ÀÔÀå±Ç µîµî
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					// ºí¸®µù ¾ÆÀÏ·Î °£´Ù 
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, true);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				case 2: //lotery
					ItemDepleteHandler(iClientH, sItemIndex, true);
					LoteryHandler(iClientH);
					break;

				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					// °áÅõÀåÀ¸·Î °£´Ù. 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3 º¯°æ ÀÔÀå±Ç Ã¼Å© ´Þ/³¯Â¥/½Ã°£À¸·Î Ã¼Å©ÇÑ´Ù. 
					// ÀÔÀå °¡´ÉÇÑ ½Ã°£º¸´Ù ÀÛ°Å³ª °°À¸¸é ÀÔÀå±ÇÀÌ »ç¶óÁø´Ù.
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour)) {
						// ³¯Â¥°¡ Á¤È®ÇÏÁö ¾Ê´Ù. ¾Æ¹«·± È¿°ú°¡ ¾ø°í ÀÔÀå±ÇÀº »ç¶óÁø´Ù.
					}
					else {
						char cDestMapName[11];
						std::memset(cDestMapName, 0, sizeof(cDestMapName));
						std::snprintf(cDestMapName, sizeof(cDestMapName), "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, true);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				// ¼ÒÈ¯È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20 * 30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20 * 30; // ÃÖ´ë 30ºÐ°£ 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// ¸Ó¸® »öÀ» ¹Ù²Û´Ù. 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				// ¸Ó¸® ½ºÅ¸ÀÏÀ» ¹Ù²Û´Ù.
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				// ÇÇºÎ»öÀ» ¹Ù²Û´Ù.
				// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;

				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4;

				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType = sTemp;
				break;

			case 4:
				// ¼ºÀüÈ¯ - ¸¸¾à ¿ÊÀ» ÀÔ°í ÀÖ´Ù¸é ½ÇÆÐÇÑ´Ù. 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTemp°¡ 0ÀÌ ¾Æ´Ï¶ó¸é °Ñ¿Ê, ¼Ó¿Ê, ¹ÙÁöÁß ÇÑ°¡Áö¸¦ ÀÔ°í ÀÖ´Â °ÍÀÌ´Ù. ¼ºÀüÈ¯À» ÇÒ ¼ö ¾ø´Ù. 
					if (m_pClientList[iClientH]->m_cSex == 1)
						m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// ³²ÀÚÀÌ´Ù. 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// ¿©ÀÚÀÌ´Ù.
						sTmpType = 4;
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						// ¹éÀÎÀÌ¸é ±×´ë·Î.
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;
					//
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
		}
		// *** Request Teleport Handler°¡ ÀÛµ¿µÇ¸é ÀÌ¹Ì µ¥ÀÌÅÍ ÀúÀåÀÌ ¿äÃ»µÈ »óÅÂÀÌ¹Ç·Î ÀÌÈÄ¿¡ ¾ÆÀÌÅÛÀ» ¾ø¾ÖºÁ¾ß ¼Ò¿ëÀÌ ¾ø´Ù. 
		// ¾ÆÀÌÅÛÀ» ¸ÕÀú ¾ø¾Ø´Ù.
		ItemDepleteHandler(iClientH, sItemIndex, true);

		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			break;
		case 2:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			break;
		case 3:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			break;
		case 4: // Invincible
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, 0, 0, 0, 0);
			break;
		case 5: // Mana
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_MANA, 0, 0, 0, 0);
			break;
		case 6: // EXP
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_EXP, 0, 0, 0, 0);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// »ç¿ëÇÏ¸é¼­ ¸ñÇ¥ÁöÁ¡À» ÁöÁ¤ÇÏ´Â ¾ÆÀÌÅÛ.
		// dX, dYÀÇ ÁÂÇ¥°¡ À¯È¿ ¹üÀ§ ³»¿¡ ÀÖ´ÂÁö È®ÀÎÇØ¾ß ÇÑ´Ù.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID))
			ItemDepleteHandler(iClientH, sItemIndex, true);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// È­»ìÀ» ÇÒ´çÇÑ´Ù. 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// ¿µ±¸È÷ ¾µ ¼ö ÀÖ´Â ¾ÆÀÌÅÛ. Áï ¾²°í³ªµµ ¾ø¾îÁöÁö ¾Ê´Â ¾ÆÀÌÅÛ. (ex: Áöµµ) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				// ÇöÀç ÀÚ½ÅÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù. 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, 0, 0);
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, 0, 0);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// ±â¼ú°ú °ü·ÃµÈ ¾ÆÀÌÅÛÀ» »ç¿ëÇÑ´Ù. ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ³·Ãß°í µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·ÏÇÑ´Ù. 

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			(m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill])) {
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù Çß°Å³ª ¾ø°Å³ª °ü·Ã ½ºÅ³À» »ç¿ëÁßÀÌ¶ó¸é ¹«½Ã 
			return;
		}
		else {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0) {
				// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan, 0, 0);
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
					// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, 0, 0);
				}
				else {
					// ±â¼ú »ç¿ë ½Ã°£ ID°ªÀ» ±¸ÇÑ´Ù. v1.12
					int iSkillUsingTimeID = (int)GameClock::GetTimeMS();

					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill,
						dwTime + m_pSkillConfigList[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill]->m_sValue2 * 1000,
						iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY,
						m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill], iSkillUsingTimeID, 0);

					// ±â¼ú »ç¿ëÁß 
					m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = true;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = iSkillUsingTimeID; //v1.12
				}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
	char cAttackerSide, cDamageMoveDir;
	uint32_t dwTime, iExp;
	double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) &&
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated)) return;

	dwTime = GameClock::GetTimeMS();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738) {
					iDamage *= (int)1.2;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
						if (iRepDamage < 5) iRepDamage = 5;
						if (iRepDamage > 15) iRepDamage = 15;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 20);
							if (iRepDamage > 5) iRepDamage = 5;
							iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 + 0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone)
			iDamage += iDamage / 3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage / 3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage * 7) / 10;
			}
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage / 2;
			}
			else
				iDamage += iDamage / 3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation)) return;

		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {

			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;

			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2 / 100.0f) * dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
			(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1 / 100.0f) * dTmp2 + 1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}

				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);
					m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
			return;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = static_cast<char>(iDice(1, 8));
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX = dX;
			m_pNpcList[sTargetH]->m_sY = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = static_cast<char>(iDice(1, 8));
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX = dX;
			m_pNpcList[sTargetH]->m_sY = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType)) {
				// Use EntityManager for NPC deletion
				if (m_pEntityManager != NULL)
					m_pEntityManager->DeleteEntity(sTargetH);
			}
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
		case 67: // McGaffin
		case 68: // Perry
		case 69: // Devlin
			return;
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// Use EntityManager for NPC death handling
			if (m_pEntityManager != NULL)
				m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

			if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp / 2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp / 2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}


void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	uint32_t dwTime, wWeaponType;
	char cAttackerSide, cDamageMoveDir;
	double dTmp1, dTmp2, dTmp3;
	int iPartyID, iMoveDamage;
	short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	dwTime = GameClock::GetTimeMS();
	sTgtX = 0;
	sTgtY = 0;

	// �ش� Ÿ�Ͽ��� ������� ���δ�. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// �����ڰ� �÷��̾��� Mag�� ���� ���ʽ� ������� ����
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 + 0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 �������̸� ����� 1.33�� 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone)
			iDamage += iDamage / 3;

		// Crusade : ������ ����϶� ���� ���ݷ� 1.33�� 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1))
		{
			// v2.15 ������ ���� �������� �����Ѵ�. 1.7 �� 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage * 7) / 10;
			} // v2.15 ������ ���� �������� �����Ѵ�. 1.5 �� 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage / 2;
			}
			else iDamage += iDamage / 3;
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) {
			iDamage += 4;
		}

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iDamage += iDamage / 3;
		}

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage / 3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// ���� ����� �������� ������ ���� 
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		// �̹� �׾� �ִٸ� ó�� ����.
		if (m_pClientList[sTargetH]->m_bIsKilled) return;
		// ������ ���� ��ȣ�� �޾ƾ� �Ѵٸ� 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) return;
		// �����ڰ� ��ġ�� ���� ���� �Ұ��� ���̶�� 
		// v2.03 ���� �ٿ�Ǿ ��ħ 
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		// v1.41 �����ڰ� �߸��̸� ���� ������ �Ұ����ϴ�. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// v2.172 ������������ �������� ���ݴ����� �ʴ´�. �����ڿ� NPC�� ���� �߸��� ���� �ʵǰ� 
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;

		// 01-12-17 ���� ��Ƽ���̸� ���� �Ұ� 
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		// ���� �����ڰ� �÷��̾��̰� �����ڰ� ���� ���� ����� ������ �ǹ̰� ����. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// �ƹ� ȿ�� ����. ���� �Һ��� �پ����Ƿ� 
				}
				else {
					// ���� �������� ���� ������ ������ ���� ���ٸ� ���� ó���� �ؾ��Ѵ�.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// ������ ������ �ٸ� ����. ������ �����ϴ�. 
						}
						else return;
					}
					else return;
				}
			}

			// ���� ��ȣ Ȥ�� ���� �����̶�� ���� ���� ���� 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		// ��ų�� �����¸� ��� ��ȿȭ �Ѵ�.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 �Ӽ��� ����� ���� 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// ���� ����� ���� ȿ���� ���� �������̴�.

			// �������� ������ ���� ������� ���δ�. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // ���Ӷ��� ���� 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;

			case 337: // ��� ���� 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				// ���� ������ ���� �������� �μ�����. 
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				// ���� ������ ���� �������� ������ ���δ�. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		// v1.42 �߰��� ���� ���� ����� ����
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2 / 100.0f) * dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT�� ���� ����� ���� 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		// ���� ���� ��ȣ���̶�� ������� 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
			(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// ���ȿ���� ������ ����Ѵ�.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 Ư�� �ɷ� �� ��� ������� ���� ȿ���� Ȱ��ȭ �� ��� ������� ���� �ʴ´�.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// �÷��̾ ����ߴ�.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {
				// v2.04 Ÿ���� �޾Ҵµ� ���� ��ȯ Ư��ġ�� �־��ٸ� 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1 / 100.0f) * dTmp2 + 1.0f;

					// �ִ� ����ġ 
					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 Ÿ���� �޾Ҵµ� �ʻ� ������ Ư��ġ�� �־��ٸ� 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// Ȯ�� ��꿡 ���� �ʻ�Ⱑ �����ȴ�.
					if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 ������ Ŭ���̾�Ʈ ���� ī��Ʈ�� ��ġ���� �ʴ� ��찡 ���� �� �����Ƿ� ������ ������� ������.
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}

				// v1.44 �������̸� ����� 80�̻��϶� �и���.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone))
					iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					// ������� 50�̻��̸� ƨ���.
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}

					// v1.44 �з����� ������� �Է��Ѵ�.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					// ���� ������� �뺸�Ѵ�. <- HP�� �״�� �˸���.
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					// ƨ�� ������� �޽��� �Է� 	
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, 0, 0);
				}
				else {
				EDSD_SKIPDAMAGEMOVE:
					// ���� ������� �뺸�Ѵ�. <- HP�� �״�� �˸���.
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					// ����� �޾Ҵٸ� ��ݵ��� ���� 
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
				}

				// v1.4 ����ô�ϰ� �ִ� ���� Owner ��ġ�� �ű��. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
					// Hold-Person �Ǿ� �־��� ���¶�� Ǯ����. �������� �з������� �� �͵� Ǯ����.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
			return;
		}

		// ����� �������� �׷��� ���� ���׷�����, ������ �ǵ� ���׷����ʹ� �Ʊ��̳� �߸��� ���ݿ� ������� ���� �ʴ´�.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
		case 67: // McGaffin
		case 68: // Perry
		case 69: // Devlin
			iDamage = 0;
			break;
		}

		// ���Ͱ� ���� ����� �������� �ִٸ�(AbsDamage�� 0���� ũ��) ���� ���� ������� ���ҽ�Ų��.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// ���� ���� ��ȣ���̶�� ������� 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC�� ����ߴ�.
			m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			// ���ݴ������� ����ִ�. �ݰ��Ѵ�.

			// ���� ������ �ݰ����� �ʴ´�.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15 ���� ���� ���� �ݰ��Ѵ�.			
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}

			// ����� �޾Ҵٸ� ��ݵ��� ����
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

			if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// �����̰� ���� ������ �ݰ����� �ʴ´�.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit�� 1�̸� �ݰ��� ���� �ʴ´�. ���� �����ϼ��� ������.
				m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

				// ���⼭ ǥȿ ���۰������� ���� �޽��� �߼�.

				// Damage�� ���� ������� ���� ����ȿ��.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
					// Hold �Ǿ� �־��� ���¶�� Ǯ����. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				uint32_t iExp;

				// NPC�� ���� ������ ���������Ƿ� �����ڰ� �÷��̾��� ���� ����� ��ŭ�� ����ġ�� �����ڿ��� �ش�. 
				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					// ExpStock�� �ø���. �� ��ȯ���� ��� ����ġ�� �ø��� �ʴ´�.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						//v2.03 918 ����ġ ���� 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						// v2.17 2002-8-6 �������� ������ 100 �̻��̸� �䳢�� �����̸� ������ ����ġ�� �ö��� �ʴ´�.
						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						//v2.03 918 ����ġ ���� 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						// v2.17 2002-8-6 �������� ������ 100 �̻��̸� �䳢�� �����̸� ������ ����ġ�� �ö��� �ʴ´�.
						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}


						if (bExp)
							GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iHP, iMaxHP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	iHP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;
		iMaxHP = (3 * m_pClientList[sTargetH]->m_iVit) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr) / 2);
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0)
			iMaxHP = iMaxHP - (iMaxHP / m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);
		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice * 4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ³»¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		// New 19/05/2004
		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {

			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ¿Ã¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;

			if (m_pClientList[sTargetH]->m_iSP > iMaxSP)
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}

/*********************************************************************************************************************
**  int bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: bool																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
	double dTmp1, dTmp2, dTmp3;
	int    iTargetMagicResistRatio, iDestHitRatio, iResult;
	char   cTargetDir, cProtect;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) return false;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return true;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return true;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) > 50)
			iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;
	}

	if (cProtect == 5) return true;

	if ((iHitRatio < 1000) && (cProtect == 2)) return true;
	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	if (sTargetH < DEF_MAXCLIENTS)
	{
		if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != 0) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) {
			iHitRatio += 50;
		}
	}

	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3);

	if (iDestHitRatio < m_iMinimumHitRatio) iDestHitRatio = m_iMinimumHitRatio;
	if (iDestHitRatio > m_iMaximumHitRatio) iDestHitRatio = m_iMaximumHitRatio;
	if (iDestHitRatio >= 100) return false;

	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return false;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return true;
}

bool CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
	// �õ��� ���ΰ��� Ȯ�� ���.
	int    iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;
		// v1.4 ��ڿ� ���� �õ������� ���ǹ� 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return true;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater * 2;
		// v2.172 �ص� ������ �԰� 30�ʰ��� ���� �ʴ´�.
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == 0) {
		}
		else if ((GameClock::GetTimeMS() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000 * 30) return true;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic / 3); // ���⿡ ���� ��� ��ġ �Է�. NPC�� ��� ���� ������ 70% ���� 
		break;
	}

	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;

	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return true;

	return false;
}

bool CGame::bSetItemToBankItem(int iClientH, class CItem* pItem)
{
	int i, iRet;

	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;

			{
				hb::net::PacketNotifyItemToBank pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_ITEMTOBANK;
				pkt.bank_index = static_cast<uint8_t>(i);
				pkt.is_new = 1;
				memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
				pkt.count = pItem->m_dwCount;
				pkt.item_type = pItem->m_cItemType;
				pkt.equip_pos = pItem->m_cEquipPos;
				pkt.is_equipped = 0;
				pkt.level_limit = pItem->m_sLevelLimit;
				pkt.gender_limit = pItem->m_cGenderLimit;
				pkt.cur_lifespan = pItem->m_wCurLifeSpan;
				pkt.weight = pItem->m_wWeight;
				pkt.sprite = pItem->m_sSprite;
				pkt.sprite_frame = pItem->m_sSpriteFrame;
				pkt.item_color = pItem->m_cItemColor;
				pkt.item_effect_value2 = pItem->m_sItemEffectValue2;
				pkt.attribute = pItem->m_dwAttribute;
				pkt.spec_effect_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
				pkt.item_id = pItem->m_sIDnum;
				pkt.max_lifespan = pItem->m_wMaxLifeSpan;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
				// DeleteClient(iClientH, true, true);
				return true; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
			}

			return true;
		}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return false;
}

bool CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
	int i;
	int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
	short sDownSkillIndex;

	if (m_pClientList[iClientH] == 0) return false;

	iTotalPoints = 0;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// ½ºÅ³ÀÇ Æ÷ÀÎÆ®°¡ ÃÊ°úµÇ¾ú´Ù. ÃÊ°úµÈ Æ÷ÀÎÆ® ¸¸Å­ ·çÇÁ¸¦ µ¹¸ç SSNÀÌ °¡Àå ³·Àº ½ºÅ³À» ³»¸°´Ù.	
		while (iRemainPoint > 0) {

			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) {
				// ÁöÁ¤µÈ ½ºÅ³ÀÌ ÀÖ´Ù. 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: // ¸¶¹ý ÀúÇ×

				default:
					// ½ºÅ³ÀÌ 20 ÀÌÇÏÀÇ »óÅÂ¶ó¸é ±×´ë·Î 0À¸·Î ¶³¾î ¶ß¸°´Ù.
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
							if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) &&
								(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
								// V1.22 ´Ù¿î ½ÃÅ³ ½ºÅ³Àº ÃÖ¼Ò 20 ÀÌÇÏ·Î´Â ¶³¾îÁú ¼ö ¾ø´Ù. 
								iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
								sDownSkillIndex = i;
							}
					}
					break;
				}
			}
			// ÇöÀç 1º¸´Ù Å« ½ºÅ³ Áß¿¡¼­ °¡Àå ÀÛÀº SSNÀ» °®´Â ½ºÅ³Àº sDownSkillIndex 

			if (sDownSkillIndex != -1) {

				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
					iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] + 1] - 1;
				iRemainPoint -= iDownPoint; // v1.4

				// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
					// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], 0, 0);
			}
			else {
				return false;
			}
		}
		return true;
	}

	return false;
}


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = true;
		break;
	case VK_F4:
		m_bF4pressed = true;
		break;
	case VK_F5:
		m_bF5pressed = true;
		break;
	case VK_F12:
		m_bF12pressed = true;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
	int i;

	switch (wParam) {
	case VK_F2:
		break;

	case VK_F1:
		m_bF1pressed = false;
		break;
	case VK_F4:
		m_bF4pressed = false;
		break;
	case VK_F5:
		m_bF5pressed = false;
		break;
	case VK_F12:
		m_bF12pressed = false;
		break;

	case VK_F6:
		if (m_bF1pressed) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, 0, 0, 0);
				}
		}
		break;

	case VK_F7:
		if (m_bF1pressed) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, 0, 0, 0);
				}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(0);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

#define VK_1 0x31
	case VK_1:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(1);
		}
		break;

#define VK_2 0x32
	case VK_2:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(2);
		}
		break;

#define VK_3 0x33
	case VK_3:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(3);
		}
		break;

#define VK_4 0x34
	case VK_4:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(1);
		}
		break;

		/*#define VK_A 0x41 // a key
		case VK_A:
			if ((m_bF1pressed )) {
				GlobalStartApocalypseMode();
			}
			break;*/

			/*#define VK_H 0x49 // H key
			case VK_H:
				if ((m_bF1pressed )) {
					GlobalStartHeldenianMode();
				}
				break;*/

				//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
	int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != 0) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW)) {

			if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
				iTotal++;
		}

	return iTotal;
}

/*********************************************************************************************************************
**  bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, uint32_t dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: bool																						**
**********************************************************************************************************************/
bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, uint32_t dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] == 0) {
			m_pDelayEventList[i] = new class CDelayEvent;
			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;
			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;
			m_pDelayEventList[i]->m_iTargetH = iTargetH;
			m_pDelayEventList[i]->m_cTargetType = cTargetType;
			m_pDelayEventList[i]->m_iV1 = iV1;
			m_pDelayEventList[i]->m_iV2 = iV2;
			m_pDelayEventList[i]->m_iV3 = iV3;
			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
			return true;
		}
	return false;
}

void CGame::DelayEventProcessor()
{
	int i, iSkillNum, iResult;
	uint32_t dwTime = GameClock::GetTimeMS();
	int iTemp;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if ((m_pDelayEventList[i] != 0) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

			// ÀÌº¥Æ®°¡ µ¿ÀÛÇÒ ½Ã°£ÀÌ µÆ´Ù. µ¿ÀÛÈÄ »èÁ¦µÈ´Ù.
			switch (m_pDelayEventList[i]->m_iDelayType) {

			case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
				if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x400000) != 0) {
					iTemp = 1;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x800000) != 0) {
					iTemp = 3;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x10000) != 0) {
					iTemp = 4;
				}

				SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, 0, 0, 0);
				SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, false);
				break;

			case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
				CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
				DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_METEORSTRIKE:
				MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
				// ¾ÆÀÌÅÛ »ç¿ë¿¡ µû¸¥ °á°ú °è»ê, Åëº¸ 
				switch (m_pDelayEventList[i]->m_cTargetType) {
				case DEF_OWNERTYPE_PLAYER:
					iSkillNum = m_pDelayEventList[i]->m_iEffectType;

					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == 0) break;
					// ±â¼ú »ç¿ëÀÌ ¹«È¿È­ µÇ¾ú´Ù¸é ¹«½Ã. 
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == false) break;
					// ±â¼ú »ç¿ë ½Ã°£ ID°¡ ´Þ¶óµµ ¹«½Ã v1.12
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;

					// ±â¼ú »ç¿ë »óÅÂ ÇØÁ¦ 
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = false;
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = 0;

					// ÀÌÁ¦ SkillÀÇ È¿°ú¿¡ µû¸¥ °è»êÀ» ÇÑ´Ù. 
					iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
						m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

					// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
					SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, 0, 0, 0);
					break;
				}
				break;

			case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
				break;

			case DEF_DELAYEVENTTYPE_MAGICRELEASE:
				// Removes the aura after time
				switch (m_pDelayEventList[i]->m_cTargetType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == 0) break;

					SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF,
						m_pDelayEventList[i]->m_iEffectType, m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType], 0, 0);

					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = 0;

					// Inbitition casting 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
						m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = false;

					// Invisibility ȿ�� ���� 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
						SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Berserk ȿ�� ����
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
						SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Haste
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_HASTE)
						SetHasteFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Confusion
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
						switch (m_pDelayEventList[i]->m_iV1) {
						case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
						case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
						}

					// Protection Magic
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
						switch (m_pDelayEventList[i]->m_iV1) {
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						}
					}


					// polymorph ȿ�� ���� 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
						m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
						SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}

					// Ice ȿ�� ���� 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
						SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[m_pDelayEventList[i]->m_iTargetH] == 0) break;

					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = 0;

					// Invisibility È¿°ú ÇØÁ¦ 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
						SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Berserk È¿°ú ÇØÁ¦
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
						SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// polymorph È¿°ú ÇØÁ¦ 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
						m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
						SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}

					// Ice È¿°ú ÇØÁ¦ 
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
						SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Illusion
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
						SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Protection Magic
					if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
						switch (m_pDelayEventList[i]->m_iV1) {
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						}
					}
					//	if (m_pDelayEventList[i]->m_iEffectType == /*notcoded*/)

					break;
				}
				break;
			}

			delete m_pDelayEventList[i];
			m_pDelayEventList[i] = 0;
		}
}
bool CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
	int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) {

			if (iEffectType == 0) {
				// Effect Á¾·ù¿¡ »ó°ü¾øÀÌ ¸ðµÎ »èÁ¦ 	
				if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType)) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = 0;
				}
			}
			else {
				// ÇØ´ç Effect¸¸ »èÁ¦.
				if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType)) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = 0;
				}
			}
		}

	return true;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
	int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = true; // v2.171

	// Send motion reject response.
	hb::net::PacketResponseMotionReject pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_MOTION;
	pkt.header.msg_type = DEF_OBJECTMOTION_REJECT;
	pkt.x = m_pClientList[iClientH]->m_sX;
	pkt.y = m_pClientList[iClientH]->m_sY;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Socket error while sending motion reject.
		DeleteClient(iClientH, true, true);
		return;
	}
	return;
}




void CGame::DynamicObjectEffectProcessor()
{
	int i, ix, iy, iIndex;
	short sOwnerH, sType;
	int iDamage;
	char  cOwnerType;
	uint32_t dwTime = GameClock::GetTimeMS(), dwRegisterTime;

	// 
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) {
			switch (m_pDynamicObjectList[i]->m_sType) {

			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
				// Æ÷ÀÌÁð Å¬¶ó¿ìµå
				for (ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++)
					for (iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							// Poison Damage¸¦ ÀÔ´Â´Ù.
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;
								// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
								//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

								// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
								if (m_pDynamicObjectList[i]->m_iV1 < 20)
									iDamage = iDice(1, 6);
								else iDamage = iDice(1, 8);

								// New 17/05/2004 Changed
								if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {
										// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
											// ¸¶ºñ »óÅÂ°¡ Ç®¸°´Ù.	
											// 1: Hold-Person 
											// 2: Paralize
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
										}
									}

									// v1.42 Poison È¿°ú
									if ((bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == false) &&
										(m_pClientList[sOwnerH]->m_bIsPoisoned == false)) {

										m_pClientList[sOwnerH]->m_bIsPoisoned = true;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										// Áßµ¶µÇ¾úÀ½À» ¾Ë¸°´Ù. 
										SetPoisonFlag(sOwnerH, cOwnerType, true);// poison aura appears from dynamic objects
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								// ¸ó½ºÅÍÀÇ Áßµ¶È¿°ú´Â ¾ÆÁ÷ ±¸Çö ¾ÈµÊ
								if (m_pNpcList[sOwnerH] == 0) break;

								// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
								if (m_pDynamicObjectList[i]->m_iV1 < 20)
									iDamage = iDice(1, 6);
								else iDamage = iDice(1, 8);

								// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0: // ÀÏ¹Ý
								case 3: // ´õ¹Ì·ù
								case 5: // °ÇÃà¹° 
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}
								//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
								//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC°¡ »ç¸ÁÇß´Ù.
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0); //v1.2 Áßµ¶±¸¸§¿¡ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
								}
								else {
									// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
										// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
									}

									// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
								}
								break;
							}
						}
					}
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
				for (ix = m_pDynamicObjectList[i]->m_sX - 2; ix <= m_pDynamicObjectList[i]->m_sX + 2; ix++)
					for (iy = m_pDynamicObjectList[i]->m_sY - 2; iy <= m_pDynamicObjectList[i]->m_sY + 2; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;

								iDamage = iDice(3, 3) + 5;

								if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {

										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {

											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
										}
									}

									if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == false) &&
										(m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0)) {

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) break;

								iDamage = iDice(3, 3) + 5;

								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0:
								case 3:
								case 5:
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC°¡ »ç¸ÁÇß´Ù.
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
								}
								else {
									// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
										// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
									}

									// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

									// v1.42 Ice È¿°ú
									if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == false) &&
										(m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0)) {

										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
							}
						}

						// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							iDamage = iDice(3, 2);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
								ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
								}
							}
						}

						// ±ÙÃ³¿¡ Fire Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
						if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != 0))
							m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
					}
				break;

			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				// Fire-Wall·ùÀÇ Å¸´Â ºÒ²É
				if (m_pDynamicObjectList[i]->m_iCount == 1) {
					// ±ÙÃ³¿¡ Å¸´Â ¹°°ÇÀÌ ÀÖ´Ù¸é ¹øÁø´Ù. 
					CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
				}
				m_pDynamicObjectList[i]->m_iCount++;
				if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10;


				for (ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++)
					for (iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							// Fire Damage¸¦ ÀÔ´Â´Ù.
							switch (cOwnerType) {

							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;
								// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
								//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

								iDamage = iDice(1, 6);
								// New 17/05/2004
								if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {
										// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
											// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. Fire Field·Î´Â ÆÐ·²¶óÀÌÁî µÈ°Íµµ Ç®¸°´Ù. 	
											// 1: Hold-Person 
											// 2: Paralize	
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
										}
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) break;

								iDamage = iDice(1, 6);

								// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0: // ÀÏ¹Ý
								case 3: // ´õ¹Ì·ù
								case 5: // °ÇÃà¹° 
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}
								//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
								//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC°¡ »ç¸ÁÇß´Ù.
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
								}
								else {
									// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
										// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
									}

									// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
								}
								break;
							}
						}

						// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							iDamage = iDice(1, 6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
								ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
								}
							}
						}

						// ±ÙÃ³¿¡ Ice Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
						if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != 0))
							m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
					}
				break;
			}
		}
}

char _tmp_cCorpseX[] = { 0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0 };
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0 };

void CGame::ClearSkillUsingStatus(int iClientH)
{
	int i;
	short tX, fX, tY, fY;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, 0) == false) {
			fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, 0) == false) {
				m_pClientList[iClientH]->m_cDir = static_cast<char>(iDice(1, 8));
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, 0) == false) {
					return;
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, 0, 0, 0);
		}
	}
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = false;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = 0;
	}

	if (m_pClientList[iClientH]->m_iAllocatedFish != 0) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0)
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHCANCELED, 0, 0, 0, 0);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
	class CItem* pItem;
	char  cItemName[21];
	short lX, lY;
	int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == 0) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == 0) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// ½ºÅ³ »ç¿ë ¿©ºÎ ÁÖ»çÀ§¸¦ ±¼¸°´Ù. 
	if (cOwnerSkill == 0) return 0;

	// ½ºÅ³ÀÌ 100ÀÌ¶ó°í ÇØµµ °¡²û ³¬½Ã¸¦ ½ÇÆÐÇÏ°Ô ÇÏ±â À§ÇØ¼­ 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // ½ÇÆÐ´Ù.

	// ¶¥¿¡¼­´Â ³¬½Ã°¡ ºÒ°¡´É 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0;

	// ¼º°øÇßÀ¸¹Ç·Î ½ºÅ³ Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// ±æµéÀÌ±â ±â¼ú: dX, dY ºÎ±ÙÀÇ ¸ó½ºÅÍ¸¦ ±æµéÀÎ´Ù.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;

	case DEF_SKILLEFFECTTYPE_GET:
		// ¾ÆÀÌÅÛÀ» ¾ò´Â ±â¼úÀÌ¾ú´Ù. 
		std::memset(cItemName, 0, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// ±¤¹° 
			std::snprintf(cItemName, sizeof(cItemName), "Meat");
			break;

		case 2:
			// ¹°°í±â 
			// ³¬½ÃÀÇ °æ¿ì À§Ä¡¿Í ½Ã°£´ëÀÇ ¿µÇâ¿¡ µû¶ó ¶Ç ¼º°ø·üÀÌ ´Þ¶óÁø´Ù. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0; 

			// ±ÙÃ³¿¡ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ¹°°í±â°¡ Á¸ÀçÇÑ´Ù¸é º»°Ý³¬½Ã ¸ðµå·Î µé¾î°£´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
				if (iFish == 0) std::snprintf(cItemName, sizeof(cItemName), "Fish");
			}
			else std::snprintf(cItemName, sizeof(cItemName), "Fish");
			break;
		}

		if (strlen(cItemName) != 0) {

			// ³¬½Ã¿¡ ¼º°øÇß´Ù¸é ¸Þ½ÃÁö¸¦ Àü¼Û.
			if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(0, iOwnerH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
				// v1.41 ¾à°£ÀÇ °æÇèÄ¡ »ó½Â 
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1, 2);
			}

			pItem = new class CItem;
			if (pItem == 0) return 0;
			if (_bInitItemAttr(pItem, cItemName)) {
				// ¾ÆÀÌÅÛÀ» ³õ´Â´Ù. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);

				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4
			}
		}
		break;
	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
	char  cOwnerType;
	short sAttackerWeapon, sOwnerH;
	int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1] == 0) return;
	// ÀÌ¹Ì ±â¼úÀ» »ç¿ëÁßÀÌ¶óµµ ¸®ÅÏ.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1]) return;

	// v1.3 !!1ÇØÅ· °É·¯³»±â¿ë! 
	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName,
																	   iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	// ÇÃ·¹ÀÌ¾îÀÇ ±â¼ú¼öÁØ¿¡ µû¶ó ¼º°ø¿©ºÎ¸¦ °è»êÇÑ´Ù. 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ½ÇÆÐ´Ù. 
		// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
		return;
	}

	// iV1ÀÌ ±â¼ú ¹øÈ£ 
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			// Á×ÀºÃ´ÇÏ±â ±â¼úÀÌ´Ù.	

			// v1.44 »çÅõÀåÀÌ¸é Á×ÀºÃ´ÇÏ±â ¸øÇÑ´Ù.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			//¸¸¾à ¹Ù´Ú¿¡ ½ÃÃ¼°¡ ÀÖ´Ù¸é Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ¼ö ¾ø´Ù. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != 0) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			// Á×ÀºÃ´ ÇÏ°íÀÚ ÇÏ´Â ÁÖº¯¿¡ ¹°Ã¼°¡ ÀÖ¾îµµ ÇÒ ¼ö ¾ø´Ù. 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY - 1);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 1);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY - 1);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY - 1);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY + 1);
				iResult += sOwnerH;
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY + 1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			// ½ºÅ³ Ä«¿îÆ® ¿Ã¸°´Ù. <-- ³»ºÎ¿¡¼­ Ä«¿îÆÃÀ» ÇØ¾ß ¾û¶×ÇÑ ½ºÅ³ÀÌ ¿À¸£´Â °æ¿ì°¡ ¾ø´Ù. 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Á×´Â µ¿ÀÛ Àü¼Û.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, 0);
			// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = true;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, const char* pItemName)
{
	char cItemCategory;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	bool   bNeutral;
	uint32_t  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
	CItem* m_pGold;

	// »ç¿ëÀÚÀÇ ¾ÆÀÌÅÛ ÆÈ±â ¿ä±¸.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < static_cast<uint32_t>(iNum)) return;

	iCalcTotalWeight(iClientH);

	m_pGold = new class CItem;
	_bInitItemAttr(m_pGold, hb::item::ItemId::Gold);

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;
	// v2.13 ¼ºÈÄ´Ï ¼öÁ¤ ¹°°ÇÀ» ¾îµð¼­³ª ÆÈ°Ô ¼öÁ¤ÇÏ¿©¼­ ÆÈ¶§´Â NPC ±¸ºÐÀÌ ÇÊ¿ä¾ø´Ù. 
	// ´Ü Ä«Å×°í¸®¸¦ ±âÁØÀ¸·Î ¾ÆÀÌÅÛ °¡°ÝÀ» °áÁ¤ÇÑ´Ù.
	switch (cSellToWhom) {
	case 15: 		// »óÁ¡ ¾ÆÁÜ¸¶ 
	case 24:        // ´ëÀå°£ ÁÖÀÎ 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22 ¼ºÈÄ´Ï ¼öÁ¤ ¾îµð¼­µç ÆÈ¼ö ÀÖ°Ô ¼öÁ¤ 
		// »óÁ¡¾ÆÀÌÅÛ 
		if ((cItemCategory >= 11) && (cItemCategory <= 50)) {

			// ÀûÇÕÇÏ´Ù. ¹«Á¶°Ç ¹Ý°ª 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) * iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;


			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {
				// v2.12 ÆÈ °æ¿ì ¹«°Ô°¡ ÃÊ°úµÇ¾î¼­ ÆÈ ¼ö ¾ø´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		// ´ëÀå°£ ¾ÆÀÌÅÛ
		else if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
			// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// °íÀå³­ ¾ÆÀÌÅÛÀº ÆÈ ¼ö ¾ø´Ù
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
				d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

				iPrice = (int)d3;
				iPrice = iPrice * iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  // °¡º­¿î 
					case 8: dwMul1 = 2; break;  // °­È­µÈ
					case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
					case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
					case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
					case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
					case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
					case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice * dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1 * (d2 / 100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}

				// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

					switch (dwSWEType) {
					case 1:
					case 12: dwMul2 = 2; break;

					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;

					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}

					d1 = (double)iPrice * dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1 * (d2 / 100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				// v2.03 925 Æ¯¼ö ¾ÆÀÌÅÛ °¡°Ý °¡ÁßÄ¡¸¦ 77%¼öÁØÀ¸·Î ´Ù¿î 
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

				//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
				if (bNeutral) iPrice = iPrice / 2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {
					// v2.12 ÆÈ °æ¿ì ¹«°Ô°¡ ÃÊ°úµÇ¾î¼­ ÆÈ ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;


	default:
		break;
	}
	if (m_pGold != 0) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, const char* pString)
{
	class CItem* pItemGold;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	char cItemCategory;
	uint32_t dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
	int    iEraseReq, iRet;
	bool   bNeutral;


	// ¾ÆÀÌÅÛÀ» ÆÈ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < static_cast<uint32_t>(iNum)) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;

	iPrice = 0;
	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
	if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
		// ¹«±â·ù´Ù
		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

		if (sRemainLife <= 0) {
			// ¸Á°¡Áø ¾ÆÀÌÅÛÀº ÆÈÁö ¸øÇÑ´Ù.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

			iPrice = (short)d3;
			iPrice = iPrice * iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // °¡º­¿î 
				case 8: dwMul1 = 2; break;  // °­È­µÈ
				case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
				case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
				case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
				case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
				case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
				case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice * dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1 * (d2 / 100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				switch (dwSWEType) {
				case 1:
				case 12: dwMul2 = 2; break;

				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;

				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}

				d1 = (double)iPrice * dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1 * (d2 / 100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

			// ÆÈ ¾ÆÀÌÅÛÀ» »èÁ¦ 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false);
		}
	}
	else
		if ((cItemCategory >= 11) && (cItemCategory <= 50)) {
			// ½ÄÇ°, ÀâÈ­µîÀÇ ¹Ý°ª¹°°Çµé 
			iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
			iPrice = iPrice * iNum;

			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

			// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ÀûÀýÇÑ Ã³¸®¸¦ ÇÑ´Ù.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false);
		}

	// Gold¸¦ Áõ°¡½ÃÅ²´Ù. ¸¸¾à ÆÇ °¡°ÝÀÌ 0 È¤Àº ¸¶ÀÌ³Ê½ºÀÌ¸é ±ÝÀ» ÁÖÁö ¾Ê´Â´Ù.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	_bInitItemAttr(pItemGold, hb::item::ItemId::Gold);
	pItemGold->m_dwCount = iPrice;

	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq)) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItemGold, 0);

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			break;
		}
	}
	else {
		// Áß·® ÃÊ°úµîÀÇ ¹®Á¦·Î Ãß°¡ ½ÇÆÐ.
		// ¹ÞÁö ¸øÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³¾îÁø´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItemGold);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItemGold->m_sIDnum, 0, pItemGold->m_cItemColor, pItemGold->m_dwAttribute); // v1.4 color

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, const char* pString)
{
	char cItemCategory;
	short sRemainLife, sPrice;
	double d1, d2, d3;

	// ¾ÆÀÌÅÛÀ» °íÄ¡°Ú´Ù´Â ¿ä±¸.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
	if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
		// ¹«±â·ù´Ù

		// ¸¸¾à ¹«±â¸¦ ´ëÀå°£ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}

		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if (((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ³¬½Ã´ë, °î±ªÀÌ µî°ú °°Àº ºñ¹«±â·ù ¼ö¸®°¡´É ¾ÆÀÌÅÛ. ¿Ê, ºÎÃ÷·ù

		// ¸¸¾à »óÁ¡ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}

		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// °íÄ¥¼ö ¾ø´Â ¾ÆÀÌÅÛÀÌ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, const char* pString)
{
	short    sRemainLife, sPrice;
	char cItemCategory;
	double   d1, d2, d3;
	uint32_t dwGoldCount;
	int      iRet, iGoldWeight;

	// ¾ÆÀÌÅÛÀ» ¼ö¸®ÇÏ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
	if (((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) ||
		((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ¹«±â·ù È¤Àº ³¬½Ã´ë, °î±ªÀÌ¿Í °°Àº ¾ÆÀÌÅÛ, ¿Ê, ½Å¹ß 

		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		// sPrice¸¸Å­ÀÇ µ·ÀÌ µÇ¸é °íÄ¥ ¼ö ÀÖÀ¸³ª ºÎÁ·ÇÏ¸é °íÄ¥ ¼ö ¾ø´Ù. 
		dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

		if (dwGoldCount < (uint32_t)sPrice) {
			// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ¾ÆÀÌÅÛ ¼ö¸® ºñ¿ë¿¡ ºñÇØ Àû´Ù. °íÄ¥ ¼ö ¾øÀ½.
			{
				hb::net::PacketNotifyNotEnoughGold pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
				pkt.item_index = static_cast<int8_t>(cItemID);
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				return;
			}
			return;
		}
		else {
			//µ·ÀÌ ÃæºÐÇÏ´Ù. °íÄ¥ ¼ö ÀÖ´Ù. 

			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ´Ã¸®°í Åëº¸ÇÑ´Ù. !BUG POINT À§Ä¡°¡ Áß¿äÇÏ´Ù. ¸ÕÀú ¼ö¸íÀ» ´Ã¸®°í µ·ÀÇ Ä«¿îÆ®¸¦ ³·Ãá´Ù.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, 0, 0);

			iGoldWeight = SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - sPrice);

			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);

			//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// °íÄ¥ ÇÊ¿ä°¡ ¾ø´Â ¾ÆÀÌÅÛ 
		// ÇØÅ·ÀÌ³ª ¹ö±×¿¡ ÀÇÇÑ °ÍÀÏµí 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
	int i, iWeight;
	short sItemIndex;

	if (m_pClientList[iClientH] == 0) return 0;

	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Âø¿ëÇÏÁö ¾Ê¾Æµµ È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ È¿°ú. ¼ÒÁöÇÏ°í ÀÖ¾îµµ È¿°ú°¡ ÀÖ±â ¶§¹®¿¡ ¿©±â¼­ °Ë»ç.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
					// ¼ö¸íÀÌ ÀÖ¾î¾ß È¿°ú°¡ ÀÖ´Ù.
					m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
				}
				break;
			}
		}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
		}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char* pMsg, uint32_t dwSize)
{
	char   seps[] = "= \t\r\n";
	char* token, * cp, cName[11], cBuff[256], cPlayerLocation[120];
	int i;
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (dwSize <= 0) return;

	std::memset(cPlayerLocation, 0, sizeof(cPlayerLocation));
	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token == 0) {
		return;
	}

	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));

	// cNameÀÇ ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î°¡ Á¢¼ÓÁßÀÎÁö Ã£´Â´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
			// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) { // GM's get more info
				cp = (char*)cPlayerLocation;

				memcpy(cp, m_pClientList[i]->m_cMapName, 10);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[i]->m_sX;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[i]->m_sY;
				cp += 2;
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERONGAME, 0, 0, 0, m_pClientList[i]->m_cCharName, 0, 0, 0, 0, 0, 0, cPlayerLocation);

			return;
		}

	/*std::memset(cBuff, 0, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (uint16_t *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (uint16_t *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 25);*/

}



void CGame::ToggleWhisperPlayer(int iClientH, char* pMsg, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[11], cBuff[256];
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (dwMsgSize <= 0) return;

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token == 0) {
		// ±Ó¼Ó¸» »ó´ë°¡ ÁöÁ¤µÇÁö ¾Ê¾Ò´Ù. ±Ó¼Ó¸» ¸ðµå¸¦ ÇØÁ¦ÇÑ´Ù. 
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		std::memset(m_pClientList[iClientH]->m_cWhisperPlayerName, 0, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = false;
		// ±Ó¼Ó¸» »óÅÂ°¡ ÇØÁ¦µÇ¾úÀ½À» Åëº¸. 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, cName);
	}
	else {
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù. 
				// ÀÚ±â ÀÚ½ÅÀÌ¶ó¸é ÇÒ´çÇÏÁö ¾Ê´Â´Ù.
				if (i == iClientH) {
					return;
				}
				//ÀÎµ¦½º¸¦ ÇÒ´ç 
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				std::memset(m_pClientList[iClientH]->m_cWhisperPlayerName, 0, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
				break;
			}

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
			/*std::memset(cBuff, 0, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;

			wp = (uint16_t *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;

			wp = (uint16_t *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 25);*/

			std::memset(m_pClientList[iClientH]->m_cWhisperPlayerName, 0, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = true;
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_WHISPERMODEON, 0, 0, 0, m_pClientList[iClientH]->m_cWhisperPlayerName);
		}
	}

}


void CGame::SetPlayerProfile(int iClientH, char* pMsg, uint32_t dwMsgSize)
{
	char cTemp[256];
	int i;


	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize - 7) <= 0) return;

	std::memset(cTemp, 0, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);

	// °ø¹é¶õÀ» ¾ð´õ¹Ù·Î ¹Ù²Û´Ù. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// ¿¡·¯ ¹æÁö ÄÚµå 
	cTemp[255] = 0;

	std::memset(m_pClientList[iClientH]->m_cProfile, 0, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char* pMsg, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[11], cBuff[256], cBuff2[500];
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		// tokenÀÌ °ð ÇÁ·ÎÇÊÀ» ¾ò°íÀÚ ÇÏ´Â »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				std::memset(cBuff2, 0, sizeof(cBuff2));
				std::snprintf(cBuff2, sizeof(cBuff2), "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERPROFILE, 0, 0, 0, cBuff2);

				return;
			}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}

	return;
}

void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	bool bFlag;
	char cTxt[120];
	return;
	if (m_pClientList[iClientH] == 0) return;

	// ¸ÕÀú °ªÀ» ¹é¾÷ÇÑ´Ù. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// º¹±¸ÇÒ ÇÊ¿ä°¡ ¾ø´Ù¸é ±ÍÈ¯.
	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		// ÀÌÁ¦ iToBeRestoredPoint ¸¸Å­ÀÇ Æ÷ÀÎÆ®¸¦ º¹±¸ÇÑ´Ù. 
		// ¸ÕÀú 10 ÀÌÇÏÀÇ Æ÷ÀÎÆ®°¡ ÀÖ´Ù¸é ¿ì¼±ÀûÀ¸·Î Ã¤¿î´Ù. 
		while (1) {
			bFlag = false;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = true;
			}

			if (bFlag == false)          break;
			if (iToBeRestoredPoint <= 0) break;
		}

		// ¸Ç¼Õ °ÝÅõ ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, StrÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if (m_pClientList[iClientH]->m_iStr < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax / 2))) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iStr == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// ¹«±â »ç¿ë ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, Dex°¡ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB)
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if (m_pClientList[iClientH]->m_iDex < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax / 2))) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iDex == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// Á×ÀºÃ´ÇÏ±â ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, IntÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if (m_pClientList[iClientH]->m_iInt < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax / 2))) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iInt == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// ¸¶¹ý ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, MagÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB)
			iMax = iA;
		else iMax = iB;

		if (m_pClientList[iClientH]->m_iMag < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax / 2))) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iMag == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// ³²Àº Æ÷ÀÎÆ®¸¦ ·£´ýÇÏ°Ô ¿Ã¸°´Ù.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1, 6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint) {
			std::snprintf(cTxt, sizeof(cTxt), "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// ¿¡·¯´Ù. ÀÌÀü °ªÀ¸·Î º¹±¸.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			std::snprintf(cTxt, sizeof(cTxt), "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// ÇØÅ·ÀÌ³ª ¿¡·¯¿¡ ÀÇÇØ¼­ Æ¯¼ºÄ¡°¡ ¿À¹öµÈ °æ¿ìÀÌ´Ù. ¿À¹öµÈ Æ÷ÀÎÆ®¸¸Å­ »«´Ù. iToBeRestoredPoint°¡ ¸¶ÀÌ³Ê½º»óÅÂ! 

		// ¸ÕÀú Æ¯¼ºÄ¡ Á¦ÇÑÄ¡¸¦ ¿À¹öÇÑ °ªÀ» »«´Ù.
		while (1) {
			bFlag = false;
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == false)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			// ³²Àº Æ÷ÀÎÆ® ¸¸Å­ ·£´ýÇÏ°Ô ¼±ÅÃµÈ Æ¯¼ºÄ¡ÀÇ °ªÀ» ³»¸°´Ù.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1, 6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// °è»êÀ» Çß´õ´Ï ´Ù½Ã °ªÀÌ ¿À¹öµÇ¾ú´Ù. ÀÌ·²¼ö°¡ ÀÖÀ»±î?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1, 6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint) {
			std::snprintf(cTxt, sizeof(cTxt), "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

		}
		else {
			std::snprintf(cTxt, sizeof(cTxt), "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, bool bNotify)
{
	short sItemIndex;
	int  i, iArrowIndex, iPrevSAType, iTemp;
	char cEquipPos;
	double dV1, dV2, dV3;
	uint32_t  dwSWEType, dwSWEValue;
	short  sTemp;

	if (m_pClientList[iClientH] == 0) return;

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) &&
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) {

		// �߸��� ���� ���� �����̴�. �� �� �ϳ��� ���� ���´�. 
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] != 0) {
			// �Ѽ� ���� ���� ���¸� �����Ѵ�. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = false;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_iAngelicStr = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicInt = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicDex = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicMag = 0; // By Snoopy81	
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM = 0;

	m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i] = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect = false;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir = 0;	// �Ӽ��� ����� ����
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType = 0;	// ��� ������ ȿ�� ����: 0-None 1-�ʻ�������߰� 2-�ߵ�ȿ�� 3-������ 4-������
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// ��� ������ ȿ�� ��

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0;
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;

	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;

	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// �������� �ʾƵ� ȿ���� �ִ� ������.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
					// ������ �־�� ȿ���� �ִ�.
					m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
				}
				break;
			}
		}

	// ������ �ؾ� ȿ���� �ִ� ������ 
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) &&
			(m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex])) {

			cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {

			case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
				// ���� ������ ���� ������. �ε����� �����Ѵ�.
				m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
			case DEF_ITEMEFFECTTYPE_ATTACK:
				// ���� ���� ȿ��
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				m_pClientList[iClientH]->m_cAttackBonus_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3);
				m_pClientList[iClientH]->m_cAttackDiceThrow_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4);
				m_pClientList[iClientH]->m_cAttackDiceRange_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5);
				m_pClientList[iClientH]->m_cAttackBonus_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);

				// v2.05 ������ Ư��ġ �߰� 
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				//testcode
				//std::snprintf(G_cTxt, sizeof(G_cTxt), "Add Damage: %d", iTemp);
				//PutLogList(G_cTxt);

				// ���� ����� �߰�
				m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
				m_pClientList[iClientH]->m_iAddMagicalDamage += iTemp;

				// ���ݹ����� �ش� ��ų��ŭ�� ���߷��� ���Ѵ�. 
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];

				// v1.432 ������� �ʴ´�. ������ ���ݴ�� ���߷� ����ġ�� ���Ѵ�.
				//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
				//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
				// �÷��̾ ����ϴ� ������ ��ų�� �����Ѵ�. 
				m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;

				// v1.41 Custom-Made �������̶�� ȿ���� �����Ѵ�. ���ݹ���� 1���� �����ȴٰ� �������� ��ȿ��.
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					// ���� ������ 
					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
						m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
						m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
						// ����� ������ Ÿ��ġ �ּҰ��� �ִ� 5���� �ö󰣴�.
						dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
						dV1 = (dV2 / 100.0f) * (5.0f);
						m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM +
							m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

						m_pClientList[iClientH]->m_iMinAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L +
							m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

						// ��ġ ���� 
						if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
						if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

						// �ּҰ��� �ִ밪���� ũ�� �ִ밪��ŭ 
						if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
							m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

						if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
							m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);

						//testcode
						//std::snprintf(G_cTxt, sizeof(G_cTxt), "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
						//PutLogList(G_cTxt);
					}
					else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
						// ������ ������ Ÿ��ġ �ִ밪�� �ִ� 5���� ��������.
						dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
						dV1 = (dV2 / 100.0f) * (5.0f);
						m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM
							+ m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

						m_pClientList[iClientH]->m_iMaxAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L
							+ m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

						// ��ġ ���� 
						if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
						if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

						// �ִ밪�� �ּҰ����� ������ �ּҰ���ŭ 
						if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
							m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

						if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
							m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);

						//testcode
						//std::snprintf(G_cTxt, sizeof(G_cTxt), "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
						//PutLogList(G_cTxt);
					}
				}

				// v1.42 ��� �������̶�� Main ȿ���� �����Ѵ�. ���ݹ���� 1���� �����ȴٰ� �������� ��ȿ��.
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

					// ��� ������ ȿ�� ����: 
					// 0-None 1-�ʻ�������߰� 2-�ߵ�ȿ�� 3-������ 4-������ 
					// 5-��ø�� 6-������ 7-������ 8-��ȭ�� 9-���빮���� 10-���� ������
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType = (int)dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

					switch (dwSWEType) {
					case 7: // ������ 
						m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
						m_pClientList[iClientH]->m_cAttackDiceRange_L++;
						break;

					case 9: // ���빮����
						m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
						m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
						break;
					}
				}

				// v1.42 ��� �������̶�� Sub ȿ���� �����Ѵ�. ���ݹ���� 1���� �����ȴٰ� �������� ��ȿ��.
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

					// ��� ������ ȿ�� ����: 
					//�߰� ��������(1), �߰� ���߰�(2), �߰� ��(3), HP ȸ���� �߰�(4), SP ȸ���� �߰�(5)
					//MP ȸ���� �߰�(6), �߰� ��������(7), ���� ����� ����(8), ���� ����� ����(9)
					//��Ÿ ����� �߰�(10), �� ���� ����ġ(11), ������ Gold(12)

					switch (dwSWEType) {
					case 0:  break;
					case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue * 7; break;
					case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue * 7; break;
					case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue * 7; break;
					case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue * 7; break;
					case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue * 7; break;
					case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue * 7; break;
					case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue * 7; break;
					case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue * 3; break;
					case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue * 3; break;
					case 10: m_pClientList[iClientH]->m_iAddCD += (int)dwSWEValue; break;
					case 11: m_pClientList[iClientH]->m_iAddExp += (int)dwSWEValue * 10; break;
					case 12: m_pClientList[iClientH]->m_iAddGold += (int)dwSWEValue * 10; break;
					}

					// v2.04 Ư��ġ ������ ����.
					switch (dwSWEType) {
					case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
					}
				}

				// �Ϲ� ���� �̿��� ȿ���� ����.
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
				case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
					// �ִ� HP ���� ȿ��
					m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					break;

				case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
					// ���� ���� ȿ��: ���� �������� �ִ� 80%
					m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
					if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
					break;

				case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
					// �߰� ���� ��� �ɷ� ȿ�� 
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					break;

				case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
					// Ư�� �ɷ� ����
					m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					// Ư�� �ɷ� ���� �ð�
					m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
					// ���� ��ġ ����� ���´�.
					m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;

					// Ư�� �ɷ� �������� �˷��ش�.
					if ((bNotify) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
					break;
				}
				break;

			case DEF_ITEMEFFECTTYPE_ADDEFFECT:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
				case 1:
					// �߰� ���� ���� ���� 
					m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 2:
					// ���� ���� ȿ�� 
					m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					// ���� �������� �ִ� 80%
					if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
					break;

				case 3:
					// ���� ���� ����� ȿ��. ��� ���� ���ݿ� ���ؼ� ���� ������� �ٴ´�. 
					m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 4:
					// �߰� ���� ���� 
					m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 5:
					// ��� ȿ��?
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
						m_pClientList[iClientH]->m_bIsLuckyEffect = true;
					else m_pClientList[iClientH]->m_bIsLuckyEffect = false;
					break;

				case 6:
					// ���� ���� ����� ȿ��. ��� ���� ���ݿ� ���ؼ� ���� ������� �ٴ´�. 
					m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 7:
					m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 8:
					m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 9:
					m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 10:
					// ���迭 ���� ����� ���Ҵ� ������ Ȯ���� ����ȿ���� �ִ�. (2��� Ȯ�� ����)
					m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 11:
					// ���� ����.
					m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 12:
					m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 13: // Magin Ruby		Characters Hp recovery rate(% applied) added by the purity formula.
					m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
					break;

				case 14: // Magin Diamond	Attack probability(physical&magic) added by the purity formula.
					m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
					break;


				case 15: // Magin Emerald	Magical damage decreased(% applied) by the purity formula.	
					m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80;
					break;

				case 30: // Magin Sapphire	Phisical damage decreased(% applied) by the purity formula.	
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] += iTemp;
					break;

					/*Functions rates confirm.
					Magic Diamond: Completion rate / 5 = Functions rate. ? Maximum 20. (not%)
					Magic Ruby: Completion rate / 5 = Functions rate.(%) ? Maximum 20%.
					Magic Emerald: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.
					Magic Sapphire: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.*/

					// ******* Angel Code - Begin ******* //			
				case 16: // Angel STR//AngelicPandent(STR)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicStr = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 17: // Angel DEX //AngelicPandent(DEX)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicDex = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 18: // Angel INT//AngelicPandent(INT)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicInt = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 19: // Angel MAG//AngelicPandent(MAG)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicMag = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;

				}
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
				// ȭ���� �ʿ�� �ϴ� ����(Ȱ��)
				// ������ ����ȿ���� � ȭ���� ���õǴ��Ŀ� ���� �޶�����. �������� ȭ���� ã�� �Ҵ��Ѵ�.
				if ((m_pClientList[iClientH]->m_cArrowIndex != -1) &&
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == 0)) {
					// ArrowIndex�� ȭ���� ����. (����ִ� ������) 
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
				}
				else if (m_pClientList[iClientH]->m_cArrowIndex == -1)
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

				if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
					// ȭ���� ����.
					m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
					m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
					m_pClientList[iClientH]->m_cAttackBonus_SM = 0;
					m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
					m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
					m_pClientList[iClientH]->m_cAttackBonus_L = 0;
				}
				else {
					iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
					m_pClientList[iClientH]->m_cAttackDiceThrow_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					m_pClientList[iClientH]->m_cAttackDiceRange_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
					m_pClientList[iClientH]->m_cAttackBonus_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3);
					m_pClientList[iClientH]->m_cAttackDiceThrow_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4);
					m_pClientList[iClientH]->m_cAttackDiceRange_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5);
					m_pClientList[iClientH]->m_cAttackBonus_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				}

				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
				break;

			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			case DEF_ITEMEFFECTTYPE_DEFENSE:
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;

					dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					dV3 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					dV1 = (double)(dV2 / 100.0f) * dV3;

					dV1 = dV1 / 2.0f;
					m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
					if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

					//testcode
					//std::snprintf(G_cTxt, sizeof(G_cTxt), "Custom-Defense: %d", (int)dV1);
					//PutLogList(G_cTxt);
				}

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

					// ��� ������ ȿ�� ����: 
					// 0-None 1-�ʻ�������߰� 2-�ߵ�ȿ�� 3-������ 4-������ 
					// 5-��ø�� 6-������ 7-������ 8-��ȭ�� 9-���빮���� 10-���������� 11-������ȯ�� 12-�ʻ�������

					switch (dwSWEType) {
					case 7: // ������ 
						m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
						m_pClientList[iClientH]->m_cAttackDiceRange_L++;
						break;

					case 9: // ���빮����
						m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
						m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
						break;

						// v2.04 
					case 11: // ���� ��ȯ�� 
						m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
						if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
						break;

					case 12: // �ʻ� ������ 
						m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
						if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
						break;
					}
				}

				// v1.42 ��� �������̶�� Sub ȿ���� �����Ѵ�. ���ݹ���� 1���� �����ȴٰ� �������� ��ȿ��.
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

					// ��� ������ ȿ�� ����: 
					//�߰� ��������(1), �߰� ���߰�(2), �߰� ��(3), HP ȸ���� �߰�(4), SP ȸ���� �߰�(5)
					//MP ȸ���� �߰�(6), �߰� ��������(7), ���� ����� ����(8), ���� ����� ����(9)
					//��Ÿ ����� �߰�(10), �� ���� ����ġ(11), ������ Gold(12)

					switch (dwSWEType) {
					case 0:  break;
					case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue * 7; break;
					case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue * 7; break;
					case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue * 7; break;
					case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue * 7; break;
					case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue * 7; break;
					case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue * 7; break;
					case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue * 7; break;
					case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue * 3; break;
					case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue * 3; break;
					case 10: m_pClientList[iClientH]->m_iAddCD += (int)dwSWEValue; break;
					case 11: m_pClientList[iClientH]->m_iAddExp += (int)dwSWEValue * 10; break;
					case 12: m_pClientList[iClientH]->m_iAddGold += (int)dwSWEValue * 10; break;
					}

					// v2.04 Ư��ġ ������ ����.
					switch (dwSWEType) {
					case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; // ���� ����� ���� �ִ� 80%
					}
				}

				switch (cEquipPos) {
				case DEF_EQUIPPOS_LHAND:
					// �� �� ���а� ���� �Ǿ���. 
					// ���п� ���� ��� ���� ȿ�� �Ҵ��Ѵ�. ���� 70% ���� 
					m_pClientList[iClientH]->m_iDamageAbsorption_Shield = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) / 3;
					break;
				default:
					// ���ʿ� ���� ��� ���� ȿ���� ���Ѵ�. ���� 70% ���� <- v1.43 100%�� ����Ǿ���. V2!
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
					break;
				}

				// �Ϲ� ���� �̿��� ȿ���� ����.
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
				case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
					// Ư�� �ɷ� ����
					m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					// Ư�� �ɷ� ���� �ð�
					m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
					// ���� ��ġ ����� ���´�.
					m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;

					// Ư�� �ɷ� �������� �˷��ش�.
					if ((bNotify) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
					break;
				}
				break;
			}
		}

	// Snoopy: Bonus for Angels	
	m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_iAngelicDex * 2;
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);


	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify)) {
		// Ư�� �ɷ��� �����Ǿ���.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, 0, 0, 0);
		// ���� Ư�� �ɷ� ��� ���̾��ٸ� �ܸ� ��ȭ�ϸ� ��뵵 ����.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			// ���� ��� ���� �ð��� �Է��Ѵ�.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// ȿ�� ��Ʈ Ŭ����
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ������ �������� �˸���.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}

	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) &&
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify)) {
		// Ư�� �ɷ� ��� ���߿� Ư�� �ɷ��� �ٲٸ� �ɷ� ����� �����.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) {
			// ���ð��� �� �Ǿ���.
			SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			// ���� ��� ���� �ð��� �Է��Ѵ�.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// ȿ�� ��Ʈ Ŭ����
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ������ �������� �˸���.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
	int ix, iy, iSum = 0;
	short sOwnerH;
	char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
		for (iy = dY - cRange; iy <= dY + cRange; iy++) {
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
				iSum++;
		}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char* pData)
{
	// ¿î¿µÀÚ ¸ðµå¸¦ È®ÀÎÇÏ±â À§ÇØ¼­´Â ÀÏ´Ü ÀÌ ¸Þ½ÃÁö¸¦ Àü¼ÛÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ °®°í ÀÖ¾î¾ß ÇÑ´Ù. 
	// ¶ÇÇÑ ³¯Â¥¸¦ Á¶ÇÕÇØ¼­ »ý¼ºµÇ´Â È®ÀÎ ÄÚµå°¡ ÀÏÄ¡ÇØ¾ß ÇÑ´Ù. 

}

bool CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, bool bIsCheck)
{
	int   iNamingValue, tX, tY;
	short sOwnerH;
	char  cOwnerType, cName[11], cNpcName[21];
	char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return false;
	if (m_bIsCrusadeMode) return false;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != true) {
			if (bIsCheck) return true;

			std::memset(cNpcName, 0, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
				strcpy(cNpcName, "Guard-Aresden");
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
				strcpy(cNpcName, "Guard-Neutral");

			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));
				std::memset(cName, 0, sizeof(cName));
				std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
					&tX, &tY, cNpcWaypoint, 0, 0, -1, false, true) == false) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					if (m_pEntityManager != 0) m_pEntityManager->bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, true);
				}
			}
		}
	}
	return false;
}

bool CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[sOwnerH] == 0) return false;

	// ÀÚ±â ÀÚ½Å¿¡ ´ëÇÑ °ø°ÝÀº ¹üÁË¶ó º¼ ¼ö ¾ø´Ù. 
	if (iClientH == sOwnerH) return true;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		// °ø°ÝÀÚ´Â ¿©ÇàÀÚÀÌ´Ù.
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌ¸é Àû¼ºÀÌ¸ç ±× ÀÌ¿Ü¿¡´Â ¾Æ´Ï´Ù. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0)
			return true;
		else return false;
	}
	else {
		// °ø°ÝÀÚ´Â ¼Ò¼Ó ¸¶À»À» °®°í ÀÖ´Ù. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// ¼­·Î »çÀÌµå°¡ ´Ù¸£´Ù. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0)
					return true;
				else return false;
			}
			else return true;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0)
				return true;
			else return false;
		}
	}

	return false;
}




void CGame::PoisonEffect(int iClientH, int iV1)
{
	int iPoisonLevel, iDamage, iPrevHP, iProb;

	// Áßµ¶À¸·Î Á×Áö´Â ¾Ê´Â´Ù. ´Ù¸¸ Ã¼·ÂÀÌ °è¼Ó ±ïÀÌ°í ÃÖ¼Ò 1¸¸ ³²´Â´Ù. 
	if (m_pClientList[iClientH] == 0)     return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);

	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);


	// µ¶¼º ÀúÇ× È®·ü·Î Áßµ¶ÀÌ Ç®¸± ¼ö ÀÖ´Ù.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] - 10 + m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1, 100) <= static_cast<uint32_t>(iProb)) {
		m_pClientList[iClientH]->m_bIsPoisoned = false;
		// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // remove poison aura after effect complete
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
	}
}
bool CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
	int iResist, iResult;

	// µ¶¼º ÀúÇ×ÀÌ ¼º°øÇß´ÂÁö¸¦ °è»êÇÑ´Ù. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return false;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return false;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
	if (iResult >= iResist) // µ¶¼º ÀúÇ× ½ÇÆÐ. Áßµ¶µÈ´Ù.
		return false;

	// µ¶¼º ÀúÇ× ¼º°ø. ÇÃ·¹ÀÌ¾î¶ó¸é ½ºÅ³À» ¿Ã¸°´Ù. 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return true;
}

bool CGame::bCheckBadWord(char* pString)
{
	char* cp;

	// ½ºÆ®¸µÀ» °Ë»öÇÏ¸ç ¿å¼³ÀÌ ÀÖ´ÂÁö¸¦ Ã£´Â´Ù. 
	cp = pString;
	while (*cp != 0) {

		cp++;
	}

	return false;
}

void CGame::CheckDayOrNightMode()
{
	SYSTEMTIME SysTime;
	char cPrevMode;
	int  i;

	//if (m_bManualTime = true) return;

	// ÇöÀç ½Ã°£¿¡ µû¶ó ³· È¤Àº ¹ãÀ» °áÁ¤ÇÑ´Ù. 
	// ÁÖ, ¾ß°£ ¸ðµå ¼³Á¤ 
	cPrevMode = m_cDayOrNight;

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= m_iNighttimeDuration)
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// ÁÖ, ¾ß°£ ¸ðµå°¡ º¯°æµÇ¾ú´Ù. ÁÖ, ¾ß°£ ¸ðµåÀÇ ¿µÇâÀ» ¹Þ´Â ¸Ê¿¡ Á¸ÀçÇÏ´Â Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¾Ë¸°´Ù. 
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				if ((m_pClientList[i]->m_cMapIndex >= 0) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex] != 0) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == false))
					SendNotifyMsg(0, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, 0, 0, 0);
			}
	}
}


void CGame::ShutUpPlayer(int iClientH, char* pMsg, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[11], cBuff[256];
	int i, iTime;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		// ´ÙÀ½ ÅäÅ«Àº Á¤Áö ½ÃÅ³ ½Ã°£. 
		token = strtok(NULL, seps);
		if (token == 0)
			iTime = 0;
		else iTime = atoi(token);

		if (iTime < 0) iTime = 0;

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ 
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, 0, 0, cName);
				SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, 0, 0, cName);

				// Admin Log
				std::snprintf(G_cTxt, sizeof(G_cTxt), "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName,
					m_pClientList[i]->m_cCharName, iTime);
				PutAdminLogFileList(G_cTxt);

				return;
			}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		/*std::memset(cBuff, 0, sizeof(cBuff));

		char *cp;
		uint16_t *wp;

		cp = (char *)cBuff;

		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (uint16_t *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (uint16_t *)cp;
		*wp = (uint16_t)iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (uint16_t *)cp;
		*wp = iTime;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);*/
	}

	return;
}


void CGame::SetPlayerReputation(int iClientH, char* pMsg, char cValue, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[11], cBuff[256];
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// �򰡸� ���� �ð��� ���� �ʾҰų� �����ڴ� �򰡸� ���� �� ����. ����� ����� �� ����.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, 0, 0, 0);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		// �Ҽ� ������ ���� ����� ������ ���� �� ����.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, 0, 0, 0, 0);
		return;
	}

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		// token�� �� ������ ���� ����� �̸� 
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				if (i != iClientH) {
					// �ڱ� �ڽ��� ���� ���� ����.
					if (cValue == 0)
						m_pClientList[i]->m_iRating--;
					else if (cValue == 1)
						m_pClientList[i]->m_iRating++;

					if (m_pClientList[i]->m_iRating > 500)  m_pClientList[i]->m_iRating = 500;
					if (m_pClientList[i]->m_iRating < -500) m_pClientList[i]->m_iRating = -500;
					// �򰡸� �������Ƿ� �ð� ������ �� �Ҵ�. 
					m_pClientList[iClientH]->m_iTimeLeft_Rating = 20 * 60;

					SendNotifyMsg(0, i, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);

					return;
				}
			}
		// ���� �������� �ƴϴ�.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}

	return;
}

bool CGame::bReadNotifyMsgListFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "=\t\n;";
	int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		PutLogList("(!) Notify Message list file not found!...");
		return false;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);
		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
						if (m_pNoticeMsgList[i] == 0) {
							m_pNoticeMsgList[i] = new class CMsg;
							m_pNoticeMsgList[i]->bPut(0, token, strlen(token), 0, 0);
							m_iTotalNoticeMsg++;
							goto LNML_NEXTSTEP1;
						}
				LNML_NEXTSTEP1:
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}
void CGame::NoticeHandler()
{
	char  cTemp, cBuffer[1000], cKey;
	uint32_t dwSize, dwTime = GameClock::GetTimeMS();
	int i, iMsgIndex, iTemp;

	// °øÁö»çÇ×ÀÌ 1°³ ÀÌÇÏ¶ó¸é º¸³¾ ÇÊ¿ä°¡ ¾ø´Ù.
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		// °øÁö»çÇ×À» Àü¼ÛÇÒ ½Ã°£ÀÌ µÇ¾ú´Ù. 
		m_dwNoticeTime = dwTime;
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;

		std::memset(cBuffer, 0, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != 0) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				SendNotifyMsg(0, i, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cBuffer);
			}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char* pData, uint32_t dwMsgSize)
{
	char* cp, cCharName[11];
	int i;

	std::memset(cCharName, 0, sizeof(cCharName));

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));
	memcpy(cCharName, cp, 10);

	// ÀÌÁ¦ ÀÌ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Æ Á¢¼ÓÀ» ²÷¾îµµ ÁÁ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. Á¢¼ÓÀ» Á¾·áÇÏ¶ó´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERCHANGE, 0, 0, 0, 0);
			}
		}
}

void CGame::CalcExpStock(int iClientH)
{
	bool bIsLevelUp;
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	// !!!!
	// v2.12 2002-2-6 ÁöÁ¸µµ ÇöÀç °æÇèÄ¡°¡ ÃÖ´ë ·¹º§ °æÇèÄ¡º¸´Ù ÀûÀ¸¸é °æÇèÄ¡¸¦ ¾òÀ»¼ö ÀÖ°Ô º¯°æ .. v2.15 »èÁ¦. ÁöÁ¸µµ °æÇèÄ¡ ¾ò´Â´Ù.
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iMaxLevel])) return;

	// Æ÷»ó°ú Æä³ÎÆ¼°¡ ¾ø´Â ¸Ê À§¿¡ ¼­ ÀÖ´Ù¸é °æÇèÄ¡´Â ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	// ±×µ¿¾È ÃàÀû µÇ¾ú´ø °æÇèÄ¡¸¦ °è»êÇÑ´Ù. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == false) {
		// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
	// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
	bIsLevelUp = bCheckLevelUp(iClientH);

	// v2.03 º¯°æ 9/1
	if ((bIsLevelUp) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// ÃÊº¸¿ë Gold Áö±Þ. ·¹º§ 1~5±îÁö 100 Gold Áö±Þ.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, hb::item::ItemId::Gold) == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32_t)100000;
		bAddItem(iClientH, pItem, 0);
	}

	// v2.03 º¯°æ 9/1
	if ((bIsLevelUp) && (m_pClientList[iClientH]->m_iLevel > 5) && (m_pClientList[iClientH]->m_iLevel <= 20)) {
		// ÃÊº¸¿ë Gold Áö±Þ. ·¹º§ 5~20±îÁö 300 Gold Áö±Þ.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, hb::item::ItemId::Gold) == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32_t)100000;
		bAddItem(iClientH, pItem, 0);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating > 10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(uint32_t iExp)
{
	int i;

	// °æÇèÄ¡°¡ ¾î´À ·¹º§ ¼öÁØ¿¡ ¼ÓÇÏ´ÂÁö ÆÇ´ÜÇÑ´Ù.
	for (i = 1; i < 1000; i++)
		if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i + 1] > iExp)) return i;

	return 0;
}
// v1.4311-3 Ãß°¡ ¿î¿µÀÚ°¡ »çÅõÀåÀ» ¿¹¾àÇÑ´Ù.



void CGame::UserCommand_BanGuildsman(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cTargetName[11], cBuff[256];
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, 0, 0, 0, 0);
		return;
	}

	std::memset(cTargetName, 0, sizeof(cTargetName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		if (strlen(token) > 10)
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {

				if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0) {

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, 0, 0, 0, 0);
					return;
				}
				//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

				SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);

				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, 0, 0, 0, 0);

				SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, 0, 0, 0, 0);

				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

				return;
			}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char* pData, uint32_t dwMsgSize)
{

}

void CGame::RequestCreateNewGuild(int iClientH, char* pData)
{
	char cFileName[255];
	char cTxt[500];
	char cTxt2[100];
	char cGuildMasterName[11], cGuildLocation[11], cDir[255], cGuildName[21];
	char* cp;
	uint32_t* dwp, dwGuildGUID;
	SYSTEMTIME SysTime;
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	std::memset(cFileName, 0, sizeof(cFileName));
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	std::memset(cDir, 0, sizeof(cDir));
	std::memset(cGuildMasterName, 0, sizeof(cGuildMasterName));
	std::memset(cGuildName, 0, sizeof(cGuildName));
	std::memset(cGuildLocation, 0, sizeof(cGuildLocation));

	cp = (char*)pData;

	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	memcpy(cGuildLocation, cp, 10);
	cp += 10;

	dwp = (uint32_t*)cp;
	dwGuildGUID = *dwp;
	cp += 4;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	std::snprintf(cTxt2, sizeof(cTxt2), "AscII%d", *cGuildName);
	strcat(cFileName, cTxt2);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

#ifdef _WIN32
	_mkdir("Guilds");
	_mkdir(cDir);
#endif

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		std::snprintf(cTxt2, sizeof(cTxt2), "(X) Cannot create new guild - Already existing guild name: Name(%s)", cFileName);
		PutLogList(cTxt2);

		ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		fclose(pFile);
	}
	else {
		pFile = fopen(cFileName, "wt");
		if (pFile == 0) {
			std::snprintf(cTxt2, sizeof(cTxt2), "(X) Cannot create new guild - cannot create file : Name(%s)", cFileName);
			PutLogList(cTxt2);

			ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		}
		else {
			std::snprintf(cTxt2, sizeof(cTxt2), "(O) New guild created : Name(%s)", cFileName);
			PutLogList(cTxt2);

			std::memset(cTxt2, 0, sizeof(cTxt2));
			std::memset(cTxt, 0, sizeof(cTxt));
			GetLocalTime(&SysTime);

			std::snprintf(cTxt, sizeof(cTxt), ";Guild file - Updated %4d/%2d/%2d/%2d/%2d", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
			strcat(cTxt, "\n");
			strcat(cTxt, ";Just created\n\n");

			strcat(cTxt, "[GUILD-INFO]\n\n");

			strcat(cTxt, "guildmaster-name     = ");
			strcat(cTxt, cGuildMasterName);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-GUID           = ");
			std::snprintf(cTxt2, sizeof(cTxt2), "%d", dwGuildGUID);
			strcat(cTxt, cTxt2);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-location       = ");
			strcat(cTxt, cGuildLocation);
			strcat(cTxt, "\n\n");

			strcat(cTxt, "[GUILDSMAN]\n\n");

			fwrite(cTxt, 1, strlen(cTxt), pFile);

			ResponseCreateNewGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
			fclose(pFile);
		}
	}
	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}

void CGame::RequestDisbandGuild(int iClientH, char* pData)
{
	char cTemp[500];
	char* cp;
	char cFileName[255], cTxt[100], cDir[100];
	char cGuildMasterName[11], cGuildName[21];
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	std::memset(cFileName, 0, sizeof(cFileName));
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cDir, 0, sizeof(cDir));
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cGuildMasterName, 0, sizeof(cGuildMasterName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	cp = (char*)(pData);
	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	std::snprintf(cTxt, sizeof(cTxt), "AscII%d", *cGuildName);
	strcat(cFileName, cTxt);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		fclose(pFile);
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(O) Disband Guild - Deleting guild file... : Name(%s)", cFileName);
		PutLogList(G_cTxt);
		if (DeleteFile(cFileName) != 0) {
			ResponseDisbandGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
		else {

			ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
	}
	else {

		ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
	}

	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem* pItem, int iDifficulty, uint32_t dwLastTime)
{
	int i, iDynamicHandle;

	// ¸ÊÀÇ À§Ä¡°¡ ¹°ÀÎÁö È®ÀÎÇÑ´Ù. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false) return 0;

	for (i = 1; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] == 0) {
			// ºó °ø°£¿¡ ¹°°í±â¸¦ ¸¸µç´Ù.
			m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
			if (m_pFish[i] == 0) return 0;

			// Dynamic Object¸¦ ¹ß»ý½ÃÅ²´Ù. Owner¿¡ Fish ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
			switch (pItem->m_sIDnum) {
			case 101: // »¡°­¹°°í±â
			case 102: // ÃÊ·Ï¹°°í±â
			case 103: // ³ë¶û¹°°í±â
			case 570:
			case 571:
			case 572:
			case 573:
			case 574:
			case 575:
			case 576:
			case 577:
				iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
				break;
			default:
				// ¹°°í±â°¡ ¾Æ´Ñ ´Ù¸¥ ¾ÆÀÌÅÛ 
				iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
				break;
			}

			if (iDynamicHandle == 0) {
				delete m_pFish[i];
				m_pFish[i] = 0;
				return 0;
			}
			m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMapList[cMapIndex]->m_iCurFish++;

			return i;
		}

	return 0;
}


bool CGame::bDeleteFish(int iHandle, int iDelMode)
{
	int i, iH;
	uint32_t dwTime;

	if (m_pFish[iHandle] == 0) return false;

	dwTime = GameClock::GetTimeMS();

	// ¿¬°üµÇ¾î ÀÖ´Â DynamicObject¸¦ »èÁ¦ÇÑ´Ù.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;

	if (m_pDynamicObjectList[iH] != 0) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, 0, (short)0);
		// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = 0;
	}

	// ÀÌ ¹°°í±â¿Í ¿¬°áµÇ¾î ÀÖ´Â ÇÃ·¹ÀÌ¾îµé¿¡°Ô ¹°°í±â°¡ »ç¶óÁ® ³¬½Ã°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// ¸Þ½ÃÁö Àü¼Û 
			SendNotifyMsg(0, i, DEF_NOTIFY_FISHCANCELED, iDelMode, 0, 0, 0);
			ClearSkillUsingStatus(i); // v1.4 ³¬½Ã ½ºÅ³À» Å¬¸®¾îÇÑ´Ù.
		}
	}

	// »èÁ¦ÇÑ´Ù.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = 0;

	return true;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
	int i;
	short sDistX, sDistY;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;

	// ¸ÊÀÇ Æ¯Á¤ À§Ä¡ ³»¿¡ ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®°¡ ÀÖ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) {
			sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
			sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);

			if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) &&
				((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
				(sDistX <= 2) && (sDistY <= 2)) {
				// ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®¸¦ Ã£¾Ò´Ù. ÀÌÁ¦ ÀÌ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ÀÎµ¦½º¸¦ ¼ÒÀ¯ÇÑ FishÀÇ ÀÎµ¦½º¸¦ ¹ÝÈ¯ÇÑ´Ù. 

				if (m_pFish[m_pDynamicObjectList[i]->m_sOwner] == 0) return 0;
				if (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

				// ÀÌ¹Ì ³¬½Ã¸ðµå¿¡ µé¾î°¡ ÀÖ´Â Ä³¸¯ÅÍ´Â Áßº¹ µ¿ÀÛÀÌ ºÒ°¡´É.
				if (m_pClientList[iClientH]->m_iAllocatedFish != 0) return 0;
				if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
				// ÀÌÁ¦ Ä³¸¯ÅÍ¿¡°Ô ³¬½Ã ¸ðµå¸¦ ½ÃÀÛÇÒ °ÍÀ» ÇÒ´çÇÑ´Ù.
				m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
				m_pClientList[iClientH]->m_iFishChance = 1;
				// ÀÌ Ä³¸¯ÅÍ´Â ³¬½Ã ½ºÅ³À» »ç¿ëÁßÀÓÀ» ¼³Á¤.
				m_pClientList[iClientH]->m_bSkillUsingStatus[1] = true;

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice / 2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
					m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

				// Ä«¿îÆ® Áõ°¡ 
				m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount++;

				return i;
			}
		}

	return 0;
}

void CGame::FishProcessor()
{
	int i, iSkillLevel, iResult, iChangeValue;

	// �̺�Ʈ ���� ��尡 �Ҵ�� �÷��̾���� ó���Ѵ�.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) &&
			(m_pClientList[i]->m_iAllocatedFish != 0)) {

			if (m_pFish[m_pClientList[i]->m_iAllocatedFish] == 0) break;

			// �� �÷��̾�� �Ҵ�� �����Ⱑ �ִ�. ���� Ȯ���� �����Ͽ� �뺸�� �ش�. 
			// ���� ����� ��ų 
			iSkillLevel = m_pClientList[i]->m_cSkillMastery[1];
			// �������� ���̵��� ���� ��ų ������ ��������. 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;

			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult) {
				// ��ų �ֻ��� ���� ����. ���� Ȯ�� ����.
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
			else if (iSkillLevel < iResult) {
				// ��ų �ֻ��� ���� ����. ���� Ȯ�� ����.	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
		}
	}
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
	int iResult, iFishH;
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == 0) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == 0) return;

	// ���� ��ų ��������� ������Ų��.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = false;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		// �� �����⸦ ���µ� �����Ͽ���!

		// ����ġ ���� 
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// ��ų ���� 
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		// ������ �����͸� ���´�.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = 0;

		// ���� �������� �ٴڿ� ����߸���.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY,
			pItem);

		// �ٸ� Ŭ���̾�Ʈ���� �������� ������ ���� �˸���. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

		// ���� ���� �޽��� ���� 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = 0;

		// �����⸦ ����� ���� 
		bDeleteFish(iFishH, 1); // <- ���⼭ �ٸ� ���ò۵鿡�� �޽����� ���۵� ���̴�.
		return;
	}

	// ���µ� ����! 
	m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHFAIL, 0, 0, 0, 0);

	m_pClientList[iClientH]->m_iAllocatedFish = 0;
}


void CGame::FishGenerator()
{
	int i, iP, tX, tY, iRet;
	char  cItemName[21];
	int sDifficulty;
	uint32_t dwLastTime;
	class CItem* pItem;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1, 10) == 5) && (m_pMapList[i] != 0) &&
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) {

			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1, 3) - 2);
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1, 3) - 2);

			pItem = new class CItem;
			if (pItem == 0) break;

			// ¸¸µé ¹°°í±â Á¾·ù¿Í ³­ÀÌµµ, Áö¼Ó ½Ã°£À» °áÁ¤ÇÑ´Ù. 
			std::memset(cItemName, 0, sizeof(cItemName));
			switch (iDice(1, 9)) {
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1, 10) + 20; break;
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1, 5) + 10; break;
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1, 10) + 1;  break;
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1, 15) + 1;  break;
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1, 18) + 1;  break;
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1, 12) + 1;  break;
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1, 10) + 1;  break;
			case 9:
				// °¡²û °¡´Ù ³¬À» ¼ö ÀÖ´Â Æ¯¼ö ¾ÆÀÌÅÛ 
				switch (iDice(1, 150)) {
				case 1:
				case 2:
				case 3:
					strcpy(cItemName, "PowerGreenPotion");
					sDifficulty = iDice(5, 4) + 30;
					break;

				case 10:
				case 11:
					strcpy(cItemName, "SuperPowerGreenPotion");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 20:
					strcpy(cItemName, "Dagger+2");
					sDifficulty = iDice(5, 4) + 30;
					break;

				case 30:
					strcpy(cItemName, "LongSword+2");
					sDifficulty = iDice(5, 4) + 40;
					break;

				case 40:
					strcpy(cItemName, "Scimitar+2");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 50:
					strcpy(cItemName, "Rapier+2");
					sDifficulty = iDice(5, 4) + 60;
					break;

				case 60:
					strcpy(cItemName, "Flameberge+2");
					sDifficulty = iDice(5, 4) + 60;
					break;

				case 70:
					strcpy(cItemName, "WarAxe+2");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 90:
					strcpy(cItemName, "Ruby");
					sDifficulty = iDice(5, 4) + 40;
					break;

				case 95:
					strcpy(cItemName, "Diamond");
					sDifficulty = iDice(5, 4) + 40;
					break;
				}
				break;
			}
			dwLastTime = (60000 * 10) + (iDice(1, 3) - 1) * (60000 * 10);

			if (_bInitItemAttr(pItem, cItemName)) {
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime);
			}
			else {
				delete pItem;
				pItem = 0;
			}
		}
	}
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
	int ix, iy, iRet;
	class CTile* pTile;

	// Ã³¸® ¼Óµµ¸¦ ³ôÀÌ±â À§ÇØ ÇÔ¼ö¸¦ ÄÝÇÏÁö ¾Ê´Â´Ù.
	if ((cMapIndex < 0) || (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
		for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) ||
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				// ÁÂÇ¥¸¦ ¹þ¾î³ª¹Ç·Î Ã³¸®ÇÏÁö ¾Ê´Â´Ù.	
			}
			else {
				pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_sOwner != 0) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
					iRet++;
			}
		}

	return iRet;
}


void CGame::WhetherProcessor()
{
	char cPrevMode;
	int i, j;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_bIsFixedDayMode == false)) {
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != 0) {
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime)
					m_pMapList[i]->m_cWhetherStatus = 0;
			}
			else {
				if (iDice(1, 300) == 13) {
					m_pMapList[i]->m_cWhetherStatus = static_cast<char>(iDice(1, 3)); //This looks better or else we only get snow :(
					//m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3; <- This original code looks fucked
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
				}
			}

			if (m_pMapList[i]->m_bIsSnowEnabled) {
				m_pMapList[i]->m_cWhetherStatus = static_cast<char>(iDice(1, 3) + 3);
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				for (j = 1; j < DEF_MAXCLIENTS; j++)
					if ((m_pClientList[j] != 0) && (m_pClientList[j]->m_bIsInitComplete) && (m_pClientList[j]->m_cMapIndex == i))
						SendNotifyMsg(0, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, 0, 0, 0);
			}
		} //If
	} //for Loop
}


void CGame::FightzoneReserveProcessor()
{
}

/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
	int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			iWheatherBonus = -1;
			break;
		}
		break;
	}
	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if (m_pClientList[iOpponentH] == 0) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == false) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// º»ÀÎÀÌ ¹üÁËÀÚÀÌÇÏ¸é »ó´ë¹æÀÌ ¸¶À»ÀÌ °°Àº °æ¿ì À§Çù. ´Ù¸£¸é Àû 
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			iRet = 7; // À§Çù 
		}
		else iRet = 2; // Àû   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌÇÏ¸é
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0))
			iRet = 6; // ¸¶À»ÀÌ °°À¸¸é PK
		else iRet = 2; // ´Ù¸£¸é ±×³É Àû 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// µÑ ´Ù 0(Traveler)ÀÌ ¾Æ´Ï¸é ÀûÀÌ´Ù.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}
		else {
			// ¾Æ±ºÀÌ´Ù. ±æµå¿ø¿©ºÎ¸¦ ÆÇ´Ü.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
				// ±æµå ÀÌ¸§ÀÌ °°´Ù. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					iRet = 5;	// ±æµå ·©Å©°¡ 0. ±æµå¸¶½ºÅÍÀÌ´Ù.
				else iRet = 3;	// °°Àº ±æµå¿ø
			}
			else
				if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
					// ±æµå À§Ä¡´Â °°°í ±æµå ÀÌ¸§ÀÌ ´Ù¸£´Ù.
					iRet = 4; // ´Ù¸¥ ±æµå¿ø 
				}
				else iRet = 1; // ±×³É °°ÀºÆí 
		}
	}

	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	int iRet;

	if (m_pClientList[iWhatH] == 0) return 0;
	if (m_pClientList[iRecvH] == 0) return 0;

	iRet = 0;

	/*if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone  &&
		m_pClientList[iWhatH]->m_iGuildRank != -1 && m_pClientList[iRecvH]->m_iGuildRank != -1 &&
		memcmp(m_pClientList[iWhatH]->m_cGuildName,m_pClientList[iRecvH]->m_cGuildName,20) != 0) {
			iRet = 8;
		}*/

	if (m_pClientList[iWhatH]->m_iPKCount != 0) {
		iRet = 8;
	}

	if (m_pClientList[iWhatH]->m_cSide != 0) {
		iRet = iRet | 4;
	}

	if (m_pClientList[iWhatH]->m_cSide == 1) {
		iRet = iRet | 2;
	}

	if (m_pClientList[iWhatH]->m_bIsPlayerCivil)
		iRet = iRet | 1;

	return iRet;
}








int CGame::iGetMapIndex(char* pMapName)
{
	int i, iMapIndex;
	char cTmpName[256];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0)
				iMapIndex = i;
		}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
	int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete)
				DeleteClient(i, true, true);
			else DeleteClient(i, false, false);
			iCnt++;
			if (iCnt >= iNum) break;
		}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
	uint32_t dwTime;

	// Æ¯º°ÇÑ ÀÌº¥Æ®¸¦ »ý¼ºÇÑ´Ù. 
	dwTime = GameClock::GetTimeMS();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime = dwTime;
	m_bIsSpecialEventTime = true;

	switch (iDice(1, 180)) {
	case 98: m_cSpecialEventType = 2; break; // µ¥¸ó È¤Àº À¯´ÏÄÜÀÌ ³ª¿Ã °¡´É¼ºÀº 30ºÐ¿¡ 1¹ø 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	// ¾ÈÀü °ø°Ý ¸ðµå¸¦ Åä±ÛÇÑ´Ù. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode)
		m_pClientList[iClientH]->m_bIsSafeAttackMode = false;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = true;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
}




void CGame::ForceDisconnectAccount(char* pAccountName, uint16_t wCount)
{
	int i;

	// Áßº¹µÈ °èÁ¤À» °®°íÀÖ´Â Ä³¸¯ÅÍ¸¦ »èÁ¦ÇÑ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
			PutLogList(G_cTxt);

			// v1.42 Ä«¿îÆÃ ÇÃ·¡±×¸¦ È°¼ºÈ­ ÇØ¾ß ÇÑ´Ù. 
			//DeleteClient(i, true, true);

			//v1.4312
			SendNotifyMsg(0, i, DEF_NOTIFY_FORCEDISCONN, wCount, 0, 0, 0);
		}
}

bool CGame::bOnClose()
{
	if (m_bIsServerShutdowned == false)
	{
#ifdef _WIN32
		if (MessageBox(0, "Player data not saved! Shutdown server now?", m_cRealmName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return true;
		return false;
#else
		return false;
#endif
	}
	else return true;

	return false;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short* spType)
{
	uint16_t wType;

	if (m_pClientList[iClientH] == 0) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:
		// ÃˆÂ­Â»Ã¬Ã€ÃŒ Â¾Ã¸Â´Ã™Â¸Ã© ÃˆÂ­Â»Ã¬ EffectÂ´Ã‚ Â³Ã–ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// ÃˆÂ° Â°Ã¸Â°ÃÃ€ÃŽÂµÂ¥ Ã€Ã¥Ã‚Ã¸Ã‡Ã‘ Â¹Â«Â±Ã¢Â°Â¡ ÃˆÂ°Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Ã€ÃÂ¹Ã Â°Ã¸Â°ÃÃ€Â¸Â·ÃŽ Ã€Ã¼ÃˆÂ¯.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// Â¸Ã‡Â¼Ã• Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21:
		// Â´ÃœÂ°Ã‹ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22:
		// Ã†Ã¦Â½ÃŒ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23:
		// Ã€Ã¥Â°Ã‹ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24:
		// ÂµÂµÂ³Â¢ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25:
		// ÃˆÂ° Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// ÃˆÂ° Â°Ã¸Â°ÃÃ€ÃŽÂµÂ¥ Ã€Ã¥Ã‚Ã¸Ã‡Ã‘ Â¹Â«Â±Ã¢Â°Â¡ ÃˆÂ°Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Ã€ÃÂ¹Ã Â°Ã¸Â°ÃÃ€Â¸Â·ÃŽ Ã€Ã¼ÃˆÂ¯.
		if (wType < 40) *spType = 1;
		break;

	case 26:
		// v2.16 2002-5-27 ÇØ¸Ó ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27:
		// v2.16 2002-5-27 ÁöÆÎÀÌ ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePortionHandler(int iClientH, char* pData)
{
	char cI[6], cPortionName[21];
	int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
	short sItemIndex[6], sTemp;
	short  sItemNumber[6], sItemArray[12];
	bool   bDup, bFlag;
	class  CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
	}

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonItems>(
		pData, sizeof(hb::net::PacketCommandCommonItems));
	if (!pkt) return;
	for (i = 0; i < 6; i++) {
		cI[i] = static_cast<char>(pkt->item_ids[i]);
	}
	// Æ÷¼ÇÀÇ Àç·á ÀÎµ¦½º¸¦ ¹Þ¾Ò´Ù. ÀÌ Àç·á°¡ Æ÷¼ÇÀ» ¸¸µé ¼ö ÀÖ´Â Á¶ÇÕÀÎÁö È®ÀÎÇÑ´Ù. 

	// µ¥ÀÌÅÍ°¡ À¯È¿ÇÑ ¾ÆÀÌÅÛ ÀÎµ¦½ºÀÎÁö Ã¼Å©ÇÑ´Ù.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0) {
			// ¸ÕÀú ÀÌ¹Ì ÀÖ´Â ¸®½ºÆ®ÀÎÁö °Ë»ö 
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i]) {
					// ÀÖ´Ù. Ä«¿îÆ® Áõ°¡ 
					sItemNumber[j]++;
					bDup = true;
				}
			if (bDup == false) {
				// ¾ø´Ù. »õ·Î Ãß°¡ÇÑ´Ù.
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1) {
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						goto RCPH_LOOPBREAK;
					}
			RCPH_LOOPBREAK:;
			}
		}

	// ¾ÆÀÌÅÛ ¸®½ºÆ®°¡ ¸¸µé¾î Á³´Ù. ¼ÒºñµÇ´Â ¾ÆÀÌÅÛÀÌ¶ó¸é °¹¼ö¸¦ È®ÀÎÇÑ´Ù. 
	for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
			// ¾ÆÀÌÅÛÀÌ °¹¼ö°¡ ¿À¹öÇØµµ ¸®ÅÏ.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < static_cast<uint32_t>(sItemNumber[i])) return;
		}

	// ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ ¾ÆÀÌµð ¹øÈ£°¡ Å« ¼ø¼­ºÎÅÍ Á¤·ÄÇÑ´Ù. Bubble Sort
	bFlag = true;
	while (bFlag) {
		bFlag = false;
		for (i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1)) {
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
					(m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum)) {
					// ¹Ù²Û´Ù.
					sTemp = sItemIndex[i + 1];
					sItemIndex[i + 1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemNumber[i + 1];
					sItemNumber[i + 1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				}
			}
	}

	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j + 1] = sItemNumber[i];
		j += 2;
	}

	std::memset(cPortionName, 0, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		if (m_pPortionConfigList[i] != 0) {
			bFlag = false;
			for (j = 0; j < 12; j++)
				if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true;

			if (bFlag == false) {
				std::memset(cPortionName, 0, sizeof(cPortionName));
				memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
				iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
				iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
			}
		}

	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, 0, 0, 0, 0);
		return;
	}

	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, 0, 0, 0, cPortionName);
		return;
	}

	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1, 100);
	if (iResult > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONFAIL, 0, 0, 0, cPortionName);
		return;
	}

	CalculateSSN_SkillIndex(iClientH, 12, 1);

	if (strlen(cPortionName) != 0) {
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;

		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
					// v1.41 !!!
					SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				else ItemDepleteHandler(iClientH, sItemIndex[i], false);
			}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONSUCCESS, 0, 0, 0, cPortionName);
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty / 3));

		if ((_bInitItemAttr(pItem, cPortionName))) {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}

				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = 0;
		}
	}
}

//{
// char * pContents, * token, cTxt[120];
// char seps[] = "= \t\r\n";
// char cReadModeA = 0;
// char cReadModeB = 0;
// int  iPortionConfigListIndex = 0;
////
//	pContents = new char[dwMsgSize+1];
//	std::memset(pContents, 0, dwMsgSize+1);
//	memcpy(pContents, pData, dwMsgSize);
//
//	while( token != 0 ) {
//		if (cReadModeA != 0) {
//			switch (cReadModeA) {
//			case 1:
//				switch (cReadModeB) {
//				case 1:
//					// ���� ��ȣ 
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
//						delete[] pContents;
//					//						return false;
//					}
//					
//					if (m_pPortionConfigList[atoi(token)] != 0) {
//						// �̹� �Ҵ�� ��ȣ�� �ִ�. �����̴�.
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
//						delete[] pContents;
//					//						return false;
//					}
//					m_pPortionConfigList[atoi(token)] = new class CPortion;
//					iPortionConfigListIndex = atoi(token);
//
//					cReadModeB = 2;
//					break;
//
//				case 2:
//					// ���� �̸� 
//					std::memset(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, 0, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
//					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
//					cReadModeB = 3;
//					break;
//
//				default:
//					// ���� ���� m_sArray[0~10]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
//					cReadModeB++;
//					break;
//
//				case 14:
//					// ������ m_sArray[11]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
//					cReadModeB = 15;
//					break;
//
//				case 15:
//					// ��ų ����ġ 
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
//					cReadModeB = 16;
//					break;
//	
//				case 16:
//					// ���̵�
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
//					cReadModeA = 0;
//					cReadModeB = 0;
//					break;
//				}
//				break;
//
//			default: 
//				break;
//			}
//		}
//		else {
//			if (memcmp(token, "potion", 5) == 0) {
//				cReadModeA = 1;
//				cReadModeB = 1;
//			}
//			
//		}
//	}	
//
////	delete[] pContents;
//
//	if ((cReadModeA != 0) || (cReadModeB != 0)) {
//		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
//		return false;
//	}
//
//	std::snprintf(cTxt, sizeof(cTxt), "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
//	PutLogList(cTxt);
//
//	return true;
//}

//////////////////////////////////////////////////////////////////////////////////////////
///		Snoopy: Added Crafting to the same file than potions
//////////////////////////////////////////////////////////////////////////////////////////
void CGame::ReqCreateCraftingHandler(int iClientH, char* pData)
{
	char cI[6], cCraftingName[21];
	int    iRet, i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
	short sTemp;
	short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
	bool   bDup, bFlag, bNeedLog;
	class  CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++)
	{
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonBuild>(
		pData, sizeof(hb::net::PacketCommandCommonBuild));
	if (!pkt) return;
	for (i = 0; i < 6; i++) {
		cI[i] = static_cast<char>(pkt->item_ids[i]);
	}

	for (i = 0; i < 6; i++)
	{
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0)
		{
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i])
				{
					sItemNumber[j]++;
					bDup = true;
				}
			if (bDup == false)
			{
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1)
					{
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						goto RCPH_LOOPBREAK;
					}
			RCPH_LOOPBREAK:;
			}
		}


	for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1)
		{
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < static_cast<uint32_t>(sItemNumber[i])) return;
			sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{
				sItemPurity[i] = 100; // Merien stones considered 100% purity.
			}
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
			{
				sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
			}
			if (sItemNumber[i] > 1) // No purity for stacked items
			{
				sItemPurity[i] = -1;
			}
			/*std::snprintf(G_cTxt, sizeof(G_cTxt), "Crafting: %d x %s (%d)"
				, sItemNumber[i]
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
			PutLogList(G_cTxt);*/

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK))
			{
				iNeededContrib = 10; // Necks Crafting requires 10 contrib
			}
		}

	// Bubble Sort
	bFlag = true;
	while (bFlag)
	{
		bFlag = false;
		for (i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1))
			{
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum))
				{
					sTemp = sItemIndex[i + 1];
					sItemIndex[i + 1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemPurity[i + 1];
					sItemPurity[i + 1] = sItemPurity[i];
					sItemPurity[i] = sTemp;
					sTemp = sItemNumber[i + 1];
					sItemNumber[i + 1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				}
			}
	}
	j = 0;
	for (i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j + 1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	std::memset(cCraftingName, 0, sizeof(cCraftingName));
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		if (m_pCraftingConfigList[i] != 0)
		{
			bFlag = false;
			for (j = 0; j < 12; j++)
			{
				if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true; // one item mismatch	
			}
			if (bFlag == false) // good Crafting receipe
			{
				std::memset(cCraftingName, 0, sizeof(cCraftingName));
				memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
				iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
				iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
			}
		}


	// Check if recipe is OK
	if (strlen(cCraftingName) == 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, 0, 0, 0); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, 0, 0, 0); // "There is not enough Contribution Point"	
		return;
	}
	// Check possible Failure
	if (iDice(1, 100) > static_cast<uint32_t>(iDifficulty))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, 0, 0, 0); // "Crafting failed"
		// Remove parts...
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;
		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1)
			{	// Deplete any Merien Stone
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
				else
					// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL))
					{
						if (iDice(1, 100) < static_cast<uint32_t>(iRiskLevel))
						{
							ItemDepleteHandler(iClientH, sItemIndex[i], false);
						}
					}
			}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
		{
			if (sItemPurity[i] != -1)
			{
				iTot += sItemPurity[i];
				iCount++;
			}
		}
	}
	if (iCount == 0)
	{
		iPurity = 20 + iDice(1, 80);			// Wares have random purity (20%..100%)
		bNeedLog = false;
	}
	else
	{
		iPurity = iTot / iCount;
		iTot = (iPurity * 4) / 5;
		iCount = iPurity - iTot;
		iPurity = iTot + iDice(1, iCount);	// Jewel completion depends off Wares purity
		bNeedLog = true;
	}
	if (iNeededContrib != 0)
	{
		iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = true;
	}
	CalculateSSN_SkillIndex(iClientH, 18, 1);

	if (strlen(cCraftingName) != 0)
	{
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;
		for (i = 0; i < 6; i++)
		{
			if (sItemIndex[i] != -1)
			{
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				{
					SetItemCount(iClientH, sItemIndex[i],
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				}
				else // So if item is not Type 5 (stackable items), you deplete item
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
			}
		}
		if (iNeededContrib != 0)
		{
			m_pClientList[iClientH]->m_iContribution -= iNeededContrib;
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, 0, 0, 0, 0);

		m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);

		if ((_bInitItemAttr(pItem, cCraftingName)))
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0)
			{
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
			// pItem->m_sTouchEffectValue3 = GameClock::GetTimeMS();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			std::memset(cTemp, 0, sizeof(cTemp));
			std::snprintf(cTemp, sizeof(cTemp), "%d%2d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
			if (bNeedLog)
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PC(%s) Crafting (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);
				PutLogFileList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq))
			{
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else
			{
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else
		{
			delete pItem;
			pItem = 0;
		}
	}
}


void CGame::LocalSavePlayerData(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	sqlite3* db = nullptr;
	std::string dbPath;
	if (EnsureAccountDatabase(m_pClientList[iClientH]->m_cAccountName, &db, dbPath)) {
		if (!SaveCharacterSnapshot(db, m_pClientList[iClientH])) {
			char logMsg[256] = {};
			std::snprintf(logMsg, sizeof(logMsg),
				"(SQLITE) SaveCharacterSnapshot failed: Account(%s) Char(%s) Error(%s)",
				m_pClientList[iClientH]->m_cAccountName,
				m_pClientList[iClientH]->m_cCharName,
				sqlite3_errmsg(db));
			PutLogList(logMsg);
		}
		CloseAccountDatabase(db);
	}
	else {
		char logMsg[256] = {};
		std::snprintf(logMsg, sizeof(logMsg),
			"(SQLITE) EnsureAccountDatabase failed: Account(%s)",
			m_pClientList[iClientH]->m_cAccountName);
		PutLogList(logMsg);
	}
}

void CGame::MineralGenerator()
{
	int i, iP, tX, tY, iRet;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1, 4) == 1) && (m_pMapList[i] != 0) &&
			(m_pMapList[i]->m_bMineralGenerator) &&
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {

			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

			iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
	int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;

	for (i = 1; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] == 0) {
			// ºó °ø°£¿¡ ±¤¹°µ¢ÀÌ¸¦ ¸¸µç´Ù.
			iMineralType = iDice(1, cLevel);
			m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
			if (m_pMineral[i] == 0) return 0;

			iDynamicHandle = 0;
			switch (iMineralType) {
			case 1: // ±¤¹°·ù
			case 2:
			case 3:
			case 4:
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
				break;

			case 5: // º¸¼®·ù 
			case 6:
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, 0, i);
				break;

			default:
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå 
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
				break;
			}

			if (iDynamicHandle == 0) {
				delete m_pMineral[i];
				m_pMineral[i] = 0;
				return 0;
			}
			m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMineral[i]->m_cMapIndex = cMapIndex;

			// ³­ÀÌµµ¿Í ¼ö·®À» ÀÔ·ÂÇÑ´Ù.
			switch (iMineralType) {
			case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
			case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
			case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
			case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
			case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
			default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			}

			// ¸ÊÀÇ ¹Ì³×¶ö ¼ö Áõ°¡
			m_pMapList[cMapIndex]->m_iCurMineral++;

			return i;
		}

	return 0;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	uint32_t dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	class CItem* pItem;
	uint16_t  wWeaponType;

	iItemID = 0;

	if (m_pClientList[iClientH] == 0)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
	}

	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// ±¤¹°Ã¤Ãë¸¦ ½ÃµµÇÑ Ä³¸¯ÅÍÀÇ Á¶°ÇÀ» »ìÇÉ´Ù. °î±ªÀÌ¸¦ µé°í ÀÖ´Â°¡? ±¤¹° Ã¤Ãë ½ºÅ³Àº? 
		// °î±ªÀÌ¿¡ ÇØ´çÇÏ´Â ¿ÜÇüÀÌ¸é Åë°ú 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// ÇÈ¾×½º¸¦ µé°í ÀÖ´Ù. ±¤¹° Ã¤Ãë °¡´É 
		}
		else return;

		// ÀüÅõ ¸ð¼ÇÀÌ ¾Æ´Ï´õ¶óµµ ¸®ÅÏ 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == 0) break;
		// Ä³´Â ±¤¹°ÀÇ ³­ÀÌµµ¸¸Å­ ½ºÅ³À» ³·Ãá´Ù.
		iSkillLevel -= m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// È®·üÀº ¼º°øÇß´Ù. ±¤¹°Ã¤Ãë ±â¼ú Áõ°¡ 
			CalculateSSN_SkillIndex(iClientH, 0, 1);

			// ÇÃ·¹ÀÌ¾îÀÇ ¹ß ¹Ø¿¡ ±¤¹°À» ¶³¾î¶ß¸°´Ù. 
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
			case 1:
				switch (iDice(1, 5)) {
				case 1:
				case 2:
				case 3:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 4:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 5:
					iItemID = 507; // BlondeStone
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				}
				break;

			case 2:
				switch (iDice(1, 5)) {
				case 1:
				case 2:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 3:
				case 4:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 5:
					if (iDice(1, 3) == 2) {
						iItemID = 356; // SilverNugget
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
					}
					else {
						iItemID = 507; // BlondeStone
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					}
					break;
				}
				break;

			case 3:
				switch (iDice(1, 6)) {
				case 1:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 2:
				case 3:
				case 4:
				case 5:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 6:
					if (iDice(1, 8) == 3) {
						if (iDice(1, 2) == 1) {
							iItemID = 356; // SilverNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
						}
						else {
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
						}
						break;
					}
					else {
						iItemID = 357; // IronOre
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					}
					break;
				}
				break;

			case 4:
				switch (iDice(1, 6)) {
				case 1:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 2:
					if (iDice(1, 3) == 2) {
						iItemID = 356; // SilverNugget
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
					}
					break;
				case 3:
				case 4:
				case 5:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 6:
					if (iDice(1, 8) == 3) {
						if (iDice(1, 4) == 3) {
							if (iDice(1, 4) < 3) {
								iItemID = 508; // Mithral
								m_pClientList[iClientH]->m_iExpStock += iDice(1, 15);
							}
							else {
								iItemID = 354; // GoldNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1, 5);
							}
							break;
						}
						else {
							iItemID = 356; // SilverNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
						}
						break;
					}
					else {
						if (iDice(1, 2) == 1) {
							iItemID = 354; // GoldNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 5);
						}
						else {
							iItemID = 357;  // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
						}
						break;
					}
					break;
				}
				break;

			case 5:
				switch (iDice(1, 19)) {
				case 3:
					iItemID = 352; // Sapphire
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				default:
					iItemID = 358; // Crystal
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				}
				break;

			case 6:
				switch (iDice(1, 5)) {
				case 1:
					if (iDice(1, 6) == 3) {
						iItemID = 353; // Emerald 
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 2:
					if (iDice(1, 6) == 3) {
						iItemID = 352; // Saphire
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 3:
					if (iDice(1, 6) == 3) {
						iItemID = 351; // Ruby
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal 
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 4:
					iItemID = 358; // Crystal 
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				case 5:
					if (iDice(1, 12) == 3) {
						iItemID = 350; // Diamond
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 5);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				}
				break;

			}

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == false) {
				delete pItem;
			}
			else {
				// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4
				// testcode
				// std::snprintf(G_cTxt, sizeof(G_cTxt), "Mining Success: %d", iItemID); 
				// PutLogList(G_cTxt);
			}

			// ±¤¹°ÀÇ ³²Àº ·®À» ÁÙÀÌ°í 0ÀÎ°æ¿ì »èÁ¦ÇÑ´Ù.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// ±¤¹°ÀÌ ¸ðµÎ ¼Ò¸ðµÇ¾ú´Ù. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// µ¿Àû °´Ã¼ »èÁ¦
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = 0;
			}
		}
		break;

	default:
		break;
	}
}

bool CGame::bDeleteMineral(int iIndex)
{
	int iDynamicIndex;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	if (m_pMineral[iIndex] == 0) return false;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == 0) return false;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex,
		m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY,
		m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, 0, (short)0);
	// ¸Ê¿¡¼­ ±¤¹° µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// ±¤¹°ÀÌ »ç¶óÁ³À¸¹Ç·Î ÀÌµ¿ÀÌ °¡´ÉÇÏ°Ô ÇÑ´Ù. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, true);

	// ±¤¹° °³Ã¼ ¼ö °¨¼Ò 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// ±¤¹° °´Ã¼ »èÁ¦ 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = 0;

	return true;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
	char cRewardName[21], cTargetName[21];
	int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	std::memset(cTargetName, 0, sizeof(cTargetName));
	if (m_pClientList[iClientH] == 0) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21:
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
		if (iQuestNum >= 1000) return;
		break;
	}

	std::memset(cRewardName, 0, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "���F-�"); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		switch (iQuestNum) {
		case  0: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (iWho + 130), 0, 0, 0, 0); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum) + 100, 0, 0, 0, 0); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
	int ix, iy, iItemNum;
	char  cItemColor;
	class CItem* pItem;
	short sIDNum;
	uint32_t dwAttr;

	for (ix = sX - 1; ix <= sX + 1; ix++)
		for (iy = sY - 1; iy <= sY + 1; iy++) {
			// ¸¸¾à ÀÌ À§Ä¡¿¡ ¹ßÈ­¼º ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é Áö¿ì°í ºÒ ¿ÀºêÁ§Æ®¸¦ ³õ´Â´Ù.	
			iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);

			switch (iItemNum) {
			case 355:
				// ¼®ÅºÀÌ´Ù. ¾ÆÀÌÅÛÀ» Áö¿ì°í ºÒÀ» ¸¸µç´Ù.
				pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sIDNum, &cItemColor, &dwAttr);
				if (pItem != 0) delete pItem;
				iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
					ix, iy, sIDNum, 0, cItemColor, dwAttr);
				break;
			}
		}
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
	uint16_t wWeaponType;

	if (m_pClientList[iClientH] == 0) return 0;

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7)
			return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}

	return 1;
}

static int ___iCAB5[] = { 0,0, 0,1,2 };
static int ___iCAB6[] = { 0,0, 0,0,0 };
static int ___iCAB7[] = { 0,0, 1,2,3 };
static int ___iCAB8[] = { 0,0, 1,3,5 };
static int ___iCAB9[] = { 0,0, 2,4,8 };
static int ___iCAB10[] = { 0,0, 1,2,3 };

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	// ´Ù¿î ½ºÅ³À» ¼³Á¤ÇßÀ¸´Ï ÀÀ´äÀ» º¸³½´Ù. 
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
}


bool CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
	int bRet;

	// À§Ä¡¸¦ ÁöÁ¤ÇÏ°í »ç¿ë ÈÄ »ç¶óÁö´Â ¾ÆÀÌÅÛ È¿°ú Ã³¸® ºÎºÐ 
	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		bRet = __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			0, iClientH, 0);
		if (bRet) {
			GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOTFLAGSPOT, 0, 0, 0, 0);
		}
		return bRet;

		// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// °Ç¼³ Å°Æ®ÀÌ´Ù. ¹Ìµé·£µå¿¡¼­¸¸ »ç¿ë °¡´ÉÇÔ. m_sItemEffectValue1: °ÇÃà¹° Á¾·ù, m_sItemEffectValue2: °ÇÃà ½Ã°£ 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
			iClientH); // ¼³Ä¡ÀÚ 
		if (bRet) {
			// °Ç¼³ ½ÃÀÛ 
		}
		else {
			// °Ç¼³ ½ÇÆÐ			
		}
		return bRet;

	case DEF_ITEMEFFECTTYPE_DYE:
		// ¾ÆÀÌÅÛ ¿°»ö: ¾ÆÀÌÅÛ °ªÀÌ À¯È¿ÇÑ°¡ Ã¼Å©.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12)) {
					// ¿°»öÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					// »ö ¼Ó¼ºÀÌ ¹Ù²î¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					// ¿°»öÀÌ ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù. 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 15) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 13)) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case DEF_ITEMEFFECTTYPE_WEAPONDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 1) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 3) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 8)) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case DEF_ITEMEFFECTTYPE_FARMING:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH);
		return bRet;

	default:
		break;
	}

	return true;
}


bool CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, bool bAdminFlag)
{
	int ix, iy;
	int   iDynamicObjectIndex, iIndex;
	class CTile* pTile;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	if (m_pMapList[cMapIndex] == 0) return false;
	if (((m_bIsHeldenianMode == false) || (static_cast<char>(m_bIsHeldenianMode) != m_cHeldenianType)) &&
		(m_bHeldenianInitiated == 1)) return false;
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex == -1)) return false;
	if ((m_cHeldenianType == 2) && (m_iGodHMapIndex == -1)) return false;
	if ((m_pClientList[iClientH]->m_iGuildRank == 0)) return false;

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != 0) return false;
	iSide = m_sLastHeldenianWinner;
	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) ||
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return false;

	if ((iClientH > 0) && (m_pClientList[iClientH] != 0)) {
		if ((bAdminFlag == false) && (m_pClientList[iClientH]->m_cSide != iSide)) return false;
	}

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != 0) return false;
	if (pTile->m_bIsMoveAllowed == false)  return false;

	for (ix = dX - 3; ix <= dX + 3; ix++)
		for (iy = dY - 3; iy <= dY + 3; iy++) {
			if ((ix == dX) && (iy == dY)) {

			}
			else {
				pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != 0) && (pTile->m_iOccupyFlagIndex > 0) &&
					(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != 0)) {
					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return false;
				}
			}
		}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		return false;
	}

	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	default: iDynamicObjectIndex = 0;
	}

	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		if (iDynamicObjectIndex > DEF_MAXGUILDS)
			return true;
	}

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;

	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	if (m_cHeldenianType == 1) {
		for (ix = dX - 3; ix <= dX + 3; ix++)
			for (iy = dY - 3; iy <= dY + 3; iy++) {
				if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) ||
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				}
				else {
					pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
					switch (iSide) {
					case 1:
						pTile->m_iOccupyStatus -= iEKNum;
						break;
					case 2:
						pTile->m_iOccupyStatus += iEKNum;
						break;
					}
				}
			}
	}

	if (m_cHeldenianType == 2) {
		if (iSide == m_sLastHeldenianWinner) {
			m_cHeldenianVictoryType = iSide;
			//sub_4AB9D0
		}
	}
	return true;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, uint32_t dwMsgSize, char* pData)
{
	int i, iTargetIndex;
	char   seps[] = "= \t\r\n";
	char* token, cTargetName[11], cBuff[256];

	if (m_pClientList[iClientH] == 0) return;
	// v2.1 �߸��� ������ ������ �� �� ����.
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	switch (iMode) {
	case 0: // Free ���
	case 1: // Hold ���
		//  �����Ͱ� iClientH�� ������ �����带 �����Ѵ�.
		for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != 0) {
				if ((m_pNpcList[i]->m_bIsSummoned) &&
					(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_bIsPermAttackMode = false;
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;
					m_pNpcList[i]->m_iTargetIndex = 0;
				}
			}
		break;

	case 2:
		// ���� ��� - ��ǥ���� ���´�. 
		if ((dwMsgSize) <= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		token = strtok(NULL, seps);
		token = strtok(NULL, seps);

		iTargetIndex = 0;
		if (token != 0) {
			// token�� �� ������ ����� �̸� 
			if (strlen(token) > 10)
				memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			// 2002.8.17 ����ȣ ����
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{
				// if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != 0) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0)) // adamas(map�� ���ƾ� �Ѵ�.)
				{
					// ��ǥ ĳ���͸� ã�Ҵ�. �ε��� ����
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

	SSMA_SKIPSEARCH:

		if ((iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) &&
			(m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
			// ��ǥ���� �����Ѵٸ� �Ҵ��Ѵ�. 
			for (i = 0; i < DEF_MAXNPCS; i++)
				if (m_pNpcList[i] != 0) {
					if ((m_pNpcList[i]->m_bIsSummoned) &&
						(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
						(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {

						m_pNpcList[i]->m_iSummonControlMode = iMode;
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;
						m_pNpcList[i]->m_iTargetIndex = iTargetIndex;
						m_pNpcList[i]->m_cTargetType = DEF_OWNERTYPE_PLAYER;
						m_pNpcList[i]->m_bIsPermAttackMode = true;
					}
				}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
	int   i, iNum, iRet, iEraseReq, iEKNum;
	char cItemName[21];
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	std::memset(cItemName, 0, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "¾Æ·¹½ºµ§±ê¹ß"); break;
	case 2: strcpy(cItemName, "¿¤¹ÙÀÎ±ê¹ß");   break;
	}

	// ReqPurchaseItemHandler¿¡¼­ °¡Á®¿Â ·çÆ¾À» °íÃÆÀ½.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î EK °ªÀ» »©µµ µÈ´Ù.
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}

				// EKNumÀ» ÀÔ·ÂÇÑ´Ù.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}

				// º¯°æµÈ ¿¡³Ê¹Ì Å³À» ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);
			}
			else
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}



// v1.4311-3 Ãß°¡  ÇÔ¼ö ÀÔÀå±ÇÀ» ÁÖ´Â ÇÔ¼ö   GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
	int   iRet, iEraseReq, iMonth, iDay, iHour;
	char cItemName[21];
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) {
		// ÀÔÀå±ÇÀ» ´Ù »ç¿ëÇßÀ½À» ¾Ë¸°´Ù.
		// »çÅõÀå ¹øÈ£°¡ À½¼ö¸é ¿¹¾àÀº Çß´Âµ¥ ÀÔÀå±ÇÀ» ´Ù ¹ÞÀº°æ¿ì ..
		m_pClientList[iClientH]->m_iFightzoneNumber *= -1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, 0, 0, 0);
		return;
	}

	std::memset(cItemName, 0, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1)
		strcpy(cItemName, "ArenaTicket");
	else  std::snprintf(cItemName, sizeof(cItemName), "ArenaTicket(%d)", m_pClientList[iClientH]->m_iFightzoneNumber);

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == false) {
		delete pItem;
		return;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
		// ¿¡·¯ ¹æÁö¿ë ÄÚµå
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î ÀÔÀå±Ç°³¼ö¸¦ »©µµ µÈ´Ù. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber - 1;

		pItem->m_sTouchEffectType = DEF_ITET_DATE;

		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000) / 100;
		iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000 - iDay * 100;

		pItem->m_sTouchEffectValue1 = iMonth;
		pItem->m_sTouchEffectValue2 = iDay;
		pItem->m_sTouchEffectValue3 = iHour;


		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);


		// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
	else {
		// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
		delete pItem;

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

int CGame::_iComposeFlagStatusContents(char* pData)
{
	SYSTEMTIME SysTime;
	char cTxt[120];
	int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");

	std::snprintf(cTxt, sizeof(cTxt), "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
		if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != 0) {

			std::snprintf(cTxt, sizeof(cTxt), "flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}

	strcat(pData, "\n\n");

	return strlen(pData);
}


//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH, int iItemID, const char* pString)
{
	int   i, iNum, iRet, iEraseReq;
	char cItemName[21];
	class CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;

	switch (iItemID) {
		// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
		break;

		// Hero Helm
	case 403: //Aresden HeroHelm(M)
	case 404: //Aresden HeroHelm(W)
	case 405: //Elvine HeroHelm(M)
	case 406: //Elvine HeroHelm(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 150) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Cap
	case 407: //Aresden HeroCap(M)
	case 408: //Aresden HeroCap(W)
	case 409: //Elvine HeroHelm(M)
	case 410: //Elvine HeroHelm(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Armour
	case 411: //Aresden HeroArmour(M)
	case 412: //Aresden HeroArmour(W)
	case 413: //Elvine HeroArmour(M)
	case 414: //Elvine HeroArmour(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
		if (m_pClientList[iClientH]->m_iContribution < 30) return;
		m_pClientList[iClientH]->m_iContribution -= 30;
		break;

		// Hero Robe
	case 415: //Aresden HeroRobe(M)
	case 416: //Aresden HeroRobe(W)
	case 417: //Elvine HeroRobe(M)
	case 418: //Elvine HeroRobe(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 200) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 200;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Hauberk
	case 419: //Aresden HeroHauberk(M)
	case 420: //Aresden HeroHauberk(W)
	case 421: //Elvine HeroHauberk(M)
	case 422: //Elvine HeroHauberk(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
		if (m_pClientList[iClientH]->m_iContribution < 10) return;
		m_pClientList[iClientH]->m_iContribution -= 10;
		break;

		// Hero Leggings
	case 423: //Aresden HeroLeggings(M)
	case 424: //Aresden HeroLeggings(W)
	case 425: //Elvine HeroLeggings(M)
	case 426: //Elvine HeroLeggings(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 150) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150;
		if (m_pClientList[iClientH]->m_iContribution < 15) return;
		m_pClientList[iClientH]->m_iContribution -= 15;
		break;

	default:
		return;
		break;
	}

	std::memset(cItemName, 0, sizeof(cItemName));
	memcpy(cItemName, m_pItemConfigList[iItemID]->m_cName, 20);
	// ReqPurchaseItemHandler
	iNum = 1;
	for (i = 1; i <= iNum; i++)
	{
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false)
		{
			delete pItem;
		}
		else {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution, cItemName);
				PutLogFileList(G_cTxt);

				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

				iCalcTotalWeight(iClientH);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);
			}
			else
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:

					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}

void CGame::_SetItemPos(int iClientH, char* pData)
{
	char cItemIndex;
	short sX, sY;

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestSetItemPos>(pData, sizeof(hb::net::PacketRequestSetItemPos));
	if (!req) return;
	cItemIndex = static_cast<char>(req->dir);
	sX = req->x;
	sY = req->y;

	// Àß¸øµÈ ÁÂÇ¥°ª º¸Á¤ 
	if (sY < -10) sY = -10;

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != 0) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
	int i, iDamage;

	if (m_pClientList[iClientH] == 0) return;
	// v1.3 À¯´ÏÅ© ¾ÆÀÌÅÛÀÇ ÀåÂø »óÅÂ¸¦ ÆÇ´ÜÇÑ´Ù. Æ¯Á¤ÀÎ¸¸ÀÌ Âø¿ë °¡´ÉÇÑ ¾ÆÀÌÅÛÀ» ÀåÂøÇÑ °æ¿ì ¹þ°ÜÁø´Ù.

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
				(m_pClientList[iClientH]->m_bIsItemEquipped[i])) {
				// Touch Effect TypeÀÌ DEF_ITET_OWNERÀÌ¸é Touch Effect Value 1, 2, 3ÀÌ ÁÖÀÎ Ä³¸¯ÅÍÀÇ °íÀ¯°ªÀ» °®´Â´Ù. 

				if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
					// ID °ªÀÌ ¸Â´Ù.
				}
				else {
					// ÀÚ½ÅÀÇ °ÍÀÌ ¾Æ´Ï¹Ç·Î Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, 0, 0);
					ReleaseItemHandler(iClientH, i, true);
					// v1.4 ´ë¹ÌÁö¸¦ ¾ò´Â´Ù. 
					iDamage = iDice(10, 10);
					m_pClientList[iClientH]->m_iHP -= iDamage;
					if (m_pClientList[iClientH]->m_iHP <= 0) {
						ClientKilledHandler(iClientH, 0, 0, iDamage);
					}
				}
			}
		}
}

void CGame::_BWM_Init(int iClientH, char* pData)
{
	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = true;
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char* pData)
{
	char* cp, cName[11];
	int i;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader) + 10);

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
				m_pClientList[i]->m_iTimeLeft_ShutUp = 20 * 3 * 10; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ ¿åÀ» ÇÏ¸é ¹«Á¶°Ç Æä³ÎÆ¼ 10ºÐ  
				SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, 20 * 3 * 10, 0, 0, cName);

				// Admin Log
				std::snprintf(G_cTxt, sizeof(G_cTxt), "BWordMonitor shutup(%s %d)", cName, 20 * 3 * 10);
				PutAdminLogFileList(G_cTxt);

				return;
			}
		}
}


void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16_t wObjectID, const char* pItemName)
{
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < static_cast<uint32_t>(iAmount)) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;

	// �������� ������ ��ȯ�ϰڴٴ� �޽����� �����ߴ�. ���濡�� �˸��� ���� ��� ��ȯâ�� ������ �Ѵ�. 
	//���� dX, dY�� �ִ� ������Ʈ���� �Һ� �������� �ǳ��ش�. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);


	if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {

		// v1.4 �ְ��� �� ��ü�� �´��� �Ǵ��Ѵ�.
		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				// �÷��̾� 
				if (m_pClientList[wObjectID] != 0) {
					if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
				}
			}
			else sOwnerH = 0;
		}

		if ((sOwnerH == 0) || (m_pClientList[sOwnerH] == 0)) {
			//¾ÆÀÌÅÛ ±³È¯À» ¿äÃ»ÇÑ ÇÃ·¹ÀÌ¾î¿¡°Ô ÇØ´ç À§Ä¡¿¡ ÇÃ·¹ÀÌ¾î°¡ ¾øÀ½À» ¾Ë¸°´Ù. 
			_ClearExchangeStatus(iClientH);
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone)) {
				// »ó´ë¹æÀÌ ÀÌ¹Ì ±³È¯ ÁßÀÌ°Å³ª ÀüÅõ¸ðµå, È¤Àº »çÅõÀåÀÌ´Ù. ±³È¯¸ðµå·Î µé¾î°¥ ¼ö ¾ø´Ù. 
				_ClearExchangeStatus(iClientH);
			}
			else {
				// ±³È¯¸ðµå°¡ ½ÃÀÛµÇ¾ú´Ù. ÀÎµ¦½º, ÀÌ¸§ ÀúÀå  
				m_pClientList[iClientH]->m_bIsExchangeMode = true;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				std::memset(m_pClientList[iClientH]->m_cExchangeName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);


				//Clear items in the list
				m_pClientList[iClientH]->iExchangeCount = 0;
				m_pClientList[sOwnerH]->iExchangeCount = 0;
				for (int i = 0; i < 4; i++) {
					//Clear the trader
					std::memset(m_pClientList[iClientH]->m_cExchangeItemName[i], 0, sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
					m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
					//Clear the guy we're trading with
					std::memset(m_pClientList[sOwnerH]->m_cExchangeItemName[i], 0, sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
				}

				// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛ ÀÎµ¦½º, ¼ö·® ÀúÀå 
				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

				//std::memset(m_pClientList[iClientH]->m_cExchangeItemName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);

				m_pClientList[sOwnerH]->m_bIsExchangeMode = true;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				std::memset(m_pClientList[sOwnerH]->m_cExchangeName, 0, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->iExchangeCount++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		// NPC¿Í´Â ¹°°ÇÀ» ±³È¯ÇÒ ¼ö ¾ø´Ù.
		_ClearExchangeStatus(iClientH);

	}
}

void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
	int iExH;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->iExchangeCount > 4) return;	//only 4 items trade

	if ((m_pClientList[iClientH]->m_bIsExchangeMode) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ((m_pClientList[iExH] == 0) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0)) {
			// ��ȯ�� ������ ���ų� ��ȯ�ϰ��� �ߴ� �� ĳ���Ͱ� �ƴϴ�. 	

		}
		else {
			// ��ȯ�ϰ��� �ϴ� ���濡�� �������� �˷��ش�. 
			// �ش� �������� �����ϴ���, ������ �´��� üũ�Ѵ�. 
			if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < static_cast<uint32_t>(iAmount)) return;

			//No Duplicate items
			for (int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
				if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			// ��ȯ�ϰ��� �ϴ� ������ �ε���, ���� ���� 
			m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

			//std::memset(m_pClientList[iClientH]->m_cExchangeItemName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			//m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			//m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			//std::memset(m_pClientList[iClientH]->m_cExchangeItemName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			//memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			m_pClientList[iClientH]->iExchangeCount++;
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
	else {
		// ��ȯ ��尡 �ƴϹǷ� 
	}
}

void CGame::ConfirmExchangeItem(int iClientH)
{
	int iExH, i;
	int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
	class CItem* pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	if ((m_pClientList[iClientH]->m_bIsExchangeMode) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;

		// v1.42 ���� �̷� ��찡?
		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != 0) {
			if ((memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
				(m_pClientList[iExH]->m_bIsExchangeMode != true) ||
				(memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0)) {
				// ��ȯ�ϰ��� �ߴ� �� ĳ���Ͱ� �ƴϴ�. ��ȯ ���´� ���.
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = true;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm) {
					// ���浵 ��ȯ�ǻ縦 ������. ��ȯ�� ������ �� �ִ��� ����Ѵ�. ������ ����, ���� ������ �Ǵ�.

					//Check all items
					for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == 0) ||
							(memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName[i], 20) != 0)) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == 0) ||
							(memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iExH]->m_cExchangeItemName[i], 20) != 0)) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					//Calculate weight for items
					iItemWeightA = 0;
					for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]],
							m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
					}
					iItemWeightB = 0;
					for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]],
							m_pClientList[iExH]->m_iExchangeItemAmount[i]);
					}

					//See if the other person can take the item weightload
					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						// ��ȯ�ϰ��� �ϴ� �������� ���� ���԰����� ����. ��ȯ �Ұ���. 
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						// ���������� �ִ� �������� ���� ���� ������ ���Ѿ� ������ �ִ�.
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {

							if (static_cast<uint32_t>(m_pClientList[iClientH]->m_iExchangeItemAmount[i]) >
								m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
								// ��ȯ�ϰ��� �ߴ� �������� �������� ����. �׵��� �پ�����.
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							pItemA[i] = new class CItem;
							_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							// �α׸� ����� ���� ������ ���繰 
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
						else {
							pItemA[i] = (class CItem*)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							// �α׸� ����� ���� ������ ���繰 
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
					}

					for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {

							if (static_cast<uint32_t>(m_pClientList[iExH]->m_iExchangeItemAmount[i]) >
								m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
								// ��ȯ�ϰ��� �ߴ� �������� �������� ����. �׵��� �پ�����.
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							pItemB[i] = new class CItem;
							_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							// �α׸� ����� ���� ������ ���繰 
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
						else {
							pItemB[i] = (class CItem*)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							// �α׸� ����� ���� ������ ���繰 
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
					}

					// ���� �������� ���� �� 
					for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						bAddItem(iClientH, pItemB[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = 0;
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
							//
							iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;
							// v1.41 !!!
							SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
							// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
							//
						}
						else {
							// ���� ������ �������̶�� �����Ѵ�.
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], 0, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						bAddItem(iExH, pItemA[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = 0;

						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
							//
							iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;
							// v1.41 !!!
							SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
							// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
							//
						}
						else {
							// ���� ������ �������̶�� �����Ѵ�.
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], 0, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					m_pClientList[iClientH]->m_bIsExchangeMode = false;
					m_pClientList[iClientH]->m_bIsExchangeConfirm = false;
					std::memset(m_pClientList[iClientH]->m_cExchangeName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					m_pClientList[iClientH]->m_iExchangeH = 0;
					m_pClientList[iClientH]->iExchangeCount = 0;

					m_pClientList[iExH]->m_bIsExchangeMode = false;
					m_pClientList[iExH]->m_bIsExchangeConfirm = false;
					std::memset(m_pClientList[iExH]->m_cExchangeName, 0, sizeof(m_pClientList[iExH]->m_cExchangeName));
					m_pClientList[iExH]->m_iExchangeH = 0;
					m_pClientList[iExH]->iExchangeCount = 0;

					for (i = 0; i < 4; i++) {
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
					}

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);
					SendNotifyMsg(0, iExH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);

					// ���� �缳��
					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;
				}
			}
		}
		else {
			// ��ȯ�� ������ ����. ��ȯ�� ��� �ȴ�.
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
	int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

bool CGame::bAddItem(int iClientH, CItem* pItem, char cMode)
{
	int iRet, iEraseReq;


	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		return true;
	}
	else {
		// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY,
			pItem);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);



		return true;
	}

	return false;
}


int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	int iQuest, iEraseReq;
	class CItem* pItem;
	uint32_t iExp;

	if (m_pClientList[iClientH] == 0) return 0;

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == 0) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			if (m_pClientList[iClientH]->m_bIsQuestCompleted) {
				if ((m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					(m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != 0)) {
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem)) {
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
						if (iEraseReq == 1) delete pItem;

						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount,
							m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						_ClearQuestStatus(iClientH);
						return -5;
					}
					else {
						delete pItem;
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount,
							m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount,
						"°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					iExp = iDice(1, (10 * m_pClientList[iClientH]->m_iLevel));
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;

					m_pClientList[iClientH]->m_iExpStock += iExp;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp,
						"°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0,
						"                     ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}

		return -4;
	}

	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;

		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		return iQuest;
	}
	else return -2;

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	if (m_pClientList[iClientH] == 0) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (200), 0, 0, 0, 0);
			return 1000;
		}
		else
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (201), 0, 0, 0, 0);
				return 1001;
			}
	}
	else
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (202), 0, 0, 0, 0);
				return 1002;
			}
			else
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (203), 0, 0, 0, 0);
					return 1003;
				}
		}
		else
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (204), 0, 0, 0, 0);
					return 1004;
				}
				else
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (205), 0, 0, 0, 0);
						return 1005;
					}
					else
						if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (206), 0, 0, 0, 0);
							return 1006;
						}
			}

	return 0;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == 0) return -1;

	// ÀûÇÕÇÑ ¹Ì¼Ç ¹è¿­ ÃÊ±âÈ­.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) {

			if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

			if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
				// °í·ÁÇØ¾ß ÇÒ ½ºÅ³ÀÌ ÀÖ´Ù. 
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] <
					m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
			}

			// Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1ÀÎ Äù½ºÆ®¸¸ ºÎ¿©µÈ´Ù.
			if ((m_bIsCrusadeMode) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP;
			// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ò¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1Àº ¼±ÅÃµÇÁö ¾Ê´Â´Ù.
			if ((m_bIsCrusadeMode == false) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP;

			if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

			// ¿©±â±îÁö ¿À¸é Á¶°Ç¿¡ ÇÕ´çÇÑ Äù½ºÆ®´Ù. µî·ÏÇÑ´Ù. 
			iQuestList[iIndex] = i;
			iIndex++;

		SFQ_SKIP:;
		}

	// iIndex°³ ¸¸Å­ÀÇ Á¶°Ç¿¡ ¸¸Á·ÇÏ´Â Äù½ºÆ®¸¦ Ã£¾Ò´Ù. ±× Áß¿¡¼­ ·£´ýÇÏ°Ô 1°³¸¦ ¼±ÅÃÇÑ´Ù.
	if (iIndex == 0) return -1;
	iQuest = (iDice(1, iIndex)) - 1;
	iQuestIndex = iQuestList[iQuest];
	// Äù½ºÆ® ÀÎµ¦½º 
	iReward = iDice(1, 3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// Äù½ºÆ® ÀÀ´ä ¸ðµå 
	*pRewardType = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// Äù½ºÆ® »óÇ° Á¾·ù 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// Äù½ºÆ® »óÇ° °¹¼ö 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// Äù½ºÆ® ÇØ°á½Ã ¿Ã¶ó°¡´Â °øÇåµµ 

	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// Äù½ºÆ® ¸Ê ÀÌ¸§ ¼ö·Ï 
	*pX = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}

// New 14/05/2004
void CGame::QuestAcceptedHandler(int iClientH)
{
	int iIndex;

	if (m_pClientList[iClientH] == 0) return;

	// Does the quest exist ??
	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == 0) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// Àü¸éÀü¿ë Äù½ºÆ®ÀÌ´Ù. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // ÅÚ·¹Æ÷Æ®¿ë 1È¸¼º Äù½ºÆ®. ÅÚ·¹Æ÷Æ®ÇÏ°í ³ª¸é ³¡ÀÌ´Ù. ´õÀÌ»óÀÇ Äù½ºÆ® ¿©ºÎ°¡ ¾øÀ½.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// ÇÃ·¹ÀÌ¾î°¡ Äù½ºÆ®¸¦ ¼ö¶ôÇß´Ù. Äù½ºÆ® ¹øÈ£, ID°ª ÇÒ´ç.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = false;

	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
	int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
	char cTargetName[21];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) {
		// ÇÒ´çµÈ Quest°¡ ¾ø´Ù. 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0);
	}
	else {
		// ÇÒ´çµÈ Quest ³»¿ëÀ» º¸³»ÁØ´Ù.
		iWho = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX = m_pQuestConfigList[iIndex]->m_sX;
		iY = m_pQuestConfigList[iIndex]->m_sY;
		iRange = m_pQuestConfigList[iIndex]->m_iRange;
		std::memset(cTargetName, 0, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, 0,
			iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
	int iIndex;
	char cTargetName[21];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) return;
	if (m_pQuestConfigList[iIndex] == 0) return;

	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// Äù½ºÆ® ID °ªÀÌ ´Ù¸£´Ù. ÇÒ´ç¹Þ¾Ò´ø ±× Äù½ºÆ®°¡ ¾Æ´Ï´Ù. Äù½ºÆ®´Â Ãë¼ÒµÈ´Ù.
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType = 0;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// ¸ó½ºÅÍ »ç³ÉÀÇ °æ¿ì ¸Å¹ø ¸ó½ºÅÍ »ç³É½Ã ¸Ê ÀÌ¸§À» ºñ±³ÇÏ´Â °ÍÀº ºñÈ¿À²ÀûÀÌ¹Ç·Î ¹Ì¸® ¸Ê ÀÌ¸§À» ºñ±³, ÇÃ·¡±×¸¦ ¼³Á¤ÇØ ³õ´Â´Ù. 
		std::memset(cTargetName, 0, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = true;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = false;
		break;
	}

}

bool CGame::_bCheckIsQuestCompleted(int iClientH)
{
	int iQuestIndex;

	// Äù½ºÆ®°¡ Á¾·áµÇ¾ú´ÂÁö ÆÇ´ÜÇÑ ÈÄ ¸Þ½ÃÁö Ã³¸®.
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted) return false;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == 0) return false;

	if (m_pQuestConfigList[iQuestIndex] != 0) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ((m_pClientList[iClientH]->m_bQuestMatchFlag_Loc) &&
				(m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount)) {
				// ¸ó½ºÅÍ »ç³É Äù½ºÆ®°¡ ¿Ï·áµÇ¾ú´Ù. ¿Ï·áµÇ¾úÀ¸¸é ÀÇ·ÚÀÎ¿¡°Ô µ¹¾Æ°¡ ´ëÈ­¸¦ ÇÏ¸é Æ÷»ó¹Þ´Â´Ù. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ((m_pClientList[iClientH]->m_bQuestMatchFlag_Loc) && // ¸ÊÀº ¸Â°í
				(m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // ÁÂÇ¥µµ ÀÌ³»ÀÌ¸é 
				(m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange)) {
				// Æ¯Á¤ Àå¼Ò Ã£¾Æ°¡±â Äù½ºÆ® ¿Ï·á.
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;
		}
	}

	return false;
}






int CGame::SendItemNotifyMsg(int iClientH, uint16_t wMsgType, CItem* pItem, int iV1)
{
	int iRet = 0;

	if (m_pClientList[iClientH] == 0) return 0;

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
	{
		hb::net::PacketNotifyItemObtained pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.is_new = 1;
		memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
		pkt.count = pItem->m_dwCount;
		pkt.item_type = pItem->m_cItemType;
		pkt.equip_pos = pItem->m_cEquipPos;
		pkt.is_equipped = 0;
		pkt.level_limit = pItem->m_sLevelLimit;
		pkt.gender_limit = pItem->m_cGenderLimit;
		pkt.cur_lifespan = pItem->m_wCurLifeSpan;
		pkt.weight = pItem->m_wWeight;
		pkt.sprite = pItem->m_sSprite;
		pkt.sprite_frame = pItem->m_sSpriteFrame;
		pkt.item_color = pItem->m_cItemColor;
		pkt.spec_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
		pkt.attribute = pItem->m_dwAttribute;
		pkt.item_id = pItem->m_sIDnum;
		pkt.max_lifespan = pItem->m_wMaxLifeSpan;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMPURCHASED:
	{
		hb::net::PacketNotifyItemPurchased pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.is_new = 1;
		memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
		pkt.count = pItem->m_dwCount;
		pkt.item_type = pItem->m_cItemType;
		pkt.equip_pos = pItem->m_cEquipPos;
		pkt.is_equipped = 0;
		pkt.level_limit = pItem->m_sLevelLimit;
		pkt.gender_limit = pItem->m_cGenderLimit;
		pkt.cur_lifespan = pItem->m_wCurLifeSpan;
		pkt.weight = pItem->m_wWeight;
		pkt.sprite = pItem->m_sSprite;
		pkt.sprite_frame = pItem->m_sSpriteFrame;
		pkt.item_color = pItem->m_cItemColor;
		pkt.cost = static_cast<uint16_t>(iV1);
		pkt.item_id = pItem->m_sIDnum;
		pkt.max_lifespan = pItem->m_wMaxLifeSpan;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	}

	return iRet;
}

bool CGame::_bCheckItemReceiveCondition(int iClientH, CItem* pItem)
{
	int i;

	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > _iCalcMaxLoad(iClientH))
		return false;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) return true;

	return false;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_iQuest = 0;
	m_pClientList[iClientH]->m_iQuestID = 0;
	m_pClientList[iClientH]->m_iQuestRewardType = 0;
	m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = false;
}

int CGame::iGetMaxHP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	int iRet = CalculateMaxHP(
		m_pClientList[iClientH]->m_iVit,
		m_pClientList[iClientH]->m_iLevel,
		m_pClientList[iClientH]->m_iStr,
		m_pClientList[iClientH]->m_iAngelicStr);

	// Apply side effect reduction if active
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return CalculateMaxMP(
		m_pClientList[iClientH]->m_iMag,
		m_pClientList[iClientH]->m_iAngelicMag,
		m_pClientList[iClientH]->m_iLevel,
		m_pClientList[iClientH]->m_iInt,
		m_pClientList[iClientH]->m_iAngelicInt);
}

int CGame::iGetMaxSP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return CalculateMaxSP(
		m_pClientList[iClientH]->m_iStr,
		m_pClientList[iClientH]->m_iAngelicStr,
		m_pClientList[iClientH]->m_iLevel);
}

void CGame::GetMapInitialPoint(int iMapIndex, short* pX, short* pY, char* pPlayerLocation)
{
	int i, iTotalPoint;
	POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == 0) return;

	// ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
		if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
			pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
			pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
			iTotalPoint++;
		}

	if (iTotalPoint == 0) return;

	// v1.42 ¼Ò¼ÓÀÌ Áß¸³ÀÌ¸é ¹«Á¶°Ç Initial PointÀÇ Ã³À½À¸·Î °£´Ù.
	if ((pPlayerLocation != 0) && (memcmp(pPlayerLocation, "NONE", 4) == 0))
		i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = static_cast<short>(pList[i].x);
	*pY = static_cast<short>(pList[i].y);
}




// MODERNIZED: New function that polls login client socket instead of handling window messages
void CGame::OnLoginClientSocketEvent(int iLoginClientH)
{
	int iRet;

	if (iLoginClientH < 0 || iLoginClientH >= DEF_MAXCLIENTLOGINSOCK) return;

	auto p = _lclients[iLoginClientH];
	if (p == 0) return;

	iRet = p->_sock->Poll();

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientLoginRead(iLoginClientH);
		break;

	case DEF_XSOCKEVENT_BLOCK:
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode Login notmatch!", iLoginClientH);
		PutLogList(G_cTxt);
		DeleteLoginClient(iLoginClientH);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteLoginClient(iLoginClientH);
		break;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	int iLogSockH, iRet;

	/*iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;*/

	iTmp = WM_USER_BOT_ACCEPT;
	iLogSockH = message - iTmp - 1;

	/*if (m_pSubLogSock[iLogSockH] == 0) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);*/

	auto p = _lclients[iLogSockH];
	if (p == 0) return;

	iRet = p->_sock->Poll();

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:

		/*std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = true;
		m_iSubLogSockActiveCount++;*/
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientLoginRead(iLogSockH); //OnSubLogRead(iLogSockH);
		break;

	case DEF_XSOCKEVENT_BLOCK:
		/*std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);*/
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode Login notmatch!", iLogSockH);
		PutLogList(G_cTxt);
		DeleteLoginClient(iLogSockH);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		/*delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = 0;
		m_bIsSubLogSockAvailable[iLogSockH] = false;

		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);

		m_pSubLogSock[iLogSockH] = new class XSocket(DEF_SERVERSOCKETBLOCKLIMIT);  // MODERNIZED: Removed m_hWnd
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort);  // MODERNIZED: Removed WM_ONLOGSOCKETEVENT
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);*/

		break;
	}
}

LoginClient::~LoginClient()
{
	if (_sock)
		delete _sock;
}

void CGame::OnClientLoginRead(int h)
{
	char* pData, cKey;
	uint32_t  dwMsgSize;

	if (_lclients[h] == 0) return;

	pData = _lclients[h]->_sock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, h, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

void CGame::DeleteLoginClient(int h)
{
	if (!_lclients[h])
		return;

	_lclients[h]->_timeout_tm = GameClock::GetTimeMS();
	_lclients_disconn.push_back(_lclients[h]);
	//delete _lclients[h];
	_lclients[h] = nullptr;
}

void CGame::OnSubLogRead(int iIndex)
{
	/*uint32_t dwMsgSize;
	char * pData, cKey;

	   pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	   if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, 0, cKey) == false) {
		   PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	   }*/
}

void CGame::_CheckGateSockConnection()
{
	/*if (m_bIsServerShutdowned ) return;

	if (m_iGateSockConnRetryTimes != 0) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes);
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	if (m_iGateSockConnRetryTimes > 20) {
		if (m_bOnExitProcess == false) {
			m_iFinalShutdownCount = 1;
			m_bOnExitProcess     = true;
			m_dwExitProcessTime  = GameClock::GetTimeMS();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}*/
}

bool CGame::_bCheckSubLogSocketIndex()
{
	/*int  iCnt;
	bool bLoopFlag;

	   m_iCurSubLogSockIndex++;
	   if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	   iCnt = 0;
	   bLoopFlag = false;
	   while (bLoopFlag == false) {
		   if ((m_pSubLogSock[m_iCurSubLogSockIndex] != 0) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] ))
				bLoopFlag = true;
		   else m_iCurSubLogSockIndex++;

		   iCnt++;
		   if (iCnt >= DEF_MAXSUBLOGSOCK) {
			   if (m_bOnExitProcess == false) {
				   m_cShutDownCode      = 3;
				   m_bOnExitProcess     = true;
				   m_dwExitProcessTime  = GameClock::GetTimeMS();
				   PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			   }
			   return false;
		   }
	   }*/

	return true;
}

void CGame::BuildItemHandler(int iClientH, char* pData)
{
	char cName[21], cElementItemID[6];
	int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
	class  CItem* pItem;
	bool   bFlag, bItemFlag[6];
	double dV1, dV2, dV3;
	uint32_t  dwTemp, dwTemp2;
	uint16_t   wTemp;

	// ����ڰ� ������ ������ ��û�ߴ�. 
	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonBuild>(
		pData, sizeof(hb::net::PacketCommandCommonBuild));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);

	//testcode
	//PutLogList(cName);

	std::memset(cElementItemID, 0, sizeof(cElementItemID));
	for (i = 0; i < 6; i++) {
		cElementItemID[i] = static_cast<char>(pkt->item_ids[i]);
	}

	// �պκ��� ������� ���ش�.
	bFlag = true;
	while (bFlag) {
		bFlag = false;
		for (i = 0; i <= 4; i++)
			if ((cElementItemID[i] == -1) && (cElementItemID[i + 1] != -1)) {
				cElementItemID[i] = cElementItemID[i + 1];
				cElementItemID[i + 1] = -1;
				bFlag = true;
			}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = false;

	//testcode
	//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ���д�. 
		// ������ ���ۿ� �����Ͽ���.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
		return;
	}

	// ������ �������� �� �����ϴ��� �˻�.
	for (i = 0; i < 6; i++)
		if (cElementItemID[i] != -1) {
			// �߸��� Item ID���̴�. ����
			if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == 0) return;
		}

	// �ش� �̸��� ���� �������� ���� ������ ����Ʈ���� ã�´�.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) {
			if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
				// �������� ã�Ҵ�. ���� ���ǰ� �������� ��ġ�ϴ��� �˻�.

				// ��ų�� ���Ƽ� ���� �Ұ���. ���� Ŭ���̾�Ʈ���� �ɷ� ����. 
				if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;

				for (x = 0; x < DEF_MAXITEMS; x++)
					if (m_pClientList[iClientH]->m_pItemList[x] != 0)
						iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
					else iItemCount[x] = 0;

				// �ش� ���� �������� ��ᰡ ��������� �˻��Ѵ�. ���Ҿ� ���� �������� ����ġ ���� ���.
				iMatch = 0;
				iTotalValue = 0;

				for (x = 0; x < 6; x++) {
					if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
						iMatch++;
					}
					else {
						for (z = 0; z < 6; z++)
							if ((cElementItemID[z] != -1) && (bItemFlag[z] == false)) {

								if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
									(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >=
										static_cast<uint32_t>(m_pBuildItemList[i]->m_iMaterialItemCount[x])) &&
									(iItemCount[cElementItemID[z]] > 0)) {
									// ����� �ϳ��� ã�Ҵ�. 
									iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
									if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
										// ����� ������ �� ��ų ������ ��ȸ�Ѵٸ� ������ �����. 
										iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13]) / 2;
									}

									iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
									iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
									iMatch++;
									bItemFlag[z] = true;

									goto BIH_LOOPBREAK;
								}
							}
					BIH_LOOPBREAK:;
					}
				}

				// ���⼭ iMatch�� 6�̸� ������ ���� ������ ������ ���̴�. 
				if (iMatch != 6) {
					// ��� ����. ������ ���� �Ұ� 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
					return;
				}

				// ���� ��� 
				dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
				if (iTotalValue <= 0)
					dV3 = 1.0f;
				else dV3 = (double)iTotalValue;
				dV1 = (double)(dV3 / dV2) * 100.0f;

				// ��з��� �ٲ� ��.
				iTotalValue = (int)dV1;

				// ������ ���� 
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == false) {
					delete pItem;
					return;
				}

				// �������� Custom-Made���� ��Ÿ���� �÷��׸� �Է� 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0xFFFFFFFE;
				dwTemp = dwTemp | 0x00000001;
				pItem->m_dwAttribute = dwTemp;

				if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
					// ������� �������� ���� ���� ���(�װ�)�̶�� ��� ���ؿ� ���� ������ �Է��Ѵ�. 
					iTemp = iDice(1, (iPlayerSkillLevel / 2) + 1) - 1;
					pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel / 2) + iTemp;
					// v2.15 ���� �����ۿ� ������ ������ȣ �߰� 
					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue3 = static_cast<short>(GameClock::GetTimeMS());

				}
				else {
					// ���� ���� ��ᰡ �ƴϰ� ���⳪ ������� 
					// ������ �Ӽ��� �Է� 
					dwTemp = pItem->m_dwAttribute;
					dwTemp = dwTemp & 0x0000FFFF;

					dwTemp2 = (uint16_t)m_pBuildItemList[i]->m_wAttribute;
					dwTemp2 = dwTemp2 << 16;

					dwTemp = dwTemp | dwTemp2;
					pItem->m_dwAttribute = dwTemp;

					iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
					//��� ������ ���� ���� �Է�: SpecEffectValue1�� ����, SpecEffectValue2�� ���� ����ġ 

					// 1. ���� ����ġ ���(�����)
					if (iResultValue > 0) {
						dV2 = (double)iResultValue;
						dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
						dV1 = (dV2 / dV3) * 100.0f;
						pItem->m_sItemSpecEffectValue2 = (int)dV1;
					}
					else if (iResultValue < 0) {
						dV2 = (double)(iResultValue);
						dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
						dV1 = (dV2 / dV3) * 100.0f;
						pItem->m_sItemSpecEffectValue2 = (int)dV1;
					}
					else pItem->m_sItemSpecEffectValue2 = 0;

					// 2. ���ο� �ִ� ���� ��� 
					dV2 = (double)pItem->m_sItemSpecEffectValue2;
					dV3 = (double)pItem->m_wMaxLifeSpan;
					dV1 = (dV2 / 100.0f) * dV3;

					iTemp = (int)pItem->m_wMaxLifeSpan;
					iTemp += (int)dV1;

					// v2.15 ���� �����ۿ� ������ ������ȣ �߰� 
					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue3 = static_cast<short>(GameClock::GetTimeMS());

					if (iTemp <= 0)
						wTemp = 1;
					else wTemp = (uint16_t)iTemp;

					if (wTemp <= pItem->m_wMaxLifeSpan * 2) {
						// ������ ���� �ʹ� ���� �������� ������ �������� 
						pItem->m_wMaxLifeSpan = wTemp;
						pItem->m_sItemSpecEffectValue1 = (short)wTemp;
						pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					}
					else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

					//Custom-Item�� ������ 2��. 
					pItem->m_cItemColor = 2;
				}

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
				PutLogList(G_cTxt);

				// ������ ���� 
				bAddItem(iClientH, pItem, 0);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, 0, 0); // Integer�� �����ϱ� ���� 

#ifdef DEF_TAIWANLOG
				// v1.41 ��� �������̶�� �α׸� �����. 
				_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int)-1, pItem);
#endif	

				// ���������� ��ᰡ �Ǵ� �������� ���ش�. 
				for (x = 0; x < 6; x++)
					if (cElementItemID[x] != -1) {
						if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == 0) {
							// ### BUG POINT!!!
							// ������ ������ ������.
							std::snprintf(G_cTxt, sizeof(G_cTxt), "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
							PutLogFileList(G_cTxt);
						}
						else {
							iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
							if (iCount < 0) iCount = 0;
							SetItemCount(iClientH, cElementItemID[x], iCount);
						}
					}

				// ���� ��ų�� ī��Ʈ �Ѵ�. �� �������� �ִ� ���� ��ų �ѵ� �������� �����ϴ�.  
				if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
					CalculateSSN_SkillIndex(iClientH, 13, 1);

				// v1.41 �ҷ��� ����ġ ���� 
				GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit / 4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

				return;
			}
		}

}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1:
		// Slime, Orc, Orge, WereWolf, YB-, Rabbit, Mountain-Giant, Stalker, Hellclaw, 
		// Wyvern, Fire-Wyvern, Barlog, Tentocle, Centaurus, Giant-Lizard, Minotaurus,
		// Abaddon, Claw-Turtle, Giant-Cray-Fish, Giant-Plant, MasterMage-Orc, Nizie,
		// Tigerworm
		switch (iDice(1, 2)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 2:
		// Giant-Ant, Cat, Giant-Frog, 
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 3:
		// Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1, 4)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		case 4: cSA = 6; break; // Critical Poisonous
		}
		break;

	case 4:
		// no linked Npc
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 7; break; // Explosive
		}
		break;

	case 5:
		// Stone-Golem, Clay-Golem, Beholder, Cannibal-Plant, Rudolph, DireBoar
		switch (iDice(1, 4)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 7; break; // Explosive
		case 4: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 6:
		// no linked Npc
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 7:
		// Orc-Mage, Unicorn
		switch (iDice(1, 3)) {
		case 1: cSA = 1; break; // Clairvoyant
		case 2: cSA = 2; break; // Distruction of Magic Protection
		case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 8:
		// Frost, Ice-Golem, Ettin, Gagoyle, Demon, Liche, Hellbound, Cyclops, 
		// Skeleton
		switch (iDice(1, 5)) {
		case 1: cSA = 1; break; // Clairvoyant
		case 2: cSA = 2; break; // Distruction of Magic Protection
		case 3: cSA = 4; break; // Anti-Magic Damage
		case 4: cSA = 3; break; // Anti-Physical Damage
		case 5: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 9:
		// no linked Npc
		cSA = static_cast<char>(iDice(1, 8)); // All abilities available
		break;
	}

	return cSA;
}

void CGame::CheckSpecialEvent(int iClientH)
{
	class CItem* pItem;
	char  cItemName[21];
	int   iEraseReq;

	if (m_pClientList[iClientH] == 0) return;

	//v1.42 ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ÁØ´Ù. 2000.8.1ÀÏ 1ÁÖ³â ¹ÝÁö ¼ö¿© 
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {

		// Àú·¾Àº ÁÖÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}

		std::memset(cItemName, 0, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing");

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get MemorialRing  : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor = 9;

				// ¾ÆÀÌÅÛ ¹Þ¾ÒÀ¸¹Ç·Î Å¬¸®¾î.
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}


void CGame::_AdjustRareItemValue(CItem* pItem)
{
	uint32_t dwSWEType, dwSWEValue;
	double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != 0) {
		dwSWEType = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
		// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 
		// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
		switch (dwSWEType) {
		case 0: break;

		case 5: // ¹ÎÃ¸ÀÇ 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // °¡º­¿î 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue * 4);
			dV1 = (dV3 / 100.0f) * dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // °­È­µÈ 
		case 9: // °í´ë¹®¸íÀÇ 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue * 7);
			dV1 = (dV3 / 100.0f) * dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char* pData)
{
	char* cp;
	int iRet, iClientSize;

	if (m_pClientList[iClientH] == 0) return;
	if (m_dwNoticementDataSize < 10) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestNoticement>(
		pData, sizeof(hb::net::PacketRequestNoticement));
	if (!pkt) return;
	iClientSize = pkt->value;

	if (iClientSize != m_dwNoticementDataSize) {
		// Å¬¶óÀÌ¾ðÆ®°¡ °®°í ÀÖ´Â ÆÄÀÏ »çÀÌÁî¿Í ´Ù¸£¸é ³»¿ëÀ» ¸ðµÎ º¸³½´Ù.
		cp = new char[m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader)];
		std::memset(cp, 0, m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader));
		memcpy((cp + sizeof(hb::net::PacketHeader)), m_pNoticementData, m_dwNoticementDataSize);

		{
			auto* header = reinterpret_cast<hb::net::PacketResponseNoticementHeader*>(cp);
			header->header.msg_id = MSGID_RESPONSE_NOTICEMENT;
			header->header.msg_type = DEF_MSGTYPE_REJECT;
		}

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader));

		delete cp;
	}
	else {
		hb::net::PacketResponseNoticementHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_NOTICEMENT;
		pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	// ¿¡·¯ ¹ß»ýÇØµµ ²÷Áö ¾Ê´Â´Ù.	
}

void CGame::RequestNoticementHandler(int iClientH)
{
	DWORD lpNumberOfBytesRead;

	if (m_pClientList[iClientH] == 0) return;

	HANDLE hFile = CreateFile("GameConfigs\\Noticement.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	uint32_t dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		return;
	}

	std::memset(G_cData50000, 0, sizeof(G_cData50000));

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, G_cData50000 + sizeof(hb::net::PacketHeader), dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	{
		auto* header = reinterpret_cast<hb::net::PacketResponseNoticementHeader*>(G_cData50000);
		header->header.msg_id = MSGID_RESPONSE_NOTICEMENT;
		header->header.msg_type = DEF_MSGTYPE_CONFIRM;
	}

	int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, dwFileSize + 2 + sizeof(hb::net::PacketHeader));

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		return;
	}
}


void CGame::RequestCheckAccountPasswordHandler(char* pData, uint32_t dwMsgSize)
{
	int* ip, i, iLevel;
	char* cp, cAccountName[11], cAccountPassword[11];

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	std::memset(cAccountName, 0, sizeof(cAccountName));
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int*)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
			// °°Àº °èÁ¤À» Ã£¾Ò´Ù. ¸¸¾à ÆÐ½º¿öµå³ª ·¹º§ÀÌ ´Ù¸£¸é µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í Á¢¼ÓÀ» ²÷´Â´Ù. 
			if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
				PutLogList(G_cTxt);
				// µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í ²÷´Â´Ù.
				DeleteClient(i, false, true);
				return;
			}
		}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
	int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pMapList[cMapIndex] == 0) return;

	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // ÃÖ´ë ¹üÀ§´Â 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
		for (iY = dY - iRange; iY <= dY + iRange; iY++) {
			sOwnerH = 0;
			if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
				m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

			if (sOwnerH != 0) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) break;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) break;
					// ¸ó½ºÅÍÀÇ Á¾·ù¿¡ µû¶ó ±æµé¿©Áú °ÍÀÎÁö¸¦ °áÁ¤ÇÑ´Ù.
					iTamingLevel = 10;
					switch (m_pNpcList[sOwnerH]->m_sType) {
					case 10:							// ½½¶óÀÓ  
					case 16: iTamingLevel = 1; break;	// °³¹Ì
					case 22: iTamingLevel = 2; break;	// ¹ì
					case 17:							// Àü°¥
					case 14: iTamingLevel = 3; break;	// ¿ÀÅ©
					case 18: iTamingLevel = 4; break;   // Á»ºñ
					case 11: iTamingLevel = 5; break;	// ½ºÄÌ·¹Åæ
					case 23:
					case 12: iTamingLevel = 6; break;	// °ñ·½
					case 28: iTamingLevel = 7; break;	// Æ®·Ñ
					case 13:							// ½ÎÀÌÅ¬·Ó½º
					case 27: iTamingLevel = 8; break;	// ÇïÇÏ¿îµå
					case 29: iTamingLevel = 9; break;	// ¿À¿ì°Å
					case 33: iTamingLevel = 9; break;	// ¿þ¾î¿ïÇÁ
					case 30: iTamingLevel = 9; break;  // ¸®Ä¡
					case 31:
					case 32: iTamingLevel = 10; break;  // µ¥¸ó, À¯´ÏÄÜ
					}

					iResult = (iSkillLevel / 10);

					// ½ºÅ³ÀÇ µî±Þ¿¡ µû¶ó ±æµéÀÏ ¼ö ÀÖ´Â °¹¼ö°¡ ´Þ¶óÁø´Ù.
					if (iResult < iTamingLevel) break;

					break;
				}
			}
		}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// ¸¶¹ý ´É·Â ½ºÅ³À» 20À¸·Î º¯°æÈÄ ¾Ë·ÁÁÜ
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);
	// v1.4311 ½ºÅ³ÀÇ ÃÑ ÇÕÀ» Ã¼Å©
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char* pData)
{
	char cDir, mapData[3000];
	short dX, dY;
	int   iRet, iSize;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestPanning>(pData, sizeof(hb::net::PacketRequestPanning));
	if (!req) return 0;
	cDir = static_cast<char>(req->dir);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
		/*
		player is in the center, and is trying to pan,
		directions not responding or causing a break will be kept as X,
		others are the cDir case...
				8	1	X

				7	_	X

				X	X	X
		*/
	}

	m_pClientList[iClientH]->m_sX = dX;
	m_pClientList[iClientH]->m_sY = dY;
	m_pClientList[iClientH]->m_cDir = cDir;

	iSize = iComposeMoveMapData((short)(dX - 12), (short)(dY - 9), iClientH, cDir, mapData);

	hb::net::PacketWriter writer;
	writer.Reserve(sizeof(hb::net::PacketResponsePanningHeader) + iSize);

	auto* pkt = writer.Append<hb::net::PacketResponsePanningHeader>();
	pkt->header.msg_id = MSGID_RESPONSE_PANNING;
	pkt->header.msg_type = DEF_OBJECTMOVE_CONFIRM;
	pkt->x = static_cast<int16_t>(dX - 12);
	pkt->y = static_cast<int16_t>(dY - 9);
	pkt->dir = static_cast<uint8_t>(cDir);

	writer.AppendBytes(mapData, iSize);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::RequestRestartHandler(int iClientH)
{
	char  cTmpMap[32];

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled) {

		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));

		if (strcmp(m_pClientList[iClientH]->m_cLocation, "NONE") == 0) {
			// �����ڶ��  default������ ����.
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// �Ҽ��� �ִٸ� �Ҽ� ������ ��Ȱ������ ����.
			if ((strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") == 0) || (strcmp(m_pClientList[iClientH]->m_cLocation, "arehunter") == 0)) {
				if (m_bIsCrusadeMode) {
					// ũ�缼�̵� ��忡�� ����� ���: ���� �ʿ��� �����ð� ���� �� ����.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04 10�� �ȿ� �� ������ ������ ������.
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0) {
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3; // 3�� 
				}
				else if (m_pClientList[iClientH]->m_iLevel > 80)
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
			else {
				if (m_bIsCrusadeMode) {
					// ũ�缼�̵� ��忡�� ����� ���: ���� �ʿ��� �����ð� ���� �� ����.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04 10�� �ȿ� �� ������ ������ ������.
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0) {
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3; // 3�� 

				}
				else if (m_pClientList[iClientH]->m_iLevel > 80)
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}

		// v2.04 �ٽ� �츮�� ó���� �Ѵ�. HP, ����� ���� ����
		m_pClientList[iClientH]->m_bIsKilled = false;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		std::memset(cTmpMap, 0, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler������ m_cMapName�� ���� ������ �״�� �Ķ���ͷ� �Ѱ��ָ� ������
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char* pData)
{
	int i, iAmount;
	char cIndex;

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestSellItemList>(pData, sizeof(hb::net::PacketRequestSellItemList));
	if (!req) return;

	// ³»¿ëÀ» ´Ù ÀÐ¾ú´Ù. ¼ø¼­´ë·Î ÆÈ¾ÆÄ¡¿î´Ù.
	for (i = 0; i < 12; i++) {
		cIndex = static_cast<char>(req->entries[i].index);
		iAmount = req->entries[i].amount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == 0) return;

		// cIndex¿¡ ÇØ´çÇÏ´Â ¾ÆÀÌÅÛÀ» ÆÇ´Ù.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, 0);
		// ÀÌ ·çÆ¾À» ¼öÇàÇÑ ´ÙÀ½ Å¬¶óÀÌ¾ðÆ®°¡ »èÁ¦µÇ¾úÀ» ¼ö ÀÖÀ¸´Ï ÁÖÀÇ!
		if (m_pClientList[iClientH] == 0) return;
	}
}

void CGame::RequestShopContentsHandler(int iClientH, char* pData)
{
	if (m_pClientList[iClientH] == 0) return;
	if (!m_bIsShopDataAvailable) {
		// No shop data configured
		return;
	}

	const auto* req = hb::net::PacketCast<hb::net::PacketShopRequest>(pData, sizeof(hb::net::PacketShopRequest));
	if (!req) return;

	int16_t npcType = req->npcType;

	// Look up shop ID for this NPC type
	auto mappingIt = m_NpcShopMappings.find(static_cast<int>(npcType));
	if (mappingIt == m_NpcShopMappings.end()) {
		// No shop configured for this NPC type
		char logMsg[128];
		std::snprintf(logMsg, sizeof(logMsg), "(!) Shop request for NPC type %d - no shop mapping found", npcType);
		PutLogList(logMsg);
		return;
	}

	int shopId = mappingIt->second;

	// Get shop data
	auto shopIt = m_ShopData.find(shopId);
	if (shopIt == m_ShopData.end() || shopIt->second.itemIds.empty()) {
		// Shop exists in mapping but has no items
		char logMsg[128];
		std::snprintf(logMsg, sizeof(logMsg), "(!) Shop request for NPC type %d, shop %d - no items found", npcType, shopId);
		PutLogList(logMsg);
		return;
	}

	const ShopData& shop = shopIt->second;
	uint16_t itemCount = static_cast<uint16_t>(shop.itemIds.size());
	if (itemCount > hb::net::MAX_SHOP_ITEMS) {
		itemCount = hb::net::MAX_SHOP_ITEMS;
	}

	// Build response packet
	// Header + array of int16_t item IDs
	size_t packetSize = sizeof(hb::net::PacketShopResponseHeader) + (itemCount * sizeof(int16_t));
	char* cData = new char[packetSize];
	std::memset(cData, 0, packetSize);

	auto* resp = reinterpret_cast<hb::net::PacketShopResponseHeader*>(cData);
	resp->header.msg_id = MSGID_RESPONSE_SHOP_CONTENTS;
	resp->header.msg_type = DEF_MSGTYPE_CONFIRM;
	resp->npcType = npcType;
	resp->shopId = static_cast<int16_t>(shopId);
	resp->itemCount = itemCount;

	// Copy item IDs after header
	int16_t* itemIds = reinterpret_cast<int16_t*>(cData + sizeof(hb::net::PacketShopResponseHeader));
	for (uint16_t i = 0; i < itemCount; i++) {
		itemIds[i] = shop.itemIds[i];
	}

	// Send to client
	m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, static_cast<uint32_t>(packetSize));

	char logMsg[128];
	std::snprintf(logMsg, sizeof(logMsg), "(!) Sent shop contents: NPC type %d, shop %d, %d items", npcType, shopId, itemCount);
	PutLogList(logMsg);

	delete[] cData;
}

void CGame::JoinPartyHandler(int iClientH, int iV1, const char* pMemberName)
{
	char* cp, cData[120];
	short sAppr2;
	uint32_t* dwp;
	uint16_t* wp;
	int i;

	if (m_pClientList[iClientH] == 0) return;

	switch (iV1) {
	case 0: // ÆÄÆ¼ Å»Åð ½ÅÃ»
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ»
		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH,
			m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
			m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != 0) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			// ÀÌ¹Ì ÆÄÆ¼¿¡ °¡ÀÔÇØ ÀÖ´Ù¸é ÆÄÆ¼ °¡ÀÔ ½ÅÃ»À» ÇÒ ¼ö ¾ø´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			PutLogList("Join Party Reject (1)");
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
				// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù.
				sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				if (sAppr2 != 0) {
					// ÀüÅõ ¸ðµå »óÅÂÀÇ »ó´ë¿¡°Ô´Â ÆÄÆ¼ °¡ÀÔ ½ÅÃ»À» ÇÒ ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (2)");
				}
				else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					// ÆíÀÌ ´Ù¸£¸é ÆÄÆ¼¿¡ µé ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (3)");
				}
				else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
					// ÆÄÆ¼ °¡ÀÔÀ» ½ÅÃ»ÇÑ ´ë»óÀÌ ÀÌ¹Ì ´Ù¸¥ ÆÄÆ¼ °¡ÀÔ °ü·Ã Ã³¸®¸¦ ÇÏ°í ÀÖ´Ù. ½ÅÃ» ºÒ°¡.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (4)");
					//testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Party join reject(2) ClientH:%d ID:%d JoinName:%s", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
					PutLogList(G_cTxt);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
					std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}
				else {
					// °¡ÀÔ ½ÂÀÎ ¿©ºÎ¸¦ ¹¯´Â´Ù.
					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					std::memset(m_pClientList[i]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(0, i, DEF_NOTIFY_QUERY_JOINPARTY, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);

					// ½ÅÃ»ÇÑ Ãø¿¡´Â ÆÄÆ¼ ¸¶½ºÅÍ°¡ µÉ Ä³¸¯ÅÍÀÇ ÀÎµ¦½º¸¦ ³Ö¾îÁÜ. Ãë¼ÒÇÒ¶§ Ã³¸®ÇÏ±â À§ÇÔÀÓ.
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					// ÆÄÆ¼ »óÅÂ ¼¼Æ®
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
		break;

	case 2: // ÆÄÆ¼ ¸â¹ö È®ÀÎ ¸í·É 
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			dwp = (uint32_t*)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (uint16_t*)cp;
			*wp = 6; // ÆÄÆ¼ ¸â¹ö ¸®½ºÆ® ¿äÃ»
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}



bool CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
	int i, sX, sY, dX, dY, iGoalMapIndex;
	char cResult;

	if (m_pNpcList[iNpcH] == 0) return false;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return false;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		// »çÅõÀåÀÇ ¿¡³ÊÁö ½ºÇÇ¾î
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX - 2) && (sX <= dX + 2) && (sY >= dY - 2) && (sY <= dY + 2)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX - 2) && (sX <= dX + 2) && (sY >= dY - 2) && (sY <= dY + 2)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Elvine Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						//
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
		}
		return false;
	}
	else {
		// ¹Ìµé·£µå ¿¡³ÊÁö ½ºÇÇ¾î.

		// ¿¡³ÊÁö ½ºÇÇ¾îÀÇ ÇöÀç À§Ä¡°¡ °ñ°ú °ÅÀÇ À¯»çÇÏ¸é 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX - 4) && (sX <= dX + 4) && (sY >= dY - 4) && (sY <= dY + 4)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX - 4) && (sX <= dX + 4) && (sY >= dY - 4) && (sY <= dY + 4)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						//
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}
		return false;
	}
}

void CGame::EnergySphereProcessor(bool bIsAdminCreate, int iClientH)
{
	int i, iNamingValue, iCIndex, iTemp, pX, pY;
	char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != true) {

		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == 0) return;
		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾îÁú È®·üÀº 3ÃÊ¸¶´Ù 2000ºÐÀÇ 1
		if (iDice(1, 2000) != 123) return;
		// ¿¡³ÊÁö ½ºÇÇ¾î´Â ÃÑ »ç¿ëÀÚ 500¸í ÀÌ»óÀÏ¶§¸¸ ¸¸µé¾î Áø´Ù.
		if (m_iTotalGameServerClients < 500) return;

		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == 0) return;

		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		std::memset(cWaypoint, 0, sizeof(cWaypoint));

		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			std::memset(cName_Internal, 0, sizeof(cName_Internal));
			std::snprintf(cName_Internal, sizeof(cName_Internal), "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;

			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false)) == false) {
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == 0) return;

		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, 0, 0);
			}

		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == 0) return;

		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		std::memset(cWaypoint, 0, sizeof(cWaypoint));

		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			std::memset(cName_Internal, 0, sizeof(cName_Internal));
			std::snprintf(cName_Internal, sizeof(cName_Internal), "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false)) == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == 0) return;

		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, 0, 0);
			}

		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
	uint32_t dwTime = GameClock::GetTimeMS();
	short sTemp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = true;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
	_ClearQuestStatus(iClientH);
	// Äù½ºÆ®°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
}

int CGame::iGetItemWeight(CItem* pItem, int iCount)
{
	int iWeight;

	// ¾ÆÀÌÅÛÀÇ ¼ö·®¿¡ µû¸¥ ¹«°Ô¸¦ °è»êÇÑ´Ù. GoldÀÎ °æ¿ì ¹«°Ô¸¦ 20ºÐÀÇ 1·Î º¯°æ 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{
	int i, ix, iy;
	int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {

			iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;
			m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
			m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
			m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

			// ±×µ¿¾È ÀúÀåÇß´ø TempSectorInfo¿¡¼­ Á¤º¸¸¦ ¾ò¾î SectorInfo¿¡ ÀúÀåÇÑ ´ÙÀ½ TempSectorInfo´Â Áö¿î´Ù.
			for (ix = 0; ix < DEF_MAXSECTORS; ix++)
				for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
						iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
						m_pMapList[i]->m_iMaxNx = ix;
						m_pMapList[i]->m_iMaxNy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
						iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
						m_pMapList[i]->m_iMaxAx = ix;
						m_pMapList[i]->m_iMaxAy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
						iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
						m_pMapList[i]->m_iMaxEx = ix;
						m_pMapList[i]->m_iMaxEy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
						iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
						m_pMapList[i]->m_iMaxMx = ix;
						m_pMapList[i]->m_iMaxMy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
						iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
						m_pMapList[i]->m_iMaxPx = ix;
						m_pMapList[i]->m_iMaxPy = iy;
					}
				}

			// TempSectorInfo ³¯¸°´Ù.
			m_pMapList[i]->ClearTempSectorInfo();

			// Sector Info¿¡ ÀúÀå
			if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
			if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
			if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
			if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
			if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
		}
}


void CGame::AgingMapSectorInfo()
{
	int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			for (ix = 0; ix < DEF_MAXSECTORS; ix++)
				for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
					m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;

					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity = 0;
				}
		}
}


bool CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
	int iNamingValue, ix, iy, tX, tY;
	char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;

	// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ï°Å³ª °Ç¼³ÇÑ »ç¶÷ÀÌ °øº´ÀÌ ¾Æ´Ï¸é ¹«½Ã.
	if ((m_bIsCrusadeMode == false) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return false;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// ÇØ´ç ¸Ê¿¡ Å©·ç¼¼ÀÌµå °Ç¹° °³¼ö Á¦ÇÑ¿¡ °É¸®Áö ¾Ê´Â´Ù¸é
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, 0, 0, 0, 0);
		return false;
	}

	// ÇØ´ç À§Ä¡¿¡ °ÇÃà¹° NPC¸¦ »ý¼º.
	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {

		// ¸ÕÀú ¼³Ä¡ÇÏ°íÀÚ ÇÏ´Â ±ÙÃ³¿¡ ±¸Á¶¹°ÀÌ ¾ø³ª È®ÀÎÇÑ´Ù.
		for (ix = dX - 3; ix <= dX + 5; ix++)
			for (iy = dY - 3; iy <= dX + 5; iy++) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return false;
			}

		// NPC¸¦ »ý¼ºÇÑ´Ù.
		std::memset(cNpcName, 0, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return false;

		std::memset(cName, 0, sizeof(cName));
		std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

		std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
		else {
			// ¼º°ø
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return true;
		}
	}

	return false;
}

void CGame::LocalStartCrusadeMode(uint32_t dwCrusadeGUID)
{
	int i;

	if (m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = true;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != 0) {
		// Å©·ç¼¼ÀÌµå GUID ÆÄÀÏÀ» ¸¸µç´Ù.
		_CreateCrusadeGUID(dwCrusadeGUID, 0);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
			// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ½ÃÀÛµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, 0, 0);
		}

	// ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ® HP ÃÊ±âÈ­.
	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) m_pMapList[i]->RestoreStrikePoints();

	// °¢°¢ÀÇ ¸Ê¿¡ ÃÊ±â °Ç¹° ¼³Ä¡. (¸¶³ª ½ºÅæ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ, ±×·¹ÀÌÆ® ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, °¡µåÅ¸¿öµîµî)
	CreateCrusadeStructures();

	PutLogList("(!)Crusade Mode ON.");
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE, 0, 0, 0);
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
	int i;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == false) return;
	m_bIsCrusadeMode = false;

	PutLogList("(!)Crusade Mode OFF.");

	// ¼³Ä¡µÇ¾ú´ø Å©·ç¼¼ÀÌµå °ÇÃà¹° Á¦°Å.
	RemoveCrusadeStructures();

	RemoveCrusadeNpcs();

	// ÀÌ±äÂÊ »çÀÌµå¸¦ ÀÔ·Â.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
			// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ³¡³µÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, m_iCrusadeWinnerSide);
		}
	RemoveCrusadeRecallTime();

	if (iWinnerSide == 2) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Elvine Win!");
	}
	else if (iWinnerSide == 1) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Aresden Win!");
	}
	else {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Drawn!");
	}

	if (m_iMiddlelandMapIndex != -1) {
		//bSendMsgToLS(0x3D00123C, 0, true, 0);
	}
}




void CGame::CreateCrusadeStructures()
{
	int i, z, tX, tY, iNamingValue;
	char cName[6], cNpcName[21], cNpcWayPoint[11];

	std::memset(cName, 0, sizeof(cName));
	std::memset(cNpcName, 0, sizeof(cNpcName));
	std::memset(cNpcWayPoint, 0, sizeof(cNpcWayPoint));

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
		if (m_stCrusadeStructures[i].cType != 0) {
			for (z = 0; z < DEF_MAXMAPS; z++)
				if ((m_pMapList[z] != 0) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
					// À§Ä¡°¡ ÀÏÄ¡ÇÏ´Â ¸Ê¿¡ °ÇÃà¹°À» À§Ä¡½ÃÅ²´Ù.
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
						// ÀÌ·± ÀÏÀÌ?
					}
					else {
						// NPC¸¦ »ý¼ºÇÑ´Ù.
						std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = z + 65;

						switch (m_stCrusadeStructures[i].cType) {
						case 36:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "AGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "AGT-Elvine");
							break;

						case 37:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "CGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "CGT-Elvine");
							break;

						case 40:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "ESG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "ESG-Elvine");
							break;

						case 41:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "GMG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "GMG-Elvine");
							break;

						case 42:
							strcpy(cNpcName, "ManaStone");
							break;

						default:
							strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName);
							break;
						}

						tX = (int)m_stCrusadeStructures[i].dX;
						tY = (int)m_stCrusadeStructures[i].dY;
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
							&tX, &tY, cNpcWayPoint, 0, 0, -1, false) == false) {
							// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
							PutLogList(G_cTxt);
						}
					}
				}
		}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, const char* pMapName)
{
	int i;
	int iIndex;
	uint32_t dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	// °ÔÀÌÆ® ¼­¹ö ¸Þ½ÃÁö ÀÛ¼º 
	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;

	memcpy(cp, pMapName, 10);
	cp += 10;*/
	//

	dwTime = GameClock::GetTimeMS();

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÄÁ½ºÆ®·°Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù. 
	// ÅÚ·¹Æ÷Æ® À§Ä¡ÀÇ 2¹ø º¯¼öµéÀ» »ç¿ëÇÑ´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				// ³»¿ë °»½ÅÈÄ 
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

				//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
				//bStockMsgToGateServer(cData, 23);
				return;
			}
		}

	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û  
			//bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
	//bStockMsgToGateServer(cData, 23);
}

// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
	char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
	int i, x;
	int iNamingValue, tX, tY, ix, iy;
	int bRet;
	short sOwnerH;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	//hbest - crusade units summon mapcheck
	if (((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "toh3") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "icebound") == 0)) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
		return;
	}

	std::memset(cNpcWayPoint, 0, sizeof(cNpcWayPoint));
	std::memset(cNpcName, 0, sizeof(cNpcName));
	std::memset(cMapName, 0, sizeof(cMapName));

	// ¿¡·¯ Ã¼Å©¿ë 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum > 10) return;

	// °Ç¼³ÇÏ±â¿¡ Æ÷ÀÎÆ®°¡ ¸ðÀÚ¶õ´Ù.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// °Ç¹° ³»ºÎ¸é ÀüÀï À¯´ÏÆ® ¼ÒÈ¯ ºÒ°¡.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)) return;

	// ÀÏ´Ü ¿¡·¯¹æÁö¿ë
	cNum = 1;

	// ConstructionPoint Á¦ÇÑÀ» °è»êÇÏ°í À¯´ÏÆ® °³¼ö¸¸Å­ ÁÙÀÎ´Ù.
	for (x = 1; x <= cNum; x++) {
		// °³¼ö¸¸Å­  ÀüÀï À¯´ÏÆ® »ý¼º 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			// ÀÌ·± ÀÏÀÌ?
		}
		else {
			// NPC¸¦ »ý¼ºÇÑ´Ù.
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			// µ¿ÀÏÇÑ Å¸ÀÔÀ» °®Áö¸¸ ´Ù¸¥ »çÀÌµå¸¦ °®´Â °æ¿ì 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Sor-Aresden"); break;
				case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "ATK-Aresden"); break;
				case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Elf-Aresden"); break;
				case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DSK-Aresden"); break;
				case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "HBT-Aresden"); break;
				case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CT-Aresden"); break;
				case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Bar-Aresden"); break;
				case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGC-Aresden"); break;
				case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}

			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);

			tX = (int)dX;
			tY = (int)dY;

			// ¸¸¾à ÀüÀï °ÇÃà¹°ÀÌ¶ó¸é °ÇÃà À§Ä¡·ÎºÎÅÍ ÀÎÁ¢ÇØ¾ß ÇÑ´Ù.
			bRet = false;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// °Ç¼³ À§Ä¡¸¦ ºñ±³
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = true;

				if (bRet) {
					// °Ç¼³ À§Ä¡¿Í ³Ê¹« ¸Ö¸® ¹þ¾î³ª ÀÖÀ¸¸é °ÇÃà ºÒ°¡.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, 0, 0, 0);
					return;
				}

				// ±æµå¿¡¼­ °Ç¼³ÇÑ °ÇÃà¹°ÀÇ °¹¼ö¸¦ Ä«¿îÆ®ÇÑ´Ù. ÀÏÁ¤ °¹¼ö ÀÌ»óÀº ÁöÀ» ¼ö ¾ø´Ù.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++)
					if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
						m_pGuildTeleportLoc[i].m_dwTime = dwTime;
						if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
							// ±æµå °Ç¼³ °³¼ö ÃÊ°ú. ÁöÀ»¼ö ¾ø´Ù.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);
							return;
						}
						else {
							// °Ç¼³µÈ °Ç¹° °¹¼ö Áõ°¡.
							m_pGuildTeleportLoc[i].m_iV2++;
							goto RSWU_LOOPBREAK;
						}
					}

				// ±æµå ¼³Á¤µÇ¾î ÀÖÁö ¾ÊÀ½. ÁöÀ»¼ö ¾ø´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);
				return;
				/////
				break;
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				break;

			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}

		RSWU_LOOPBREAK:

			// ¸¸¾à ÀüÀï °ÇÃà¹°Áß °¡µåÅ¸¿ö°°ÀÌ °ø°ÝÇüÀÌ¶ó¸é ³Ê¹« ÀÎÁ¢ÇØ¼­ °Ç¼³ÇÒ ¼ö ¾ø´Ù.
			bRet = false;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX - 2; ix <= tX + 2; ix++)
					for (iy = tY - 2; iy <= tY + 2; iy++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 36:
							case 37:
								bRet = true;
								break;
							}
						}
					}

				// ÁöÀ» ¼ö ¾ø´Â »óÀ§ÁÂÇ¥
				if ((dY <= 32) || (dY >= 783)) bRet = true;
				break;
			}

			if (bRet) {
				// ±ÙÃ³¿¡ °¡µåÅ¸¿öµéÀÌ ÀÖ¾î¼­ °ÇÃàºÒ°¡.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, 0, 0, 0);
				return;
			}

			// °¡µå ¸ðµåÀÎ°¡ ÃßÁ¾ ¸ðµåÀÎ°¡ ¼±ÅÃ 
			if (cMode == 0) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);
				if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);

			if (bRet == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// °Ç¼³¿¡ ¼º°øÇßÀ¸¹Ç·Î °Ç¼³ Æ÷ÀÎÆ® °¨¼Ò ½ÃÅ²´Ù.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char* pData)
{
	uint32_t dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == 0) return;
	//m_pClientList[iClientH]->m_cConnectionCheck = 0;

	dwTime = GameClock::GetTimeMS();
	const auto* req = hb::net::PacketCast<hb::net::PacketCommandCheckConnection>(pData, sizeof(hb::net::PacketCommandCheckConnection));
	if (!req) return;
	dwTimeRcv = req->time_ms;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == 0) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);

		if (dwTimeGapClient < dwTimeGapServer) return;
		if ((dwTimeGapClient - dwTimeGapServer) >= (uint32_t)m_iClientTimeout) {
			DeleteClient(iClientH, true, true);
			return;
		}
	}

	hb::net::PacketCommandCheckConnection resp{};
	resp.header.msg_id = MSGID_COMMAND_CHECKCONNECTION;
	resp.header.msg_type = DEF_MSGTYPE_CONFIRM;
	resp.time_ms = dwTimeRcv;
	m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&resp), sizeof(resp));
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{

	if (m_pClientList[iClientH] == 0) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide &&
		m_pClientList[iClientH]->m_dwCrusadeGUID == 0 && iDuty == 3) {
		m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	if (iDuty == 1)
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY, iClientH, 0, "Fighter");
	else if (iDuty == 2)
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY, iClientH, 0, "Constructor");
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY, iClientH, 0, "Commander");
}

void CGame::MapStatusHandler(int iClientH, int iMode, const char* pMapName)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) return;

		for (i = 0; i < DEF_MAXGUILDS; i++)
			if ((m_pGuildTeleportLoc[i].m_iV1 != 0) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
					0, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
					0, 0, 0, 0, m_pGuildTeleportLoc[i].m_cDestMapName2);
				// �Ǽ� ��ġ�� ������ ���´�.
				std::memset(m_pClientList[iClientH]->m_cConstructMapName, 0, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
				memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
				m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
				m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
				return;
			}

		// ��� �Ҽ��� �ƴ� ������ ��û�̴�.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		// ������ ĳ�� ����ü �ʱ�ȭ 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = 0;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = 0;
		std::memset(m_pClientList[iClientH]->m_cSendingMapName, 0, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			// ���� ����ڰ� ��ġ�� ���� ������ �䱸�ߴ�.
			// �� �����͸� ��û�� ����� ������ �״�� ī���Ѵ�.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15 ����ڰ� Commander �� �ƴϾ �ǹ��� ��ġ�� �����ش�.
				if (m_pClientList[iClientH]->m_iCrusadeDuty == 3)
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42)
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// �ٸ� ���� ��Ȳ�� ��û�ߴ�. �̵鷣���� ���� ���� 
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
					// v2.15 ����ڰ� Commander �� �ƴϾ �ǹ��� ��ġ�� �����ش�.
					if (m_pClientList[iClientH]->m_iCrusadeDuty == 3)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
					}
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				// ���� �������� �ʴ� ����̴�.
			}
		}

		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{
	int i, iDataSize;
	char* cp, cData[DEF_MAXCRUSADESTRUCTURES * 6];
	short* sp;

	cp = (char*)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;

	sp = (short*)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// ÃÑ ¸î°³ÀÇ µ¥ÀÌÅÍ°¡ ÀÖ´ÂÁö ¾Ë¸®´Â °÷ ¶ç¿ò.
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == 0)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = true;

	// 100°³¾¿ Á¤º¸¸¦ º¸³½´Ù.
	iDataSize = 0;
	for (i = 0; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == 0) goto SMS_ENDOFDATA;

		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short*)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short*)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// ¿©±â±îÁö ¿Ô´Ù¸é ´õ º¸³¾ ¸Þ½ÃÁö°¡ ÀÖ´Ù´Â ÀÇ¹Ì.
	cp = (char*)(cData + 12);
	*cp = (iDataSize / 6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize + 13, 0, 0, cData);
	return;

SMS_ENDOFDATA:

	// µ¥ÀÌÅÍ°¡ ´Ù Àü¼Û µÇ¾úÀ½À» ÀÇ¹Ì.
	cp = (char*)(cData + 12);
	*cp = (iDataSize / 6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize + 13, 0, 0, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = false;

	return;
}


void CGame::RemoveCrusadeStructures()
{
	int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			switch (m_pNpcList[i]->m_sType) {
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
				// Use EntityManager for NPC deletion
				if (m_pEntityManager != NULL)
					m_pEntityManager->DeleteEntity(i);
				break;
			}
		}
}

void CGame::RequestHelpHandler(int iClientH)
{
	// ÇïÇÁ ¿äÃ»ÀÌ´Ù. ±æµå ¸¶½ºÅÍ¿¡°Ô ÁÂÇ¥¸¦ Àü´ÞÇØ ÁØ´Ù.
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildRank == 0) &&
			(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// °°Àº ±æµå ¸¶½ºÅÍÀÌ°í ÁöÈÖ°ü ¿ªÈ°À» ¸ÃÀº »óÅÂÀÌ´Ù.
			SendNotifyMsg(0, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
			return;
		}

	// ÇöÀç ¸Ê¿¡ ÁöÈÖ°üÀÌ ¾øÀ½À» Åëº¸ÇØ ÁØ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELPFAILED, 0, 0, 0, 0);
}


bool CGame::bStockMsgToGateServer(char* pData, uint32_t dwSize)
{
	//char * cp;

	   ////testcode
	   ////std::snprintf(G_cTxt, sizeof(G_cTxt), "StockMsg(%d) Size(%d)", *pData, dwSize);
	   ////PutLogList(G_cTxt);

	   //if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return false;

	   //cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	   //memcpy(cp, pData, dwSize);

	   //m_iIndexGSS += dwSize;

	return true;
}


void CGame::SendStockMsgToGateServer()
{
	//uint32_t * dwp;
	//uint16_t * wp;
	//char * cp;

	   //// ±×µ¿¾È ¸ð¾Æ³õ¾Ò´ø ¸Þ½ÃÁö¸¦ °ÔÀÌÆ® ¼­¹ö·Î Àü¼Û.
	   //if (m_iIndexGSS > 6) {
	   //	//testcode
	   //	//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
	   //	//PutLogList(G_cTxt);

	   //	SendMsgToGateServer(MSGID_SERVERSTOCKMSG, 0, m_cGateServerStockMsg);
	   //
	   //	// ¹öÆÛ Å¬¸®¾î
	   //	std::memset(m_cGateServerStockMsg, 0, sizeof(m_cGateServerStockMsg));
	   //	// ¸Ç ¾ÕºÎºÐ¿¡ ¸Þ½ÃÁö »ðÀÔ
	   //	cp = (char *)m_cGateServerStockMsg;
	   //	dwp = (uint32_t *)cp;
	   //	*dwp = MSGID_SERVERSTOCKMSG;
	   //	cp += 4;
	   //	wp = (uint16_t *)cp;
	   //	*wp = DEF_MSGTYPE_CONFIRM;
	   //	cp += 2;

	   //	m_iIndexGSS = 6;
	   //}
}

void CGame::ServerStockMsgHandler(char* pData)
{
	// char * cp, * cp2, cTemp[120], cLocation[10], cGuildName[20], cName[11], cTemp2[120], cTemp3[120], cMapName[11], cBuffer[256]; short * sp;
	// uint16_t * wp, wServerID, wClientH, wV1, wV2, wV3, wV4, wV5;
	// uint32_t * dwp;
	// bool bFlag = false;
	// int * ip, i, iTotal, iV1, iV2, iV3, iRet;
	// short sX, sY;
	//
	//	iTotal = 0;
	//	cp = (char *)(pData + 6);
	//	while (bFlag == false) {
	//		iTotal++;
	//		switch (*cp) {
	//		
	//// SUMMONGUILD Deleted
	//		case GSM_REQUEST_SUMMONGUILD:
	//			cp++;
	//			std::memset(cGuildName, 0, sizeof(cGuildName));
	//			memcpy(cGuildName, cp, 20);
	//			cp += 20;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			cp2 = (char *) cTemp + 10;
	//			wp = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			wp = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//
	//			for (i = 0; i < DEF_MAXCLIENTS; i++)
	//			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cGuildName, cGuildName) == 0)) {
	//			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
	//			}
	//			break;
	//
	//		// v2.14 ¼ºÈÄ´Ï Ãß°¡ À¯Àú ¼ÒÈ¯ 
	//		case GSM_REQUEST_SUMMONPLAYER:
	//			cp++;
	//			std::memset(cName, 0, sizeof(cName));
	//			memcpy(cName, cp, 10);
	//			cp += 10;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			cp2 = (char *) cTemp + 10 ;
	//			
	//			wp = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			wp = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//			
	//			for (i = 1; i < DEF_MAXCLIENTS; i++)
	//				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
	//					//std::snprintf(G_cTxt, sizeof(G_cTxt), "%s %d %d", cTemp, wV1, wV2);
	//					//PutLogFileList(G_cTxt);					
	//					RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
	//					break;
	//				}
	//			break;
	//		
	//		case GSM_REQUEST_SUMMONALL:
	//			cp++;
	//			std::memset(cLocation, 0, sizeof(cLocation));
	//			memcpy(cLocation, cp, 10);
	//			cp += 10;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			cp2 = (char *) cTemp + 10;
	//			
	//			wp = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			wp = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//			
	//			for (i = 0; i < DEF_MAXCLIENTS; i++)
	//			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cLocation, cLocation) == 0)) {
	//			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
	//		}
	//		break;
	//
	//		case GSM_CHATMSG:
	//			cp++;
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			std::memset(cName, 0, sizeof(cName));
	//			iV1 = *cp;
	//			cp++;
	//			ip = (int *)cp;
	//			iV2 = *ip;
	//			cp += 4;
	//			memcpy(cName, cp, 10);
	//			cp += 10;;
	//			sp = (short *)cp;
	//			wV1 = (uint16_t)*sp;
	//			cp += 2;
	//			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
	//			cp += wV1;
	//			break;
	//		
	//		case GSM_CONSTRUCTIONPOINT:
	//			cp++;
	//			ip = (int *)cp;
	//			iV1 = *ip;
	//			cp += 4;
	//			ip = (int *)cp;
	//			iV2 = *ip;
	//			cp += 4;
	//			GSM_ConstructionPoint(iV1, iV2);
	//			break;
	//
	//		case GSM_SETGUILDTELEPORTLOC:
	//			cp++;
	//			ip = (int *)cp;
	//			iV1 = *ip;
	//			cp += 4;
	//			ip = (int *)cp;
	//			iV2 = *ip;
	//			cp += 4;
	//			ip = (int *)cp;
	//			iV3 = *ip;
	//			cp += 4;
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
	//			break;
	//
	//		case GSM_SETGUILDCONSTRUCTLOC:
	//			cp++;
	//			ip = (int *)cp;
	//			iV1 = *ip;
	//			cp += 4;
	//			ip = (int *)cp;
	//			iV2 = *ip;
	//			cp += 4;
	//			ip = (int *)cp;
	//			iV3 = *ip;
	//			cp += 4;
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
	//			break;
	//
	//		case GSM_REQUEST_SETFORCERECALLTIME:
	//			cp++;
	//			wp = (uint16_t *)cp;
	//			m_sForceRecallTime = *wp;
	//			cp += 2;
	//
	//			std::snprintf(G_cTxt, sizeof(G_cTxt),"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
	//			PutLogList(G_cTxt) ;
	//			break;
	//
	//		case GSM_MIDDLEMAPSTATUS:
	//			cp++;
	//			// ±¸Á¶Ã¼ Å¬¸®¾î
	//			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
	//				m_stMiddleCrusadeStructureInfo[i].cType = 0;
	//				m_stMiddleCrusadeStructureInfo[i].cSide = 0;
	//				m_stMiddleCrusadeStructureInfo[i].sX    = 0;
	//				m_stMiddleCrusadeStructureInfo[i].sY    = 0;
	//			}
	//			sp = (short *)cp;
	//			m_iTotalMiddleCrusadeStructures = *sp;
	//			cp += 2;
	//			// Á¤º¸ ÀÐ¾îµéÀÎ´Ù.
	//			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
	//				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
	//				cp++;
	//				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
	//				cp++;
	//				sp = (short *)cp;
	//				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
	//				cp += 2;
	//				sp = (short *)cp;
	//				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
	//				cp += 2;	
	//			}
	//			break;
	//		
	//		case GSM_BEGINCRUSADE:
	//			cp++;
	//			dwp = (uint32_t *)cp;
	//			cp += 4;
	//			LocalStartCrusadeMode(*dwp);
	//			break;
	//
	//		case GSM_BEGINAPOCALYPSE:
	//			cp++;
	//			dwp = (uint32_t *)cp;
	//			cp += 4;
	//			LocalStartApocalypse(*dwp);
	//			break;
	//
	//		case GSM_STARTHELDENIAN:
	//			cp++;
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//			wp  = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//			dwp = (uint32_t *)cp;
	//			cp += 4;
	//			LocalStartHeldenianMode(wV1, wV2, *dwp);
	//			break;
	//
	//		case GSM_ENDHELDENIAN:
	//			cp++;
	//			LocalEndHeldenianMode();
	//			break;
	//			
	//			/*case GSM_BEGINHELDENIEN:
	//			cp++;
	//			dwp = (uint32_t *)cp;
	//			cp += 4;
	//			LocalStartHeldenian(*dwp);
	//			break;
	//		
	//		case GSM_ENDHeldenian:
	//			cp++;
	//			LocalEndHeldenian(*dwp)//sub_4ABCD0(*dwp);
	//			break;*/
	//
	//		case GSM_UPDATECONFIGS:
	//			cp++;
	//			LocalUpdateConfigs(*cp);
	//			cp += 16;
	//			break;
	//
	//		case GSM_ENDAPOCALYPSE:
	//			cp++;
	//			LocalEndApocalypse();
	//			break;
	//
	//		case GSM_ENDCRUSADE:
	//			cp++;
	//			LocalEndCrusadeMode(*cp);
	//			cp += 16;
	//			break;
	//
	//		case GSM_COLLECTEDMANA:
	//			cp++;
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			wp  = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//			CollectedManaHandler(wV1, wV2);
	//			break;
	//
	//		case GSM_GRANDMAGICLAUNCH:
	//			cp++;
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			wp  = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//
	//			switch (wV1) {
	//			case 1: // ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© 
	//				MeteorStrikeMsgHandler((char)wV2);
	//				break;
	//			}
	//			break;
	//		
	//		case  GSM_GRANDMAGICRESULT:
	//			cp++;
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//			wp  = (uint16_t *)cp;
	//			wV2 = *wp;
	//			cp += 2;
	//			wp  = (uint16_t *)cp;
	//			wV3 = *wp;
	//			cp += 2;
	//			wp  = (uint16_t *)cp;
	//			wV4 = *wp;
	//			cp += 2;
	//
	//			wp  = (uint16_t *)cp;
	//			wV5 = *wp;
	//
	//			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4, wV5, cp);
	//			break;
	//		
	//			// v2.15 2002-5-21
	//		case GSM_REQUEST_SHUTUPPLAYER:
	//			cp++;
	//			wp = (uint16_t *)cp;
	//			wServerID = *wp;
	//			cp += 2;
	//			wp = (uint16_t *)cp;
	//			wClientH = *wp;
	//			cp += 2;
	//
	//			std::memset(cName, 0, sizeof(cName));
	//			memcpy(cName, cp, 10);
	//			cp += 10;
	//
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);
	//			break ;
	//
	//		case GSM_RESPONSE_SHUTUPPLAYER:
	//			cp++;
	//			wp = (uint16_t *)cp;
	//			wServerID = *wp;
	//			cp += 2;
	//			wp = (uint16_t *)cp;
	//			wClientH = *wp;
	//			cp += 2;
	//
	//			std::memset(cName, 0, sizeof(cName));
	//			memcpy(cName, cp, 10);
	//			cp += 10;
	//
	//			wp  = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//
	//			if (wServerID == m_wServerID_GSS) {
	//				if ((m_pClientList[wClientH] != 0)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
	//					SendNotifyMsg(0, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, 0, 0, cTemp);
	//
	//				}
	//			}
	//			break;
	//
	//		// New 16/05/2004
	//		case GSM_WHISFERMSG:
	//			std::memset(cName, 0, sizeof(cName));
	//			std::memset(cBuffer, 0, sizeof(cBuffer));
	//			cp++;
	//			memcpy(cName, cp, 10);
	//			cp += 10;
	//			wp = (uint16_t *)cp;
	//			wV1 = *wp;
	//			cp += 2;
	//
	//			memcpy(cBuffer, cp, wV1);
	//			cp += wV1;
	//
	//			for (i = 1; i < DEF_MAXCLIENTS; i++)
	//				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
	//					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
	//					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
	//						char cTxt[200],cTmpName[12] ;
	//						std::memset(cTxt, 0, sizeof(cTxt)) ;
	//						std::memset(cTmpName, 0, sizeof(cTmpName)) ;
	//
	//						memcpy(cTmpName,cBuffer+10,10) ;
	//						std::snprintf(cTxt, sizeof(cTxt),"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
	//						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, 0, cTxt);
	//					}
	//					break;
	//				}
	//		break;
	//
	//		// New 16/05/2004 Changed
	//		case GSM_REQUEST_FINDCHARACTER:
	//			cp++;
	//
	//			wp = (uint16_t *)cp;
	//			wServerID = *wp;
	//			cp += 2;
	//
	//			wp = (uint16_t *)cp;
	//			wClientH = *wp;
	//			cp += 2;
	//
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			std::memset(cTemp2, 0, sizeof(cTemp2));
	//			memcpy(cTemp2, cp, 10);
	//			cp += 10;
	//
	//			GSM_RequestFindCharacter(wServerID, wClientH, cTemp, cTemp2);
	//			break;
	//
	//		case GSM_RESPONSE_FINDCHARACTER:
	//			sX = -1;
	//			sY = -1;
	//			cp++;
	//			wp = (uint16_t *)cp;
	//			wServerID = *wp;
	//			cp += 2;
	//			wp = (uint16_t *)cp;
	//			wClientH = *wp;
	//			cp += 2;
	//			std::memset(cTemp, 0, sizeof(cTemp));
	//			memcpy(cTemp, cp, 10);
	//			cp += 10;
	//
	//			std::memset(cTemp2, 0, sizeof(cTemp2));
	//			memcpy(cTemp2, cp, 10);
	//			cp += 10;
	//
	//			std::memset(cTemp3, 0, sizeof(cTemp3));
	//			memcpy(cTemp3, cp, 14);
	//
	//			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != 0) {
	//				if (m_pClientList[wClientH]->m_bIsAdminOrderGoto ) {
	//					m_pClientList[wClientH]->m_bIsAdminOrderGoto = false;
	//					std::memset(cMapName, 0, sizeof(cMapName));
	//					memcpy(cMapName, cp, 10);
	//					cp += 10;
	//
	//					wp = (uint16_t *)cp;
	//					sX = *wp;
	//					cp += 2;
	//
	//					wp = (uint16_t *)cp;
	//					sY = *wp;
	//					cp += 2;
	//
	//					if (m_pClientList[wClientH]->m_iAdminUserLevel > 0) {
	//						if(sX == -1 && sY == -1){
	//							std::snprintf(G_cTxt, sizeof(G_cTxt),"GM Order(%s): GoTo MapName(%s)",m_pClientList[wClientH]->m_cCharName, cMapName);
	//						}
	//						else{
	//							std::snprintf(G_cTxt, sizeof(G_cTxt),"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[wClientH]->m_cCharName,
	//								cMapName, sX, sY);
	//						}
	//						bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, false, G_cTxt);
	//						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
	//					}
	//				}
	//				else{
	//					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer ) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
	//						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
	//						SendNotifyMsg(0, wClientH, DEF_NOTIFY_WHISPERMODEON, 0, 0, 0, m_pClientList[wClientH]->m_cWhisperPlayerName);
	//					}
	//					else{
	//						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) {
	//							std::memset(cTemp3, 0, sizeof(cTemp3));
	//						}
	//						if (strcmp(m_pClientList[wClientH]->m_cCharName, cTemp2) == 0) {
	//							SendNotifyMsg(0, wClientH, DEF_NOTIFY_PLAYERONGAME, 0, 0, 0, cTemp,
	//								0, 0, 0, 0, 0, 0, cTemp3);
	//						}
	//					}
	//				}
	//			}
	//			break;
	//
	//		default:
	//			bFlag = true;
	//			break;
	//		}
	//	}

		//testcode
		//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Total %d GSM Messages.", iTotal-1);
		//PutLogList(G_cTxt);
}

void CGame::GSM_RequestFindCharacter(uint16_t wReqServerID, uint16_t wReqClientH, char* pName, char* pFinder)
{
	//char * cp, cTemp[120];
	//uint16_t * wp;
	//int i;

	   //for (i = 1; i < DEF_MAXCLIENTS; i++)
	   //if ((m_pClientList[i] != 0)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
	   //	// Ã£¾Ò´Ù.
	   //	std::memset(cTemp, 0, sizeof(cTemp));
	   //	cp = (char *)(cTemp);
	   //	*cp = GSM_RESPONSE_FINDCHARACTER;
	   //	cp++;

	   //	wp = (uint16_t *)cp;
	   //	*wp = wReqServerID;
	   //	cp += 2;

	   //	wp = (uint16_t *)cp;
	   //	*wp = wReqClientH;
	   //	cp += 2;
	   //	
	   //	memcpy(cp, pName, 10);
	   //	cp += 10;

	   //	memcpy(cp, pFinder, 10);
	   //	cp += 10;

	   //	memcpy(cp, m_pClientList[i]->m_cMapName, 10);
	   //	cp += 10;

	   //	wp = (uint16_t *)cp;
	   //	*wp = m_pClientList[i]->m_sX;
	   //	cp += 2;

	   //	wp = (uint16_t *)cp;
	   //	*wp = m_pClientList[i]->m_sY;
	   //	cp += 2;

	   //	bStockMsgToGateServer(cTemp, 39);
	   //	return;	
	   //}
}

// New 11/05/2004 Changed
void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
	int i, iDamage;

	// ÇØ´ç ¸ÊÀÇ ÇÃ·¹ÀÌ¾îµéÀÇ HP¸¦ ÀÏ°ý »è°¨
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			if (m_pClientList[i]->m_iLevel < 80)
				iDamage = m_pClientList[i]->m_iLevel + iDice(1, 10);
			else iDamage = m_pClientList[i]->m_iLevel * 2 + iDice(1, 10);
			iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
			// ÃÖ´ë 255ÀÌ»óÀÇ ´ë¹ÌÁö´Â ¹ÞÁö ¾Ê´Â´Ù.
			if (iDamage > 255) iDamage = 255;

			if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) { //magic cut in half
				iDamage = (iDamage / 2) - 2;
			}

			if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) {
				iDamage = 0;
			}

			if (m_pClientList[i]->m_iAdminUserLevel > 0) { // Admins get no damage
				iDamage = 0;
			}

			m_pClientList[i]->m_iHP -= iDamage;
			if (m_pClientList[i]->m_iHP <= 0) {
				// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
				ClientKilledHandler(i, 0, 0, iDamage);
				m_stMeteorStrikeResult.iCasualties++;
			}
			else {
				if (iDamage > 0) {
					// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
					SendNotifyMsg(0, i, DEF_NOTIFY_HP, 0, 0, 0, 0);
					// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û 
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

					// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != true) {
						m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}

					if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
						// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ý°ø°Ý ÆÐ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
						// 1: Hold-Person 
						// 2: Paralize
						SendNotifyMsg(0, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);

						m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}
			}
		}
}

void CGame::SyncMiddlelandMapInfo()
{
	int i;

	// �̵鷣���� ������ ��� �������� ��ũ��Ų��. �̵鷣�带 ����� ������� �ٷ� ����ü�� ������Ʈ �ϰ� ������ �����鿡�� ���� ����.
	if (m_iMiddlelandMapIndex != -1) {
		// ����ü Ŭ����
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = 0;
			m_stMiddleCrusadeStructureInfo[i].cSide = 0;
			m_stMiddleCrusadeStructureInfo[i].sX = 0;
			m_stMiddleCrusadeStructureInfo[i].sY = 0;
		}
		// ����ü ���� �� ���� �޽��� �ۼ� 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		/*std::memset(G_cData50000, 0, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;*/

		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;

			/**cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;*/
		}

		// �޽��� ����.
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//std::snprintf(G_cTxt, sizeof(G_cTxt), "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			//bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char* pMapName)
{
	int i, iIndex;
	uint32_t dwTemp, dwTime;

	// Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍÀÇ ¿äÃ»ÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ¼­¹ö·ÎºÎÅÍÀÇ ÅÚ·¹Æ÷Æ® ÁÂÇ¥ ¼³Á¤ ¿äÃ»ÀÓ. ÀÀ´äÇÒ ÇÊ¿ä ¾øÀ½.

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = GameClock::GetTimeMS();

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				// ³»¿ë °»½Å
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
		}

	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_bIsCrusadeMode == false) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // ÆÄÀÌÅÍ
	case 2: // °Ç¼³ÀÚ: ¸ð¾Æ ³õÀº Æ÷ÀÎÆ®¸¦ ±æµå¸¶½ºÅÍ ÁöÈÖ°ü¿¡°Ô Àü´ÞÇÑ´Ù.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
				(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
				// ÇöÀç ¼­¹ö ³»¿¡ ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀÌ ÀÖ´Ù. ÁöÈÖ°üÀÇ Æ÷ÀÎÆ®¸¦ ³ôÀÎ ÈÄ 
				m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
				m_pClientList[i]->m_iWarContribution += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

				if (m_pClientList[i]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[i]->m_iConstructionPoint = m_iMaxConstructionPoints;

				if (m_pClientList[i]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[i]->m_iWarContribution = m_iMaxWarContribution;

				SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
				m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
				return;
			}

		// ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
		/*std::memset(cData, 0, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);*/

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
		break;

	case 3: // ÁöÈÖ°ü: º¸³¾ ÇÊ¿ä ¾øÀ½ 

		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
	int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
			// ÇØ´ç ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀ» Ã£¾Ò´Ù.
			m_pClientList[i]->m_iConstructionPoint += iPoint;
			m_pClientList[i]->m_iWarContribution += iPoint / 10;

			if (m_pClientList[i]->m_iConstructionPoint > m_iMaxConstructionPoints)
				m_pClientList[i]->m_iConstructionPoint = m_iMaxConstructionPoints;

			if (m_pClientList[i]->m_iWarContribution > m_iMaxWarContribution)
				m_pClientList[i]->m_iWarContribution = m_iMaxWarContribution;

			SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
			PutLogList(G_cTxt);
			return;
		}
}

bool CGame::bAddClientShortCut(int iClientH)
{
	int i;

	// ¸ÕÀú µ¿ÀÏÇÑ ¹øÈ£°¡ Á¸ÀçÇÏ´ÂÁö °Ë»ö

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == iClientH) return false;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == 0) {
			m_iClientShortCut[i] = iClientH;
			return true;
		}

	return false;
}

void CGame::RemoveClientShortCut(int iClientH)
{
	int i;

	for (i = 0; i < DEF_MAXCLIENTS + 1; i++)
		if (m_iClientShortCut[i] == iClientH) {
			m_iClientShortCut[i] = 0;
			goto RCSC_LOOPBREAK;
		}

RCSC_LOOPBREAK:

	// ºó ¿©¹éÀ» ¸Þ²Û´Ù.
	//m_iClientShortCut[i] = m_iClientShortCut[m_iTotalClients+1];
	//m_iClientShortCut[m_iTotalClients+1] = 0;
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i + 1] != 0)) {
			m_iClientShortCut[i] = m_iClientShortCut[i + 1];
			m_iClientShortCut[i + 1] = 0;
		}
}

void CGame::_CreateCrusadeGUID(uint32_t dwCrusadeGUID, int iWinnerSide)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "CrusadeGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		// ÆÄÀÏÀ» ¸¸µé ¼ö ¾ø°Å³ª »çÀÌÁî°¡ Áö³ªÄ¡°Ô ÀÛÀº °æ¿ì´Â . 
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}


bool CGame::bReadCrusadeGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					// New 13/05/2004 Changed
					m_iLastCrusadeWinner = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "CrusadeWinnerSide = %d", m_iLastCrusadeWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{


	// ¸Å´º¾ó·Î Å©·ç¼¼ÀÌµå ¸ðµå¸¦ Á¾·á½ÃÅ²´Ù. ºñ±ä »óÅÂ·Î Á¾·á½ÃÅ²´Ù.
	if (m_bIsCrusadeMode == false) return;

	LocalEndCrusadeMode(iWinnerSide);

	// ´Ù¸¥ ¼­¹ö¿¡ Å©·ç¼¼ÀÌµå Á¾·á¸¦ ¾Ë¸².
	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;

	wp  = (uint16_t *)cp;
	*wp = 0;
	cp += 2;

	wp  = (uint16_t *)cp;
	*wp = 0;
	cp += 2;

	wp  = (uint16_t *)cp;
	*wp = 0;
	cp += 2;

	cp += 10;

	bStockMsgToGateServer(cData, 18);*/
}

int CGame::iGetMapLocationSide(char* pMapName)
{

	if (strcmp(pMapName, "aresden") == 0) return 3;
	if (strcmp(pMapName, "elvine") == 0) return 4;
	if (strcmp(pMapName, "arebrk11") == 0) return 3;
	if (strcmp(pMapName, "elvbrk11") == 0) return 4;

	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "arefarm") == 0) return 1;
	if (strcmp(pMapName, "elvfarm") == 0) return 2;
	if (strcmp(pMapName, "arewrhus") == 0) return 1;
	if (strcmp(pMapName, "elvwrhus") == 0) return 2;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 1;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 2;

	return 0;
}

bool CGame::bCopyItemContents(CItem* pCopy, CItem* pOriginal)
{
	if (pOriginal == 0) return false;
	if (pCopy == 0) return false;

	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// ¾ÆÀÌÅÛÀÇ °íÀ¯ ¹øÈ£ 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3;
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6;
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;

	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 ¸íÁß·ü °¡°¨ »ç¿ë ¾ÈÇÑ´Ù. ´ë½Å Æ¯¼ö ´É·Â ¼öÄ¡°¡ µé¾î°£´Ù.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2;

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice;
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;

	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 = pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;

	return true;
}


//ArchAngel Function

void CGame::RequestChangePlayMode(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall", 8) != 0) return;

	if (m_pClientList[iClientH]->m_iLevel < 100 ||
		m_pClientList[iClientH]->m_bIsPlayerCivil) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "arehunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "elvhunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

		if (m_pClientList[iClientH]->m_bIsPlayerCivil)
			m_pClientList[iClientH]->m_bIsPlayerCivil = false;
		else m_pClientList[iClientH]->m_bIsPlayerCivil = true;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, 0, 0, 0, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, 100, 0, 0, 0);
	}

	g_login->LocalSavePlayerData(iClientH);
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

void CGame::SetHasteFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus |= 0x00040000;
		else m_pClientList[sOwnerH]->m_iStatus ^= 0x00040000;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show hero item aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == 0) {
		// ¿äÃ» ¹ÞÀº Object°¡ ¾ø´Ù.

	}
	else {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, 0, m_pClientList[iObjectID]->m_cGuildName);
	}
}

// Item Logging
bool CGame::_bItemLog(int iAction, int iGiveH, int iRecvH, class CItem* pItem, bool bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount;
	if (pItem == 0) return false;

	if (m_pClientList[iGiveH]->m_cCharName == 0) return false;

	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTemp1, 0, sizeof(cTemp1));
	std::memset(cTemp2, 0, sizeof(cTemp2));

	switch (iAction) {

	case DEF_ITEMLOG_EXCHANGE:
		if (m_pClientList[iRecvH]->m_cCharName == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_GIVE:
		if (m_pClientList[iRecvH]->m_cCharName == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_DROP:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_GET:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_MAKE:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_DEPLETE:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_BUY:
		iItemCount = iRecvH;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_SELL:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_RETRIEVE:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_DEPOSIT:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_UPGRADEFAIL:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;

	case DEF_ITEMLOG_UPGRADESUCCESS:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
		PutItemLogFileList(cTxt);
		break;
	default:
		return false;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, 0, cTxt);
	return true;
}

bool CGame::_bItemLog(int iAction, int iClientH, char* cName, class CItem* pItem)
{
	if (pItem == 0) return false;
	if (_bCheckGoodItem(pItem) == false) return false;
	if (iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if (m_pClientList[iClientH] == 0) return false;
	}
	char  cTxt[200], cTemp1[120];
	//  ·Î±× ³²±ä´Ù. 
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTemp1, 0, sizeof(cTemp1));
	if (m_pClientList[iClientH] != 0) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {

	case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "NPC(%s)\tDrop\t%s(%d %d %d %d)", cName, pItem->m_cName, pItem->m_dwCount,
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		PutItemLogFileList(cTxt);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
		PutItemLogFileList(cTxt);
		break;
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
		break;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
		break;

	case DEF_ITEMLOG_REPAIR:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
		break;

	default:
		return false;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, 0, cTxt);
	return true;
}

bool CGame::_bCheckGoodItem(class CItem* pItem)
{
	if (pItem == 0) return false;

	if (pItem->m_sIDnum == 90)
	{
		if (pItem->m_dwCount > 10000) return true;  //Gold¿¡ ÇÑÇØ 10000¿ø ÀÌ»ó¸¸ ·Î±×¿¡ ³²±ä´Ù.
		else return false;
	}
	switch (pItem->m_sIDnum) {
		//	case 90: // Gold Ãß°¡ 
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // µ¥¸ó-½½·¹ÀÌ¾î
	case 618:  // ´ÙÅ©¿¤ÇÁ-º¸¿ì

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:

	case 650:
	case 654:
	case 655:
	case 656:
	case 657:

	case 700: 	// v2.03 »ó¾î ¾ÆÀÌÅÛ 
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  // »õ·Î¿î »ó¾îÀÇ ÀÚÀÌ¾ðÆ® ¼Òµå
	case 737:  // »õ·Î¿î Èæ±â»çÀÇ ÀÚÀÌ¾ðÆ® ¼Òµå
	case 738:  // »õ·Î¿î Èæ¸¶¹ý»çÀÇ¸ÅÁ÷¿øµå
	case 924:

		return true;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛÀÌ±â ¶«½Ã ±â·Ï...
		break;
	default:
		// v2.17 2002-7-31 Á¦ÀÛ ¾ÆÀÌÅÛµµ ·Î±×¿¡ ³²°Ô ÇÑ´Ù.
		if ((pItem->m_dwAttribute & 0xF0F0F001) == 0) return false;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛµÎ ¾Æ´Ï±¸ Æ¯¼ºÄ¡µµ ¾ø´Ù¸é º°·ç..
		else if (pItem->m_sIDnum > 30) return true;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛÀº ¾Æ´ÏÁö¸¸ Æ¯¼ºÄ¡°¡ ÀÖ°í ´Ü°Ë·ù°¡ ¾Æ´Ï¶ó¸é ÁÁÀº ¾ÆÅÛ..
		else return false;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛµÎ ¾Æ´Ï±¸ Æ¯¼ºÄ¡´Â ÀÖÁö¸¸ ´Ü°Ë·ù¶ó¸é º°·ç...
	}
}

void CGame::GetExp(int iClientH, uint32_t iExp, bool bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int i, iH;
	uint32_t dwTime = GameClock::GetTimeMS(), iUnitValue;
	int iTotalPartyMembers;

	if (m_pClientList[iClientH] == 0) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f) * dV3;
		iExp = (uint32_t)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 80) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0))) {
			iExp = (iExp / 10);
		}
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0)) {
			iExp = (iExp * 1 / 4);
		}
	}

	//Check for party status, else give exp to player
	if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
		//Only divide exp if >= 1 person 
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0) {

			//Calc total ppl in party
			iTotalPartyMembers = 0;
			for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iHP > 0)) {
					//Newly added, Only players on same map get exp :}
					if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
						if (memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0) {
							iTotalPartyMembers++;
						}
					}
				}
			}

			//Check for party bug
			if (iTotalPartyMembers > DEF_MAXPARTYMEMBERS) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
				PutLogFileList(G_cTxt);
				iTotalPartyMembers = DEF_MAXPARTYMEMBERS;
			}

			//Figure out how much exp a player gets
			dV1 = (double)iExp;
			dV2 = dV1;

			if (iTotalPartyMembers > 1)
			{
				dV2 = (dV1 + (dV1 * (double)(iTotalPartyMembers / DEF_MAXPARTYMEMBERS))) / (double)iTotalPartyMembers;
			}

			dV3 = dV2 + 5.0e-1;
			iUnitValue = (uint32_t)dV3;

			//Divide exp among party members
			for (i = 0; i < iTotalPartyMembers; i++) {

				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
					if ((m_pClientList[iH]->m_iStatus & 0x10000) != 0)  iUnitValue *= 3;
					m_pClientList[iH]->m_iExpStock += iUnitValue;
				}
			}
		}
	}
	else {
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iClientH]->m_iHP > 0)) { // Is player alive ??
			if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0)  iExp *= 3;
			m_pClientList[iClientH]->m_iExpStock += iExp;
		}
	}
}

bool CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return true;
		break;
	}
	return false;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == 0) return;
	// v1.3 ÇÇ°Ý´çÇßÀ¸¹Ç·Î ÀåÂøÇÏ°í ÀÖ´Â ¸öÅë ¹æ¾î±¸ÀÇ ¼ö¸íÀ» ÁÙÀÎ´Ù. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == 0) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}

	// v2.16 °°Àº ÆíÀÌ¸é ¼ö¸í ´ÞÁö ¾Ê°Ô 
	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return;

	// ¸öÅë °©¿Ê 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {
		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸í ÁÙÁö ¾Ê´Â´Ù.
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// ¹ÙÁö È¤Àº ½Å¹ß·ù ¹æ¾î±¸
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// ÆÈ°©¿Ê 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// Åõ±¸ 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}
}

// v2.17 2002-7-15 ��� ���ɾ�� ���ݽð��� �����Ѵ�.

// New 12/05/2004
void CGame::RemoveCrusadeNpcs(void)
{
	for (int i = 0; i < DEF_MAXNPCS; i++) {
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_sType >= 43 && m_pNpcList[i]->m_sType <= 47) || m_pNpcList[i]->m_sType == 51) {
				m_pEntityManager->OnEntityKilled(i, 0, 0, 0);
			}
		}
	}
}

void CGame::RemoveCrusadeRecallTime(void)
{
	for (int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsWarLocation &&
				m_pClientList[i]->m_bIsPlayerCivil &&
				m_pClientList[i]->m_bIsInitComplete) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}
		}
	}
}

// New 13/05/2004
bool CGame::_bCrusadeLog(int iAction, int iClientH, int iData, char* cName)
{
	char  cTxt[200];

	//  ·Î±× ³²±ä´Ù. 
	std::memset(cTxt, 0, sizeof(cTxt));

	switch (iAction) {

	case DEF_CRUSADELOG_ENDCRUSADE:
		if (cName == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "\tEnd Crusade\t%s", cName);
		break;

	case DEF_CRUSADELOG_SELECTDUTY:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, cName, m_pClientList[iClientH]->m_cGuildName);
		break;

	case DEF_CRUSADELOG_GETEXP:
		if (m_pClientList[iClientH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, iData, m_pClientList[iClientH]->m_cGuildName);
		break;

	case DEF_CRUSADELOG_STARTCRUSADE:
		std::snprintf(cTxt, sizeof(cTxt), "\tStart Crusade");
		break;

	default:
		return false;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, 0, cTxt);
	return true;
}

// Testcode, found reference to it in 3.51, InitPlayerData and RequestTeleportHandler
int CGame::iGetPlayerABSStatus(int iClientH)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		iRet = 8;
	}

	if (m_pClientList[iClientH]->m_cSide != 0) {
		iRet = iRet | 4;
	}

	if (m_pClientList[iClientH]->m_cSide == 1) {
		iRet = iRet | 2;
	}

	if (m_pClientList[iClientH]->m_bIsPlayerCivil)
		iRet = iRet | 1;

	return iRet;
}

// New 16/05/2004
void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i, iRet;
	char cItemID[4], ctr[4];
	char cSlateColour;
	bool bIsSlatePresent = false;
	CItem* pItem;
	int iSlateType, iEraseReq;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	for (i = 0; i < 4; i++) {
		cItemID[i] = 0;
		ctr[i] = 0;
	}
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonItems>(
		pData, sizeof(hb::net::PacketCommandCommonItems));
	if (!pkt) return;

	// 14% chance of creating slates
	if (iDice(1, 100) < static_cast<uint32_t>(m_sSlateSuccessRate)) bIsSlatePresent = true;

	try {
		// make sure slates really exist
		for (i = 0; i < 4; i++) {
			cItemID[i] = static_cast<char>(pkt->item_ids[i]);

			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] == 0 || cItemID[i] > DEF_MAXITEMS) {
				bIsSlatePresent = false;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
				return;
			}

			//No duping
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
				ctr[0] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
				ctr[1] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
				ctr[2] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
				ctr[3] = 1;
		}
	}
	catch (...) {
		//Crash Hacker Caught
		bIsSlatePresent = false;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
		std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, true, true);
		return;
	}

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = false;
		return;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = true;

	// if we failed, kill everything
	if (!bIsSlatePresent) {
		for (i = 0; i < 4; i++) {
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
				ItemDepleteHandler(iClientH, cItemID[i], false);
			}
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
		return;
	}

	// make the slates
	for (i = 0; i < 4; i++) {
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
			ItemDepleteHandler(iClientH, cItemID[i], false);
		}
	}

	pItem = new class CItem;

	i = iDice(1, 1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i < 1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, 0, 0, 0);


	// Create slates
	if (_bInitItemAttr(pItem, 867) == false) {
		delete pItem;
		return;
	}
	else {
		pItem->m_sTouchEffectType = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
		pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
		pItem->m_sTouchEffectValue3 = (short)GameClock::GetTimeMS();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, true, true);
				break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == 0) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		return;
	}

	if (bFlag) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= 0x400000;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= 0x800000;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= 0x10000;
		}
	}
	else {
		if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{
	char cMapName[11], cLocation[11];

	if (m_pClientList[iClientH] == 0) return;

	std::memset(cMapName, 0, sizeof(cMapName));
	std::memset(cLocation, 0, sizeof(cLocation));

	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = false;
	m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (memcmp(cLocation, cMapName, 3) == 0) {
		m_pClientList[iClientH]->m_bIsOwnLocation = true;
	}

	if (memcmp(cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;
	else if (memcmp(cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;
	else {
		if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) {
			m_pClientList[iClientH]->m_bIsOwnLocation = true;
		}
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = true;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = true;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = false;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if (m_pClientList[iClientH] == 0) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil)
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (bNotify) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, 0, 0, 0, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	}
}

void CGame::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	std::memset(cVerMessage, 0, sizeof(cVerMessage));
	std::snprintf(cVerMessage, sizeof(cVerMessage), "Helbreath Sources %s.%s - www.xtremehb.com", DEF_UPPERVERSION, DEF_LOWERVERSION);
	ShowClientMsg(iClientH, cVerMessage);

}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char* pGMName, uint16_t wReqServerID, uint16_t wReqClientH, uint16_t wTime, char* pPlayer)
{
	//char * cp, cTemp[120];
	//uint16_t * wp;
	//int i;

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	//	if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
	//		// Ã£¾Ò´Ù.
	//		std::memset(cTemp, 0, sizeof(cTemp));
	//		cp = (char *)(cTemp);
	//		*cp = GSM_RESPONSE_SHUTUPPLAYER;
	//		cp++;

	//		wp = (uint16_t *)cp;
	//		*wp = wReqServerID;
	//		cp += 2;

	//		wp = (uint16_t *)cp;
	//		*wp = wReqClientH;
	//		cp += 2;

	//		memcpy(cp, pGMName, 10);
	//		cp += 10;

	//		wp = (uint16_t *)cp;
	//		*wp = (uint16_t) wTime;
	//		cp += 2;

	//		memcpy(cp, pPlayer, 10);
	//		cp += 10;

	//		// v2.14 ¼Ë¾÷½Ã°£À» ºÐÀ¸·Î ¼öÁ¤
	//		m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ 

	//		SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, 0, 0, pPlayer);

	//		bStockMsgToGateServer(cTemp, 27);
	//		return;	
	//	}
}

// v2.14 05/22/2004 - Hypnotoad - adds pk log
bool CGame::_bPKLog(int iAction, int iAttackerH, int iVictumH, char* pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	//  ·Î±× ³²±ä´Ù. 
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTemp1, 0, sizeof(cTemp1));
	std::memset(cTemp2, 0, sizeof(cTemp2));

	if (m_pClientList[iVictumH] == 0) return false;

	switch (iAction) {

	case DEF_PKLOG_REDUCECRIMINAL:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
		break;

	case DEF_PKLOG_BYPLAYER:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by PC\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYPK:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYENERMY:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by Enemy\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYNPC:
		if (pNPC == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, pNPC);
		break;
	case DEF_PKLOG_BYOTHER:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnknown", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
		break;
	default:
		return false;
	}
	PutPvPLogFileList(cTxt);
	return true;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
	short sX, sY;
	char buff[100];

	if (m_pClientList[iClientH] == 0) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (bResurrect == false) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = false;
		return;
	}

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == false) {
		try
		{
			std::snprintf(buff, sizeof(buff), "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	std::snprintf(buff, sizeof(buff), "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);


	m_pClientList[iClientH]->m_bIsKilled = false;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH) / 2;
	// Player's MP
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	// Player's SP
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = false;

	// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

bool CGame::bCheckClientAttackFrequency(int iClientH, uint32_t dwClientTime)
{
	uint32_t dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == 0)
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 450) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Swing Hack: (%s) Player: (%s) - attacking with weapon at irregular rates.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}

			return false;
		}

		//testcode
		//std::snprintf(G_cTxt, sizeof(G_cTxt), "Attack: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return false;
}

bool CGame::bCheckClientMagicFrequency(int iClientH, uint32_t dwClientTime)
{
	uint32_t dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == 0)
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if ((dwTimeGap < 1500) && (m_pClientList[iClientH]->m_bMagicConfirm)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Speed Cast: (%s) Player: (%s) - casting magic at irregular rates. ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}
			return false;
		}

		m_pClientList[iClientH]->m_iSpellCount--;
		m_pClientList[iClientH]->m_bMagicConfirm = false;
		m_pClientList[iClientH]->m_bMagicPauseTime = false;

		//testcode
		//std::snprintf(G_cTxt, sizeof(G_cTxt), "Magic: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return false;
}

bool CGame::bCheckClientMoveFrequency(int iClientH, uint32_t dwClientTime)
{
	uint32_t dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == 0)
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsMoveBlocked = false;
			return false;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsAttackModeChange = false;
			return false;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

		if ((dwTimeGap < 200) && (dwTimeGap >= 0)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Speed Hack: (%s) Player: (%s) - running too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}
			return false;
		}

		// testcode
		// std::snprintf(G_cTxt, sizeof(G_cTxt), "Move: %d", dwTimeGap);
		// PutLogList(G_cTxt);
	}

	return false;
}

void CGame::CrusadeWarStarter()
{
	SYSTEMTIME SysTime;
	int i;

	if (m_bIsCrusadeMode) return;
	if (m_bIsCrusadeWarStarter == false) return;

	// ���� ���� 1�������� 
	GetLocalTime(&SysTime);

	for (i = 0; i < DEF_MAXSCHEDULE; i++)
		if ((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) &&
			(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) &&
			(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
		}
}

void CGame::OnTimer(char cType)
{
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	// MODERNIZED: GameProcess moved to EventLoop to prevent blocking socket polling
	// OnTimer now only handles periodic events (CheckClientResponseTime, weather, etc.)
	// GameProcess() is called directly in EventLoop every 300ms


	if ((dwTime - m_dwGameTime2) > 1000) {
		CheckClientResponseTime();
		//SendMsgToGateServer(MSGID_GAMESERVERALIVE, 0);
		CheckDayOrNightMode();
		// ȭ�� ���� 
		InvalidateRect(G_hWnd, 0, true);
		m_dwGameTime2 = dwTime;
		// v1.41 
		//_CheckGateSockConnection();

		// v1.41
		if (m_bIsGameStarted == false) {
			// ������ ������ �غ� �Ǿ���. �޽����� ������.
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0);
			m_bIsGameStarted = true;

			// Initialize EntityManager now that maps are loaded
			if (m_pEntityManager != NULL) {
				// EntityManager owns the entity array now, just set maps and game reference
				m_pEntityManager->SetMapList(m_pMapList, DEF_MAXMAPS);
				m_pEntityManager->SetGame(this);
				PutLogList("EntityManager initialized");
			}
		}
	}
	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		//SendStockMsgToGateServer();
		m_dwGameTime6 = dwTime;

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14 ���Ĵ� �˴ٿ�� ������ �α� ���� 
				SendMessage(m_hWnd, WM_CLOSE, 0, 0);
				return;

			}
		}
	}

	if ((dwTime - m_dwGameTime3) > 1000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		// Use EntityManager for spawn generation
		if (m_pEntityManager != NULL)
			m_pEntityManager->ProcessSpawns();

		// v1.432-3 Sub-Log-Socket�� �Ѳ����� ����� ���� �ƴ϶� ������ �����.
		/*if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
		 m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(DEF_SERVERSOCKETBLOCKLIMIT);  // MODERNIZED: Removed m_hWnd
		 m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort);  // MODERNIZED: Removed WM_ONLOGSOCKETEVENT
		 m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
		 std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
		 PutLogList(G_cTxt);
		 m_iSubLogSockInitIndex++;
		}*/

		m_dwGameTime4 = dwTime;
	}



	if ((dwTime - m_dwGameTime5) > 1000 * 60 * 3) {

		m_dwGameTime5 = dwTime;

		// v1.41 ���� �õ尪 �ʱ�ȭ.
		srand((unsigned)time(0));
	}

	if ((dwTime - m_dwFishTime) > 5000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		//ApocalypseStarter();
		ApocalypseEnder();
		m_dwFishTime = dwTime;
	}

	if ((dwTime - m_dwWhetherTime) > 1000 * 20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}

	if ((m_bHeldenianRunning) && (m_bIsHeldenianMode)) {
		SetHeldenianMode();
	}
	// v1.4311-3 �߰�  �νð����� ������ ������ �ʱ�ȭ�ϰ� ������ �������� ����� �˷��ش�. 1000*60*60*2 = 7200000
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == false) && (m_bOnExitProcess) && ((dwTime - m_dwExitProcessTime) > 1000 * 2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = true;

			// v1.41 ���� ������ �������� �ڵ� �˴ٿ� �� ���̶�� �ٽ� ������ �⵿��Ų��. 
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				// v1.432 ���� �˴ٿ��� ������ ���� ���� ī��Ʈ �ٿ ����. ���� ���޵��� ���� �޽����� �����ϱ� ���� �����ð��� �δ°��� ����. v2.05
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10�ʸ��� ���� ���� �м� 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000 * 10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		// v2.03 ������ ������ �󵵼��� ���� 
		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// �ð��� ������ ���� Ȱ�� �� ī��Ʈ�� ���ҽ�Ŵ.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::GlobalStartCrusadeMode()
{
	uint32_t dwCrusadeGUID;
	SYSTEMTIME SysTime;

	// ������ ���� �Ϸ翡 �ι� �������� �߻��ϴ� ���� ���� �ڵ� 
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = GameClock::GetTimeMS();

	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (uint32_t *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);*/

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::OnStartGameSignal()
{
	// Load map configurations from MapInfo.db
	sqlite3* mapInfoDb = nullptr;
	std::string mapInfoDbPath;
	bool mapInfoDbCreated = false;

	if (EnsureMapInfoDatabase(&mapInfoDb, mapInfoDbPath, &mapInfoDbCreated)) {
		if (HasMapInfoRows(mapInfoDb, "maps")) {
			PutLogListLevel(LOG_LEVEL_NOTICE, "Loading map configurations from MapInfo.db...");
			int mapsLoaded = 0;
			for (int i = 0; i < DEF_MAXMAPS; i++)
			{
				if (m_pMapList[i] != 0)
				{
					// Auto-detect fight zone and ice maps from name
					if (memcmp(m_pMapList[i]->m_cName, "fightzone", 9) == 0)
						m_pMapList[i]->m_bIsFightZone = true;
					if (memcmp(m_pMapList[i]->m_cName, "icebound", 8) == 0)
						m_pMapList[i]->m_bIsSnowEnabled = true;

					if (LoadMapConfig(mapInfoDb, m_pMapList[i]->m_cName, m_pMapList[i])) {
						mapsLoaded++;
						// Spawn static NPCs for this map from database
						SpawnMapNpcsFromDatabase(mapInfoDb, i);
					}
					else {
						char cTxt[256];
						std::snprintf(cTxt, sizeof(cTxt), "(!) WARNING: Failed to load map config for: %s", m_pMapList[i]->m_cName);
						PutLogList(cTxt);
						// Fallback to text file
						_bReadMapInfoFiles(i);
					}
				}
			}
			char cTxt[128];
			std::snprintf(cTxt, sizeof(cTxt), "Loaded %d map configurations from database.", mapsLoaded);
			PutLogListLevel(LOG_LEVEL_NOTICE, cTxt);
		}
		else {
			PutLogListLevel(LOG_LEVEL_NOTICE, "MapInfo.db empty, falling back to text files...");
			for (int i = 0; i < DEF_MAXMAPS; i++)
			{
				if (m_pMapList[i] != 0)
				{
					_bReadMapInfoFiles(i);
				}
			}
		}
		CloseMapInfoDatabase(mapInfoDb);
	}
	else {
		PutLogListLevel(LOG_LEVEL_NOTICE, "MapInfo.db not available, loading from text files...");
		for (int i = 0; i < DEF_MAXMAPS; i++)
		{
			if (m_pMapList[i] != 0)
			{
				_bReadMapInfoFiles(i);
			}
		}
	}

	bool loadedSchedules = false;
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	bool configDbReady = EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated);
	if (configDbReady && !configDbCreated) {
		bool hasCrusade = HasGameConfigRows(configDb, "crusade_structures");
		bool hasSchedule = HasGameConfigRows(configDb, "event_schedule");
		if (hasCrusade && hasSchedule) {
			if (LoadCrusadeConfig(configDb, this) && LoadScheduleConfig(configDb, this)) {
				loadedSchedules = true;
			}
		}
	}

	if (!loadedSchedules) {
		PutLogList("(!!!) WARNING! Crusade/Schedule configs missing in GameConfigs.db.");
	}

	_LinkStrikePointMapIndex();

	if (configDb != nullptr) {
		CloseGameConfigDatabase(configDb);
	}

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");

	PutLogList("(!) Game Server Activated.");

}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
	int i;
	char cMapName[11];

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing crusade teleport: (%s) Player: (%s) - setting teleport location when crusade is disabled.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing crusade teleport: (%s) Player: (%s) - teleporting when not in a guild",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&
		m_iMiddlelandMapIndex != -1)
		return;

	for (i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
			// ��带 ã�Ҵ�.
			std::memset(cMapName, 0, sizeof(cMapName));
			strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
			PutLogList(G_cTxt);

			// !!! RequestTeleportHandler������ m_cMapName�� ���� ������ �״�� �Ķ���ͷ� �Ѱ��ָ� ������
			RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
			return;
		}

	// ��忡 �Ҵ�� �ڷ���Ʈ ��ǥ�� ����. ��� �Ҽ��� �ƴ� ���
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // �Ʒ����� �Ҽ� 
		break;
	case 2: // ������ �Ҽ�
		break;
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char* pMapName)
{
	int i, iIndex;
	uint32_t dwTemp, dwTime;

	// Ŭ���̾�Ʈ�κ����� ��û�� �ƴ϶� �ٸ� �����κ����� �ڷ���Ʈ ��ǥ ���� ��û��. ������ �ʿ� ����.

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = GameClock::GetTimeMS();

	// ���� ���� GUID�� ���� ��� �ڷ���Ʈ ��ǥ�� �����Ǿ� �ִ��� ã�´�.
	for (i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			// �̹� ��尡 �ִ�.
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
				// ������ ��ġ�Ѵ�. Ÿ�� �Է��� ��ŵ.
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				// ���� ����
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
		}

	// ������ ������ ����. ���� �����Ѵ�.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// ���� �������� �������� ���� ����Ʈ�� �ε����� ã�´�.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// ĳ�� ������ �� á��. �̷� ��� ����Ʈ �� ���� �������� ������� ���� ����Ʈ(iIndex)�� �����ϰ� ������Ʈ �Ѵ�.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char* pMapName)
{
	int i;
	int iIndex;
	uint32_t dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	// if a player is teleporting and its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing Crusade Set Teleport:(%s) Player: (%s) - setting point when not a crusade.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{

		}
		return;
	}

	// if a player is teleporting and its not a crusade, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing Crusade Set Teleport: (%s) Player: (%s) - setting point when not a guildmaster.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{

		}
		return;
	}

	// v2.04 ��ǥ ���� 
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	// ����Ʈ ���� �޽��� �ۼ� 
	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;

	memcpy(cp, pMapName, 10);
	cp += 10;*/
	//

	dwTime = GameClock::GetTimeMS();

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ���� ���� GUID�� ���� ��� �ڷ���Ʈ ��ǥ�� �����Ǿ� �ִ��� ã�´�.
	for (i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			// �̹� ��尡 �ִ�.
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
				// ������ ��ġ�Ѵ�. Ÿ�� �Է��� ��ŵ.
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				// ���� ������ 
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;

				//����Ʈ ������ ���� �ٸ� ������ ���� ����
				//bStockMsgToGateServer(cData, 23);
				return;
			}
		}

	// ������ ������ ����. ���� �����Ѵ�.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//����Ʈ ������ ���� �ٸ� ������ ���� ����  
			//bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// ���� �������� �������� ���� ����Ʈ�� �ε����� ã�´�.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// ĳ�� ������ �� á��. �̷� ��� ����Ʈ �� ���� �������� ������� ���� ����Ʈ(iIndex)�� �����ϰ� ������Ʈ �Ѵ�.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//����Ʈ ������ ���� �ٸ� ������ ���� ����
	//bStockMsgToGateServer(cData, 23);
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
	int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
	int iTargetArray[DEF_MAXSTRIKEPOINTS];
	short sOwnerH;
	char  cOwnerType;
	uint32_t dwTime = GameClock::GetTimeMS();

	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}

	if (m_pMapList[iMapIndex] == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! 0 Map!");
		return;
	}

	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}

	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®ÀÇ ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
			iIndex++;
		}
	}

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// °á°ú º¸°í¿ë ½ºÆ®·°Ãç Å¬¸®¾î
	m_stMeteorStrikeResult.iCasualties = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// Æø°ÝÇÒ °Ç¹°ÀÌ ¾ø´Ù. ¸ðµÎ ÆÄ±«µÇ¾ú´Ù.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
	else {

		// ÇØ´ç ¸ÊÀÇ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¸ÞÅ×¿À °ø°Ý È¿°ú¸¦ º¸¿©ÁÖ¶ó´Â ¸Þ½ÃÁö Àü¼Û
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKEHIT, 0, 0, 0, 0);
			}

		for (i = 0; i < iIndex; i++) {
			// ¸ðµç Æø°Ý ¸ñÇ¥¿¡ ´ëÇØ µ¿ÀÏÇÑ °ø°ÝÀ» °¡ÇÑ´Ù.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY À§Ä¡ ÁÖÀ§¿¡ ÃÖ¼Ò 2°³ ÀÌ»óÀÇ Energy Shield Generator°¡ Á¸ÀçÇÏ¸é ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®´Â ¹«»çÇÏ´Ù. ±×·¯³ª 1°³ ÀÌÇÏÀÌ¸é °ø°Ý¹Þ¾ÒÀ»¶§ HP°¡ ÁÙ¾îµç´Ù.
			// NPC ÁÖº¯¿¡ ÀÖ´Â Àû Ä³¸¯ÅÍ¸¦ Å½ÁöÇØ °æº¸¸¦ ¿ï¸°´Ù.
			iTotalESG = 0;
			for (ix = dX - 10; ix <= dX + 10; ix++)
				for (iy = dY - 10; iy <= dY + 10; iy++) {
					m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != 0) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
						iTotalESG++;
					}
				}

			// testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {

				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// °Ç¹°ÀÌ ÆÄ±«µÇ¾ú´Ù.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// °Ç¹° ±â´É »ó½Ç
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = true;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// °Ç¹°ÀÌ ´ë¹ÌÁö¸¦ ¾ò¾ú´Ù.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// °Ç¹° ´ë¹ÌÁö ÀÔÀº ÈÄ ºÒÅ¸´Â ÀÌ¹ÌÁö »ðÀÔ 
					iEffect = iDice(1, 5) - 1;
					iAddDynamicObjectList(0, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex,
						static_cast<short>(m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] + (iDice(1, 3) - 2)),
						static_cast<short>(m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] + (iDice(1, 3) - 2)),
						60 * 1000 * 50);
				}
			}
		MSH_SKIP_STRIKE:;
		}

		// 1ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 1000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		// 4ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 4000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		// 6ÃÊ ÈÄ °ø°Ý °á°ú ÆÇ´Ü.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
}

void CGame::_ClearExchangeStatus(int iToH)
{
	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == 0) return;

	if (m_pClientList[iToH]->m_cExchangeName)
		SendNotifyMsg(0, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0);

	// m_pClientList[iToH]->m_cExchangeName    = false;
	m_pClientList[iToH]->m_dwInitCCTime = false;
	m_pClientList[iToH]->m_iAlterItemDropIndex = 0;
	//m_pClientList[iToH]->m_cExchangeItemIndex = -1;
	m_pClientList[iToH]->m_iExchangeH = 0;

	m_pClientList[iToH]->m_bIsExchangeMode = false;

	std::memset(m_pClientList[iToH]->m_cExchangeName, 0, sizeof(m_pClientList[iToH]->m_cExchangeName));

}

void CGame::CancelExchangeItem(int iClientH)
{
	int iExH;

	// ÇöÀç ±³È¯À» Ãë¼ÒÇÑ´Ù. »ó´ë¹æµµ ÀÚµ¿À¸·Î Ãë¼ÒµÈ´Ù. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

//HBest force recall start code

//HBest force recall code

// v2.17 2002-7-15 ���Ͽ� ������� ���� �ð��� ���� �� �� �ְ� �����Ѵ�.
void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// �������� �� �ִ� ���� �ð��� ������ �ش�. 
		// �ð��� ���Ѵ��� iWarPeriod�� ���Ѵ�.

		// ������ ���� �ð��� �����Ǿ� ������ ���� ���� �ð��� ���� �ð����� �Ѵ�.

		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sForceRecallTime;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeMonday; break;  //������  3�� 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeTuesday; break;  //ȭ����  3�� 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeWednesday; break;  //������  3�� 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeThursday; break;  //�����  3�� 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeFriday; break; //�ݿ��� 15��
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSaturday; break; //����� 45�� 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSunday; break; //�Ͽ��� 60��
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0) {
			iTL_ = 20 * m_sForceRecallTime;
		}
		else {

			// �����ð��� �ִ�. ���Ϻ� �����ð����� ũ�� 1�� �ʱ�ȭ 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20 * m_sRaidTimeMonday; break;  //������  3�� 2002-09-10 #1
			case 2:	iTL_ = 20 * m_sRaidTimeTuesday; break;  //ȭ����  3��
			case 3:	iTL_ = 20 * m_sRaidTimeWednesday; break;  //������  3��
			case 4:	iTL_ = 20 * m_sRaidTimeThursday; break;  //�����  3��
			case 5:	iTL_ = 20 * m_sRaidTimeFriday; break; //�ݿ��� 15��
			case 6:	iTL_ = 20 * m_sRaidTimeSaturday; break; //����� 45�� 
			case 0:	iTL_ = 20 * m_sRaidTimeSunday; break; //�Ͽ��� 60��
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_)
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return;
}

void CGame::CheckForceRecallTime(int iClientH)
{
	SYSTEMTIME SysTime;
	int iTL_;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeMonday; break;  //������  3�� 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeTuesday; break;  //ȭ����  3�� 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeWednesday; break;  //������  3�� 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeThursday; break;  //�����  3�� 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeFriday; break; //�ݿ��� 15��
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSaturday; break; //����� 45�� 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSunday; break; //�Ͽ��� 60��
			}
		}
	}
	else {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			iTL_ = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20 * m_sRaidTimeMonday; break;  //������  3�� 2002-09-10 #1
			case 2:	iTL_ = 20 * m_sRaidTimeTuesday; break;  //ȭ����  3�� 
			case 3:	iTL_ = 20 * m_sRaidTimeWednesday; break;  //������  3�� 
			case 4:	iTL_ = 20 * m_sRaidTimeThursday; break;  //�����  3�� 
			case 5:	iTL_ = 20 * m_sRaidTimeFriday; break; //�ݿ��� 15��
			case 6:	iTL_ = 20 * m_sRaidTimeSaturday; break; //����� 45�� 
			case 0:	iTL_ = 20 * m_sRaidTimeSunday; break; //�Ͽ��� 60��
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_)
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return;

}

int ITEMSPREAD_FIEXD_COORD[25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};


// 05/21/2004 - Hypnotoad - Balances to drop status
// SUMMONGUILD Deleted
/*
*/

void CGame::SendCollectedMana()
{
	//SendMsgToGateServer(MSGID_COLLECTEDMANA, 0);

	// ���� ������ ���ٸ� �޽��� �������� �ʴ´�. ���� ������ ���� �ʿ��� �޽����� �����ϸ� �ȵȴ�.
	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	PutLogList(G_cTxt);

	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (uint16_t *)cp;
	*wp = (uint16_t)m_iCollectedMana[1];
	cp += 2;

	wp = (uint16_t *)cp;
	*wp = (uint16_t)m_iCollectedMana[2];
	cp += 2;*/

	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

	//bStockMsgToGateServer(cData, 5);

	// �׵��� ���� ������ ������ Ŭ����.
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(uint16_t wAresdenMana, uint16_t wElvineMana)
{
	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wElvineMana > 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}

//New Changed 11/05/2004
// v2.15 ���׿��� ������ ���� �ǹ� HP �� �����ֱ� ���� ��ƾ 
// ���� ���� �ǹ��� 4���� ��쿡 ���缭 ��ƾ�� ���� �Ǿ� �ִ�.
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
	int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS];
	char* cp2, cWinnerSide, cTempData[120];
	uint16_t* wp;

	if (m_bIsCrusadeMode == false) return;

	// ����ڿ��� ���� �ǹ��� HP�� �����ֱ� ���� ���� �ʱ�ȭ 
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0;

	// ������ ȿ���� ����Ѵ�. ��� �ǹ��� �ı��Ǿ��ٸ� ������ ��� ����. �׷��� ������ ����� ��� ������ ����Ʈ.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP;
		}
	}

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// �۵����� �ǹ��� ����. ũ�缼�̵� ��� ����: �ٸ� ������ �˷��ش�.
		// ũ�缼�̵� ��� ������� ���� ������ Ŭ���̾�Ʈ�鿡�� �ٷ� ����.
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // �̱� ���� ������
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // �̱� ���� �Ʒ�����
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0);
		}

		// �ٸ� ������ ũ�缼�̵� ���Ḧ �˸�.
		/*std::memset(cData, 0, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);*/

	}
	else {
		// ���� ��Ȳ�� ��� ������ ����Ʈ.
		/*std::memset(cData, 0, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (uint16_t *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (uint16_t *)cp;
		*wp = (uint16_t) iActiveStructure;
		cp += 2;*/

		//v2.15 �߰�  ��Ż �ǹ��� ���� 
		std::memset(cTempData, 0, sizeof(cTempData));
		cp2 = (char*)(cTempData);

		wp = (uint16_t*)cp2;
		*wp = (uint16_t)m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
			wp = (uint16_t*)cp2;
			*wp = (uint16_t)iStructureHP[i];
			cp2 += 2;
		}

		//memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 
		//bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );

		// ���� �������� ���� �޽����� ���� �����Ƿ� ���� �����Ѵ�.
		// v2.15 �ǹ��� ������ HP�� ������.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure, m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	// ��� ������ ��Ʈ���� Ŭ����
	m_stMeteorStrikeResult.iCasualties = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

void CGame::_LinkStrikePointMapIndex()
{
	int i, z, x;

	// ������ �ǹ� ���θ� �ٸ� ������ ���� ��ũ�� �Ұ����ϹǷ� �ٿ�ȴ�!
	for (i = 0; i < DEF_MAXMAPS; i++)
		if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
			// ��Ʈ����ũ ����Ʈ�� ���ǵ� ���̴�. ������ ��Ʈ����ũ ����Ʈ�� ����� ���� �ε����� ���� �����Ѵ�.
			for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++)
				if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
					for (x = 0; x < DEF_MAXMAPS; x++)
						if ((m_pMapList[x] != 0) && (strcmp(m_pMapList[x]->m_cName, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
							// �ε����� ���ߴ�. �����Ѵ�.
							m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
							//testcode
							PutLogList(G_cTxt);

							goto LSPMI_LOOPBREAK;
						}
				LSPMI_LOOPBREAK:;
				}
		}
}

bool CGame::_bRegisterMap(char* pName)
{
	int i;
	char cTmpName[11], cTxt[120];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXMAPS; i++)
		if ((m_pMapList[i] != 0) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
			std::snprintf(cTxt, sizeof(cTxt), "Map already installed: %s", cTmpName);
			PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
			return false;
		}

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] == 0) {
			m_pMapList[i] = new class CMap(this);
			if (m_pMapList[i]->bInit(pName) == false) {
				std::snprintf(cTxt, sizeof(cTxt), "Map data load failed: %s", pName);
				PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
				return false;
			};

			if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0))
				m_iMiddlelandMapIndex = i;

			if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0))
				m_iAresdenMapIndex = i;

			if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0))
				m_iElvineMapIndex = i;

			if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0))
				m_iBTFieldMapIndex = i;

			if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0))
				m_iGodHMapIndex = i;

			m_iTotalMaps++;
			return true;
		}

	std::snprintf(cTxt, sizeof(cTxt), "Map cannot be added (no space): %s", pName);
	PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
	return false;
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char* cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char* cData)
{
	int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, 0, 0, 0, 0, iTotalStrikePoints, cData);
		}
}

// v2.16 2002-5-21 °í±¤Çö Ãß°¡
bool CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, bool bBonus)
{
	int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == 0) return false;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb = 8; break;  // +7 :0.57%    +8
	case 7: iProb = 8; break;  // +8 :0.05%    +9
	case 8: iProb = 5; break;  // +9 :0.004%   +10
	case 9: iProb = 3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {
		if (iProb > 20)
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7)
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if (bBonus) iProb *= 2;

	iProb *= 100;
	iResult = iDice(1, 10000);

	if (iProb >= iResult) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return true;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return false;
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char* cp, cTemp[256];
	uint32_t dwMsgSize;
	short* sp;

	std::memset(cTemp, 0, sizeof(cTemp));

	{
		auto* header = reinterpret_cast<hb::net::PacketHeader*>(cTemp);
		header->msg_id = MSGID_COMMAND_CHATMSG;
		header->msg_type = 0;
	}

	cp = (char*)(cTemp + sizeof(hb::net::PacketHeader));
	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, "HGServer", 8); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if (dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::Command_YellowBall(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cBuff[256], cPlayerName[11], cMapName[32];
	int iSoxH, iSoX, i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 653: iSoX++; iSoxH = i; break; // ���� ���� ������ 
			}
		}
	if (iSoX > 0) {

		std::memset(cPlayerName, 0, sizeof(cPlayerName));
		std::memset(cBuff, 0, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		token = strtok(NULL, seps);

		token = strtok(NULL, seps);
		if (token == 0) {
			return;
		}

		if (strlen(token) > 10) {
			memcpy(cPlayerName, token, 10);
		}
		else {
			memcpy(cPlayerName, token, strlen(token));
		}

		for (int i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != 0) {
				if (memcmp(cPlayerName, m_pClientList[i]->m_cCharName, 10) == 0) {
					if ((m_pClientList[iClientH]->m_cLocation) != (m_pClientList[i]->m_cLocation)) return;
					std::memset(cMapName, 0, sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(%s) Player: (%s) - YellowBall MapName(%s)(%d %d)", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					PutItemLogFileList(G_cTxt);
					ItemDepleteHandler(iClientH, iSoxH, true);
					RequestTeleportHandler(iClientH, "2   ", cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					return;
				}
			}
		}
		m_pClientList[iClientH]->m_bIsAdminOrderGoto = true;

		/*std::memset(cBuff, 0, sizeof(cBuff));

		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;

		wp = (uint16_t *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (uint16_t *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp,cPlayerName,10);
		cp += 10;

		memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
		cp += 10;

		bStockMsgToGateServer(cBuff,25);*/

	}
}

void CGame::Command_RedBall(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char seps[] = "= \t\r\n", cName[21], cNpcName[21], cNpcWaypoint[11];
	int iNamingValue, tX, tY, i, x, iNpcID;
	int iSoxH, iSoX;

	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;

	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 652: iSoX++; iSoxH = i; break; // ���� ���� ������ 
			}
		}
	if (iSoX > 0) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {

		}
		else {

			std::memset(cNpcName, 0, sizeof(cNpcName));
			switch (iDice(1, 5)) {
			case 1: strcpy(cNpcName, "Wyvern"); iNpcID = 66; break;
			case 2: strcpy(cNpcName, "Hellclaw"); iNpcID = 49; break;
			case 3: strcpy(cNpcName, "Fire-Wyvern"); iNpcID = 73; break;
			case 4: strcpy(cNpcName, "Tigerworm"); iNpcID = 50; break;
			case 5: strcpy(cNpcName, "Gagoyle"); iNpcID = 52; break;
			}
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));

			tX = (int)m_pClientList[iClientH]->m_sX;
			tY = (int)m_pClientList[iClientH]->m_sY;
			if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(%s) Player: (%s) - RedBall used %s [%s(%d, %d)] ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cNpcName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, tX, tY);
				PutItemLogFileList(G_cTxt);
			}
		}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
			if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
				SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, tX, tY, iNpcID, 0, 0, 0);
			}
		ItemDepleteHandler(iClientH, iSoxH, true);
	}
}

void CGame::Command_BlueBall(int iClientH, char* pData, uint32_t dwMsgSize)

{
	char seps[] = "= \t\r\n";
	char   cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA;
	int    pX, pY, j, iNum, iNamingValue, iNpcID;
	int i, x;
	bool   bMaster;
	int iSoxH, iSoX;

	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;


	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 654: iSoX++; iSoxH = i; break; // ���� ���� ������ 
			}
		}
	if (iSoX > 0) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {

		}
		else {

			std::memset(cNpcName, 0, sizeof(cNpcName));

			switch (iDice(1, 38)) {
			case 1: strcpy(cNpcName, "Slime");			iNpcID = 10; break;
			case 2: strcpy(cNpcName, "Giant-Ant");		iNpcID = 15; break;
			case 3: strcpy(cNpcName, "Zombie");			iNpcID = 17; break;
			case 4: strcpy(cNpcName, "Scorpion");		iNpcID = 16; break;
			case 5: strcpy(cNpcName, "Skeleton");		iNpcID = 11; break;
			case 6: strcpy(cNpcName, "Orc-Mage");		iNpcID = 14; break;
			case 7: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; break;
			case 8: strcpy(cNpcName, "Stone-Golem");	iNpcID = 12; break;
			case 9: strcpy(cNpcName, "Hellbound");		iNpcID = 27; break;
			case 10: strcpy(cNpcName, "Giant-Frog");	iNpcID = 57; break;
			case 11: strcpy(cNpcName, "Troll");			iNpcID = 28; break;
			case 12: strcpy(cNpcName, "Cyclops");		iNpcID = 13; break;
			case 13: strcpy(cNpcName, "Ice-Golem");		iNpcID = 65; break;
			case 14: strcpy(cNpcName, "Beholder");		iNpcID = 53; break;
			case 15: strcpy(cNpcName, "Cannibal-Plant"); iNpcID = 60; break;
			case 16: strcpy(cNpcName, "Orge");			iNpcID = 29; break;
			case 17: strcpy(cNpcName, "Mountain-Giant"); iNpcID = 58; break;
			case 18: strcpy(cNpcName, "DireBoar");		iNpcID = 62; break;
			case 19: strcpy(cNpcName, "Liche");			iNpcID = 30; break;
			case 20: strcpy(cNpcName, "Stalker");		iNpcID = 48; break;
			case 21: strcpy(cNpcName, "WereWolf");		iNpcID = 33; break;
			case 22: strcpy(cNpcName, "Dark-Elf");		iNpcID = 54; break;
			case 23: strcpy(cNpcName, "Frost");			iNpcID = 63; break;
			case 24: strcpy(cNpcName, "Orc");			iNpcID = 14; break;
			case 25: strcpy(cNpcName, "Ettin");			iNpcID = 59; break;
			case 26: strcpy(cNpcName, "Tentocle");		iNpcID = 80; break;
			case 27: strcpy(cNpcName, "Giant-Crayfish"); iNpcID = 74; break;
			case 28: strcpy(cNpcName, "Giant-Plant");	iNpcID = 76; break;
			case 29: strcpy(cNpcName, "Rudolph");		iNpcID = 61; break;
			case 30: strcpy(cNpcName, "Claw-Turtle");	iNpcID = 72; break;
			case 31: strcpy(cNpcName, "Centaurus");		iNpcID = 71; break;
			case 32: strcpy(cNpcName, "Barlog");		iNpcID = 70; break;
			case 33: strcpy(cNpcName, "Giant-Lizard");	iNpcID = 75; break;
			case 34: strcpy(cNpcName, "MasterMage-Orc"); iNpcID = 77; break;
			case 35: strcpy(cNpcName, "Minotaurs");		iNpcID = 78; break;
			case 36: strcpy(cNpcName, "Unicorn");		iNpcID = 32; break;
			case 37: strcpy(cNpcName, "Nizie");			iNpcID = 79; break;
			}

			iNum = 10;
			cSA = 0;
			pX = m_pClientList[iClientH]->m_sX;
			pY = m_pClientList[iClientH]->m_sY;

			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) BlueBallEvent: SummonMob (%s)-(%d)", cNpcName, iNum);
			PutLogList(G_cTxt);

			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {

				std::memset(cName_Master, 0, sizeof(cName_Master));
				std::snprintf(cName_Master, sizeof(cName_Master), "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false, true)) == false) {

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
			}

			for (j = 0; j < (iNum - 1); j++) {
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Slave Mob
					std::memset(cName_Slave, 0, sizeof(cName_Slave));
					std::snprintf(cName_Slave, sizeof(cName_Slave), "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;



					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false) == false) {

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						// Slave
						if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}

			//
		}
	}

	for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
			SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, 0, 0, 0);
		}
	ItemDepleteHandler(iClientH, iSoxH, true);
}


/*
at the end of client connection have a true switch
at the start of client move handler check if the switch is true
if it is not true add 1 warning, if the warning reaches 3
delete client and log him, if the true switch
*/
//and when a client walks into a map with dynamic portal
//[KLKS] - [Pretty Good Coders] says:
//u gotta inform it
//[KLKS] - [Pretty Good Coders] says:
//or else they wont see it

/*void CGame::OpenApocalypseGate(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	//m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATEOPEN, 95, 31, 0, m_pClientList[iClientH]->m_cMapName);
}*/

void CGame::GlobalEndApocalypseMode()
{
	//char * cp, cData[120];

	if (m_bIsApocalypseMode == false) return;

	/*std::memset(cData, 0, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;*/

	LocalEndApocalypse();

	//bStockMsgToGateServer(cData, 5);
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{
	/*char * cp, cData[120];

	   std::memset(cData, 0, sizeof(cData));
	   cp = (char *)cData;
	   *cp = GSM_UPDATECONFIGS;
	   cp++;

	   *cp = (char)cConfigType;
	   cp++;*/

	LocalUpdateConfigs(cConfigType);

	//bStockMsgToGateServer(cData, 5);
}

void CGame::LocalUpdateConfigs(char cConfigType)
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated) {
		PutLogList("(!!!) GameConfigs.db unavailable; cannot reload configs.");
		return;
	}

	bool ok = false;
	if (cConfigType == 1) {
		ok = HasGameConfigRows(configDb, "settings") && LoadSettingsConfig(configDb, this);
		PutLogList(ok ? "(!!!) Settings updated successfully!" : "(!!!) Settings reload failed!");
	}
	if (cConfigType == 2) {
		ok = LoadAdminListConfig(configDb, this);
		PutLogList(ok ? "(!!!) AdminList updated successfully!" : "(!!!) AdminList reload failed!");
	}
	if (cConfigType == 3) {
		ok = LoadBannedListConfig(configDb, this);
		PutLogList(ok ? "(!!!) BannedList updated successfully!" : "(!!!) BannedList reload failed!");
	}
	if (cConfigType == 4) {
		ok = HasGameConfigRows(configDb, "admin_settings") && LoadAdminSettingsConfig(configDb, this);
		PutLogList(ok ? "(!!!) AdminSettings updated successfully!" : "(!!!) AdminSettings reload failed!");
	}

	CloseGameConfigDatabase(configDb);
}

void CGame::LocalEndApocalypse()
{
	int i;

	m_bIsApocalypseMode = false;

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEENDMSG, 0, 0, 0, 0);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
}

void CGame::LocalStartApocalypse(uint32_t dwApocalypseGUID)
{
	int i;
	//uint32_t dwApocalypse;

	m_bIsApocalypseMode = true;

	if (dwApocalypseGUID != 0) {
		_CreateApocalypseGUID(dwApocalypseGUID);
		//m_dwApocalypseGUID = dwApocalypse;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0);
			//RequestTeleportHandler(i, "0   ");
			//SendNotifyMsg(0, i, DEF_NOTIFY_APOCFORCERECALLPLAYERS, 0, 0, 0, 0);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)Apocalypse Mode ON.");
	PutLogList(G_cTxt);
}

bool CGame::bReadApocalypseGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "ApocalypseGUID = %d", m_dwApocalypseGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "ApocalypseGUID", 14) == 0) cReadMode = 1;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

bool CGame::bReadHeldenianGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianGUID = %d", m_dwHeldenianGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianWinnerSide = %d", m_sLastHeldenianWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::_CreateApocalypseGUID(uint32_t dwApocalypseGUID)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "ApocalypseGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		// ÆÄÀÏÀ» ¸¸µé ¼ö ¾ø°Å³ª »çÀÌÁî°¡ Áö³ªÄ¡°Ô ÀÛÀº °æ¿ì´Â . 
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create ApocalypseGUID(%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) ApocalypseGUID(%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

/*void CGame::ApocalypseStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode ) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleStart[i].iDay == SysTime.wDayOfWeek) &&
		(m_stApocalypseScheduleStart[i].iHour == SysTime.wHour) &&
		(m_stApocalypseScheduleStart[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is initiated!");
			GlobalStartApocalypseMode();
			return;
	}
}*/

void CGame::ApocalypseEnder()
{
	SYSTEMTIME SysTime;
	int i;

	if (m_bIsApocalypseMode == false) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
		if ((m_stApocalypseScheduleEnd[i].iDay == SysTime.wDayOfWeek) &&
			(m_stApocalypseScheduleEnd[i].iHour == SysTime.wHour) &&
			(m_stApocalypseScheduleEnd[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is concluded!");
			GlobalEndApocalypseMode();
			return;
		}
}

// New 06/05/2004
// Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		// ÆÄÆ¼ »óÅÂ°¡ ÀÌ¹Ì Á¸ÀçÇÏ¸é ÆÄÆ¼¸¦ ¸¸µé ¼ö ¾ø´Ù.
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

	// Gate Server¿¡ ÆÄÆ¼ »ý¼ºÈÄ PartyID¸¦ ¾Ë·ÁÁÙ °ÍÀ» ¿äÃ»ÇÑ´Ù. 
	cp = (char*)cData;

	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResultHandler(char* pData)
{
	char* cp, cResult, cName[12];
	uint16_t* wp;
	int i, iClientH, iPartyID, iTotal;

	cp = (char*)(pData);
	wp = (uint16_t*)cp;
	cp += 2;

	switch (*wp) {
	case 1:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2:
		wp = (uint16_t*)cp;
		iPartyID = *wp;
		cp += 2;

		PartyOperationResult_Delete(iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3:
		wp = (uint16_t*)cp;
		iClientH = *wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORH_LOOPBREAK1;
			}
	PORH_LOOPBREAK1:

		for (i = 0; i < DEF_MAXPARTYMEMBERS - 1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] = 0;
			}

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

		std::snprintf(G_cTxt, sizeof(G_cTxt), "Party Status 0: %s", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 8, 0, 0, 0);
		break;

	case 4:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5:
		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (uint16_t*)cp;
		iTotal = (int)*wp;
		cp += 2;

		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}


void CGame::PartyOperationResult_Create(int iClientH, char* pName, int iResult, int iPartyID)
{
	char* cp, cData[120];
	uint16_t* wp;
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: // ÆÄÆ¼ »ý¼º ½ÇÆÐ 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 0, 0, 0);
		break;

	case 1: // ÆÄÆ¼ »ý¼º ¼º°ø 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 1, 0, 0);

		// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡ µî·Ï.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
	PORC_LOOPBREAK1:

		// ¸¸¾à ÆÄÆ¼ °¡ÀÔÀ» ½ÅÃ»ÇÑ ÇÃ·¹ÀÌ¾î°¡ ÀÖ´Ù¸é 
		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != 0) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != 0)) {
			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			// ¸Þ½ÃÁö¸¦ º¸³ÂÀ¸´Ï Å¬¸®¾î
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char* pName, int iResult, int iPartyID)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 0, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 1, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
	PORC_LOOPBREAK1:

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((i != iClientH) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 4, 1, 0, pName);
			}
		break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char* pName, int iResult, int iPartyID)
{
	int i;
	// iClientH´Â ÀÌ¹Ì »ç¶óÁö°í ¾ø´Â Ä³¸¯ÅÍÀÏ¼öµµ ÀÖ´Ù.

	switch (iResult) {
	case 0: // ÆÄÆ¼ Å»Åð ½ÇÆÐ ? ÀÌ·± ÀÏÀÌ?
		break;

	case 1: // ÆÄÆ¼ Å»Åð ¼º°ø 
		if (iClientH == 0) {
			// iClientH °¡ NULLÀÌ¸é ¼­¹ö ÀÌµ¿Áß Á¢¼Ó Á¾·áµÇ¾î °­Á¦ Á¦°Å ¿äÃ»µÈ °ÍÀÓ.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					goto PORD_LOOPBREAK;
				}
		PORD_LOOPBREAK:

			// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡¼­ ÇØÁ¦.
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					//testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
					PutLogList(G_cTxt);
					goto PORC_LOOPBREAK1;
				}
		PORC_LOOPBREAK1:
			// ¸®½ºÆ® ÀÎµ¦½ºÀÇ ºó°ø°£À» Á¦°ÅÇÑ´Ù.
			for (i = 0; i < DEF_MAXPARTYMEMBERS - 1; i++)
				if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i + 1] != 0)) {
					m_stPartyInfo[iPartyID].iIndex[i] = m_stPartyInfo[iPartyID].iIndex[i + 1];
					m_stPartyInfo[iPartyID].iIndex[i + 1] = 0;
				}

			if (m_pClientList[iClientH] != 0) {
				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			}

			// ¸ðµç ÆÄÆ¼¿øµé¿¡°Ô ¾Ë·ÁÁØ´Ù.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
				}
			return;
		}

		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != 0) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		// ¸ðµç ÆÄÆ¼¿øµé¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
			}

		// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡¼­ ÇØÁ¦.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK2;
			}
	PORC_LOOPBREAK2:
		// ¸®½ºÆ® ÀÎµ¦½ºÀÇ ºó°ø°£À» Á¦°ÅÇÑ´Ù.
		for (i = 0; i < DEF_MAXPARTYMEMBERS - 1; i++)
			if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[iPartyID].iIndex[i] = m_stPartyInfo[iPartyID].iIndex[i + 1];
				m_stPartyInfo[iPartyID].iIndex[i + 1] = 0;
			}

		if (m_pClientList[iClientH] != 0) {
			m_pClientList[iClientH]->m_iPartyID = 0;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		}
		break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	// ÆÄÆ¼ ÇØ»êµÊ 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 2, 0, 0, 0);
			m_pClientList[i]->m_iPartyID = 0;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = 0;
			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Notify delete party: %d", i);
			PutLogList(G_cTxt);
		}
}



void CGame::RequestJoinPartyHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* cp, * token, cBuff[256], cData[120], cName[12];
	uint16_t* wp;
	int i;

	// ÆÄÆ¼ °¡ÀÔ ¿©ºÎ¸¦ ¹¯°í ÀÖ´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize) <= 0) return;

	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	token = strtok(cBuff, seps);

	token = strtok(NULL, seps);
	if (token != 0) {
		std::memset(cName, 0, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
			// °ÔÀÌÆ® ¼­¹ö·Î ÆÄÆ¼ ¸â¹ö °¡ÀÔÀ» ½ÅÃ»ÇÑ´Ù.
			if ((m_pClientList[i]->m_iPartyID == 0) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
				// ÆÄÆ¼¿¡ °¡ÀÔÇÏ°íÀÚ ÇÑ Ä³¸¯ÅÍ°¡ ÆÄÆ¼ ¸¶½ºÅÍ°¡ ¾Æ´Ï´Ù.
				return;
			}

			std::memset(cData, 0, sizeof(cData));

			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			return;
		}

	// °¡ÀÔÇÏ°íÀÚ ÇÏ´Â ÆÄÆ¼ ¸¶½ºÅÍ°¡ ÇöÀç ¼­¹ö¿¡ Á¸ÀçÇÏÁö ¾Ê´Â´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	cp = (char*)cData;
	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 4; // ¸â¹ö Á¦°Å ¿äÃ»
	cp += 2;
	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (uint16_t*)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	cp = (char*)cData;
	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 5; // ÆÄÆ¼ Á¤º¸ ¿äÃ»
	cp += 2;
	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (uint16_t*)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char* pName, int iTotal, char* pNameList)
{
	if (m_pClientList[iClientH] == 0) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		std::memset(cData, 0, sizeof(cData));
		cp = (char*)cData;
		/*dwp = (uint32_t *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;*/
		wp = (uint16_t*)cp;
		*wp = 4; // ¸â¹ö Á¦°Å ¿äÃ»
		cp += 2;
		wp = (uint16_t*)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		// »óÅÂ º¯È¯
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char* cp, cData[120];
	uint16_t* wp;
	int iH;

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» °ÅºÎµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == 0) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
			return;
		}

		SendNotifyMsg(0, iH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = 0;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» ½ÂÀÎ
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != 0)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
				return;
			}

			// °¡ÀÔ Ã³¸® ÇÑ´Ù.
			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
				return;
			}

			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				// ½ÅÃ» ¹ÞÀº ÇÃ·¹ÀÌ¾î°¡ ¾Æ¹«·± ÆÄÆ¼¿¡µµ °¡ÀÔÇÏ°í ÀÖÁö ¾Ê´Ù. ÀÌ Ä³¸¯ÅÍ¸¦ ÆÄÆ¼ ¸¶½ºÅÍ·Î ½ÅÃ»ÇÑ´Ù.
				RequestCreatePartyHandler(iClientH);
			}
			else {
				// Ã³¸® ºÒ°¡
			}
		}
		break;

	case 2: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» Ãë¼Ò
		// ÀÌ ¸Þ½ÃÁö¸¦ ¹Þ±â Àü¿¡ ÀÌ¹Ì ÆÄÆ¼¿¡ °¡ÀÔµÇ¾ú´Ù¸é Å»Åð Ã³¸®¸¦ ÇÑ´Ù.
		if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			// ¸â¹ö Á¦°Å¸¦ ¿äÃ»ÇÑ´Ù.
			RequestDismissPartyHandler(iClientH);
		}
		else {
			// °¡ÀÔ ½ÅÃ» »óÅÂ¿´´ø °ªµéÀ» ÃÊ±âÈ­ ÇÑ´Ù.
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// ½ÅÃ»Çß´ø Ä³¸¯ÅÍ°¡ Á¢¼ÓÀ» ²÷Àº »óÅÂ¶ó¸é NULLÀÏ ¼ö ÀÖ´Ù.
			if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) &&
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
				// ½ÅÃ»Çß´ø Ä³¸¯ÅÍÀÇ ÆÄÆ¼ ¾ÆÀÌµð¿Í »óÅÂ´Â °Çµå¸®Áö ¾Ê´Â´Ù.
				m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
				std::memset(m_pClientList[iH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			m_pClientList[iClientH]->m_iPartyID = 0;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperation(char* pData)
{
	char* cp, cName[12], cData[120];
	uint16_t* wp, wRequestType;
	int iGSCH, iPartyID;
	int bRet;

	cp = (char*)pData;

	wp = (uint16_t*)cp;
	wRequestType = *wp;
	cp += 2;

	wp = (uint16_t*)cp;
	iGSCH = (uint16_t)*wp;
	cp += 2;

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	wp = (uint16_t*)cp;
	iPartyID = (uint16_t)*wp;
	cp += 2;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Party Operation Type: %d Name: %s PartyID:%d", wRequestType, cName, iPartyID);
	PutLogList(G_cTxt);

	cp = (char*)cData;
	wp = (uint16_t*)cp;

	switch (wRequestType) {
	case 1: // ��Ƽ ���� ��û 
		iPartyID = m_pPartyManager->iCreateNewParty(cName);

		// ��Ƽ ���� ����! 
		*wp = 1; // ��Ƽ ���� ���� ��û�� ���� �����̴�.
		cp += 2;
		*cp = (int)!(iPartyID == 0); // ���� ���� 
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 2: // ��Ƽ �ػ� ��û 
		break;

	case 3: // ��� �߰� ��û
		bRet = m_pPartyManager->bAddMember(iPartyID, cName);

		// ��� �߰� ����
		*wp = 4; // ��� �߰��� ���� �����̴�.
		cp += 2;
		*cp = (int)bRet; // �߰� ���� 
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 4: // ��� ���� ��û
		bRet = m_pPartyManager->bRemoveMember(iPartyID, cName);

		// ��� ���� ����
		*wp = 6; // ��� ���ſ� ���� �����̴�.
		cp += 2;
		*cp = (int)bRet; // ���� ���� 
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 5: // ��Ƽ ��� Ȯ�� ��û. ���� �̵� ���¸� Ŭ�����Ѵ�.
		m_pPartyManager->bCheckPartyMember(iGSCH, iPartyID, cName);
		break;

	case 6: // ��Ƽ ���� ���� ��û. ��Ƽ�� �� ������ ���� �̸��� �˷��ش�.
		m_pPartyManager->bGetPartyInfo(iGSCH, cName, iPartyID);
		break;

	case 7: // ����� ���� �̵� ���� ��ȯ: �̰� ���õ� ���� ���� �ð� ���� Ȯ���� �ȵǸ� ��Ƽ���� �����Ѵ�.
		m_pPartyManager->SetServerChangeStatus(cName, iPartyID);
		break;
	}
}

// v2.16 2002-5-21 °í±¤Çö¼öÁ¤ : ÇÔ¼ö ¸ðµÎ º¯°æµÊ 
void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iItemX, iItemY, iSoM, iSoX, iSomH, iSoxH, iValue; // v2.172
	uint32_t dwTemp, dwSWEType;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	//hbest
	int bugint = 0;

	if (m_pClientList[iClientH] == 0) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, 0, 0, 0);
		return;
	}

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 46: // Pendants are category 46
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are type 1
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType 14
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
		default: // Other items are not upgradable
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType 14

		case 16: // AngelicPandent(STR)
		case 17: // AngelicPandent(DEX)
		case 18: // AngelicPandent(INT)
		case 19: // AngelicPandent(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			if (iValue >= 10)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			switch (iValue) {
			case 0:	sItemUpgrade = 10; break;
			case 1: sItemUpgrade = 11; break;
			case 2: sItemUpgrade = 13; break;
			case 3: sItemUpgrade = 16; break;
			case 4: sItemUpgrade = 20; break;
			case 5: sItemUpgrade = 25; break;
			case 6: sItemUpgrade = 31; break;
			case 7: sItemUpgrade = 38; break;
			case 8: sItemUpgrade = 46; break;
			case 9: sItemUpgrade = 55; break;
			default:
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
				break;
			}
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
				return;
			}
			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			int iDicePTA = iDice(1, 100);
			if (iDicePTA <= 70)
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				iValue++;
				if (iValue > 10) iValue = 10;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			else
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
			}
			return;
			break;
		}
		break;

	case 1: // weapons upgrade
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 703: // »ó¾îÀÇ ÇÃ·¥¹ö±× 
		case 709: // DarkKnightFlameberge 
		case 718: // DarkKnightGreatSword
		case 727: // DarkKnightFlamebergW
		case 736: // »õ·Î¿î »ó¾îÀÇ ÀÚÀÌ¾ðÆ®¼Òµå
		case 737: // DarkKnightAxe
		case 745: // DarkKnightHammer
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
				return;
			}
			// ¾ÆÀÌÅÛ ·¹º§¾÷ÀÌ ³ô¾ÆÁú¼ö·Ï ¾ÆÀÌÅÛ ·¹º§¾÷ÇÏ±â°¡ ¾î·Æ´Ù.
			// v2.15 ÁöÁ¸ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå °ø½Ä x(x+6)/8 +2 

			sItemUpgrade = (iValue * (iValue + 6) / 8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				if (iValue != 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
					return;
				}
			}

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
				return;
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

			if ((iValue == 0) && m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703)
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 709) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;

			}
			else if ((iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709)))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 709) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 745) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 737) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else
			{
				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;

		default:

			// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
			// °í´ëÀÇ~ Á¢µÎ»ç°¡ ºÙ´Â ¹«±â´Â ¾÷±×·¹ÀÌµå ºÒ°¡´É
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
				if (dwSWEType == 9) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
					return;
				}
			}
			// ÀÏ¹Ý ¹«±â ¾ÆÀÌÅÛ
			// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
					case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
					}
				}
			// ½ºÅæ ¿Àºê Á¦¸®¸¶°¡ ÀÖ´Ù.
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
					// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					// ½ÇÆÐÇÑ ¾ÆÀÌÅÛ ¾ø¾Ø´Ù.
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
					// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
					ItemDepleteHandler(iClientH, iSoxH, false);
					return;
				}

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					// Á¦ÀÛµÈ ¹«±â ¾÷±×·¹ÀÌµå ÃÖ´ë +10
					iValue++;
					if (iValue > 10)
						iValue = 10;
					else {
						// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
						// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
						ItemDepleteHandler(iClientH, iSoxH, false);
					}
				}
				else {
					// ÀÏ¹Ý ¹«±â ¾÷±×·¹ÀÌµå ÃÖ´ë +7
					iValue++;
					if (iValue > 7)
						iValue = 7;
					else {
						// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
						// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
						ItemDepleteHandler(iClientH, iSoxH, false);
					}
				}
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
			break;
		}
		break;

	case 3: // È° 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;

	case 5: // ¹æÆÐ
		// ¸ðµÎ ÀÏ¹Ý ¾ÆÀÌÅÛ
		// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
		// °­È­µÈ~ Á¢µÎ»ç°¡ ºÙ´Â ¹æ¾î±¸´Â ¾÷±×·¹ÀÌµå ºÒ°¡´É
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
			dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
			if (dwSWEType == 8) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 620: // ¸Þ¸®¿£-½Çµå
		case 623: // GM-½Çµå
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
			return;
		default: break;
		}


		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
				case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
				}
			}

		// ½ºÅæ ¿Àºê ¸Þ¸®¿£ÀÌ ÀÖ´Ù.			
		if (iSoM > 0) {
			// ¾÷±×·¹ÀÌµå ¼º°ø È®·ü °è»ê.
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, true) == false) {
				// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
				if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
				// ½ºÅæ ¿Àºê ¸Þ¸®¿£ ¾ø¾Ø´Ù.
				ItemDepleteHandler(iClientH, iSomH, false);
				return;
			}

			// ¾÷±×·¹ÀÌµå ¼º°ø!
			iValue++;
			if (iValue > 10)
				iValue = 10; // ¾÷±×·¹ÀÌµå ÇÑ°è 
			else {
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					// Á¦ÀÛ ¹æ¾î±¸ ÀÌ¹Ç·Î ¼ö¸í +20%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}
				else {
					// ÀÏ¹Ý ¹æ¾î±¸ ÀÌ¹Ç·Î ¼ö¸í +15%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0)
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				// ½ºÅæ ¿Àºê ¸Þ¸®¿£ ¾ø¾Ø´Ù.
				ItemDepleteHandler(iClientH, iSomH, false);
			}
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		break;

	case 6: // armors upgrade
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 621: // 
		case 622: // 

		case 700: // 
		case 701: // 
		case 702: //
		case 704: //  
		case 706: // 
		case 707:
		case 708:
		case 710:
		case 711: // 
		case 712: // 
		case 713: // 
		case 724: // 
		case 725:
		case 726:
		case 728:
		case 729: //
		case 730:
		case 731:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
				if (dwSWEType == 8) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, true) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
					ItemDepleteHandler(iClientH, iSomH, false);
					return;
				}
				iValue++;
				if (iValue > 10)
					iValue = 10;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0)
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					ItemDepleteHandler(iClientH, iSomH, false);
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 8: // wands upgrade 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 291: // MagicWand(LLF)

		case 714: // Èæ¸¶¹ý»çÀÇ ÁöÆÎÀÌ 
		case 732: // Èæ¿©¸¶¹ý»çÀÇ ÁöÆÎÀÌ
		case 738: // Èæ¸¶¹ý»çÀÇ ¸ÅÁ÷¿øµå
		case 746:

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				if (iValue != 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
					return;
				}
			}

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
				return;
			}
			// ¾ÆÀÌÅÛ ·¹º§¾÷ÀÌ ³ô¾ÆÁú¼ö·Ï ¾ÆÀÌÅÛ ·¹º§¾÷ÇÏ±â°¡ ¾î·Æ´Ù.
			// v2.15 ÁöÁ¸ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå °ø½Ä x(x+6)/8 +2 
			sItemUpgrade = (iValue * (iValue + 6) / 8) + 2;

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
				return;
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

			if (iValue == 0) {
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			}

			if ((iValue == 11) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 738) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else if ((iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 746) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else if ((iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 892) == false) {
					// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else
			{
				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

		default:
			// ÀÏ¹Ý ¾ÆÀÌÅÛ
			// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
					case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
					}
				}
			// ½ºÅæ ¿Àºê Á¦¸®¸¶°¡ ÀÖ´Ù.
			if (iSoX > 0) {
				// ¾÷±×·¹ÀÌµå ¼º°ø È®·ü °è»ê.
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
					// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
					// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
					ItemDepleteHandler(iClientH, iSoxH, false);
					return;
				}

				iValue++;
				if (iValue > 7)
					iValue = 7;
				else {
					// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
					// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
					ItemDepleteHandler(iClientH, iSoxH, false);
				}
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);

			break;
		}
		break;

		//hbest hero cape upgrade
	case 13:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 400:
		case 401:
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
					case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
					}
				}

			if (iSoM < 1) {
				return;
			}

			bugint = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
				return;
			}

			if ((m_pClientList[iClientH]->m_iContribution < 50) || (m_pClientList[iClientH]->m_iEnemyKillCount < 50))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
				return;
			}

			m_pClientList[iClientH]->m_iContribution -= 50;
			m_pClientList[iClientH]->m_iEnemyKillCount -= 50;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);

			if (iValue == 0)
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (bugint == 400) {
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 427) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}
				}
				else {
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 428) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				ItemDepleteHandler(iClientH, iSomH, false);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}

		default: break;
		}
		break;

	default:
		// ¾÷±×·¹ÀÌµå µÈ °Í ¾øÀ½.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
	int iMaxHP, iTemp, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {

		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));

		if (iTemp < (m_pClientList[iClientH]->m_iVit / 2)) iTemp = (m_pClientList[iClientH]->m_iVit / 2);

		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)

			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal;

		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
	}
	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{
	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;

	if (m_pClientList[iClientH] == 0) return 0;

	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0;

	if (m_pClientList[iClientH]->m_pItemList[sHeroHelm] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroArmor] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == 0) return 0;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

bool CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{
	int iNamingValue, tX, tY;
	short sOwnerH;
	char cOwnerType, cNpcName[21], cName[21], cNpcWaypointIndex[11];
	int bRet;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, 0, 0, 0, 0);
		return false;
	}

	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, 0, 0, 0, 0);
		return false;
	}

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != 0 && sOwnerH == DEF_OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
			return false;
		}
		else {
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
				return false;
			}

			std::memset(cNpcName, 0, sizeof(cNpcName));
			strcpy(cNpcName, "Crops");
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = iMapIndex + 65;

			std::memset(cNpcWaypointIndex, 0, sizeof(cNpcWaypointIndex));
			tX = dX;
			tY = dY;

			bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, 0, 0, 0, false, true);
			if (bRet == false) {
				m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (m_pNpcList[sOwnerH] == 0) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
				switch (iItemEffectValue1) {
				case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;
				}
				m_pNpcList[sOwnerH]->m_sAppr2 = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return true;
			}
		}
	}
	return false;
}

void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, bool bType)
{
	char cCropType;
	int iItemID;
	class CItem* pItem;

	iItemID = 0;
	cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3, 10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3, 10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4, 10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4, 10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5, 10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5, 10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6, 10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6, 10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7, 10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7, 10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8, 10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8, 10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9, 10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10, 10)); iItemID = 721; break; // Ginseng

	}

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
		delete pItem;
	}
	if (bType == 0) {
		m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem->m_sIDnum, 0,
			pItem->m_cItemColor, pItem->m_dwAttribute);
	}
	else if (bType == 1) {
		m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem->m_sIDnum, 0,
			pItem->m_cItemColor, pItem->m_dwAttribute);
	}

}

/*void CGame::CalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 short sItemIndex;
 int iDownValue = 1, iHammerChance = 100;

	if (m_pClientList[sTargetH] == 0) return;

	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0 )) {
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 14:
					if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
								iDownValue = 35;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
						}
					}
					else {
						iDownValue = 20; break;
					}
				case 10: iDownValue = 3; break;
				default: iDownValue = 1; break;
				}

				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled ) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType)
						case 52: iDownValue = 0; iHammerChance = 0;
				}
			}
		}

		if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
				m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		}

		if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 64000)) {
			m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			ReleaseItemHandler(sTargetH, iArmorType, true);
			return;
		}

	/*try
	{
		if (m_pClientList[sAttackerH] != 0) {
			if (cTargetType == DEF_OWNERTYPE_PLAYER) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 617) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 618) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 619) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 873) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 874) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 75) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 76)) {
						m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 6;
						return;
					}
				}
			}
		}*/

		/*if (m_pClientList[sAttackerH] != 0) {
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
				iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			else {
				iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}

			if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer
						iHammerChance = iHammerChance/2;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
				}
			}
			if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 622) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 621)) {
				iHammerChance = 0;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(iHammerChance (%d), target armor endurance (%d)!", iHammerChance, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan);
				PutLogList(G_cTxt);
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
				return;
			}
		}
		}
		}
	//}
	//catch(...)
	{

	}
}*/

bool CGame::bCalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
	int iDownValue = 1, iHammerChance = 100, iItemIndex;
	uint16_t wWeaponType;

	if (m_pClientList[sTargetH] == 0) return false;
	if (sAttackerH > DEF_MAXCLIENTS) return false;
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == 0)) return false;
	wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);		// sAttackerH was 2536 == null
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
		switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
		case 14:
			if ((wWeaponType == 31) || (wWeaponType == 32)) {
				iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iDownValue = 35;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
						iDownValue = 30;
					}
					break;
				}
			}
			else {
				iDownValue = 20;
			}
			break;
		case 10:
			iDownValue = 3;
			break;
		default:
			iDownValue = 1;
			break;
		}
	}
	if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled) {
		switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
		case 52:
			iDownValue = 0;
			iHammerChance = 0;
			break;
		}
	}
	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iArmorType, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan, 0, 0);
	}
	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
		ReleaseItemHandler(sTargetH, iArmorType, true);
		return true;
	}
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
			iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		else {
			iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		if ((wWeaponType == 31) || (wWeaponType == 32)) {
			iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
					iHammerChance -= iHammerChance >> 1;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
			}
			else {
				iHammerChance = ((iHammerChance + 3) >> 2);
			}
			switch (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum) {
			case 621:
			case 622:
				iHammerChance = 0;
				break;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			}
		}
	}
	return true;
}

uint32_t CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, bool bNearAttack, bool bIsDash, bool bArrowUse)
{
	int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	uint32_t  dwTime;
	uint16_t   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	bool   bKilled;
	bool   bNormalMissileAttack;
	bool   bIsAttackerBerserk;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    iAttackerHP, iMoveDamage, iRepDamage;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	short sItemIndex;
	short sSkillUsed;

	dwTime = GameClock::GetTimeMS();
	bKilled = false;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = false;
	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	cAttackerSA = 0;
	iAttackerSAvalue = 0;
	wWeaponType = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sAttackerH] == 0) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] == 0) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap) && (m_bIsHeldenianMode)) return 0;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

		if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
		}

		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L = 0;

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;
		if ((bIsDash) && (m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed] != 100) && (wWeaponType != 25) && (wWeaponType != 27)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Fullswing Hack: (%s) Player: (%s) - dashing with only (%d) weapon skill.", m_pClientList[sAttackerH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cCharName, m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed]);
				PutHackLogFileList(G_cTxt);
				DeleteClient(sAttackerH, true, true);
			}
			catch (...)
			{

			}
			return 0;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		if (wWeaponType == 0) {
			iAP_SM = iAP_L = iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L <= 0) iAP_L = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 + 0.5f);

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 + 0.5f);
		}
		else if (wWeaponType >= 40) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = true;

			iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
			iAP_L += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
		}

		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L <= 0) iAP_L = 1;

		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 5;
			iAP_L += 5;
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 851) || // KlonessEsterk 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863) || // KlonessWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864)) { // KlonessWand(MS.10) 
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732) || // BerserkWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738)) { // BerserkWand(MS.10)
				iAP_SM += 1;
				iAP_L += 1;
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) &&
				(m_cDayOrNight == 2)) {
				iAP_SM += 4;
				iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) &&
				(m_cDayOrNight == 1)) {
				iAP_SM += 4;
				iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 849) || // KlonessBlade 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 850)) { // KlonessAxe
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 20);
					if (iRepDamage > 5) iRepDamage = 5;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
			}
		}

		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;

		if ((bArrowUse != true) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 + 0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 + 0.5f);
			iAP_L += iTemp;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 6:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break;

			case 7:  iAP_SM *= 1; iAP_L *= 1; break;

			case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break;
			case 10:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5);                           break;
			case 14:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); iAttackerHitRatio += 20; break;
			case 21:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); iAttackerHitRatio += 50; break;
			default: break;
			}
			iAttackerHitRatio += 100;
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		if (bIsDash) {

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); break;
			case 10: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;
			case 14: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;
			default: break;
			}
		}

		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sAttackerH] == 0) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false) return 0;

		if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
		}

		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L = 0;

		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow >= 0)
		{
			iAP_L = iAP_SM = iDice(
				static_cast<uint32_t>(m_pNpcList[sAttackerH]->m_cAttackDiceThrow),
				static_cast<uint32_t>(m_pNpcList[sAttackerH]->m_cAttackDiceRange)
			);
		}

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;

		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled) return 0;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation)) return 0;

		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;

		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral)
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;

		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode)) {
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				iAP_SM = iAP_SM / 2;
				iAP_L = iAP_L / 2;
			}
			else {
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						iAP_SM = iAP_SM / 2;
						iAP_L = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;



		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sTargetH] == 0) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;

		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}

			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;

				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					// administrators instantly build crusade structures
					if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) {
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}

					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;
						}

						m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > m_iMaxWarContribution)
							m_pClientList[sAttackerH]->m_iWarContribution = m_iMaxWarContribution;
						std::snprintf(G_cTxt, sizeof(G_cTxt), "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, 0);
						break;
					case 5:
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					}
					break;
				}

				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						// Use EntityManager for NPC deletion
						if (m_pEntityManager != NULL)
							m_pEntityManager->DeleteEntity(sTargetH);
						return 0;
					case 8:
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						break;
					case 18:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						break;

					}
					break;
				}
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
		}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER)) {

		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;

		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
			iAttackerHitRatio += ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) - 50);
		}
	}

	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
		}
	}

	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == 0) {
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = false;
				DeleteClient(sAttackerH, true, true);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					return 0;
				}
				else {
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == 0)
						return 0;

					if (bArrowUse != true)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount <= 0) {

						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, false);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount, false, 0);
						iCalcTotalWeight(sAttackerH);
					}
				}
				if (cProtect == 1) return 0;
			}
			else {
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break;
				case 4: iTargetDefenseRatio += 100; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		switch (cProtect) {
		case 1:
			switch (m_pNpcList[sAttackerH]->m_sType) {
			case 54:
				if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0;
			}
			break;
		case 3: iTargetDefenseRatio += 40;  break;
		case 4: iTargetDefenseRatio += 100; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3);

	if (iDestHitRatio < m_iMinimumHitRatio) iDestHitRatio = m_iMinimumHitRatio;
	if (iDestHitRatio > m_iMaximumHitRatio) iDestHitRatio = m_iMaximumHitRatio;

	if ((bIsAttackerBerserk) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L = iAP_L * 2;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	if (bNearAttack) {
		iAP_SM = iAP_SM / 2;
		iAP_L = iAP_L / 2;
	}

	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
		iAP_L -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L <= 1) iAP_L = 1;
	}
	else {
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L <= 0) iAP_L = 0;
	}

	iResult = iDice(1, 100);

	if (iResult <= iDestHitRatio) {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1, 10) == 5)) return false;
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != 0))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L += iComboBonus;

			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
			case 0: break;
			case 1:
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
					iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
				}
				break;

			case 2:
				cAttackerSA = 61;
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue * 5;
				break;

			case 3:
				cAttackerSA = 62;
				break;
			}

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
				iAP_SM += iAP_SM / 3;
				iAP_L += iAP_L / 3;
			}

			if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
				iAP_SM += iAP_SM / 3;
				iAP_L += iAP_L / 3;
			}

			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iAP_SM += (iAP_SM * 7) / 10;
					iAP_L += (iAP_L * 7) / 10;
				}
				else {
					iAP_SM += iAP_SM / 3;
					iAP_L += iAP_L / 3;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) {
				return 0;
			}
			else {
				switch (cAttackerSA) {
				case 62:
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
						if (iTemp > 10) iTemp = 10;
						iAP_SM += iTemp;
					}
					break;
				}

				iAP_Abs_Armor = 0;
				iAP_Abs_Shield = 0;
				iTemp = iDice(1, 10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1;
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2;
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3;
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4;

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
						if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 3:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1, 100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						CalculateSSN_SkillIndex(sTargetH, 11, 1);
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
							}
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
								ReleaseItemHandler(sTargetH, iTemp, true);
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
					case 0: break;
					case 1:
						iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
						if (iTemp > iAP_SM) iAP_SM = iTemp;
						if (iAP_SM <= 0) iAP_SM = 1;
						break;
					case 2:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 30000,
								sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
						}
						break;
					case 3:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 2;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000,
								sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 10, 0, 0);
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, 0, 0);
						}
						break;
					case 4:
						iAP_SM = (m_pClientList[sTargetH]->m_iHP);
						break;
					case 5:
						m_pClientList[sAttackerH]->m_iHP += iAP_SM;
						if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
						break;
					}
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 50:
						if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
							sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						break;
					case 51:
						if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
							iAP_SM = 0;
						break;
					case 52:
						iAP_SM = 0;
						break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
					(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
					iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					else {
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
						}
					}
					break;

				case 3:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;
				}

				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT], 0, 0);
					switch (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
				}

				if ((m_pClientList[sTargetH]->m_bIsPoisoned == false) &&
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61))) {
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == false) {
						m_pClientList[sTargetH]->m_bIsPoisoned = true;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;

						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, 0, 0);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);
					bKilled = true;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iTemp = iGetMaxMP(sTargetH);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
							}
						}

						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);

						if (cAttackerType == DEF_OWNERTYPE_PLAYER)
							sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;

						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone))
							iMoveDamage = 60;
						else iMoveDamage = 40;

						if (iAP_SM >= iMoveDamage) {
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;
							}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;

							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, 0);
						}
						else {
						CAE_SKIPDAMAGEMOVE:
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
								case 6: iProb = 3500; break;
								case 8: iProb = 1000; break;
								case 9: iProb = 2900; break;
								case 10: iProb = 2500; break;
								case 14: iProb = 2000; break;
								case 21: iProb = 2000; break;
								default: iProb = 1; break;
								}
							}
							else iProb = 1;

							if (iDice(1, 10000) >= static_cast<uint32_t>(iProb))
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, 0);
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], 0, 0);
							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}

						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) {
							m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
						}
					}
				}
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled) return 0;
			if (m_bIsCrusadeMode) {
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47:
					case 51:
						return 0;

					default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 41:
						if (cAttackerSide != 0) {
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
								std::snprintf(G_cTxt, sizeof(G_cTxt), "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
								PutLogList(G_cTxt);
							}
						}
						break;
					}
				}
			}
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 1:
			case 2:
				return 0;
			}

			if (m_pNpcList[sTargetH]->m_cSize == 0)
				iDamage = iAP_SM;
			else iDamage = iAP_L;

			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage)) / 100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
				else if ((m_pNpcList[sTargetH]->m_sType == 31) && (cAttackerType == 1) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7))
					iDamage += iDice(3, 2);
			}


			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
				switch (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
				case 1:
					SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = 0;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);
			}

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5:
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}

			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
				bKilled = true;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

				if (iDice(1, 3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
								tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
								tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						}

						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX) * (m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY) * (m_pNpcList[sTargetH]->m_sY - tY);

						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != 0) {
								tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != 0) {
								tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						}

						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX) * (m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY) * (m_pNpcList[sTargetH]->m_sY - tY);

						if (iDst2 <= iDst1) {
							m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
					}
				}

			CAE_SKIPCOUNTERATTACK:

				if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER)
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;

				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = static_cast<char>(iDice(1, 8));
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = static_cast<char>(iDice(1, 8));
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType)) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp / 3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
								iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1 / 100.0f) * dTmp2;
								iExp += (int)dTmp3;
							}

							if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

							GetExp(sAttackerH, iExp);

							// Use EntityManager for NPC deletion
							if (m_pEntityManager != NULL)
								m_pEntityManager->DeleteEntity(sTargetH);
							return false;
						}
					}

				CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, 0);
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 2) {
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 0;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}

					if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
						dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iExp += (int)dTmp3;
					}

					if (m_bIsCrusadeMode) iExp = iExp / 3;

					if (m_pClientList[sAttackerH]->m_iLevel > 100) {
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 55:
						case 56:
							iExp = 0;
							break;
						default: break;
						}
					}
				}
			}
			break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

			if ((sWeaponIndex != -1) && (bArrowUse != true)) {
				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231)) {
					if (bKilled == false)
						CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else {
						if (m_pClientList[sAttackerH]->m_iHP <= 3)
							CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice) * 2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
					}
				}

				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0)) {
					iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) {
						switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1, 3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 2); break;
						case 3:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 3); break;
						}
					}

					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff)
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;

						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CURLIFESPAN, sWeaponIndex, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan, 0, 0);
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, 0, 0);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, true);
					}
				}
			}
			else {
				if (wWeaponType == 0) {
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
	/*char * cp, cBuff[120];
	uint16_t * wp;

	   std::memset(cBuff, 0, sizeof(cBuff));
	   cp = (char *)cBuff;
	   *cp = GSM_GRANDMAGICLAUNCH;
	   cp++;

	   wp = (uint16_t *)cp;
	   *wp = (uint16_t)iType;
	   cp += 2;

	   wp = (uint16_t *)cp;
	   *wp = (uint16_t)cAttackerSide;
	   cp += 2;

	   bStockMsgToGateServer(cBuff, 5);*/
}

// October 19, 2004 - 3.51 translated



// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
	int i;
	uint32_t dwTime = GameClock::GetTimeMS();

	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, 0, 0, 0);
					}
					else {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
					}
				}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 5000, 0, 0, m_iElvineMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
				}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, 0, 0, 0);
					}
					else {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
					}
				}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 1000 * 5, 0, 0, m_iAresdenMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
				}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated



// October 19, 2004 - 3.51 translated



// October 19,2004 - 3.51 translated





/*
void CGame::StormBringer(int iClientH, short dX, short dY)
{
	char cOwnerType;
	short sOwner, sAppr2, sAttackerWeapon;
	int  iDamage, iTemp, iV1, iV2, iV3;

	//ArchAngel Fix

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

		if (memcmp(m_pClientList[iClientH]->m_pItemList[iTemp]->m_cName, "StormBringer", 12) == 0){

			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner]->m_iAdminUserLevel < 3) {
					if (sAppr2 != 0) {
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;

						if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
							iDamage = iDice(iV1*2,iV2*2)+iV3;
						}
						else{
							iDamage = iDice(iV1,iV2)+iV3;
						}

						m_pClientList[sOwner]->m_iHP -= iDamage;
						if (m_pClientList[sOwner]->m_iHP <= 0){
							sAttackerWeapon = 1;
							m_pClientList[sOwner]->m_iHP = 0;

							m_pClientList[sOwner]->m_bIsKilled = true;
							m_pClientList[sOwner]->m_iLastDamage = iDamage;
							SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->ClearOwner(14, sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
						}
						else{
							SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
						}
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (sAppr2 != 0) {
					if (m_pNpcList[sOwner]->m_cSize == 0){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_SM;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_SM;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_SM;
					}
					else if (m_pNpcList[sOwner]->m_cSize == 1){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;
					}

					if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
						iDamage = iDice(iV1*2,iV2*2)+iV3;
					}
					else{
						iDamage = iDice(iV1,iV2)+iV3;
					}

					m_pNpcList[sOwner]->m_iHP -= iDamage;
					if (m_pNpcList[sOwner]->m_iHP <= 0){
						sAttackerWeapon = 1;
						m_pNpcList[sOwner]->m_iHP = 0;

						m_pNpcList[sOwner]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sOwner]->m_cBehavior = DEF_BEHAVIOR_DEAD;
						m_pNpcList[sOwner]->m_dwDeadTime = GameClock::GetTimeMS();
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->ClearOwner(10, sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
					}
					else{
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
					}
				}
				break;
			}
		}
	}
}*/

bool CGame::_bCheckCharacterData(int iClientH)
{
	int i;

	if ((m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) ||
		(m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) stat points are greater then server accepts.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iLevel > m_iMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) level above max server level.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if (m_pClientList[iClientH]->m_iExp < 0) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) experience is below 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			if (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])]->m_sIDnum == 492) || (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])]->m_sIDnum == 491)) {
					if (m_pClientList[iClientH]->m_iHP > (4 * (iGetMaxHP(iClientH) / 5))) {

					}
				}
			}
			else if (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND])] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND])]->m_sIDnum == 490)) {
					if (m_pClientList[iClientH]->m_iHP > (4 * (iGetMaxHP(iClientH) / 5))) {

					}
				}
			}
			else {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) HP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, iGetMaxHP(iClientH));
				PutHackLogFileList(G_cTxt);
				return false;
			}
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) MP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iMP, iGetMaxMP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) SP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iSP, iGetMaxSP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	try
	{
		for (i = 0; i < DEF_MAXBANNED; i++) {
			if (strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
			if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) {
				if (memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0) {
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Client Rejected: Banned: (%s)", m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					return false;
				}
				else {

				}
			}
		}
	}
	catch (...)
	{

	}

	return true;
}

void CGame::GlobalEndHeldenianMode()
{
	//char * cp, cData[32];

	if (m_bIsHeldenianMode == false) return;

	//std::memset(cData, 0, sizeof(cData));
	//cp = (char *)cData;
	//*cp = GSM_ENDHELDENIAN; // 22
	//cp++;
	//
	//bStockMsgToGateServer(cData, 1);
	LocalEndHeldenianMode();

}

void CGame::LocalEndHeldenianMode()
{
	int i, x, n;

	if (m_bIsHeldenianMode == false) return;
	m_bIsHeldenianMode = false;
	m_bHeldenianInitiated = true;

	m_dwHeldenianFinishTime = static_cast<uint32_t>(time(0));
	if (var_88C == 1) {
		if (m_cHeldenianModeType == 1) {
			if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 2;
			}
			else if (m_iHeldenianAresdenDead < m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenDead > m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 2;
			}
			else {
				m_sLastHeldenianWinner = m_cHeldenianVictoryType;
			}
		}
		else if (m_cHeldenianModeType == 2) {
			m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		}
		m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		if (bNotifyHeldenianWinner() == false) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN End. Result Report Failed");
			PutLogList(G_cTxt);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN End. %d", m_sLastHeldenianWinner);
	PutLogList(G_cTxt);

	for (i = 0; i < DEF_MAXMAPS; i++)
		if ((i < 0) || (i > 100)) break;
	if (m_pMapList[i] != 0) {
		for (x = 0; x < DEF_MAXCLIENTS; x++)
			if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
				SendNotifyMsg(0, x, DEF_NOTIFY_HELDENIANEND, 0, 0, 0, 0);
				if (m_pMapList[m_pClientList[x]->m_cMapIndex]->m_bIsHeldenianMap) {
					for (n = 0; n < DEF_MAXNPCS; n++)
						if ((m_pNpcList[n] != 0) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != 0) && (m_pNpcList[n]->m_bIsSummoned)) {
							RemoveHeldenianNpc(n);
						}
					RemoveOccupyFlags(x);
				}
			}
	}
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianVictoryType);
}

bool CGame::bNotifyHeldenianWinner()
{
	if (var_88C == 0) {
		bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, 0, 1, 0);
		return true;
	}
	else {
		return false;
	}

}

void CGame::RemoveHeldenianNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled) return;

	m_pNpcList[iNpcH]->m_bIsKilled = true;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;

	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, 1, 0);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = GameClock::GetTimeMS();

}

void CGame::RemoveOccupyFlags(int iMapIndex)
{
	uint32_t dwTime = GameClock::GetTimeMS();
	int i;
	short dX, dY;
	int iDynamicObjectIndex;
	class COccupyFlag* iOccupyFlagIndex;
	class CTile* pTile;
	int iy, ix;

	if (m_pMapList[iMapIndex] == 0) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
		//if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) return; // centu : wtf ?
		if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) {
			dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			pTile = (class CTile*)(m_pMapList[iMapIndex]->m_pTile + dX + dY * m_pMapList[iMapIndex]->m_sSizeY);
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) return;

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex,
				m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY,
				m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, 0, (short)0);

			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

			iOccupyFlagIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i];

			if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) {
				for (ix = dX - 2; ix <= dX + 2; ix++)
					for (iy = dY - 2; iy <= dY + 2; iy++) {
						pTile = (class CTile*)(m_pMapList[iMapIndex]->m_pTile + ix + iy * m_pMapList[iMapIndex]->m_sSizeY);
						pTile->m_sOwner = 0;
					}
			}
		}
}

void CGame::_CreateHeldenianGUID(uint32_t dwHeldenianGUID, int iWinnerSide)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "HeldenianGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create HeldenianGUID(%d) file", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "HeldenianGUID = %d", dwHeldenianGUID);
		strcat(cTemp, cTxt);

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) HeldenianGUID(%d) file created", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

/*********************************************************************************************************************
**  bool CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)										**
**  description			:: checks if the player is in the specified map												**
**  last updated		:: November 22, 2004; 6:19 PM; Hypnotoad													**
**	return value		:: bool																						**
**  commentary			::	-	translated from scratch using IDA Pro												**
**						::	-	changed pTile->m_cOwner to m_iOccupyStatus											**
**						::	-	added check to prevent access violation if pTile == 0							**
**						::	-	removed 4 return(s) after "iRet = 1;" and placed at end								**
*********************************************************************************************************************/
bool CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)
{
	short tX, tY;
	int iRet;
	class CTile* pTile;

	iRet = 0;
	if (m_pClientList[sAttackerH] == 0) return 0;
	if ((m_bIsHeldenianMode == 1) || (m_cHeldenianType == 1)) {
		if (cType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				tX = m_pClientList[sAttackerH]->m_sX;
				tY = m_pClientList[sAttackerH]->m_sY;
				if ((tX < 0) || (tX >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeX) ||
					(tY < 0) || (tY >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY)) return 0;
				pTile = (class CTile*)(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY * m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
		else if (cType == DEF_OWNERTYPE_NPC) {
			if ((m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex] != 0) && (iMapIndex != -1) && (m_pNpcList[sAttackerH]->m_cSide > 0)) {
				tX = m_pNpcList[sAttackerH]->m_sX;
				tY = m_pNpcList[sAttackerH]->m_sY;
				pTile = (class CTile*)(m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY * m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
	}
	return iRet;
}

void CGame::RequestHeldenianTeleport(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char cTmpName[21], * cp, cTxt[512], cMapName[11];
	short tX, tY, cLoc, * sp;
	uint16_t wResult;
	int iRet, iWhyReturn, iProcessed;

	iProcessed = 1;
	if (m_pClientList[iClientH] == 0) return;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));
	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	if (strcmp(cTmpName, "Gail") == 0) {
		std::memset(cTxt, 0, sizeof(cTxt));
		if ((m_bIsHeldenianMode == 1) && (m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[iClientH]->m_cSide == 2 || m_pClientList[iClientH]->m_cSide == 1)) {
			if (m_cHeldenianType == 1) {
				std::memset(cMapName, 0, sizeof(cMapName));
				memcpy(cMapName, "BtField", 10);
				if (m_pClientList[iClientH]->m_cSide == 1) {
					tX = 68;
					tY = 225;
					cLoc = 1;
				}
				else if (m_pClientList[iClientH]->m_cSide == 2) {
					tX = 202;
					tY = 70;
					cLoc = 2;
				}
			}
			else if (m_cHeldenianType == 2) {
				std::memset(cMapName, 0, sizeof(cMapName));
				memcpy(cMapName, "HRampart", 10);
				if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
					tX = 81;
					tY = 42;
					cLoc = 3;
				}
				else {
					tX = 156;
					tY = 153;
					cLoc = 4;
				}
			}
			wResult = DEF_MSGTYPE_CONFIRM;
			iProcessed = 1;
			iWhyReturn = 0;
		}
	}

	wResult = DEF_MSGTYPE_REJECT;
	iProcessed = 0;
	iWhyReturn = 0;

	sp = (short*)cp;
	*sp = 4;
	cp += 4;

	sp = (short*)cp;
	*sp = cLoc;
	cp += 4;

	memcpy(cp, cMapName, 10);
	cp += 10;

	sp = (short*)cp;
	*sp = tX;
	cp += 4;

	sp = (short*)cp;
	*sp = tY;
	cp += 4;

	sp = (short*)cp;
	*sp = iWhyReturn;
	cp += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTxt, 36);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		break;
	}
}



void CGame::GlobalStartHeldenianMode()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	//std::memset(cData, 0, sizeof(cData));

	//cp = (char *)cData;
	//*cp = GSM_STARTHELDENIAN; // 21
	//cp++;
	//
	//wp  = (uint16_t *)cp;
	//*wp = m_cHeldenianModeType;
	//cp += 2;

	//wp  = (uint16_t *)cp;
	//*wp = m_sLastHeldenianWinner;
	//cp += 2;

	//dwp = (uint32_t *)cp;
	//*dwp = dwTime;
	//cp += 4;

	//bStockMsgToGateServer(cData, 9);
	LocalStartHeldenianMode(m_cHeldenianModeType, m_sLastHeldenianWinner, dwTime);

}

/*********************************************************************************************************************
**  void CGame::LocalStartHeldenianMode(short sV1, short sV2, uint32_t dwHeldenianGUID)								**
**  description			:: localy performs all required tasks upon recieving heldenian initiate message				**
**  last updated		:: December 10, 2004; 12:02 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	translated from scratch using official 3.51 chinese hgserver						**
*********************************************************************************************************************/
void CGame::LocalStartHeldenianMode(short sV1, short sV2, uint32_t dwHeldenianGUID)
{
	int i, x, z, iNamingValue;
	char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
	short sOwnerH;
	int bRet;
	int dX, dY;

	if (m_bIsHeldenianMode) return;

	if ((m_cHeldenianModeType == -1) || (m_cHeldenianModeType != sV1)) {
		m_cHeldenianModeType = static_cast<char>(sV1);
	}
	if ((m_sLastHeldenianWinner != -1) && (m_sLastHeldenianWinner == sV2)) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Heldenian Mode : %d , Heldenian Last Winner : %d", m_cHeldenianModeType, m_sLastHeldenianWinner);
		PutLogFileList(G_cTxt);
	}

	if (dwHeldenianGUID != 0) {
		_CreateHeldenianGUID(dwHeldenianGUID, 0);
		m_dwHeldenianGUID = dwHeldenianGUID;
	}
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete != true) break;
			m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(0, i, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
			m_pClientList[i]->m_iWarContribution = 0;
			m_pClientList[i]->m_iConstructionPoint = (m_pClientList[i]->m_iCharisma * 300);
			if (m_pClientList[i]->m_iConstructionPoint > 12000) m_pClientList[i]->m_iConstructionPoint = 12000;
			SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 1, 0);
		}
	}

	for (x = 0; x < DEF_MAXMAPS; x++) {
		if (m_pMapList[x] == 0) break;
		if (m_pMapList[x]->m_bIsHeldenianMap) {
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsInitComplete != true) break;
				if (m_pClientList[i]->m_iAdminUserLevel >= 1) break;
				if (m_pClientList[i]->m_cMapIndex != x) break;
				SendNotifyMsg(0, i, DEF_NOTIFY_0BE8, 0, 0, 0, 0);
				RequestTeleportHandler(i, "1   ", 0, -1, -1);
			}
			for (i = 0; i < DEF_MAXNPCS; i++) {
				if (m_pNpcList[i] == 0) break;
				if (m_pNpcList[i]->m_bIsKilled) break;
				if (m_pNpcList[i]->m_cMapIndex != x) break;
				m_pNpcList[i]->m_bIsSummoned = true;
				RemoveHeldenianNpc(i);
			}

			if (m_cHeldenianModeType == 1) {
				if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) {
					for (i = 0; i < MAX_HELDENIANTOWER; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == m_pMapList[x]->m_stHeldenianTower[i].sTypeID) {
									std::memset(cTmp, 0, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							std::memset(cName, 0, sizeof(cName));
							std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = static_cast<char>(i + 65);
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == 0) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != 0) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) {
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
							}
						}
					}
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogFileList(G_cTxt);
					UpdateHeldenianStatus();
				}
			}
			else if (m_cHeldenianModeType == 2) {
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) {
					for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							cSide = m_sLastHeldenianWinner;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == 91) {
									std::memset(cTmp, 0, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							std::memset(cName, 0, sizeof(cName));
							std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = static_cast<char>(i + 65);
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == 0) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								//m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[bRet] != 0) && (bRet > 0) && (bRet < DEF_MAXNPCS)) {
									m_pNpcList[bRet]->m_iBuildCount = 0;
									m_pNpcList[bRet]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
								}
							}
						}
					}
				}
			}
		}
	}
	m_bHeldenianInitiated = true;
	m_bIsHeldenianMode = true;
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN Start.");
	PutLogFileList(G_cTxt);
	m_dwHeldenianStartTime = static_cast<uint32_t>(time(0));
}

void CGame::ManualStartHeldenianMode(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char cHeldenianType, cBuff[256], * token, seps[] = "= \t\r\n";
	SYSTEMTIME SysTime;
	int iV1;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);

	if (m_bIsHeldenianMode) return;
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;
	if ((dwMsgSize != 0) && (pData != 0)) {
		m_bHeldenianRunning = true;
		GetLocalTime(&SysTime);

		std::memset(cBuff, 0, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		token = strtok(NULL, seps);
		token = strtok(NULL, seps);
		if (token != 0) {
			iV1 = atoi(token);
			iV1 += (SysTime.wHour * 24 + SysTime.wMinute * 60);
			m_dwHeldenianStartHour = (iV1 / 24);
			m_dwHeldenianStartMinute = (iV1 / 60);
		}
		token = strtok(NULL, seps);
		if (token != 0) {
			cHeldenianType = atoi(token);
			if ((cHeldenianType == 1) || (cHeldenianType == 2)) {
				m_cHeldenianModeType = cHeldenianType;
			}
		}
	}
	GlobalStartHeldenianMode();
	std::snprintf(G_cTxt, sizeof(G_cTxt), "GM Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutLogFileList(G_cTxt);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
}

void CGame::ManualEndHeldenianMode(int iClientH, char* pData, uint32_t dwMsgSize)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
	}

	if (m_bIsHeldenianMode) {
		GlobalEndHeldenianMode();
		m_bHeldenianRunning = false;
		std::snprintf(G_cTxt, sizeof(G_cTxt), "GM Order(%s): end Heldenian", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
	}
}

/*void CGame::GlobalStartApocalypseMode(int iClientH, char *pData, uint32_t dwMsgSize)
{
 char * cp, cData[120], cBuff[256];
 uint32_t * dwp, dwApocalypseGUID;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
	}
	if (m_bIsApocalypseMode ) return;
	if (m_bIsHeldenianMode ) return;
	if (m_bIsCrusadeMode ) return;
	if (dwMsgSize != 0) && (pData != 0) {
		m_bIsApocalypseGateOpen = true;
		GetLocalTime(&SysTime);
		std::memset(cBuff, 0, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

			token = strtok(NULL, seps);
		token = strtok(NULL, seps);
		if (token != 0) {
			var_124 = atoi(token);
			m_dwApocalypseStartHour = SysTime.wHour;
			m_dwApocalypseStartMinute = SysTime.wMinute;
		}
		else {
			return;
		}
	}
	sub_4AD0E0();
	std::snprintf(cTemp, sizeof(cTemp), "(%s) GM Order(%s): beginapocalypse", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
}*/

void CGame::SetHeldenianMode()
{
	SYSTEMTIME SysTime;

	GetLocalTime(&SysTime);
	m_dwHeldenianStartHour = SysTime.wHour;
	m_dwHeldenianStartMinute = SysTime.wMinute;

	if (m_cHeldenianModeType != 2) {
		m_cHeldenianVictoryType = m_sLastHeldenianWinner;
	}
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar == 1) return;

	if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		if (m_pClientList[iClientH]->m_iWarContribution > m_iMaxWarContribution) m_pClientList[iClientH]->m_iWarContribution = m_iMaxWarContribution;
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution / 6);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);
				_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution / 6), 0);
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 40;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, m_pClientList[iClientH]->m_iWarContribution, 0);
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 40;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution / 10;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, -1 * m_pClientList[iClientH]->m_iWarContribution, 0);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution / 10), 0);
				}
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::CheckHeldenianResultCalculation(int iClientH)
{
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar != 2) return;
	if ((m_cHeldenianType == 0) || (m_pClientList[iClientH]->m_dwHeldenianGUID == 0)) return;
	if (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID) {
		if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
			if (m_pClientList[iClientH]->m_iLevel <= 80) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 200;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80 && m_pClientList[iClientH]->m_iLevel <= 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 100;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 30;
			}
			dV2 = (double)m_pClientList[iClientH]->m_iExp;
			dV3 = (double)m_pClientList[iClientH]->m_iWarContribution * 1.2f;
			dV1 = dV2 + dV3;
			GetExp(iClientH, (uint32_t)dV1);
		}
		else {
			GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution / 5));
		}
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwHeldenianGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


bool CGame::UpdateHeldenianStatus()
{
	int i;
	bool bFlag;
	int iShortCutIndex, iClientH;

	if (m_bIsHeldenianMode != true) return false;
	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			if (m_pMapList[i]->m_bIsHeldenianMap) {
				bFlag = true;
				iShortCutIndex = 0;
			}
			if (bFlag) {
				iClientH = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (iClientH == 0) {
					bFlag = 0;
				}
				else {
					if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bIsInitComplete) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField") == 0)) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenDead, 0, m_iHeldenianElvineDead, 0);
					}
				}
			}
		}
	return true;
}




void CGame::ForceRecallProcess() {
	int i;
	int iMapSide = 0;

	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete) {
				//force recall in enemy buidlings at crusade
				iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (iMapSide == 2) && (m_pClientList[i]->m_iAdminUserLevel == 0) && (m_bIsCrusadeMode)) {
					RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
				}
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (iMapSide == 1) && (m_pClientList[i]->m_iAdminUserLevel == 0) && (m_bIsCrusadeMode)) {
					RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
				}

				//remove mim in building
				if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wrhus", 5) == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_2") == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wzdtwr", 6) == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gldhall", 7) == 0))
				{
					//SetIllusionFlag(i, DEF_OWNERTYPE_PLAYER, false);
					if (m_pClientList[i]->m_iStatus & 0x00200000) {
						SetIllusionMovementFlag(i, DEF_OWNERTYPE_PLAYER, false);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + 2, i, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 4, 0, 0);
					}
				}
			}
			//check gizon errors
			if (m_pClientList[i]->m_iLevel < 180) {
				if (m_pClientList[i]->m_iGizonItemUpgradeLeft > 0) {
					m_pClientList[i]->m_iGizonItemUpgradeLeft = 0;
				}
			}
		}
	}
}

//in stat change, check skillpoints
void CGame::SkillCheck(int sTargetH) {
	//magic
	while ((m_pClientList[sTargetH]->m_iMag * 2) < m_pClientList[sTargetH]->m_cSkillMastery[4]) {
		m_pClientList[sTargetH]->m_cSkillMastery[4]--;
	}
	//hand attack
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[5]) {
		m_pClientList[sTargetH]->m_cSkillMastery[5]--;
	}
	//hammer
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[14]) {
		m_pClientList[sTargetH]->m_cSkillMastery[14]--;
	}
	//shield
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[11]) {
		m_pClientList[sTargetH]->m_cSkillMastery[11]--;
	}
	//axe
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[10]) {
		m_pClientList[sTargetH]->m_cSkillMastery[10]--;
	}
	//fencing
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[9]) {
		m_pClientList[sTargetH]->m_cSkillMastery[9]--;
	}
	//LS
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[8]) {
		m_pClientList[sTargetH]->m_cSkillMastery[8]--;
	}
	//SS
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[7]) {
		m_pClientList[sTargetH]->m_cSkillMastery[7]--;
	}
	//archery
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[6]) {
		m_pClientList[sTargetH]->m_cSkillMastery[6]--;
	}
	//staff
	while ((m_pClientList[sTargetH]->m_iMag * 2) < m_pClientList[sTargetH]->m_cSkillMastery[21]) {
		m_pClientList[sTargetH]->m_cSkillMastery[21]--;
	}
	//alc
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[12]) {
		m_pClientList[sTargetH]->m_cSkillMastery[12]--;
	}
	//manu
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[13]) {
		m_pClientList[sTargetH]->m_cSkillMastery[13]--;
	}
	//pr
	while ((m_pClientList[sTargetH]->m_iVit * 2) < m_pClientList[sTargetH]->m_cSkillMastery[23]) {
		m_pClientList[sTargetH]->m_cSkillMastery[23]--;
	}
	//pc
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[19]) {
		m_pClientList[sTargetH]->m_cSkillMastery[19]--;
	}
	//farming
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[2]) {
		m_pClientList[sTargetH]->m_cSkillMastery[2]--;
	}
	//fishing
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[1]) {
		m_pClientList[sTargetH]->m_cSkillMastery[1]--;
	}
	//mining
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[0]) {
		m_pClientList[sTargetH]->m_cSkillMastery[0]--;
	}
}

bool CGame::IsEnemyZone(int i) {
	if (memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "areuni") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone2") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone4") == 0)) {
			return true;
		}
	}
	else if (memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvined1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvuni") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone3") == 0)) {
			return true;
		}
	}
	return false;
}

void CGame::LoteryHandler(int iClientH)
{
	class  CItem* pItem;
	int     iItemID;
	if (m_pClientList[iClientH] == 0) return;
	switch (iDice(1, 22)) {
	case 1:iItemID = 656; break; // XelimaStone
	case 2:iItemID = 657; break; // MerienStone
	case 3:iItemID = 650; break; // ZemstoneOfSacrifice
	case 4:iItemID = 652; break; // RedBall
	case 5:iItemID = 654; break; // BlueBall
	case 6:iItemID = 881; break; // ArmorDye(Indigo)
	case 7:iItemID = 882; break; // ArmorDye(CrimsonRed)
	case 8:iItemID = 883; break; // ArmorDye(Gold)
	case 9:iItemID = 884; break; // ArmorDye(Aqua)
	case 10:iItemID = 885; break; // ArmorDye(Pink)
	case 11:iItemID = 886; break; // ArmorDye(Violet)
	case 12:iItemID = 887; break; // ArmorDye(Blue) 
	case 13:iItemID = 888; break; // ArmorDye(Khaki) 
	case 14:iItemID = 889; break; // ArmorDye(Yellow) 
	case 15:iItemID = 890; break; // ArmorDye(Red) 
	case 16:iItemID = 971; break; // ArmorDye(Green)
	case 17:iItemID = 972; break; // ArmorDye(Black) 
	case 18:iItemID = 973; break; // ArmorDye(Knight) 
	case 19:iItemID = 970; break; // CritCandy
	case 20:iItemID = 651; break; // GreenBall
	case 21:iItemID = 653; break; // YellowBall
	case 22:iItemID = 655; break; // PearlBall
	}

	//chance
	if (iDice(1, 120) <= 3) iItemID = 650;//ZemstoneOfSacrifice
	//chance

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
		delete pItem;
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
	}


}

void CGame::SetSkillAll(int iClientH, char* pData, uint32_t dwMsgSize)
//SetSkillAll Acidx Command,  Added July 04, 2005 INDEPENDENCE BABY Fuck YEA
{
	if (m_pClientList[iClientH] == 0) return;
	//Magic
	if (m_pClientList[iClientH]->m_cSkillMastery[4] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[4] = m_pClientList[iClientH]->m_iMag * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[4] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
		}
		if (m_pClientList[iClientH]->m_iMag > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);

	}
	//LongSword
	if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[8] = m_pClientList[iClientH]->m_iDex * 2;

		if (m_pClientList[iClientH]->m_cSkillMastery[8] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 8, m_pClientList[iClientH]->m_cSkillMastery[8], 0, 0);

	}
	//Hammer
	if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[14] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 14, m_pClientList[iClientH]->m_cSkillMastery[14], 0, 0);

	}
	//Axes
	if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[10] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 10, m_pClientList[iClientH]->m_cSkillMastery[10], 0, 0);

	}
	//hand attack
	if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[5] = m_pClientList[iClientH]->m_iStr * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
		}
		if (m_pClientList[iClientH]->m_iStr > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 5, m_pClientList[iClientH]->m_cSkillMastery[5], 0, 0);

	}
	//ShortSword
	if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[7] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 7, m_pClientList[iClientH]->m_cSkillMastery[7], 0, 0);

	}
	//archery
	if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[6] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 6, m_pClientList[iClientH]->m_cSkillMastery[6], 0, 0);

	}
	//Fencing
	if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[9] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 9, m_pClientList[iClientH]->m_cSkillMastery[9], 0, 0);

	}
	//Staff Attack
	if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[21] = m_pClientList[iClientH]->m_iInt * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
		}
		if (m_pClientList[iClientH]->m_iInt > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 21, m_pClientList[iClientH]->m_cSkillMastery[21], 0, 0);

	}
	//shield
	if (m_pClientList[iClientH]->m_cSkillMastery[11] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[11] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[11] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 11, m_pClientList[iClientH]->m_cSkillMastery[11], 0, 0);

	}
	//mining
	if (m_pClientList[iClientH]->m_cSkillMastery[0] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[0] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 0, m_pClientList[iClientH]->m_cSkillMastery[0], 0, 0);

	}
	//fishing
	if (m_pClientList[iClientH]->m_cSkillMastery[1] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[1] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 1, m_pClientList[iClientH]->m_cSkillMastery[1], 0, 0);

	}
	//farming
	if (m_pClientList[iClientH]->m_cSkillMastery[2] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[2] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 2, m_pClientList[iClientH]->m_cSkillMastery[2], 0, 0);

	}
	//alchemy
	if (m_pClientList[iClientH]->m_cSkillMastery[12] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[12] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 12, m_pClientList[iClientH]->m_cSkillMastery[12], 0, 0);

	}
	//manufacturing
	if (m_pClientList[iClientH]->m_cSkillMastery[13] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[13] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 13, m_pClientList[iClientH]->m_cSkillMastery[13], 0, 0);

	}
	//poison resistance
	if (m_pClientList[iClientH]->m_cSkillMastery[23] < 20)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[23] = 20;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 23, m_pClientList[iClientH]->m_cSkillMastery[23], 0, 0);

	}
	//pretend corpse
	if (m_pClientList[iClientH]->m_cSkillMastery[19] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[19] = m_pClientList[iClientH]->m_iInt * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[19] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
		}
		if (m_pClientList[iClientH]->m_iInt > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 19, m_pClientList[iClientH]->m_cSkillMastery[19], 0, 0);

	}
	//magic resistance
	if (m_pClientList[iClientH]->m_cSkillMastery[3] < 20)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[3] = 20;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[3], 0, 0);

	}
}

//Angel Code By SlammeR(I dont know if it works)
/*void CGame::GetAngelMantleHandler(int iClientH,int iItemID,char * pString)
{
 int   i, iNum, iRet, iEraseReq;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 uint32_t * dwp;
 short * sp;
 uint16_t  * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;

	switch(iItemID) {
	//Angels
	case 908: //AngelicPandent(STR)
	case 909: //AngelicPandent(DEX)
		case 910: //AngelicPandent(INT)
		case 911: //AngelicPandent(MAG)
		if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft<5) return;
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
		break;


  default:
	 return;
	 break;
  }

  std::memset(cItemName, 0, sizeof(cItemName));
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20);

  iNum = 1;
  for (i = 1; i <= iNum; i++)
  {
	 pItem = new class CItem;
	 if (_bInitItemAttr(pItem, cItemName) == false)
	 {
		delete pItem;
	 }
	 else {

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		   if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		   std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get Angel : Char(%s) Player-Majestic-Points(%d) Angel Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, cItemName);
		   PutLogFileList(G_cTxt);

		   pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		   pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		   pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		   pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

		   iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		   if (iEraseReq == 1) delete pItem;

		   iCalcTotalWeight(iClientH);

		   switch (iRet) {
		   case DEF_XSOCKEVENT_QUENEFULL:
		   case DEF_XSOCKEVENT_SOCKETERROR:
		   case DEF_XSOCKEVENT_CRITICALERROR:
		   case DEF_XSOCKEVENT_SOCKETCLOSED:
			  DeleteClient(iClientH, true, true);
			  return;
		   }

		   SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
		}
		else
		{
		   delete pItem;

		   iCalcTotalWeight(iClientH);

	   iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		   switch (iRet) {
		   case DEF_XSOCKEVENT_QUENEFULL:
		   case DEF_XSOCKEVENT_SOCKETERROR:
		   case DEF_XSOCKEVENT_CRITICALERROR:
		   case DEF_XSOCKEVENT_SOCKETCLOSED:

			  DeleteClient(iClientH, true, true);
			  return;
		   }
		}
	 }
   }
}*/

/*int CGame::iAngelEquip(int iClientH)
{
 int iTemp;
 CItem * cAngelTemp;
	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp != 0)) {
		if(cAngelTemp->m_sIDnum >= 908){ //AngelicPandent(STR)
				if(cAngelTemp->m_sIDnum >= 909){ //AngelicPandent(DEX)
				if(cAngelTemp->m_sIDnum >= 910){ //AngelicPandent(INT)
				if(cAngelTemp->m_sIDnum >= 911){ //AngelicPandent(MAG)

				return cAngelTemp->m_sIDnum;
			} else {
				return 0;
				}
				}
				}
		}
	}
}*/

/*void CGame::CheckAngelUnequip(int iClientH,int iAngelID)
{
 int iTemp;
 CItem * cAngelTemp;

	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp->m_sIDnum != iAngelID)) {
		cAngelTemp->m_sIDnum = iAngelID;
	}

}*/

/*********************************************************************************************************************
**  bool CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, iTemp)		Snoopy			**
** description	  :: Sets the staus to send or not Angels to every client							**
*********************************************************************************************************************/
void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp)
{
	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == 0) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF00FF;
		break;
	}
	if (iTemp > 4)
	{
		int iAngelicStars = (iTemp / 3) * (iTemp / 5);
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | (iAngelicStars << 8);
	}
	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

/*********************************************************************************************************************
**  bool CGame::GetAngelHandler(int iClientH, char * pData, uint32_t dwMsgSize)										**
** description	  :: Reversed and coded by Snoopy																	**
*********************************************************************************************************************/
void CGame::GetAngelHandler(int iClientH, char* pData, uint32_t dwMsgSize)
{
	char cTmpName[21];
	int   iAngel;
	class CItem* pItem;
	int   iRet, iEraseReq;
	char  cItemName[21];
	if (m_pClientList[iClientH] == 0)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (_iGetItemSpaceLeft(iClientH) == 0)
	{
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}
	const auto* req = hb::net::PacketCast<hb::net::PacketRequestAngel>(pData, sizeof(hb::net::PacketRequestAngel));
	if (!req) return;
	std::memset(cTmpName, 0, sizeof(cTmpName));
	std::memcpy(cTmpName, req->name, 20);
	iAngel = req->angel_id; // 0x00 l a i
	std::snprintf(G_cTxt, sizeof(G_cTxt), "PC(%s) obtained an Angel (%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY);
	PutLogList(G_cTxt);
	switch (iAngel) {
	case 1: // STR
		//iItemNbe = 1108;
		std::snprintf(cItemName, sizeof(cItemName), "AngelicPandent(STR)");
		break;
	case 2: // DEX
		//iItemNbe = 1109;
		std::snprintf(cItemName, sizeof(cItemName), "AngelicPandent(DEX)");
		break;
	case 3: // INT
		//iItemNbe = 1110;
		std::snprintf(cItemName, sizeof(cItemName), "AngelicPandent(INT)");
		break;
	case 4: // MAG
		//iItemNbe = 1111;
		std::snprintf(cItemName, sizeof(cItemName), "AngelicPandent(MAG)");
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");
		break;
	}
	// Them create the summonScroll
	pItem = 0;
	pItem = new class CItem;
	if (pItem == 0) return;
	if ((_bInitItemAttr(pItem, cItemName)))
	{
		pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq))
		{
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
		}
		else
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4			
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
		}
	}
	else
	{
		delete pItem;
		pItem = 0;
	}
}

//50Cent - Repair All
void CGame::RequestRepairAllItemsHandler(int iClientH)
{
	int i, price;
	double d1, d2, d3;
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	m_pClientList[iClientH]->totalItemRepair = 0;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			if (((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 1) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 12)) ||
				((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 43) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 50)))
			{
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan)
					continue;
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan <= 0)
					price = (m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2);
				else
				{
					d1 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
					if (m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan != 0)
						d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan);
					else
						d2 = (double)1.0f;
					d3 = (double)((d1 / d2) * 0.5f);
					d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wPrice);
					d3 = (d3 * d2);
					price = ((m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2) - (short)(d3));
				}
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].index = i;
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].price = price;
				m_pClientList[iClientH]->totalItemRepair++;
			}
		}
	}
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsDeleteHandler(int iClientH, int index)
{
	int i;
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = index; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		m_pClientList[iClientH]->m_stRepairAll[i] = m_pClientList[iClientH]->m_stRepairAll[i + 1];
	}
	m_pClientList[iClientH]->totalItemRepair--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsConfirmHandler(int iClientH)
{
	int      iRet, i, totalPrice = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	for (i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		totalPrice += m_pClientList[iClientH]->m_stRepairAll[i].price;
	}

	if (dwGetItemCountByID(iClientH, hb::item::ItemId::Gold) < (uint32_t)totalPrice)
	{
		{
			hb::net::PacketNotifyNotEnoughGold pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
			pkt.item_index = 0;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			break;
		}

	}
	else
	{
		for (i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++)
		{
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index] != 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wMaxLifeSpan;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, m_pClientList[iClientH]->m_stRepairAll[i].index, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan, 0, 0);
			}
		}
		iCalcTotalWeight(SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGetItemCountByID(iClientH, hb::item::ItemId::Gold) - totalPrice));
	}
}