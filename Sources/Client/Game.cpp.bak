// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////


#include "Game.h"
#include "CommonTypes.h"
#include "Benchmark.h"
#include "FrameTiming.h"
#include "lan_eng.h"
#include "Packet/SharedPackets.h"
#include "SharedCalculations.h"
#include <cstdio>
#include <windows.h>

// Renderer - include DXC_ddraw.h for CSprite compatibility (takes DXC_ddraw*)
#include "DXC_ddraw.h"

// Manager singletons
#include "ConfigManager.h"
#include "Camera.h"
#include "AudioManager.h"
#include "WeatherManager.h"
#include "ChatCommandManager.h"
#include "HotkeyManager.h"

// DialogBox system
#include "IDialogBox.h"

extern char G_cSpriteAlphaDegree;

extern char G_cCmdLine[256], G_cCmdLineTokenA[120], G_cCmdLineTokenA_Lowercase[120], G_cCmdLineTokenB[120], G_cCmdLineTokenC[120], G_cCmdLineTokenD[120], G_cCmdLineTokenE[120];
extern class XSocket* G_pCalcSocket;
extern bool G_bIsCalcSocketConnected;
extern uint32_t G_dwCalcSocketTime, G_dwCalcSocketSendTime;
extern HWND	G_hWnd, G_hEditWnd;
extern HINSTANCE G_hInstance;

char _cDrawingOrder[] = { 0, 1, 0, 0, 0, 0, 0, 1, 1 };
char _cMantleDrawingOrder[] = { 0, 1, 1, 1, 0, 0, 0, 2, 2 };
char _cMantleDrawingOrderOnRun[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1 };

short _tmp_sOwnerType, _tmp_sAppr1, _tmp_sAppr2, _tmp_sAppr3, _tmp_sAppr4;//, _tmp_iStatus;
//CInt _tmp_iStatus;
int _tmp_iStatus;
char  _tmp_cAction, _tmp_cDir, _tmp_cFrame, _tmp_cName[12];
int   _tmp_iChatIndex, _tmp_dx, _tmp_dy, _tmp_iApprColor, _tmp_iEffectType, _tmp_iEffectFrame, _tmp_dX, _tmp_dY; // 21.171 2002-6-14
uint16_t _tmp_wObjectID;
char cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData3, cDynamicObjectData4;
uint16_t wFocusObjectID;
short sFocus_dX, sFocus_dY;
char  cFocusAction, cFocusFrame, cFocusDir, cFocusName[12];
short sFocusX, sFocusY, sFocusOwnerType, sFocusAppr1, sFocusAppr2, sFocusAppr3, sFocusAppr4;
int iFocuiStatus;
int   iFocusApprColor;

static void EnsureNetDebugConsole()
{
	static bool s_bConsoleReady = false;
	if (s_bConsoleReady) return;

	if (GetConsoleWindow() == nullptr) {
		AllocConsole();
	}

	FILE* pOut = nullptr;
	FILE* pIn = nullptr;
	freopen_s(&pOut, "CONOUT$", "w", stdout);
	freopen_s(&pOut, "CONOUT$", "w", stderr);
	freopen_s(&pIn, "CONIN$", "r", stdin);
	SetConsoleTitleA("Helbreath Client Net Debug");
	s_bConsoleReady = true;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void CGame::ReadSettings()
{
	// Initialize and load settings from JSON file via ConfigManager
	ConfigManager::Get().Initialize();
	ConfigManager::Get().Load();

	// Copy values to CGame member variables
	m_sMagicShortCut = ConfigManager::Get().GetMagicShortcut();
	m_sRecentShortCut = ConfigManager::Get().GetRecentShortcut();
	for (int i = 0; i < 5; i++)
	{
		m_sShortCut[i] = ConfigManager::Get().GetShortcut(i);
	}
	m_sShortCut[5] = -1; // 6th slot unused

	// Audio settings loaded into AudioManager
	AudioManager::Get().SetSoundVolume(ConfigManager::Get().GetSoundVolume());
	AudioManager::Get().SetMusicVolume(ConfigManager::Get().GetMusicVolume());
	AudioManager::Get().SetSoundEnabled(ConfigManager::Get().IsSoundEnabled());
	AudioManager::Get().SetMusicEnabled(ConfigManager::Get().IsMusicEnabled());
}

void CGame::WriteSettings()
{
	// Copy CGame member variables to ConfigManager
	ConfigManager::Get().SetMagicShortcut(m_sMagicShortCut);
	for (int i = 0; i < 5; i++)
	{
		ConfigManager::Get().SetShortcut(i, m_sShortCut[i]);
	}

	// Audio settings from AudioManager
	ConfigManager::Get().SetSoundVolume(AudioManager::Get().GetSoundVolume());
	ConfigManager::Get().SetMusicVolume(AudioManager::Get().GetMusicVolume());
	ConfigManager::Get().SetSoundEnabled(AudioManager::Get().IsSoundEnabled());
	ConfigManager::Get().SetMusicEnabled(AudioManager::Get().IsMusicEnabled());

	// Save to JSON file
	ConfigManager::Get().Save();
}

CGame::CGame()
{
	int i;

	// Initialize critical pointers first to avoid 0xCDCDCDCD debug heap issues
	m_pInputBuffer = nullptr;
	m_Renderer = nullptr;
	EnsureNetDebugConsole();
	m_dialogBoxManager.Initialize(this);
	m_dialogBoxManager.InitializeDialogBoxes();

	srand((unsigned)time(0));
	ReadSettings();
	RegisterHotkeys();

	iMaxStats = 0;
	iMaxLevel = 0;
	iMaxBankItems = 200; // Default soft cap, server overrides
	m_cLoading = 0;
	m_bIsFirstConn = true;
	m_iItemDropCnt = 0;
	m_bItemDrop = false;
	m_bIsSpecial = false;
	m_cGameMode = DEF_GAMEMODE_ONLOADING;
	m_cWhisperIndex = DEF_MAXWHISPERMSG;
	m_cGameModeCount = 0;
	std::memset(m_cMapName, 0, sizeof(m_cMapName));
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	m_pGSock = 0;
	m_pLSock = 0;
	m_pMapData = 0;
	m_cCommandCount = 0;
	m_dwCommandTime = 0; //v2.15 SpeedHack
	m_sPlayerX = 0;
	m_sPlayerY = 0;
	m_sViewDX = 0;
	m_sViewDY = 0;
	m_sViewDstX = 0;
	m_sViewDstY = 0;
	m_sViewPointX = 0;
	m_sViewPointY = 0;
	m_sVDL_X = 0;
	m_sVDL_Y = 0;
	m_wCommObjectID = 0;
	m_wLastAttackTargetID = 0;
	m_wEnterGameType = 0;
	m_cCommand = DEF_OBJECTSTOP;
	m_bIsObserverMode = false;
	for (i = 0; i < DEF_MAXSPRITES; i++) m_pSprite[i] = 0;
	for (i = 0; i < DEF_MAXTILES; i++) m_pTileSpr[i] = 0;
	for (i = 0; i < DEF_MAXEFFECTSPR; i++) m_pEffectSpr[i] = 0;

	for (i = 0; i < 5000; i++) m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXCHATMSGS; i++) m_pChatMsgList[i] = 0;

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) m_pChatScrollList[i] = 0;

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) m_pWhisperMsg[i] = 0;


	m_pEffectManager = new EffectManager(this);
	m_pNetworkMessageManager = new NetworkMessageManager(this);

	for (i = 0; i < DEF_MAXITEMS; i++) m_pItemList[i] = 0;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) m_pBankList[i] = 0;

	for (i = 0; i < 4; i++) m_pCharList[i] = 0;

	for (i = 0; i < 61; i++) m_dialogBoxManager.SetOrderAt(i, 0);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicCfgList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillCfgList[i] = 0;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		m_pMsgTextList[i] = 0;
		m_pMsgTextList2[i] = 0;
		m_pAgreeMsgTextList[i] = 0;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = 0;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispBuildItemList[i] = 0;

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pCraftItemList[i] = 0;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispCraftItemList[i] = 0;



	for (i = 0; i < DEF_MAXGAMEMSGS; i++) m_pGameMsgList[i] = 0;

	m_pExID = 0;

	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	std::memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
	m_iGameServerMode = 2; // Snoopy: Default is INTERNET

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		m_pItemForSaleList[i] = 0;
	m_sPendingShopType = 0;

	// CLEROTh - INIT DIALOG BOXES

	//Guild Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sSizeY = 339;

	//Guild Operation Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sSizeX = 295;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sSizeY = 346;

	//Bank Dialog
	m_dialogBoxManager.Info(DialogBoxId::Bank).sX = 60 + SCREENX; //337
	m_dialogBoxManager.Info(DialogBoxId::Bank).sY = 50 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sSizeY = 339;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sV1 = 13;

	//ItemSellorRepair Dialog
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sSizeY = 339;

	//Manufacture Dialog
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY = 60 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 339;

	//Exchange Dialog
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sY = 30 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sSizeX = 520;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sSizeY = 357;

	//Quest Dialog
	m_dialogBoxManager.Info(DialogBoxId::Quest).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sSizeY = 339;

	//Party Dialog
	m_dialogBoxManager.Info(DialogBoxId::Party).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Party).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Party).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Party).sSizeY = 339;

	//Crusade Commander Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sSizeY = 386;

	//Crusade Constructor Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sSizeY = 386;

	//Crusade Soldier Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sSizeY = 386;

	// Give item ???
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sSizeX = 291;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sSizeY = 413;

	// 3.51 Slates Dialog - Diuuude
	m_dialogBoxManager.Info(DialogBoxId::Slates).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sY = 60 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeY = 339;

	// MJ Stats Change DialogBox - Diuuude
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sSizeY = 339;

	//Guild Hall Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sSizeY = 339;

	InputManager::Get().ClearAllKeys();
	InputManager::Get().ClearEnterPressed();
	InputManager::Get().ClearEscPressed();
	m_dwDialogCloseTime = 0;
	m_iTimeLeftSecAccount = 0;
	m_iTimeLeftSecIP = 0;
	m_bWhisper = true;
	m_bShout = true;

	// Initialize char arrays that were previously zero-initialized by HEAP_ZERO_MEMORY
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
	std::memset(m_cMsg, 0, sizeof(m_cMsg));
	std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
	std::memset(m_cBackupChatMsg, 0, sizeof(m_cBackupChatMsg));
	std::memset(m_cAmountString, 0, sizeof(m_cAmountString));
	std::memset(m_cCurLocation, 0, sizeof(m_cCurLocation));
	std::memset(m_cMapMessage, 0, sizeof(m_cMapMessage));
	std::memset(m_cGameServerName, 0, sizeof(m_cGameServerName));
	std::memset(m_cAccountAge, 0, sizeof(m_cAccountAge));
	std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
	std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
	std::memset(m_cAccountCountry, 0, sizeof(m_cAccountCountry));
	std::memset(m_cAccountSSN, 0, sizeof(m_cAccountSSN));
	std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
	std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
	std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
	std::memset(m_cName_IE, 0, sizeof(m_cName_IE));
	std::memset(m_cTakeHeroItemName, 0, sizeof(m_cTakeHeroItemName));
}

CGame::~CGame()
{
	Renderer::Destroy();
	m_Renderer = nullptr;
}

bool CGame::bInit(HWND hWnd, HINSTANCE hInst, char* pCmdLine)
{
	int iIndex;
	int i;
	char seps[] = "&= ,\t\n";
	char* token;
	// CLEROTH - BUG
	for (i = 0; i < DEF_MAXSPRITES; i++)
		m_pSprite[i] = 0;
	if (pCmdLine != 0)
	{
		std::memset(G_cCmdLine, 0, sizeof(G_cCmdLine));
		std::memset(G_cCmdLineTokenA, 0, sizeof(G_cCmdLineTokenA));
		std::memset(G_cCmdLineTokenB, 0, sizeof(G_cCmdLineTokenB));
		std::memset(G_cCmdLineTokenC, 0, sizeof(G_cCmdLineTokenC));
		std::memset(G_cCmdLineTokenD, 0, sizeof(G_cCmdLineTokenD));
		std::memset(G_cCmdLineTokenE, 0, sizeof(G_cCmdLineTokenE));

		strcpy(G_cCmdLine, pCmdLine);

		iIndex = 0;
		token = strtok(pCmdLine, seps);
		while (token != 0)
		{
			switch (iIndex) {
			case 0:	strcpy(G_cCmdLineTokenA, token); break;
			case 1: strcpy(G_cCmdLineTokenB, token); break;
			case 2: strcpy(G_cCmdLineTokenC, token); break;
			case 3: strcpy(G_cCmdLineTokenD, token); break;
			case 4: strcpy(G_cCmdLineTokenE, token); break;
			}
			token = strtok(0, seps);
			iIndex++;
		}
	}

	std::memset(G_cCmdLineTokenA_Lowercase, 0, sizeof(G_cCmdLineTokenA_Lowercase));
	strcpy(G_cCmdLineTokenA_Lowercase, G_cCmdLineTokenA);
	_strlwr(G_cCmdLineTokenA_Lowercase);

	if (memcmp(G_cCmdLineTokenA_Lowercase, "/egparam", 8) == 0)
	{
		std::memset(G_cCmdLineTokenA, 0, sizeof(G_cCmdLineTokenA));
		memcpy(G_cCmdLineTokenA, "dataq", 5);
	}
	m_hWnd = hWnd;
	m_bCommandAvailable = true;
	m_pCGameMonitor = 0;
	m_dwTime = G_dwGlobalTime;

	// Initialize AudioManager (sounds loaded later during loading screen)
	AudioManager::Get().Initialize(m_hWnd);

	// Initialize ChatCommandManager
	ChatCommandManager::Get().Initialize(this);

	m_bIsHideLocalCursor = false;
	m_cEnterCheck = m_cTabCheck = m_cLeftArrowCheck = 0;

	if (bCheckImportantFile() == false)
	{
		MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR1", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	if (_bDecodeBuildItemContents() == false)
	{
		MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR2", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	bReadIp();

	if (bInitMagicCfgList() == false) {
		MessageBox(m_hWnd, "MAGICCFG.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	// Skill
	if (bInitSkillCfgList() == false)
	{
		MessageBox(m_hWnd, "SKILLCFG.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	// Create and initialize the renderer
	if (!Renderer::Set(RendererType::DirectDraw))
	{
		MessageBox(m_hWnd, "Failed to create renderer!", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	m_Renderer = Renderer::Get();
	if (m_Renderer->Init(m_hWnd) == false)
	{
		MessageBox(m_hWnd, "This program requires DirectX7.0a!", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	InputManager::Get().Initialize(m_hWnd);

	m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "New-Dialog", 0, false);
	CloseHandle(m_hPakFile);

	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface2", 0, false);
	m_pSprite[DEF_SPRID_INTERFACE_CRAFTING] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface2", 3, false);
	CloseHandle(m_hPakFile);

	// CLEROTH - LOAD FONTS BEFORE MAIN LOADING
	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile != INVALID_HANDLE_VALUE)
	{
		m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface2", 1, false);
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface2", 2, false);
		CloseHandle(m_hPakFile);
	}

	m_hPakFile = CreateFile("sprites\\sprfonts.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile != INVALID_HANDLE_VALUE)
	{
		m_pSprite[DEF_SPRID_INTERFACE_FONT1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "sprfonts", 0, false);
		m_pSprite[DEF_SPRID_INTERFACE_FONT2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "sprfonts", 1, false);
		CloseHandle(m_hPakFile);
	}

	m_stMCursor.sX = 0;
	m_stMCursor.sY = 0;
	m_pMapData = new class CMapData(this);
	std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
	std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
	std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));

	m_sPlayerType = 2;
	m_cPlayerTurn = 0;
	// Snoopy: fixed here
	m_dialogBoxManager.SetOrderAt(60, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetOrderAt(59, DialogBoxId::HudPanel); // 29�� GaugePannel

	m_cMenuDir = 4;
	m_cMenuDirCnt = 0;
	m_cMenuFrame = 0;

	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(70, 70, 80), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(70, 70, 80), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(70, 70, 80), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(70, 100, 70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(130, 90, 10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(42, 53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Violet
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(75, 10, 10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(135, 104, 30), &m_wR[10], &m_wG[10], &m_wB[10]);	// Gold, buggy

	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(200 / 2, 200 / 2, 200 / 2), &m_wR[0], &m_wG[0], &m_wB[0]);
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0x50 / 2, 0x50 / 2, 0xC0 / 2), &m_wR[1], &m_wG[1], &m_wB[1]); // Indigo Blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(79, 79, 62), &m_wR[2], &m_wG[2], &m_wB[2]); // Custom-Weapon Color
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(135, 104, 30), &m_wR[3], &m_wG[3], &m_wB[3]); // Gold
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(255 / 2, 36 / 2, 0), &m_wR[4], &m_wG[4], &m_wB[4]); // Crimson
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(10, 60, 10), &m_wR[5], &m_wG[5], &m_wB[5]); // Green
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0x50 / 2, 0x50 / 2, 0x50 / 2), &m_wR[6], &m_wG[6], &m_wB[6]); // Gray
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0x5F / 2, 0x9E / 2, 0xA0 / 2), &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0xFF / 2, 0x69 / 2, 0xB4 / 2), &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(90, 60, 90), &m_wR[9], &m_wG[9], &m_wB[9]); // Violet

	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0, 35, 60), &m_wR[10], &m_wG[10], &m_wB[10]); // Blue
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0xD2 / 2, 0xB4 / 2, 0x8C / 2), &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0xBD / 2, 0xB7 / 2, 0x6B / 2), &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(85, 85, 8), &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(75, 10, 10), &m_wR[14], &m_wG[14], &m_wB[14]); // Red
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0x30, 0x30, 0x30), &m_wR[15], &m_wG[15], &m_wB[15]); // Black



#ifndef _DEBUG
	m_pCGameMonitor = new class CGameMonitor;
	//===============================================
	// badword.txt
	if (!CMisc::_iConvertFileXor("contents\\badword.txt", "contents\\badword.tmp", 35))
	{
		MessageBox(m_hWnd, "BADWORD.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	m_pCGameMonitor->iReadBadWordFileList("contents\\badword.tmp");
	DeleteFile("contents\\badword.tmp");

	if (!CMisc::_iConvertFileXor("contents\\Curse.txt", "contents\\Curse.tmp", 35))
	{
		MessageBox(m_hWnd, "CURSE.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	m_curse.LoadCurse("contents\\Curse.tmp");
	DeleteFile("contents\\Curse.tmp");
	//==============================================
#endif

	_LoadGameMsgTextContents();
	std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));

	// Initialize manager singletons (ConfigManager already initialized in ReadSettings)
	Camera::Get().Initialize();
	// AudioManager initialized in bInit() with HWND
	WeatherManager::Get().Initialize();

	// Set Camera viewport to match screen dimensions
	Camera::Get().SetViewportSize(SCREENX * 2 + 640, SCREENY * 2 + 480);
	Camera::Get().SetTileSize(32, 32);

	return true;
}

void CGame::Quit()
{
	int i;
	WriteSettings();
	ChangeGameMode(DEF_GAMEMODE_NULL);

	// Shutdown manager singletons
	WeatherManager::Get().Shutdown();
	AudioManager::Get().Shutdown();
	Camera::Get().Shutdown();
	ConfigManager::Get().Shutdown();

	for (i = 0; i < 5000; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXSPRITES; i++)
		if (m_pSprite[i] != 0) delete m_pSprite[i];
	for (i = 0; i < DEF_MAXTILES; i++)
		if (m_pTileSpr[i] != 0) delete m_pTileSpr[i];
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
		if (m_pEffectSpr[i] != 0) delete m_pEffectSpr[i];

	// Sound cleanup handled by AudioManager::Shutdown()

	for (i = 0; i < 4; i++)
		if (m_pCharList[i] != 0) delete m_pCharList[i];

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)	delete m_pItemList[i];

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)	delete m_pBankList[i];

	// Effects now managed by EffectManager (cleaned up in destructor)

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++)
		if (m_pChatScrollList[i] != 0) delete m_pChatScrollList[i];

	for (i = 0; i < DEF_MAXWHISPERMSG; i++)
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicCfgList[i] != 0) delete m_pMagicCfgList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != 0) delete m_pSkillCfgList[i];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != 0)  delete m_pMsgTextList[i];
		if (m_pMsgTextList2[i] != 0) delete m_pMsgTextList2[i];
		if (m_pAgreeMsgTextList[i] != 0) delete m_pAgreeMsgTextList[i];
	}

	if (m_pExID != 0) delete m_pExID;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0) delete m_pDispBuildItemList[i];

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pCraftItemList[i] != 0) delete m_pCraftItemList[i];
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispCraftItemList[i] != 0) delete m_pDispCraftItemList[i];


	for (i = 0; i < DEF_MAXGAMEMSGS; i++)
		if (m_pGameMsgList[i] != 0) delete m_pGameMsgList[i];

	delete m_pMapData;

	if (m_pGSock != 0) delete m_pGSock;
	if (m_pLSock != 0) delete m_pLSock;
	if (G_pCalcSocket != 0) delete G_pCalcSocket;
	if (m_pCGameMonitor != 0) delete m_pCGameMonitor;
	
	if (m_pEffectManager != 0) delete m_pEffectManager;
	if (m_pNetworkMessageManager != 0) delete m_pNetworkMessageManager;
}


void CGame::UpdateScreen()
{
	G_dwGlobalTime = GameClock::GetTimeMS();
	OnGameSocketEvent();
	OnLogSocketEvent();
	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		// UpdateScreen_OnAgreement(); //unused by HBx server..
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		UpdateScreen_CreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		UpdateScreen_VersionNotMatch();
		break;

	case DEF_GAMEMODE_ONCONNECTING:
		UpdateScreen_Connecting();
		break;

	case DEF_GAMEMODE_ONMAINMENU:
		UpdateScreen_MainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		UpdateScreen_Loading();
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		UpdateScreen_OnGame();
		break;

	case DEF_GAMEMODE_ONWAITINGINITDATA:
		UpdateScreen_WaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		UpdateScreen_ConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		UpdateScreen_Msg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		UpdateScreen_Login();
		break;

	case DEF_GAMEMODE_ONSELECTSERVER:
		UpdateScreen_SelectServer();
		break;

	case DEF_GAMEMODE_ONQUIT:
		UpdateScreen_Quit();
		break;

	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		UpdateScreen_QueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		UpdateScreen_SelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		UpdateScreen_CreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		UpdateScreen_WaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		UpdateScreen_QueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		UpdateScreen_LogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		UpdateScreen_ChangePassword();
		break;
	}
}


// DrawScreen: Dispatches to DrawScreen_* methods based on current game mode
// Separated from UpdateScreen to allow: Update -> ClearBackB4 -> Draw -> iFlip
// NOTE: Unsplit screens temporarily call the old combined UpdateScreen_On* method here
void CGame::DrawScreen()
{
	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		DrawScreen_CreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		DrawScreen_VersionNotMatch();
		break;

	case DEF_GAMEMODE_ONCONNECTING:
		DrawScreen_Connecting();
		break;

	case DEF_GAMEMODE_ONMAINMENU:
		DrawScreen_MainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		DrawScreen_Loading();
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		DrawScreen_OnGame();
		break;

	case DEF_GAMEMODE_ONWAITINGINITDATA:
		DrawScreen_WaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		DrawScreen_ConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		DrawScreen_Msg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		DrawScreen_Login();
		break;

	case DEF_GAMEMODE_ONSELECTSERVER:
		DrawScreen_SelectServer();
		break;

	case DEF_GAMEMODE_ONQUIT:
		DrawScreen_Quit();
		break;

	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		DrawScreen_QueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		DrawScreen_SelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		DrawScreen_CreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		DrawScreen_WaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		DrawScreen_QueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		DrawScreen_LogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		DrawScreen_ChangePassword();
		break;
	}
}


// RenderFrame: Centralized rendering frame wrapper
// Handles: Update -> (skip check) -> Clear backbuffer -> Draw -> Flip
// This centralizes surface operations that were previously scattered across all screen methods
void CGame::RenderFrame()
{
	// Reset skip flag - screens can set this to skip rendering (e.g., UpdateScreen_OnGame when iUpdateRet == 0)
	m_bSkipFrame = false;

	// Update manager singletons with frame delta time
	double deltaTime = FrameTiming::GetDeltaTime();
	Camera::Get().Update(deltaTime);
	AudioManager::Get().Update(deltaTime);

	// Update phase: Logic, input handling, state changes
	// May set m_bSkipFrame = true to skip rendering entirely
	FrameTiming::BeginProfile(ProfileStage::Update);
	UpdateScreen();
	FrameTiming::EndProfile(ProfileStage::Update);

	// Skip rendering if update phase indicated nothing needs to be drawn
	// This saves ClearBackB4 and iFlip operations when frame is skipped
	if (m_bSkipFrame)
		return;

	// Clear backbuffer before drawing
	FrameTiming::BeginProfile(ProfileStage::ClearBuffer);
	m_Renderer->BeginFrame();
	FrameTiming::EndProfile(ProfileStage::ClearBuffer);

	// Draw phase: Pure rendering based on current state
	DrawScreen();

	// Flip to show the drawn content
	FrameTiming::BeginProfile(ProfileStage::Flip);
	if (m_Renderer->EndFrameCheckLostSurface())
		RestoreSprites();
	FrameTiming::EndProfile(ProfileStage::Flip);

	// Count this as a displayed frame for FPS calculation
	FrameTiming::CountDisplayedFrame();
}


void CGame::CalcViewPoint()
{
	short dX, dY;
	dX = m_sViewPointX - m_sViewDstX;
	dY = m_sViewPointY - m_sViewDstY;
	if (abs(dX) < abs(m_sViewDX))
	{
		m_sViewPointX = m_sViewDstX;
		m_sViewDX = 0;
	}
	else
	{
		if (dX > 0) m_sViewDX--;
		if (dX < 0) m_sViewDX++;
		if (dX == 0) m_sViewDX = 0;
		if (abs(dX) < 40) {
			if (m_sViewDX > 2)  m_sViewDX = 2;
			else if (m_sViewDX < -2) m_sViewDX = -2;
		}
		m_sViewPointX += m_sViewDX;
	}

	if (abs(dY) < abs(m_sViewDY))
	{
		m_sViewPointY = m_sViewDstY;
		m_sViewDY = 0;
	}
	else
	{
		if (dY > 0) m_sViewDY--;
		if (dY < 0) m_sViewDY++;
		if (dY == 0) m_sViewDY = 0;
		if (abs(dY) < 40) {
			if (m_sViewDY > 2)  m_sViewDY = 2;
			else if (m_sViewDY < -2) m_sViewDY = -2;
		}
		m_sViewPointY += m_sViewDY;
	}
}

// MODERNIZED: No longer a window message handler - polls socket directly
void CGame::OnGameSocketEvent()
{
	int iRet;
	char* pData;
	uint32_t dwMsgSize;

	if (m_pGSock == 0) return;

	// MODERNIZED: Poll() instead of iOnSocketEvent()
	iRet = m_pGSock->Poll();
	switch (iRet) {
	case 0:
		// No events
		return;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_GAME);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		m_dwLastNetRecvTime = GameClock::GetTimeMS();
		pData = m_pGSock->pGetRcvDataPointer(&dwMsgSize);
		GameRecvMsgHandler(dwMsgSize, pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = 0;
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		break;
	}
}

void CGame::RestoreSprites()
{
	for (int i = 0; i < DEF_MAXSPRITES; i++)
		if (m_pSprite[i] != 0) m_pSprite[i]->Restore();
}

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };
char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, bool bMoveCheck, bool bMIM)
{
	char  cDir, cTmpDir;
	//int   aX, aY, aX2, aY2, dX, dY;
	int   aX, aY, dX, dY;
	int   i;
	if ((sX == dstX) && (sY == dstY)) return 0;
	dX = sX;
	dY = sY;

	if (bMIM == false) // MIM Fix
		cDir = CMisc::cGetNextMoveDir(dX, dY, dstX, dstY);
	else cDir = CMisc::cGetNextMoveDir(dstX, dstY, dX, dY);

	if (m_cPlayerTurn == 0)
		for (i = cDir; i <= cDir + 2; i++)
		{
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(DEF_MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}

	if (m_cPlayerTurn == 1)
		for (i = cDir; i >= cDir - 2; i--)
		{
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(DEF_MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}
	return 0;
}

bool CGame::_bCheckMoveable(short sx, short sy)
{	// Snoopy: This function prevents the client from asking at TP from some maps to
	// ML or PL if not citizen
	// Incomplete function and useless (the server will handle such cases)
/*	if( m_bIsCrusadeMode ) return true;
	if( m_bHunter == false ) return true;
	if( m_bCitizen == false ) return true;
	if( m_bAresden == true && m_cMapIndex == 11 )
	{	if( sy == 20 )
		{	if( (sx>=39) && (sx<=47) ) return false;
			if( (sx>=360) && (sx<=368) ) return false;
		}
	}
	if( m_bAresden == false && m_cMapIndex == 3 )
	{
		if( sy == 373 )
		{	if( (sx>=27) && (sx<=32) ) return false;
		}
		if( sy == 374 )
		{	if( (sx>=298) && (sx<=305) ) return false;
		}
	}*/
	return true;
}

bool CGame::bSendCommand(uint32_t dwMsgID, uint16_t wCommand, char cDir, int iV1, int iV2, int iV3, char* pString, int iV4)
{
	char cMsg[300], cKey;
	DWORD dwTime;
	int iRet, i;

	if ((m_pGSock == 0) && (m_pLSock == 0)) return false;
	dwTime = GameClock::GetTimeMS();
	std::memset(cMsg, 0, sizeof(cMsg));
	cKey = (char)(rand() % 255) + 1;

	switch (dwMsgID) {

	case DEF_REQUEST_ANGEL:	// to Game Server
	{
		hb::net::PacketRequestAngel req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		if (pString != nullptr) {
			std::size_t name_len = std::strlen(pString);
			if (name_len >= sizeof(req.name)) name_len = sizeof(req.name) - 1;
			std::memcpy(req.name, pString, name_len);
		}
		req.angel_id = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case DEF_REQUEST_RESURRECTPLAYER_YES: // By snoopy
	case DEF_REQUEST_RESURRECTPLAYER_NO:  // By snoopy
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_SCROLL:// By snoopy
	{
		hb::net::PacketRequestHeldenianScroll req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		if (pString != nullptr) {
			std::size_t name_len = std::strlen(pString);
			if (name_len >= sizeof(req.name)) name_len = sizeof(req.name) - 1;
			std::memcpy(req.name, pString, name_len);
		}
		req.item_id = wCommand;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_TELEPORT_LIST:
	{
		hb::net::PacketRequestName20 req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		std::memcpy(req.name, "William", sizeof(req.name));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_TP_LIST: // Snoopy: Heldenian TP
	{
		hb::net::PacketRequestName20 req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		std::memcpy(req.name, "Gail", sizeof(req.name));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_TP: // Snoopy: Heldenian TP
	case MSGID_REQUEST_CHARGED_TELEPORT:
	{
		hb::net::PacketRequestTeleportId req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.teleport_id = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_SELLITEMLIST:
	{
		hb::net::PacketRequestSellItemList req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		for (i = 0; i < DEF_MAXSELLLIST; i++) {
			req.entries[i].index = static_cast<uint8_t>(m_stSellItemList[i].iIndex);
			req.entries[i].amount = m_stSellItemList[i].iAmount;
		}
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_RESTART:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_PANNING:
	{
		hb::net::PacketRequestPanning req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.dir = static_cast<uint8_t>(cDir);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_CHANGEPASSWORD:
	{
		hb::net::ChangePasswordRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.new_password, 0, sizeof(req.new_password));
		std::memcpy(req.new_password, m_cNewPassword, sizeof(req.new_password));
		std::memset(req.new_password_confirm, 0, sizeof(req.new_password_confirm));
		std::memcpy(req.new_password_confirm, m_cNewPassConfirm, sizeof(req.new_password_confirm));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_CREATENEWACCOUNT:
		// to Log Server
	{
		hb::net::CreateAccountRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.email, 0, sizeof(req.email));
		std::memcpy(req.email, m_cEmailAddr, sizeof(req.email));
		std::memset(req.quiz, 0, sizeof(req.quiz));
		std::memcpy(req.quiz, m_cAccountQuiz, sizeof(req.quiz));
		std::memset(req.answer, 0, sizeof(req.answer));
		std::memcpy(req.answer, m_cAccountAnswer, sizeof(req.answer));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_GETMINIMUMLOADGATEWAY:
	case MSGID_REQUEST_LOGIN:
		// to Log Server
	{
		hb::net::LoginRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	break;

	case MSGID_REQUEST_CREATENEWCHARACTER:
		// to Log Server
	{
		hb::net::CreateCharacterRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_cPlayerName, sizeof(req.character_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		req.gender = static_cast<uint8_t>(m_cGender);
		req.skin = static_cast<uint8_t>(m_cSkinCol);
		req.hairstyle = static_cast<uint8_t>(m_cHairStyle);
		req.haircolor = static_cast<uint8_t>(m_cHairCol);
		req.underware = static_cast<uint8_t>(m_cUnderCol);
		req.str = static_cast<uint8_t>(m_ccStr);
		req.vit = static_cast<uint8_t>(m_ccVit);
		req.dex = static_cast<uint8_t>(m_ccDex);
		req.intl = static_cast<uint8_t>(m_ccInt);
		req.mag = static_cast<uint8_t>(m_ccMag);
		req.chr = static_cast<uint8_t>(m_ccChr);
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_ENTERGAME:
		// to Log Server
	{
		hb::net::EnterGameRequestFull req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = static_cast<uint16_t>(m_wEnterGameType);
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_cPlayerName, sizeof(req.character_name));
		std::memset(req.map_name, 0, sizeof(req.map_name));
		std::memcpy(req.map_name, m_cMapName, sizeof(req.map_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		req.level = m_iLevel;
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		std::memset(req.cmd_line, 0, sizeof(req.cmd_line));
		std::memcpy(req.cmd_line, G_cCmdLineTokenA, sizeof(req.cmd_line));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_DELETECHARACTER:
		// to Log Server
	{
		hb::net::DeleteCharacterRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = static_cast<uint16_t>(m_wEnterGameType);
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_pCharList[m_wEnterGameType - 1]->m_cName, sizeof(req.character_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_SETITEMPOS:
		// to Game Server
	{
		hb::net::PacketRequestSetItemPos req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.dir = static_cast<uint8_t>(cDir);
		req.x = static_cast<int16_t>(iV1);
		req.y = static_cast<int16_t>(iV2);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_COMMAND_CHECKCONNECTION:
	{
		hb::net::PacketCommandCheckConnection req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.time_ms = dwTime;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	break;

	case MSGID_REQUEST_INITDATA:
	case MSGID_REQUEST_INITPLAYER:
		// to Game Server
	{
		hb::net::PacketRequestInitPlayer req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.player, 0, sizeof(req.player));
		std::memcpy(req.player, m_cPlayerName, sizeof(req.player));
		std::memset(req.account, 0, sizeof(req.account));
		std::memcpy(req.account, m_cAccountName, sizeof(req.account));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		req.is_observer = static_cast<uint8_t>(m_bIsObserverMode);
		std::memset(req.server, 0, sizeof(req.server));
		std::memcpy(req.server, m_cGameServerName, sizeof(req.server));
		req.padding = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	//m_bIsObserverMode = false;
	break;
	case MSGID_LEVELUPSETTINGS:
	{
		hb::net::PacketRequestLevelUpSettings req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.str = m_cLU_Str;
		req.vit = m_cLU_Vit;
		req.dex = m_cLU_Dex;
		req.intel = m_cLU_Int;
		req.mag = m_cLU_Mag;
		req.chr = m_cLU_Char;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_COMMAND_CHATMSG:
		if (m_bIsTeleportRequested == true) return false;
		if (pString == 0) return false;

		// to Game Server
		{
			hb::net::PacketCommandChatMsgHeader req{};
			req.header.msg_id = dwMsgID;
			req.header.msg_type = 0;
			req.x = m_sPlayerX;
			req.y = m_sPlayerY;
			std::memset(req.name, 0, sizeof(req.name));
			std::memcpy(req.name, m_cPlayerName, sizeof(req.name));
			req.chat_type = static_cast<uint8_t>(iV1);
			if (bCheckLocalChatCommand(pString) == true) return false;
			std::size_t text_len = std::strlen(pString);
			std::memset(cMsg, 0, sizeof(cMsg));
			std::memcpy(cMsg, &req, sizeof(req));
			std::memcpy(cMsg + sizeof(req), pString, text_len + 1);
			iRet = m_pGSock->iSendMsg(cMsg, static_cast<int>(sizeof(req) + text_len + 1));
		}
		break;

	case MSGID_COMMAND_COMMON:
		if (m_bIsTeleportRequested == true) return false;
		switch (wCommand) {
		case DEF_COMMONTYPE_BUILDITEM:
		{
			hb::net::PacketCommandCommonBuild req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			std::memset(req.name, 0, sizeof(req.name));
			if (pString != 0) {
				std::size_t name_len = std::strlen(pString);
				if (name_len > sizeof(req.name)) name_len = sizeof(req.name);
				std::memcpy(req.name, pString, name_len);
			}
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		case DEF_COMMONTYPE_REQ_CREATEPORTION:
		{
			hb::net::PacketCommandCommonItems req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			req.padding = 0;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		//Crafting
		case DEF_COMMONTYPE_CRAFTITEM:
		{
			hb::net::PacketCommandCommonBuild req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			std::memset(req.name, ' ', sizeof(req.name));
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		// Create Slate Request - Diuuude
		case DEF_COMMONTYPE_REQ_CREATESLATE:
		{
			hb::net::PacketCommandCommonItems req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV6);
			req.padding = 0;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		default:
			if (pString == 0)
			{
				hb::net::PacketCommandCommonWithTime req{};
				req.base.header.msg_id = dwMsgID;
				req.base.header.msg_type = wCommand;
				req.base.x = m_sPlayerX;
				req.base.y = m_sPlayerY;
				req.base.dir = static_cast<uint8_t>(cDir);
				req.v1 = iV1;
				req.v2 = iV2;
				req.v3 = iV3;
				req.time_ms = dwTime;
				iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
			}
			else
			{
				hb::net::PacketCommandCommonWithString req{};
				req.base.header.msg_id = dwMsgID;
				req.base.header.msg_type = wCommand;
				req.base.x = m_sPlayerX;
				req.base.y = m_sPlayerY;
				req.base.dir = static_cast<uint8_t>(cDir);
				req.v1 = iV1;
				req.v2 = iV2;
				req.v3 = iV3;
				std::memset(req.text, 0, sizeof(req.text));
				std::size_t text_len = std::strlen(pString);
				if (text_len > sizeof(req.text)) text_len = sizeof(req.text);
				std::memcpy(req.text, pString, text_len);
				req.v4 = iV4;
				iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
			}
			break;
		}

		break;

	case MSGID_REQUEST_CREATENEWGUILD:
	case MSGID_REQUEST_DISBANDGUILD:
		// to Game Server
	{
		hb::net::PacketRequestGuildAction req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		std::memset(req.player, 0, sizeof(req.player));
		std::memcpy(req.player, m_cPlayerName, sizeof(req.player));
		std::memset(req.account, 0, sizeof(req.account));
		std::memcpy(req.account, m_cAccountName, sizeof(req.account));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.guild, 0, sizeof(req.guild));
		char cTemp[21];
		std::memset(cTemp, 0, sizeof(cTemp));
		std::memcpy(cTemp, m_cGuildName, 20);
		CMisc::ReplaceString(cTemp, ' ', '_');
		std::memcpy(req.guild, cTemp, sizeof(req.guild));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_TELEPORT:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}

	m_bIsTeleportRequested = true;
	break;

	case MSGID_REQUEST_CIVILRIGHT:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_REQUEST_RETRIEVEITEM:
	{
		hb::net::PacketRequestRetrieveItem req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		req.item_slot = static_cast<uint8_t>(iV1);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_REQUEST_NOTICEMENT:
	{
		hb::net::PacketRequestNoticement req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.value = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case  MSGID_REQUEST_FIGHTZONE_RESERVE:
	{
		hb::net::PacketRequestFightzoneReserve req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.fightzone = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_STATECHANGEPOINT:
		// Diuuude
	{
		hb::net::PacketRequestStateChange req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.change1 = static_cast<uint8_t>(cStateChange1);
		req.change2 = static_cast<uint8_t>(cStateChange2);
		req.change3 = static_cast<uint8_t>(cStateChange3);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	default:
		if (m_bIsTeleportRequested == true) return false;
		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE))
		{
			hb::net::PacketCommandMotionAttack req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.base.dx = static_cast<int16_t>(iV1);
			req.base.dy = static_cast<int16_t>(iV2);
			req.base.type = static_cast<int16_t>(iV3);
			req.target_id = static_cast<uint16_t>(iV4);
			req.time_ms = dwTime;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		else
		{
			hb::net::PacketCommandMotionSimple req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.base.dx = static_cast<int16_t>(iV1);
			req.base.dy = static_cast<int16_t>(iV2);
			req.base.type = static_cast<int16_t>(iV3);
			req.time_ms = dwTime;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req)); //v2.171
		}
		m_cCommandCount++;
		break;
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
	{
		char cDbg[160];
		wsprintf(cDbg, "[NETWARN] bSendCommand: ret=%d msgid=0x%X cmd=0x%X\n", iRet, dwMsgID, wCommand);
		OutputDebugStringA(cDbg);
	}
	ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
	delete m_pGSock;
	m_pGSock = 0;
	break;

	case DEF_XSOCKEVENT_CRITICALERROR:
	{
		char cDbg[160];
		wsprintf(cDbg, "[NETWARN] bSendCommand: CRITICAL ret=%d msgid=0x%X cmd=0x%X\n", iRet, dwMsgID, wCommand);
		OutputDebugStringA(cDbg);
	}
	delete m_pGSock;
	m_pGSock = 0;
	if (G_pCalcSocket != 0) {
		delete G_pCalcSocket;
		G_pCalcSocket = 0;
	}
	SendMessage(m_hWnd, WM_DESTROY, 0, 0);
	break;
	}
	return true;
}


void CGame::DrawObjects(short sPivotX, short sPivotY, short sDivX, short sDivY, short sModX, short sModY, short msX, short msY)
{
	int ix, iy, indexX, indexY, dX, dY, iDvalue;
	char cItemColor;
	bool bIsPlayerDrawed = false;
	bool bContact = false;
	bool bRet = false;
	short sItemSprite, sItemSpriteFrame, sObjSpr, sObjSprFrame, sDynamicObject, sDynamicObjectFrame;
	static DWORD dwMCAnimTime = G_dwGlobalTime;
	static short sMCAnimFrame = 1;
	// Xmas
	static int ix1[100];
	static int iy2[100];
	static int iXmasTreeBulbDelay = 76;
	int idelay = 75;
	bool frame_omit = false;

	// Item's desc on floor
	uint32_t dwItemAttr, dwItemSelectedAttr;
	int iItemSelectedx, iItemSelectedy;
	short sItemID, sItemSelectedID = -1;

	int res_x = LOGICAL_MAX_X;
	int res_y = LOGICAL_MAX_Y;
	int res_msy = LOGICAL_HEIGHT - 49;

	if (sDivY < 0 || sDivX < 0) return;
	m_sMCX = 0;
	m_sMCY = 0;
	std::memset(m_cMCName, 0, sizeof(m_cMCName));

	//dwTime = G_dwGlobalTime;
	uint32_t dwTime = m_dwCurTime;
	m_stMCursor.sCursorFrame = 0;

	indexY = sDivY + sPivotY - 7;
	for (iy = -sModY - 224; iy <= res_y + 352; iy += 32)
	{
		indexX = sDivX + sPivotX - 4;
		for (ix = -sModX - 128; ix <= res_x + 128; ix += 32)
		{
			sDynamicObject = 0;
			bRet = false;
			if ((ix >= -sModX) && (ix <= res_x + 16) && (iy >= -sModY) && (iy <= res_y + 32 + 16))
			{
				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = 0;
				_tmp_cDir = _tmp_cFrame = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iChatIndex = 0;
				std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{
					sItemID = 0;
					bRet = false;
					cItemColor = 0;
					dwItemAttr = 0;
				}
				else
				{
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX;
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY;
					_tmp_wObjectID = m_pMapData->m_pData[dX][dY].m_wDeadObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sDeadOwnerType;
					_tmp_cDir = m_pMapData->m_pData[dX][dY].m_cDeadDir;
					_tmp_sAppr1 = m_pMapData->m_pData[dX][dY].m_sDeadAppr1;
					_tmp_sAppr2 = m_pMapData->m_pData[dX][dY].m_sDeadAppr2;
					_tmp_sAppr3 = m_pMapData->m_pData[dX][dY].m_sDeadAppr3;
					_tmp_sAppr4 = m_pMapData->m_pData[dX][dY].m_sDeadAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iDeadApprColor;
					_tmp_cFrame = m_pMapData->m_pData[dX][dY].m_cDeadOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iDeadChatMsg;
					_tmp_iStatus = m_pMapData->m_pData[dX][dY].m_iDeadStatus;
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cDeadOwnerName);
					sItemID = m_pMapData->m_pData[dX][dY].m_sItemID;
					dwItemAttr = m_pMapData->m_pData[dX][dY].m_dwItemAttr;
					cItemColor = m_pMapData->m_pData[dX][dY].m_cItemColor;
					sDynamicObject = m_pMapData->m_pData[dX][dY].m_sDynamicObjectType;
					sDynamicObjectFrame = (short)m_pMapData->m_pData[dX][dY].m_cDynamicObjectFrame;
					cDynamicObjectData1 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData1;
					cDynamicObjectData2 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData2;
					cDynamicObjectData3 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData3;
					cDynamicObjectData4 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData4;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					bRet = true;
				}

				if ((bRet == true) && (sItemID != 0) && m_pItemConfigList[sItemID] != 0)
				{
					if (cItemColor == 0)
						m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->Draw(ix, iy, m_pItemConfigList[sItemID]->m_sSpriteFrame);
					else
					{
						switch (m_pItemConfigList[sItemID]->m_sSprite) {
						case 1: // Swds
						case 2: // Bows
						case 3: // Shields
						case 15: // Axes hammers
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->Draw(ix, iy, m_pItemConfigList[sItemID]->m_sSpriteFrame, SpriteLib::DrawParams::Tint(m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0]));
							break;
						default:
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->Draw(ix, iy, m_pItemConfigList[sItemID]->m_sSpriteFrame, SpriteLib::DrawParams::Tint(m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0]));
							break;
						}
					}

					if (InputManager::Get().IsShiftDown() && msX >= ix - 16 && msY >= iy - 16 && msX <= ix + 16 && msY <= iy + 16) {
						sItemSelectedID = sItemID;
						dwItemSelectedAttr = dwItemAttr;
						iItemSelectedx = ix;
						iItemSelectedy = iy;
					}

					if ((ix - 13 < msX) && (ix + 13 > msX) && (iy - 13 < msY) && (iy + 13 > msY))
					{
						if ((dwTime - dwMCAnimTime) > 200)
						{
							dwMCAnimTime = dwTime;
							if (sMCAnimFrame == 1)
								sMCAnimFrame = 2;
							else sMCAnimFrame = 1;
						}
						m_stMCursor.sCursorFrame = sMCAnimFrame;
					}
				}

				if ((bRet == true) && (_tmp_wObjectID != 0))
				{
					bContact = DrawObject_OnDead(indexX, indexY, ix, iy, false, dwTime, msX, msY);
				}

				if ((bContact == true) && (msY <= res_msy))
				{
					m_sMCX = indexX;
					m_sMCY = indexY;
					sFocusX = ix;
					sFocusY = iy;
					sFocusOwnerType = _tmp_sOwnerType;
					cFocusAction = DEF_OBJECTDEAD;
					wFocusObjectID = _tmp_wObjectID;
					cFocusFrame = _tmp_cFrame;
					cFocusDir = _tmp_cDir;
					sFocusAppr1 = _tmp_sAppr1;
					sFocusAppr2 = _tmp_sAppr2;
					sFocusAppr3 = _tmp_sAppr3;
					sFocusAppr4 = _tmp_sAppr4;
					iFocusApprColor = _tmp_iApprColor;
					iFocuiStatus = _tmp_iStatus;
					std::memset(cFocusName, 0, sizeof(cFocusName));
					strcpy(cFocusName, _tmp_cName);
					std::memset(m_cMCName, 0, sizeof(m_cMCName));
					strcpy(m_cMCName, _tmp_cName);
					sFocus_dX = _tmp_dX;
					sFocus_dY = _tmp_dY;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					bContact = false;
				}

				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = 0;
				_tmp_cFrame = _tmp_cDir = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iApprColor = _tmp_iChatIndex = 0;
				std::memset(_tmp_cName, 0, sizeof(_tmp_cName));

				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{
					sItemID = 0;
					bRet = false;
				}
				else
				{
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX; // v2.171 2002-6-14
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY; // v2.171 2002-6-14
					_tmp_wObjectID = m_pMapData->m_pData[dX][dY].m_wObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sOwnerType;
					_tmp_cAction = m_pMapData->m_pData[dX][dY].m_cOwnerAction;
					_tmp_iStatus = m_pMapData->m_pData[dX][dY].m_iStatus;
					_tmp_cDir = m_pMapData->m_pData[dX][dY].m_cDir;
					_tmp_sAppr1 = m_pMapData->m_pData[dX][dY].m_sAppr1;
					_tmp_sAppr2 = m_pMapData->m_pData[dX][dY].m_sAppr2;
					_tmp_sAppr3 = m_pMapData->m_pData[dX][dY].m_sAppr3;
					_tmp_sAppr4 = m_pMapData->m_pData[dX][dY].m_sAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iApprColor; // v1.4
					_tmp_cFrame = m_pMapData->m_pData[dX][dY].m_cOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iChatMsg;
					_tmp_iEffectType = m_pMapData->m_pData[dX][dY].m_iEffectType;
					_tmp_iEffectFrame = m_pMapData->m_pData[dX][dY].m_iEffectFrame;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cOwnerName);
					bRet = true;

					if (m_iIlusionOwnerH != 0)
					{
						if ((strcmp(_tmp_cName, m_cPlayerName) != 0) && (_tmp_sOwnerType < 10))
						{
							_tmp_sOwnerType = m_cIlusionOwnerType;
							_tmp_iStatus = m_iStatus_IE;
							_tmp_sAppr1 = m_sAppr1_IE;
							_tmp_sAppr2 = m_sAppr2_IE;
							_tmp_sAppr3 = m_sAppr3_IE;
							_tmp_sAppr4 = m_sAppr4_IE;
							_tmp_iApprColor = m_iApprColor_IE;
						}
					}
				}

				if ((bRet == true) && (strlen(_tmp_cName) > 0))
				{
					_tmp_dx = 0;
					_tmp_dy = 0;
					switch (_tmp_cAction) {
					case DEF_OBJECTSTOP:
						bContact = DrawObject_OnStop(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTMOVE:
						bContact = DrawObject_OnMove(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTDAMAGEMOVE:
						bContact = DrawObject_OnDamageMove(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTRUN:
						bContact = DrawObject_OnRun(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTATTACK:
						bContact = DrawObject_OnAttack(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACKMOVE:
						bContact = DrawObject_OnAttackMove(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTMAGIC:
						bContact = DrawObject_OnMagic(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTGETITEM:
						bContact = DrawObject_OnGetItem(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGE:
						bContact = DrawObject_OnDamage(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTDYING:
						bContact = DrawObject_OnDying(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;
					}

					if ((bContact == true) && (msY <= res_msy))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusX = ix;
						sFocusY = iy;
						wFocusObjectID = _tmp_wObjectID;
						sFocusOwnerType = _tmp_sOwnerType;
						cFocusAction = _tmp_cAction;
						cFocusFrame = _tmp_cFrame;
						cFocusDir = _tmp_cDir;
						sFocusAppr1 = _tmp_sAppr1;
						sFocusAppr2 = _tmp_sAppr2;
						sFocusAppr3 = _tmp_sAppr3;
						sFocusAppr4 = _tmp_sAppr4;
						iFocusApprColor = _tmp_iApprColor; // v1.4
						iFocuiStatus = _tmp_iStatus;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						strcpy(cFocusName, _tmp_cName);
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
						strcpy(m_cMCName, _tmp_cName);
						sFocus_dX = _tmp_dX; // v2.171
						sFocus_dY = _tmp_dY; // v2.171
						bContact = false;
						frame_omit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					}

					if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
					{
						if (m_bIsObserverMode == false)
						{
							m_sViewDstX = (indexX - VIEW_CENTER_TILE_X) * 32;
							m_sViewDstY = (indexY - (VIEW_CENTER_TILE_Y + 1)) * 32;
						}
						SetRect(&m_rcPlayerRect, m_rcBodyRect.left, m_rcBodyRect.top, m_rcBodyRect.right, m_rcBodyRect.bottom);
						bIsPlayerDrawed = true;
					}
				}
			}

			// CLEROTH
			sObjSpr = m_pMapData->m_tile[indexX][indexY].m_sObjectSprite;
			sObjSprFrame = m_pMapData->m_tile[indexX][indexY].m_sObjectSpriteFrame;

			if (sObjSpr != 0)
			{
				if ((sObjSpr < 100) || (sObjSpr >= 200))
				{
					switch (sObjSpr) {
					case 200:
					case 223:
						m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame, SpriteLib::DrawParams::Shadow());
						break;

					case 224:
						switch (sObjSprFrame) {
						case 24:
						case 34:
						case 35:
						case 36:
						case 37:
						case 38:
							break;
						default:
							m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame, SpriteLib::DrawParams::Shadow());
							break;
						}
					}
					if (ConfigManager::Get().GetDetailLevel() == 0) // Special Grass & Flowers
					{
						if ((sObjSpr != 6) && (sObjSpr != 9))
							m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame);
					}
					else
					{
						m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame);
					}

					switch (sObjSpr) {
					case 223:
						if (sObjSprFrame == 4)
						{
							if (G_cSpriteAlphaDegree == 2) //nuit
							{
								int iDvalue1 = -1 * (rand() % 5);
								int iDvalue2 = -1 * (rand() % 5);
								int iDvalue3 = -1 * (rand() % 5);
								m_pEffectSpr[0]->Draw(ix + 2 - 17, iy - 147 - 15, 1, SpriteLib::DrawParams::TintedAlpha(iDvalue1, iDvalue1, iDvalue1, 0.7f));
								m_pEffectSpr[0]->Draw(ix + 16 - 17, iy - 96 - 15, 1, SpriteLib::DrawParams::TintedAlpha(iDvalue2, iDvalue2, iDvalue2, 0.7f));
								m_pEffectSpr[0]->Draw(ix - 19 - 17, iy - 126 - 15, 1, SpriteLib::DrawParams::TintedAlpha(iDvalue3, iDvalue3, iDvalue3, 0.7f));
							}
						}
						break;

					case 370: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 16 + 30, m_sViewPointY + iy - 16 - 334, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 16 + 17, m_sViewPointY + iy - 16 - 300, 0, 0, 0, 0);
						break;

					case 374: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 7, m_sViewPointY + iy - 122, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 6) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 14, m_sViewPointY + iy - 321, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 7) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix + 7, m_sViewPointY + iy - 356, 0, 0, 0, 0);
						break;

					case 376: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 12) && (G_cSpriteAlphaDegree == 2)) {
							m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 16, m_sViewPointY + iy - 346, 0, 0, 0, 0);
							m_pEffectManager->AddEffect(65, m_sViewPointX + ix + 11, m_sViewPointY + iy - 308, 0, 0, 0, 0);
						}
						break;

					case 378: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix, m_sViewPointY + iy - 91, 0, 0, 0, 0);
						break;

					case 382: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) {
							m_pEffectManager->AddEffect(65, m_sViewPointX + ix + 73, m_sViewPointY + iy - 264, 0, 0, 0, 0);
							m_pEffectManager->AddEffect(65, m_sViewPointX + ix + 23, m_sViewPointY + iy - 228, 0, 0, 0, 0);
						}
						break;

					case 429:
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2)) m_pEffectManager->AddEffect(65, m_sViewPointX + ix - 15, m_sViewPointY + iy - 224, 0, 0, 0, 0);
						break;
					}
				}
				else // sprites 100..199: Trees and tree shadows
				{
					m_pTileSpr[sObjSpr]->GetFrameRect(ix - 16, iy - 16, sObjSprFrame);
					if (ConfigManager::Get().GetDetailLevel() == 0)
					{
						if (sObjSpr < 100 + 11) m_pTileSpr[100 + 4]->Draw(ix - 16, iy - 16, sObjSprFrame);
						else if (sObjSpr < 100 + 23) m_pTileSpr[100 + 9]->Draw(ix - 16, iy - 16, sObjSprFrame);
						else if (sObjSpr < 100 + 32) m_pTileSpr[100 + 23]->Draw(ix - 16, iy - 16, sObjSprFrame);
						else m_pTileSpr[100 + 32]->Draw(ix - 16, iy - 16, sObjSprFrame);
					}
					else
					{
						if ((bIsPlayerDrawed == true) && (m_pTileSpr[sObjSpr]->m_rcBound.top <= m_rcPlayerRect.top) && (m_pTileSpr[sObjSpr]->m_rcBound.bottom >= m_rcPlayerRect.bottom) &&
							(ConfigManager::Get().GetDetailLevel() >= 2) && (m_pTileSpr[sObjSpr]->m_rcBound.left <= m_rcPlayerRect.left) && (m_pTileSpr[sObjSpr]->m_rcBound.right >= m_rcPlayerRect.right))
						{
							m_pTileSpr[sObjSpr + 50]->Draw(ix, iy, sObjSprFrame, SpriteLib::DrawParams::Fade());
							m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame, SpriteLib::DrawParams::Alpha(0.25f));
						}
						else
						{
							m_pTileSpr[sObjSpr + 50]->Draw(ix, iy, sObjSprFrame);
							m_pTileSpr[sObjSpr]->Draw(ix - 16, iy - 16, sObjSprFrame);
						}
						if (m_bIsXmas == true)
						{
							if (G_cSpriteAlphaDegree == 2) // nuit
							{
								if (iXmasTreeBulbDelay < 0 || iXmasTreeBulbDelay > idelay + 1) iXmasTreeBulbDelay = 0;
								if (iXmasTreeBulbDelay > idelay)
								{
									for (int i = 0; i < 100; i++) {
										ix1[i] = 1 * (rand() % 400) - 200;
										iy2[i] = -1 * (rand() % 300);
									}
									iXmasTreeBulbDelay = 0;
								}
								else iXmasTreeBulbDelay++;

								for (int j = 0; j < 100; j++)
								{
									if (m_pTileSpr[sObjSpr]->CheckCollision(ix - 16, iy - 16, sObjSprFrame, ix + ix1[j], iy + iy2[j]))
									{
										m_pEffectSpr[66 + (j % 6)]->Draw(ix + ix1[j], iy + iy2[j], (iXmasTreeBulbDelay >> 2), SpriteLib::DrawParams::Alpha(0.5f));
									}
								}
							}
						}
					}
				}
			}

			// Dynamic Object
			if ((bRet == true) && (sDynamicObject != 0))
			{
				switch (sDynamicObject) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:	// 10
					if (sDynamicObjectFrame >= 0)
						m_pEffectSpr[23]->Draw(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame, SpriteLib::DrawParams{0.5f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_LOOP:		// 11
					m_pEffectSpr[23]->Draw(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame + 8, SpriteLib::DrawParams{0.5f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_END:		// 12
					m_pEffectSpr[23]->Draw(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame + 16, SpriteLib::DrawParams{0.5f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:		// 8
					iDvalue = (rand() % 5) * (-1);
					m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams::TintedAlpha(iDvalue, iDvalue, iDvalue, 0.7f));
					m_pEffectSpr[13]->Draw(ix, iy, sDynamicObjectFrame, SpriteLib::DrawParams{0.7f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_FIRE:			// 1
				case DEF_DYNAMICOBJECT_FIRE3:			// 14
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.25f, 0, 0, 0, false}); break;
					case 1: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.5f, 0, 0, 0, false}); break;
					case 2: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.7f, 0, 0, 0, false}); break;
					}
					m_pEffectSpr[9]->Draw(ix, iy, sDynamicObjectFrame / 3, SpriteLib::DrawParams{0.7f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_FIRE2:			// 13
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.25f, 0, 0, 0, false}); break;
					case 1: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.5f, 0, 0, 0, false}); break;
					case 2: m_pEffectSpr[0]->Draw(ix, iy, 1, SpriteLib::DrawParams{0.7f, 0, 0, 0, false}); break;
					}
					break;

				case DEF_DYNAMICOBJECT_FISH:			// 2
				{
					char cTmpDOdir, cTmpDOframe;
					cTmpDOdir = CMisc::cCalcDirection(cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData1 + cDynamicObjectData3, cDynamicObjectData2 + cDynamicObjectData4);
					cTmpDOframe = ((cTmpDOdir - 1) * 4) + (rand() % 4);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 0]->Draw(ix + cDynamicObjectData1, iy + cDynamicObjectData2, cTmpDOframe, SpriteLib::DrawParams::Alpha(0.25f));
				}
				break;

				case DEF_DYNAMICOBJECT_MINERAL1:		// 4
					if (ConfigManager::Get().GetDetailLevel() != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->Draw(ix, iy, 0, SpriteLib::DrawParams::Shadow());
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->Draw(ix, iy, 0);
					if ((m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top != -1)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top < msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.bottom > msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.left < msX)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.right > msX))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = 0;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL2:		// 5
					if (ConfigManager::Get().GetDetailLevel() != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->Draw(ix, iy, 1, SpriteLib::DrawParams::Shadow());
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->Draw(ix, iy, 1);
					if ((m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top != -1)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top < msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.bottom > msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.left < msX)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.right > msX))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = 0;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_SPIKE:			// 9
					m_pEffectSpr[17]->Draw(ix, iy, sDynamicObjectFrame, SpriteLib::DrawParams{0.7f, 0, 0, 0, false});
					break;

				case DEF_DYNAMICOBJECT_ARESDENFLAG1:  // 6
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 2]->Draw(ix, iy, sDynamicObjectFrame);
					break;

				case DEF_DYNAMICOBJECT_ELVINEFLAG1: // 7
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 2]->Draw(ix, iy, sDynamicObjectFrame);
					break;
				}
			}
			indexX++;
		}
		indexY++;
	}

	if ((dwTime - m_dwEnvEffectTime) > 400) m_dwEnvEffectTime = dwTime;

	if (m_sMCX != 0)	// CLEROTH - STATUS
	{
		if (_iGetFOE(iFocuiStatus) < 0) m_stMCursor.sCursorFrame = 3;
		else m_stMCursor.sCursorFrame = 6;

		_tmp_wObjectID = wFocusObjectID;
		_tmp_sOwnerType = sFocusOwnerType;
		_tmp_cAction = cFocusAction;
		_tmp_cFrame = cFocusFrame;
		_tmp_cDir = cFocusDir;
		_tmp_sAppr1 = sFocusAppr1;
		_tmp_sAppr2 = sFocusAppr2;
		_tmp_sAppr3 = sFocusAppr3;
		_tmp_sAppr4 = sFocusAppr4;
		_tmp_iApprColor = iFocusApprColor; // v1.4
		_tmp_iStatus = iFocuiStatus;
		strcpy(_tmp_cName, cFocusName);
		_tmp_dX = sFocus_dX; // v2.171
		_tmp_dY = sFocus_dY; // v2.171

		if ((_tmp_cAction != DEF_OBJECTDEAD) && (_tmp_cFrame < 0)) return;
		switch (_tmp_cAction) {
		case DEF_OBJECTSTOP:
			DrawObject_OnStop(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;
		case DEF_OBJECTMOVE:
			switch (_tmp_sOwnerType) {
			case 1:
			case 2:
			case 3: // Human M
			case 4:
			case 5:
			case 6: // Human F

			case 28: // Troll.
			case 29: // Ogre
			case 30: // Liche
			case 31: // DD
			case 32: // Uni
			case 33: // WW
			case 43: // LWB
			case 44: // GHK
			case 45: // GHKABS
			case 46: // TK
			case 47: // BG
			case 48: // SK
			case 49: // HC
			case 50: // TW
			case 51: // CP
			case 52: // GG
			case 53: // BB
			case 54: // DE
			case 55: // Rabbit
			case 56: // Cat
			case 57: // Frog
			case 58: // MG
			case 59: // Ettin
			case 60: // Plant
			case 61: // Rudolph
			case 62: // DireBoar
			case 63: // Frost
			case 65: // Ice-Golem
			case 66: // Wyvern
			case 70: // Dragon..........Ajouts par Snoopy
			case 71: // Centaur
			case 72: // ClawTurtle
			case 73: // FireWyvern
			case 74: // GiantCrayfish
			case 75: // Gi Lizard
			case 76: // Gi Tree
			case 77: // Master Orc
			case 78: // Minaus
			case 79: // Nizie
			case 80: // Tentocle
			case 81: // Abaddon
			case 82: // Sorceress
			case 83: // ATK
			case 84: // MasterElf
			case 85: // DSK
			case 86: // HBT
			case 87: // CT
			case 88: // Barbarian
			case 89: // AGC
			case 91: // Gate

				/*	case 15: // ShopKeeper // Ils ont 8 sprites Stop
					case 19: // Gandalf
					case 20: // Howard
					case 24: // Tom
					case 25: // William
					case 26: // Kenedy
					case 90: // Gail*/
				break;

			default: // 10..27
				_tmp_cFrame = _tmp_cFrame * 2; //
				break;
			}

			DrawObject_OnMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTDAMAGEMOVE:
			DrawObject_OnDamageMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTRUN:
			DrawObject_OnRun(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTATTACK:
			DrawObject_OnAttack(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTATTACKMOVE:
			DrawObject_OnAttackMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTMAGIC:
			DrawObject_OnMagic(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDAMAGE:
			DrawObject_OnDamage(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDYING: //10
			DrawObject_OnDying(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDEAD: //101
			DrawObject_OnDead(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;
		}
	}

	if (sItemSelectedID != -1) {
		char cStr1[64], cStr2[64], cStr3[64];
		int  iLoc;
		GetItemName(m_pItemConfigList[sItemSelectedID], cStr1, cStr2, cStr3);

		iLoc = 0;
		if (strlen(cStr1) != 0)
		{
			if (m_bIsSpecial)
				PutString(msX, msY + 25, cStr1, RGB(0, 255, 50), false, 1);
			else
				PutString(msX, msY + 25, cStr1, RGB(255, 255, 255), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr2) != 0)
		{
			PutString(msX, msY + 25 + iLoc, cStr2, RGB(150, 150, 150), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr3) != 0)
		{
			PutString(msX, msY + 25 + iLoc, cStr3, RGB(150, 150, 150), false, 1);
			iLoc += 15;
		}
	}

	if (m_bIsGetPointingMode == true)
	{
		if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200)) // spell
		{
			if (m_bCommandAvailable == true)
			{
				if (m_sMCX != 0)
				{
					if (_iGetFOE(iFocuiStatus) < 0)
						m_stMCursor.sCursorFrame = 5;   // Red enemi for spell
					else m_stMCursor.sCursorFrame = 4;  // Blue friend for spell
				}
				else m_stMCursor.sCursorFrame = 4;     // Blue friend for spell
			}
			else m_stMCursor.sCursorFrame = 8;
		}
		else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50)) // item
		{
			m_stMCursor.sCursorFrame = 10;				// hand to grap item
		}
	}
}

bool CGame::_bDecodeItemConfigFileContents(char* pData, uint32_t dwMsgSize)
{
	// Parse binary item config packet
	constexpr size_t headerSize = sizeof(hb::net::PacketItemConfigHeader);
	constexpr size_t entrySize = sizeof(hb::net::PacketItemConfigEntry);

	printf("[ITEM CONFIG] Received packet, size=%u, headerSize=%zu, entrySize=%zu\n",
		dwMsgSize, headerSize, entrySize);

	if (dwMsgSize < headerSize) {
		printf("[ITEM CONFIG] Packet too small for header\n");
		return false;
	}

	const auto* pktHeader = reinterpret_cast<const hb::net::PacketItemConfigHeader*>(pData);
	uint16_t itemCount = pktHeader->itemCount;
	printf("[ITEM CONFIG] Header says %u items, totalItems=%u, packetIndex=%u\n",
		itemCount, pktHeader->totalItems, pktHeader->packetIndex);

	if (dwMsgSize < headerSize + (itemCount * entrySize)) {
		return false;
	}

	const auto* entries = reinterpret_cast<const hb::net::PacketItemConfigEntry*>(pData + headerSize);

	for (uint16_t i = 0; i < itemCount; i++) {
		const auto& entry = entries[i];
		int itemId = entry.itemId;

		if (itemId <= 0 || itemId >= 5000) {
			continue;
		}

		// Delete existing item if present (shouldn't happen, but be safe)
		if (m_pItemConfigList[itemId] != 0) {
			delete m_pItemConfigList[itemId];
		}

		m_pItemConfigList[itemId] = new class CItem;
		CItem* pItem = m_pItemConfigList[itemId];

		pItem->m_sIDnum = entry.itemId;
		std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
		std::strncpy(pItem->m_cName, entry.name, sizeof(pItem->m_cName) - 1);
		pItem->m_cItemType = entry.itemType;
		pItem->m_cEquipPos = entry.equipPos;
		pItem->m_sItemEffectType = entry.effectType;
		pItem->m_sItemEffectValue1 = entry.effectValue1;
		pItem->m_sItemEffectValue2 = entry.effectValue2;
		pItem->m_sItemEffectValue3 = entry.effectValue3;
		pItem->m_sItemEffectValue4 = entry.effectValue4;
		pItem->m_sItemEffectValue5 = entry.effectValue5;
		pItem->m_sItemEffectValue6 = entry.effectValue6;
		pItem->m_wMaxLifeSpan = entry.maxLifeSpan;
		pItem->m_sSpecialEffect = entry.specialEffect;
		pItem->m_sSprite = entry.sprite;
		pItem->m_sSpriteFrame = entry.spriteFrame;
		pItem->m_bIsForSale = (entry.price >= 0);
		pItem->m_wPrice = static_cast<uint32_t>(entry.price >= 0 ? entry.price : -entry.price);
		pItem->m_wWeight = entry.weight;
		pItem->m_cApprValue = entry.apprValue;
		pItem->m_cSpeed = entry.speed;
		pItem->m_sLevelLimit = entry.levelLimit;
		pItem->m_cGenderLimit = entry.genderLimit;
		pItem->m_sSpecialEffectValue1 = entry.specialEffectValue1;
		pItem->m_sSpecialEffectValue2 = entry.specialEffectValue2;
		pItem->m_sRelatedSkill = entry.relatedSkill;
		pItem->m_cCategory = entry.category;
		pItem->m_cItemColor = entry.itemColor;
	}

	// Count how many items we have now
	int storedCount = 0;
	for (int j = 0; j < 5000; j++) {
		if (m_pItemConfigList[j] != nullptr) storedCount++;
	}
	printf("[ITEM CONFIG] After processing: %d items in m_pItemConfigList\n", storedCount);

	return true;
}

void CGame::GameRecvMsgHandler(uint32_t dwMsgSize, char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	m_dwLastNetMsgId = header->msg_id;
	m_dwLastNetMsgTime = GameClock::GetTimeMS();
	m_dwLastNetMsgSize = dwMsgSize;
	switch (header->msg_id) {
	case MSGID_ITEMCONFIGURATIONCONTENTS:
		// Pass full pData - PacketItemConfigHeader includes the PacketHeader
		_bDecodeItemConfigFileContents(pData, dwMsgSize);
		break;
	case MSGID_RESPONSE_CHARGED_TELEPORT:
		ResponseChargedTeleport(pData);
		break;

	case MSGID_RESPONSE_TELEPORT_LIST:
		ResponseTeleportList(pData);
		break;

	case MSGID_RESPONSE_HELDENIAN_TP_LIST: // Snoopy Heldenian TP
		ResponseHeldenianTeleportList(pData);
		break;

	case MSGID_RESPONSE_NOTICEMENT:
		NoticementHandler(pData);
		break;

	case MSGID_DYNAMICOBJECT:
		DynamicObjectHandler(pData);
		break;

	case MSGID_RESPONSE_INITPLAYER:
		InitPlayerResponseHandler(pData);
		break;

	case MSGID_RESPONSE_INITDATA:
		InitDataResponseHandler(pData);
		break;

	case MSGID_RESPONSE_MOTION:
		MotionResponseHandler(pData);
		break;

	case MSGID_EVENT_COMMON:
		CommonEventHandler(pData);
		break;

	case MSGID_EVENT_MOTION:
		MotionEventHandler(pData);
		break;

	case MSGID_EVENT_LOG:
		LogEventHandler(pData);
		break;

	case MSGID_COMMAND_CHATMSG:
		ChatMsgHandler(pData);
		break;

	case MSGID_PLAYERITEMLISTCONTENTS:
		InitItemList(pData);
		break;

	case MSGID_NOTIFY:
		if (m_pNetworkMessageManager) {

			m_pNetworkMessageManager->ProcessMessage(MSGID_NOTIFY, pData, dwMsgSize);
		}
		break;

	case MSGID_RESPONSE_CREATENEWGUILD:
		CreateNewGuildResponseHandler(pData);
		break;

	case MSGID_RESPONSE_DISBANDGUILD:
		DisbandGuildResponseHandler(pData);
		break;

	case MSGID_PLAYERCHARACTERCONTENTS:
		InitPlayerCharacteristics(pData);
		break;

	case MSGID_RESPONSE_CIVILRIGHT:
		CivilRightAdmissionHandler(pData);
		break;

	case MSGID_RESPONSE_RETRIEVEITEM:
		RetrieveItemHandler(pData);
		break;

	case MSGID_RESPONSE_PANNING:
		ResponsePanningHandler(pData);
		break;

	case MSGID_RESPONSE_FIGHTZONE_RESERVE:
		ReserveFightzoneResponseHandler(pData);
		break;

	case MSGID_RESPONSE_SHOP_CONTENTS:
		ResponseShopContentsHandler(pData);
		break;

	case MSGID_COMMAND_CHECKCONNECTION:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCheckConnection>(
			pData, sizeof(hb::net::PacketCommandCheckConnection));
		if (!pkt) return;
		uint32_t dwRecvTime = m_dwLastNetRecvTime;
		if (dwRecvTime == 0) dwRecvTime = GameClock::GetTimeMS();
		if (dwRecvTime >= pkt->time_ms)
		{
			m_iLatencyMs = static_cast<int>(dwRecvTime - pkt->time_ms);
		}
	}
	break;
	}
}


void CGame::ConnectionEstablishHandler(char cWhere)
{
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGRESPONSE);

	switch (cWhere) {
	case DEF_SERVERTYPE_GAME:
		bSendCommand(MSGID_REQUEST_INITPLAYER, 0, 0, 0, 0, 0, 0);
		break;

	case DEF_SERVERTYPE_LOG:
		switch (m_dwConnectMode) {
		case MSGID_REQUEST_LOGIN:
			bSendCommand(MSGID_REQUEST_LOGIN, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CREATENEWACCOUNT:
			bSendCommand(MSGID_REQUEST_CREATENEWACCOUNT, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CREATENEWCHARACTER:
			bSendCommand(MSGID_REQUEST_CREATENEWCHARACTER, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_ENTERGAME:
			bSendCommand(MSGID_REQUEST_ENTERGAME, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_DELETECHARACTER:
			bSendCommand(MSGID_REQUEST_DELETECHARACTER, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CHANGEPASSWORD:
			bSendCommand(MSGID_REQUEST_CHANGEPASSWORD, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_INPUTKEYCODE:
			bSendCommand(MSGID_REQUEST_INPUTKEYCODE, 0, 0, 0, 0, 0, 0);
			break;
		}
		break;
	}
}

void CGame::InitPlayerResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		bSendCommand(MSGID_REQUEST_INITDATA, 0, 0, 0, 0, 0, 0);
		ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
		break;

	case DEF_MSGTYPE_REJECT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3J");
		break;
	}
}


void CGame::MakeSprite(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pSprite[i + sStart] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeTileSpr(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pTileSpr[i + sStart] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeEffectSpr(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pEffectSpr[i + sStart] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::UpdateScreen_OnLoading(bool bActive)
{
	int i;
	if (bActive) UpdateScreen_OnLoading_Progress();

	switch (m_cLoading) {
	case 0:
	{
		m_hPakFile = CreateFile("sprites\\interface.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_MOUSECURSOR] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "interface", 1, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\Newmaps.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Newmaps", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Newmaps", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Newmaps", 2, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Newmaps", 3, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Newmaps", 4, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\LoginDialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "LoginDialog", 0, false);
#ifdef DEF_MAKE_ACCOUNT
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "LoginDialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_AGREEMENT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "LoginDialog", 2, false);
#endif
			CloseHandle(m_hPakFile);
		}
#ifdef DEF_MAKE_ACCOUNT			// CLEROTH - ACC - Snoopy: fixed to use without special pak
		m_hPakFile = CreateFile("sprites\\CreateNewAcc.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "CreateNewAcc", 0, false);
			CloseHandle(m_hPakFile);
		}
		else
		{
			m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "New-Dialog", 2, false);
			CloseHandle(m_hPakFile);
		}
#endif
		m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "New-Dialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "New-Dialog", 2, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\GameDialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 2, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 3, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 4, false);
			//m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP] =      new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 5, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 6, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 7, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_SELECTCHAR] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 8, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWCHAR] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 9, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWEXCHANGE] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog", 10, false);
			CloseHandle(m_hPakFile);
		}

		//m_hPakFile = CreateFile("sprites\\GameDialog2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		//if (m_hPakFile != INVALID_HANDLE_VALUE) {
		//	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "GameDialog2", 6, false);
		//	CloseHandle(m_hPakFile);
		//}

		m_hPakFile = CreateFile("sprites\\PartySprite.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "PartySprite", 0, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\DialogText.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_TEXT] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "DialogText", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "DialogText", 1, false);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Telescope", DEF_SPRID_INTERFACE_GUIDEMAP, 32, false);	  // Snoopy: 20->32
		MakeSprite("Telescope2", DEF_SPRID_INTERFACE_GUIDEMAP + 35, 4, false); // Snoopy: Ajout.351 (heldenian maps)
		MakeSprite("monster", DEF_SPRID_INTERFACE_MONSTER, 1, false);
		m_cLoading = 4;
	}
	break;
	case 4:
	{
		MakeTileSpr("maptiles1", 0, 32, true);
		m_hPakFile = CreateFile("sprites\\structures1.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); //�Ⱦ��� Ÿ�� �ε� ���Ѵ�.2002.09.06����
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pTileSpr[1 + 50] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "structures1", 1, true);
			m_pTileSpr[5 + 50] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "structures1", 5, true);
			CloseHandle(m_hPakFile);
		}
		MakeTileSpr("Sinside1", 70, 27, false);
		MakeTileSpr("Trees1", 100, 46, true);
		MakeTileSpr("TreeShadows", 150, 46, true);
		MakeTileSpr("objects1", 200, 10, true); // snoopy: 8->10
		MakeTileSpr("objects2", 211, 5, true);
		MakeTileSpr("objects3", 216, 4, true);
		MakeTileSpr("objects4", 220, 2, true); //snoopy: 1->2
		m_cLoading = 8;
	}
	break;
	case 8:
	{
		MakeTileSpr("Tile223-225", 223, 3, true);
		MakeTileSpr("Tile226-229", 226, 4, true);
		MakeTileSpr("objects5", 230, 9, true);	// Snoopy
		MakeTileSpr("objects6", 238, 4, true);	// Snoopy
		MakeTileSpr("objects7", 242, 7, true);	// Snoopy
		MakeTileSpr("maptiles2", 300, 15, true);//- Index 300
		MakeTileSpr("maptiles4", 320, 10, true);
		MakeTileSpr("maptiles5", 330, 19, true);
		MakeTileSpr("maptiles6", 349, 4, true);
		MakeTileSpr("maptiles353-361", 353, 9, true);
		MakeTileSpr("Tile363-366", 363, 4, true);
		MakeTileSpr("Tile367-367", 367, 1, true); // Add by Snoopy (fountains)
		MakeTileSpr("Tile370-381", 370, 12, true);// Tile370~381
		MakeTileSpr("Tile382-387", 382, 6, true);
		MakeTileSpr("Tile388-402", 388, 15, true);
		m_cLoading = 12;
	}
	break;
	case 12:
	{
		MakeTileSpr("Tile403-405", 403, 3, true);
		MakeTileSpr("Tile406-421", 406, 16, true);
		MakeTileSpr("Tile422-429", 422, 8, true);
		MakeTileSpr("Tile430-443", 430, 14, true);
		MakeTileSpr("Tile444-444", 444, 1, true);
		MakeTileSpr("Tile445-461", 445, 17, true);
		MakeTileSpr("Tile462-473", 462, 12, true);	// Diuuude
		MakeTileSpr("Tile474-478", 474, 5, true);	// Diuuude
		MakeTileSpr("Tile479-488", 479, 10, true);	// Diuuude
		MakeTileSpr("Tile489-522", 489, 34, true);	// Diuuude Drunken City
		MakeTileSpr("Tile523-530", 523, 8, true);	// Diuuude Rampart
		MakeTileSpr("Tile531-540", 531, 10, true);	// Diuuude GodH + Pont
		MakeTileSpr("Tile541-545", 541, 5, true);	// Diuuude GodH

		// DEF_SPRID_ITEMPACK_PIVOTPOINT+0
		MakeSprite("item-pack", DEF_SPRID_ITEMPACK_PIVOTPOINT + 1, 27, false);
		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 17, false); //
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 18, false); //
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 19, false); // Angels
			CloseHandle(m_hPakFile);
		}

		// DEF_SPRID_ITEMGROUND_PIVOTPOINT+1
		MakeSprite("item-ground", DEF_SPRID_ITEMGROUND_PIVOTPOINT + 1, 19, false);
		m_hPakFile = CreateFile("sprites\\item-ground.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-ground", 17, false);
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-ground", 18, false);
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-ground", 19, false);//Angels
			CloseHandle(m_hPakFile);
		}
		MakeSprite("item-dynamic", DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT, 3, false);// Snoopy 2-> 3 (flags)
		m_cLoading = 16;
	}
	break;
	case 16:
	{
		m_hPakFile = CreateFile("sprites\\item-equipM.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 0, false);	// body
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 1, false);	// 1-swords
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 2, false);	// 2-bows
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 3, false);	// 3-shields
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 4, false);	// 4-tunics
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 5, false);	// 5-shoes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 6, false);	// 6-berk
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 8] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 7, false);	// 7-hoses
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 9] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 8, false);	// 8-bodyarmor
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 15] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 11, false); // Axe hammer
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 17] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 12, false); // Wands
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 9, false);  // hair
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 10, false); // undies
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 13, false); // capes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipM", 14, false); // helm
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 16] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 15); // Necks
			//Snoopy: Angels pandents
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 19); // Angels
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-equipW.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 0, false); // body
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 41] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 1, false); // 1-swords
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 42] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 2, false); // 2-bows
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 43] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 3, false); // 3-shields
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 45] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 4, false); // 4-shoes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 50] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 5, false); // 5-Soustif
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 51] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 6, false); // 6 berk
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 52] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 7, false); // 7 hose
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 53] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 8, false); // 8-hoses
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 55] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 11, false); // Axe hammer
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 57] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 12, false); // Wands
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 58] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 9, false); // hair
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 59] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 10, false);// undies
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 60] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 13, false);// capes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 61] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-equipW", 14, false);// helm
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 56] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 15);// necks
			//Snoopy: Angels pandents
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 62] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "item-pack", 19); // Angels
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Bm", 500 + 15 * 8 * 0, 96, true);// Black Man (Type: 1)
		MakeSprite("Wm", 500 + 15 * 8 * 1, 96, true);// White Man (Type: 2)
		MakeSprite("Ym", 500 + 15 * 8 * 2, 96, true);// Yellow Man (Type: 3)
		m_cLoading = 20;
	}
	break;
	case 20:
	{
		MakeSprite("TutelarAngel1", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 0, 48, false);//(STR)
		MakeSprite("TutelarAngel2", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 1, 48, false);//(DEX)
		MakeSprite("TutelarAngel3", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 2, 48, false);//(INT)
		MakeSprite("TutelarAngel4", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 3, 48, false);//(MAG)
		MakeSprite("Bw", 500 + 15 * 8 * 3, 96, true);// Black Woman (Type: 4)
		MakeSprite("Ww", 500 + 15 * 8 * 4, 96, true);// White Woman (Type: 5)
		MakeSprite("Yw", 500 + 15 * 8 * 5, 96, true);// Yellow Woman (Type: 6)
		m_cLoading = 24;
	}
	break;
	case 24:
	{
		MakeSprite("slm", DEF_SPRID_MOB + 7 * 8 * 0, 40, true);// Slime (Type: 10)
		MakeSprite("ske", DEF_SPRID_MOB + 7 * 8 * 1, 40, true);// Skeleton (Type: 11)
		MakeSprite("Gol", DEF_SPRID_MOB + 7 * 8 * 2, 40, true);// Stone-Golem (Type: 12)
		MakeSprite("Cyc", DEF_SPRID_MOB + 7 * 8 * 3, 40, true);// Cyclops (Type: 13)
		MakeSprite("Orc", DEF_SPRID_MOB + 7 * 8 * 4, 40, true);// Orc (Type: 14)
		MakeSprite("Shopkpr", DEF_SPRID_MOB + 7 * 8 * 5, 8);		// ShopKeeper-Woman (Type: 15)
		MakeSprite("Ant", DEF_SPRID_MOB + 7 * 8 * 6, 40, true);//  Giant-Ant (Type: 16)
		MakeSprite("Scp", DEF_SPRID_MOB + 7 * 8 * 7, 40, true);//  Scorpion (Type: 17)
		MakeSprite("Zom", DEF_SPRID_MOB + 7 * 8 * 8, 40, true);//  Zombie (Type: 18)
		MakeSprite("Gandlf", DEF_SPRID_MOB + 7 * 8 * 9, 8, true);// Gandalf � (Type: 19)
		MakeSprite("Howard", DEF_SPRID_MOB + 7 * 8 * 10, 8, true);// Howard ������ ���� (Type: 20)
		MakeSprite("Guard", DEF_SPRID_MOB + 7 * 8 * 11, 40, true);// Guard (Type: 21)
		MakeSprite("Amp", DEF_SPRID_MOB + 7 * 8 * 12, 40, true);// Amphis (Type: 22)
		MakeSprite("Cla", DEF_SPRID_MOB + 7 * 8 * 13, 40, true);// Clay-Golem (Type: 23)
		MakeSprite("tom", DEF_SPRID_MOB + 7 * 8 * 14, 8, true);// Tom (Type: 24)
		MakeSprite("William", DEF_SPRID_MOB + 7 * 8 * 15, 8, true);// William (Type: 25)
		m_cLoading = 28;
	}
	break;
	case 28:
	{
		MakeSprite("Kennedy", DEF_SPRID_MOB + 7 * 8 * 16, 8, true);// Kennedy (Type: 26)
		MakeSprite("Helb", DEF_SPRID_MOB + 7 * 8 * 17, 40, true);// Hellbound (Type: 27)
		MakeSprite("Troll", DEF_SPRID_MOB + 7 * 8 * 18, 40, true);// Troll (Type: 28)
		MakeSprite("Orge", DEF_SPRID_MOB + 7 * 8 * 19, 40, true);// Orge (Type: 29)
		MakeSprite("Liche", DEF_SPRID_MOB + 7 * 8 * 20, 40, true);// Liche (Type: 30)
		MakeSprite("Demon", DEF_SPRID_MOB + 7 * 8 * 21, 40, true);// Demon (Type: 31)
		MakeSprite("Unicorn", DEF_SPRID_MOB + 7 * 8 * 22, 40, true);// Unicorn (Type: 32)
		MakeSprite("WereWolf", DEF_SPRID_MOB + 7 * 8 * 23, 40, true);// WereWolf (Type: 33)
		MakeSprite("Dummy", DEF_SPRID_MOB + 7 * 8 * 24, 40, true);// Dummy (Type: 34)
		m_hPakFile = CreateFile("sprites\\Effect5.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); // Energy-Ball (Type: 35)
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 40; i++)
				m_pSprite[DEF_SPRID_MOB + i + 7 * 8 * 25] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Effect5", 0, true);

			CloseHandle(m_hPakFile);
		}
		m_cLoading = 32;
	}
	break;
	case 32:
	{
		MakeSprite("GT-Arrow", DEF_SPRID_MOB + 7 * 8 * 26, 40, true);// Arrow-GuardTower (Type: 36)
		MakeSprite("GT-Cannon", DEF_SPRID_MOB + 7 * 8 * 27, 40, true);// Cannon-GuardTower (Type: 37)
		MakeSprite("ManaCollector", DEF_SPRID_MOB + 7 * 8 * 28, 40, true);// Mana Collector (Type: 38)
		MakeSprite("Detector", DEF_SPRID_MOB + 7 * 8 * 29, 40, true);// Detector (Type: 39)
		MakeSprite("ESG", DEF_SPRID_MOB + 7 * 8 * 30, 40, true);// ESG (Type: 40)
		MakeSprite("GMG", DEF_SPRID_MOB + 7 * 8 * 31, 40, true);// GMG (Type: 41)
		MakeSprite("ManaStone", DEF_SPRID_MOB + 7 * 8 * 32, 40, true);// ManaStone (Type: 42)
		MakeSprite("LWB", DEF_SPRID_MOB + 7 * 8 * 33, 40, true);// Light War Beetle (Type: 43)
		MakeSprite("GHK", DEF_SPRID_MOB + 7 * 8 * 34, 40, true);// God's Hand Knight (Type: 44)
		MakeSprite("GHKABS", DEF_SPRID_MOB + 7 * 8 * 35, 40, true);// God's Hand Knight with Armored Battle Steed (Type: 45)
		MakeSprite("TK", DEF_SPRID_MOB + 7 * 8 * 36, 40, true);// Temple Knight (Type: 46)
		MakeSprite("BG", DEF_SPRID_MOB + 7 * 8 * 37, 40, true);// Battle Golem (Type: 47)
		m_cLoading = 36;
	}
	break;
	case 36:
	{
		MakeSprite("Stalker", DEF_SPRID_MOB + 7 * 8 * 38, 40, true);// Stalker (Type: 48)
		MakeSprite("Hellclaw", DEF_SPRID_MOB + 7 * 8 * 39, 40, true);// Hellclaw (Type: 49)
		MakeSprite("Tigerworm", DEF_SPRID_MOB + 7 * 8 * 40, 40, true);// Tigerworm (Type: 50)
		MakeSprite("Catapult", DEF_SPRID_MOB + 7 * 8 * 41, 40, true);// Catapult (Type: 51)
		MakeSprite("Gagoyle", DEF_SPRID_MOB + 7 * 8 * 42, 40, true);// Gargoyle (Type: 52)
		MakeSprite("Beholder", DEF_SPRID_MOB + 7 * 8 * 43, 40, true);// Beholder (Type: 53)
		MakeSprite("DarkElf", DEF_SPRID_MOB + 7 * 8 * 44, 40, true);// Dark-Elf (Type: 54)
		MakeSprite("Bunny", DEF_SPRID_MOB + 7 * 8 * 45, 40, true);// Bunny (Type: 55)
		MakeSprite("Cat", DEF_SPRID_MOB + 7 * 8 * 46, 40, true);// Cat (Type: 56)
		MakeSprite("GiantFrog", DEF_SPRID_MOB + 7 * 8 * 47, 40, true);// GiantFrog (Type: 57)
		MakeSprite("MTGiant", DEF_SPRID_MOB + 7 * 8 * 48, 40, true);// Mountain Giant (Type: 58)
		m_cLoading = 40;
	}
	break;
	case 40:
	{
		MakeSprite("Ettin", DEF_SPRID_MOB + 7 * 8 * 49, 40, true);// Ettin (Type: 59)
		MakeSprite("CanPlant", DEF_SPRID_MOB + 7 * 8 * 50, 40, true);// Cannibal Plant (Type: 60)
		MakeSprite("Rudolph", DEF_SPRID_MOB + 7 * 8 * 51, 40, true);// Rudolph (Type: 61)
		MakeSprite("DireBoar", DEF_SPRID_MOB + 7 * 8 * 52, 40, true);// Boar (Type: 62)
		MakeSprite("frost", DEF_SPRID_MOB + 7 * 8 * 53, 40, true);// Frost (Type: 63)
		MakeSprite("Crop", DEF_SPRID_MOB + 7 * 8 * 54, 40, true);// Crop(Type: 64)
		MakeSprite("IceGolem", DEF_SPRID_MOB + 7 * 8 * 55, 40, true);// IceGolem (Type: 65)
		MakeSprite("Wyvern", DEF_SPRID_MOB + 7 * 8 * 56, 24, true);// Wyvern (Type: 66)
		MakeSprite("McGaffin", DEF_SPRID_MOB + 7 * 8 * 57, 16, true);// McGaffin (Type: 67)
		MakeSprite("Perry", DEF_SPRID_MOB + 7 * 8 * 58, 16, true);// Perry (Type: 68)
		MakeSprite("Devlin", DEF_SPRID_MOB + 7 * 8 * 59, 16, true);// Devlin (Type: 69)
		MakeSprite("Barlog", DEF_SPRID_MOB + 7 * 8 * 60, 40, true);// Barlog (Type: 70)
		MakeSprite("Centaurus", DEF_SPRID_MOB + 7 * 8 * 61, 40, true);// Centaurus (Type: 71)
		MakeSprite("ClawTurtle", DEF_SPRID_MOB + 7 * 8 * 62, 40, true);// Claw-Turtle (Type: 72)
		MakeSprite("FireWyvern", DEF_SPRID_MOB + 7 * 8 * 63, 24, true);// Fire-Wyvern (Type: 73)
		MakeSprite("GiantCrayfish", DEF_SPRID_MOB + 7 * 8 * 64, 40, true);// Giant-Crayfish (Type: 74)
		MakeSprite("GiantLizard", DEF_SPRID_MOB + 7 * 8 * 65, 40, true);// Giant-Lizard (Type: 75)
		m_cLoading = 44;
	}
	break;
	case 44:
	{	// New NPCs - Diuuude - fixed by Snoopy
		MakeSprite("GiantPlant", DEF_SPRID_MOB + 7 * 8 * 66, 40, true);// Giant-Plant (Type: 76)
		MakeSprite("MasterMageOrc", DEF_SPRID_MOB + 7 * 8 * 67, 40, true);// MasterMage-Orc (Type: 77)
		MakeSprite("Minotaurs", DEF_SPRID_MOB + 7 * 8 * 68, 40, true);// Minotaurs (Type: 78)
		MakeSprite("Nizie", DEF_SPRID_MOB + 7 * 8 * 69, 40, true);// Nizie (Type: 79)
		MakeSprite("Tentocle", DEF_SPRID_MOB + 7 * 8 * 70, 40, true);// Tentocle (Type: 80)
		MakeSprite("yspro", DEF_SPRID_MOB + 7 * 8 * 71, 32, true);// Abaddon (Type: 81)
		MakeSprite("Sorceress", DEF_SPRID_MOB + 7 * 8 * 72, 40, true);// Sorceress (Type: 82)
		MakeSprite("TPKnight", DEF_SPRID_MOB + 7 * 8 * 73, 40, true);// TPKnight (Type: 83)
		MakeSprite("ElfMaster", DEF_SPRID_MOB + 7 * 8 * 74, 40, true);// ElfMaster (Type: 84)
		MakeSprite("DarkKnight", DEF_SPRID_MOB + 7 * 8 * 75, 40, true);// DarkKnight (Type: 85)
		MakeSprite("HBTank", DEF_SPRID_MOB + 7 * 8 * 76, 32, true);// HeavyBattleTank (Type: 86)
		MakeSprite("CBTurret", DEF_SPRID_MOB + 7 * 8 * 77, 32, true);// CBTurret (Type: 87)
		MakeSprite("Babarian", DEF_SPRID_MOB + 7 * 8 * 78, 40, true);// Babarian (Type: 88)
		MakeSprite("ACannon", DEF_SPRID_MOB + 7 * 8 * 79, 32, true);// ACannon (Type: 89)
		m_cLoading = 48;
	}
	break;
	case 48:
	{
		MakeSprite("Gail", DEF_SPRID_MOB + 7 * 8 * 80, 8, true); // Gail (Type: 90)
		MakeSprite("Gate", DEF_SPRID_MOB + 7 * 8 * 81, 24, true);// Heldenian Gate (Type: 91)/**/
		m_hPakFile = CreateFile("sprites\\Mpt.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 0] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 1, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mpt", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 52;
	}
	break;

	case 52:
	{
		m_hPakFile = CreateFile("sprites\\Mhr.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 0] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 1, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mhr", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("MLArmor", DEF_SPRID_BODYARMOR_M + 15 * 1, 12, true);
		MakeSprite("MCMail", DEF_SPRID_BODYARMOR_M + 15 * 2, 12, true);
		MakeSprite("MSMail", DEF_SPRID_BODYARMOR_M + 15 * 3, 12, true);
		MakeSprite("MPMail", DEF_SPRID_BODYARMOR_M + 15 * 4, 12, true);
		MakeSprite("Mtunic", DEF_SPRID_BODYARMOR_M + 15 * 5, 12, true);
		MakeSprite("MRobe1", DEF_SPRID_BODYARMOR_M + 15 * 6, 12, true);
		MakeSprite("MSanta", DEF_SPRID_BODYARMOR_M + 15 * 7, 12, true);
		MakeSprite("MHRobe1", DEF_SPRID_BODYARMOR_M + 15 * 10, 12, true); //hero
		MakeSprite("MHRobe2", DEF_SPRID_BODYARMOR_M + 15 * 11, 12, true); //hero
		MakeSprite("MHPMail1", DEF_SPRID_BODYARMOR_M + 15 * 8, 12, true); //hero
		MakeSprite("MHPMail2", DEF_SPRID_BODYARMOR_M + 15 * 9, 12, true); //hero
		MakeSprite("MShirt", DEF_SPRID_BERK_M + 15 * 1, 12, true);
		MakeSprite("MHauberk", DEF_SPRID_BERK_M + 15 * 2, 12, true);
		MakeSprite("MHHauberk1", DEF_SPRID_BERK_M + 15 * 3, 12, true);
		MakeSprite("MHHauberk2", DEF_SPRID_BERK_M + 15 * 4, 12, true);
		m_cLoading = 56;
	}
	break;
	case 56:
	{
		MakeSprite("MTrouser", DEF_SPRID_LEGG_M + 15 * 1, 12, true);
		MakeSprite("MHTrouser", DEF_SPRID_LEGG_M + 15 * 2, 12, true);
		MakeSprite("MCHoses", DEF_SPRID_LEGG_M + 15 * 3, 12, true);
		MakeSprite("MLeggings", DEF_SPRID_LEGG_M + 15 * 4, 12, true);
		MakeSprite("MHLeggings1", DEF_SPRID_LEGG_M + 15 * 5, 12, true); // hero
		MakeSprite("MHLeggings2", DEF_SPRID_LEGG_M + 15 * 6, 12, true); // hero
		MakeSprite("MShoes", DEF_SPRID_BOOT_M + 15 * 1, 12, true);
		MakeSprite("MLBoots", DEF_SPRID_BOOT_M + 15 * 2, 12, true);
		m_hPakFile = CreateFile("sprites\\Msw.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 0, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 1, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 2, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 3, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 5, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 6, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 8] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 7, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 9] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 8, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 10] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 9, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 11] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 10, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 12] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msw", i + 56 * 11, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 60;
	}
	break;
	case 60:
	{
		MakeSprite("Mswx", DEF_SPRID_WEAPON_M + 64 * 5, 56, true);
		MakeSprite("Msw2", DEF_SPRID_WEAPON_M + 64 * 13, 56, true);
		MakeSprite("Msw3", DEF_SPRID_WEAPON_M + 64 * 14, 56, true);
		MakeSprite("MStormBringer", DEF_SPRID_WEAPON_M + 64 * 15, 56, true);
		MakeSprite("MDarkExec", DEF_SPRID_WEAPON_M + 64 * 16, 56, true);
		MakeSprite("MKlonessBlade", DEF_SPRID_WEAPON_M + 64 * 17, 56, true);
		MakeSprite("MKlonessAstock", DEF_SPRID_WEAPON_M + 64 * 18, 56, true);
		MakeSprite("MDebastator", DEF_SPRID_WEAPON_M + 64 * 19, 56, true);
		MakeSprite("MAxe1", DEF_SPRID_WEAPON_M + 64 * 20, 56, true);// Axe
		MakeSprite("MAxe2", DEF_SPRID_WEAPON_M + 64 * 21, 56, true);
		MakeSprite("MAxe3", DEF_SPRID_WEAPON_M + 64 * 22, 56, true);
		MakeSprite("MAxe4", DEF_SPRID_WEAPON_M + 64 * 23, 56, true);
		MakeSprite("MAxe5", DEF_SPRID_WEAPON_M + 64 * 24, 56, true);
		MakeSprite("MPickAxe1", DEF_SPRID_WEAPON_M + 64 * 25, 56, true);
		MakeSprite("MAxe6", DEF_SPRID_WEAPON_M + 64 * 26, 56, true);
		MakeSprite("Mhoe", DEF_SPRID_WEAPON_M + 64 * 27, 56, true);
		MakeSprite("MKlonessAxe", DEF_SPRID_WEAPON_M + 64 * 28, 56, true);
		MakeSprite("MLightBlade", DEF_SPRID_WEAPON_M + 64 * 29, 56, true);
		m_cLoading = 64;
	}
	break;
	case 64:
	{
		MakeSprite("MHammer", DEF_SPRID_WEAPON_M + 64 * 30, 56, true);
		MakeSprite("MBHammer", DEF_SPRID_WEAPON_M + 64 * 31, 56, true);
		MakeSprite("MBabHammer", DEF_SPRID_WEAPON_M + 64 * 32, 56, true);
		MakeSprite("MBShadowSword", DEF_SPRID_WEAPON_M + 64 * 33, 56, true);
		MakeSprite("MBerserkWand", DEF_SPRID_WEAPON_M + 64 * 34, 56, true);
		MakeSprite("Mstaff1", DEF_SPRID_WEAPON_M + 64 * 35, 56, true);// Staff
		MakeSprite("Mstaff2", DEF_SPRID_WEAPON_M + 64 * 36, 56, true);
		MakeSprite("MStaff3", DEF_SPRID_WEAPON_M + 64 * 37, 56, true);
		MakeSprite("MReMagicWand", DEF_SPRID_WEAPON_M + 64 * 38, 56, true);
		MakeSprite("MKlonessWand", DEF_SPRID_WEAPON_M + 64 * 39, 56, true);
		// Bows 40 41 below
		MakeSprite("MDirectBow", DEF_SPRID_WEAPON_M + 64 * 42, 56, true);
		MakeSprite("MFireBow", DEF_SPRID_WEAPON_M + 64 * 43, 56, true);
		m_cLoading = 68;
	}
	break;
	case 68:
	{
		MakeSprite("Mbo", DEF_SPRID_WEAPON_M + 64 * 40, 56, true);
		m_hPakFile = CreateFile("sprites\\Mbo.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 41] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Mbo", i + 56 * 1, true);
			CloseHandle(m_hPakFile);
		}
		m_hPakFile = CreateFile("sprites\\Msh.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 0, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 1, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 2, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 3, true);
			for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 4, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 5, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 6, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 8] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 7, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 9] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Msh", i + 7 * 8, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 72;
	}
	break;
	case 72:
	{
		MakeSprite("Mmantle01", DEF_SPRID_MANTLE_M + 15 * 1, 12, true);
		MakeSprite("Mmantle02", DEF_SPRID_MANTLE_M + 15 * 2, 12, true);
		MakeSprite("Mmantle03", DEF_SPRID_MANTLE_M + 15 * 3, 12, true);
		MakeSprite("Mmantle04", DEF_SPRID_MANTLE_M + 15 * 4, 12, true);
		MakeSprite("Mmantle05", DEF_SPRID_MANTLE_M + 15 * 5, 12, true);
		MakeSprite("Mmantle06", DEF_SPRID_MANTLE_M + 15 * 6, 12, true);
		MakeSprite("MHelm1", DEF_SPRID_HEAD_M + 15 * 1, 12, true);
		MakeSprite("MHelm2", DEF_SPRID_HEAD_M + 15 * 2, 12, true);
		MakeSprite("MHelm3", DEF_SPRID_HEAD_M + 15 * 3, 12, true);
		MakeSprite("MHelm4", DEF_SPRID_HEAD_M + 15 * 4, 12, true);
		MakeSprite("MHCap1", DEF_SPRID_HEAD_M + 15 * 11, 12, true);
		MakeSprite("MHCap2", DEF_SPRID_HEAD_M + 15 * 12, 12, true);
		MakeSprite("MHHelm1", DEF_SPRID_HEAD_M + 15 * 9, 12, true);
		MakeSprite("MHHelm2", DEF_SPRID_HEAD_M + 15 * 10, 12, true);
		MakeSprite("NMHelm1", DEF_SPRID_HEAD_M + 15 * 5, 12, true);
		MakeSprite("NMHelm2", DEF_SPRID_HEAD_M + 15 * 6, 12, true);
		MakeSprite("NMHelm3", DEF_SPRID_HEAD_M + 15 * 7, 12, true);
		MakeSprite("NMHelm4", DEF_SPRID_HEAD_M + 15 * 8, 12, true);
		m_cLoading = 76;
	}
	break;
	case 76:
	{
		m_hPakFile = CreateFile("sprites\\Wpt.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 0] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wpt", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\Whr.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 0] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Whr", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 80;
	}
	break;
	case 80:
	{
		MakeSprite("WBodice1", DEF_SPRID_BODYARMOR_W + 15 * 1, 12, true);
		MakeSprite("WBodice2", DEF_SPRID_BODYARMOR_W + 15 * 2, 12, true);
		MakeSprite("WLArmor", DEF_SPRID_BODYARMOR_W + 15 * 3, 12, true);
		MakeSprite("WCMail", DEF_SPRID_BODYARMOR_W + 15 * 4, 12, true);
		MakeSprite("WSMail", DEF_SPRID_BODYARMOR_W + 15 * 5, 12, true);
		MakeSprite("WPMail", DEF_SPRID_BODYARMOR_W + 15 * 6, 12, true);
		MakeSprite("WRobe1", DEF_SPRID_BODYARMOR_W + 15 * 7, 12, true);
		MakeSprite("WSanta", DEF_SPRID_BODYARMOR_W + 15 * 8, 12, true);
		MakeSprite("WHRobe1", DEF_SPRID_BODYARMOR_W + 15 * 11, 12, true); // hero
		MakeSprite("WHRobe2", DEF_SPRID_BODYARMOR_W + 15 * 12, 12, true); // hero
		MakeSprite("WHPMail1", DEF_SPRID_BODYARMOR_W + 15 * 9, 12, true); //hero
		MakeSprite("WHPMail2", DEF_SPRID_BODYARMOR_W + 15 * 10, 12, true); //hero
		MakeSprite("WChemiss", DEF_SPRID_BERK_W + 15 * 1, 12, true);
		MakeSprite("WShirt", DEF_SPRID_BERK_W + 15 * 2, 12, true);
		MakeSprite("WHauberk", DEF_SPRID_BERK_W + 15 * 3, 12, true);
		MakeSprite("WHHauberk1", DEF_SPRID_BERK_W + 15 * 4, 12, true);
		MakeSprite("WHHauberk2", DEF_SPRID_BERK_W + 15 * 5, 12, true);
		MakeSprite("WSkirt", DEF_SPRID_LEGG_W + 15 * 1, 12, true);
		MakeSprite("WTrouser", DEF_SPRID_LEGG_W + 15 * 2, 12, true);
		MakeSprite("WHTrouser", DEF_SPRID_LEGG_W + 15 * 3, 12, true);
		MakeSprite("WHLeggings1", DEF_SPRID_LEGG_W + 15 * 6, 12, true);
		MakeSprite("WHLeggings2", DEF_SPRID_LEGG_W + 15 * 7, 12, true);
		MakeSprite("WCHoses", DEF_SPRID_LEGG_W + 15 * 4, 12, true);
		MakeSprite("WLeggings", DEF_SPRID_LEGG_W + 15 * 5, 12, true);
		MakeSprite("WShoes", DEF_SPRID_BOOT_W + 15 * 1, 12, true);
		MakeSprite("WLBoots", DEF_SPRID_BOOT_W + 15 * 2, 12, true);
		m_cLoading = 84;
	}
	break;
	case 84:
	{
		m_hPakFile = CreateFile("sprites\\Wsw.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 0, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 1, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 2, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 3, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 5, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 6, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 8] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 7, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 9] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 8, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 10] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 9, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 11] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 10, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 12] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsw", i + 56 * 11, true);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Wswx", DEF_SPRID_WEAPON_W + 64 * 5, 56, true);
		MakeSprite("Wsw2", DEF_SPRID_WEAPON_W + 64 * 13, 56, true);
		MakeSprite("Wsw3", DEF_SPRID_WEAPON_W + 64 * 14, 56, true); // TheVampire
		MakeSprite("WStormBringer", DEF_SPRID_WEAPON_W + 64 * 15, 56, true);
		MakeSprite("WDarkExec", DEF_SPRID_WEAPON_W + 64 * 16, 56, true);
		MakeSprite("WKlonessBlade", DEF_SPRID_WEAPON_W + 64 * 17, 56, true);
		MakeSprite("WKlonessAstock", DEF_SPRID_WEAPON_W + 64 * 18, 56, true);
		MakeSprite("WDebastator", DEF_SPRID_WEAPON_W + 64 * 19, 56, true);
		m_cLoading = 88;
	}
	break;
	case 88:
	{
		MakeSprite("WAxe1", DEF_SPRID_WEAPON_W + 64 * 20, 56, true);// Axe
		MakeSprite("WAxe2", DEF_SPRID_WEAPON_W + 64 * 21, 56, true);
		MakeSprite("WAxe3", DEF_SPRID_WEAPON_W + 64 * 22, 56, true);
		MakeSprite("WAxe4", DEF_SPRID_WEAPON_W + 64 * 23, 56, true);
		MakeSprite("WAxe5", DEF_SPRID_WEAPON_W + 64 * 24, 56, true);
		MakeSprite("WpickAxe1", DEF_SPRID_WEAPON_W + 64 * 25, 56, true);
		MakeSprite("WAxe6", DEF_SPRID_WEAPON_W + 64 * 26, 56, true);
		MakeSprite("Whoe", DEF_SPRID_WEAPON_W + 64 * 27, 56, true);
		MakeSprite("WKlonessAxe", DEF_SPRID_WEAPON_W + 64 * 28, 56, true);
		MakeSprite("WLightBlade", DEF_SPRID_WEAPON_W + 64 * 29, 56, true);
		MakeSprite("WHammer", DEF_SPRID_WEAPON_W + 64 * 30, 56, true);
		MakeSprite("WBHammer", DEF_SPRID_WEAPON_W + 64 * 31, 56, true);
		MakeSprite("WBabHammer", DEF_SPRID_WEAPON_W + 64 * 32, 56, true);
		MakeSprite("WBShadowSword", DEF_SPRID_WEAPON_W + 64 * 33, 56, true);
		MakeSprite("WBerserkWand", DEF_SPRID_WEAPON_W + 64 * 34, 56, true);
		MakeSprite("Wstaff1", DEF_SPRID_WEAPON_W + 64 * 35, 56, true);// Staff
		MakeSprite("Wstaff2", DEF_SPRID_WEAPON_W + 64 * 36, 56, true);
		MakeSprite("WStaff3", DEF_SPRID_WEAPON_W + 64 * 37, 56, true);
		MakeSprite("WKlonessWand", DEF_SPRID_WEAPON_W + 64 * 39, 56, true);
		MakeSprite("WReMagicWand", DEF_SPRID_WEAPON_W + 64 * 38, 56, true);
		// bows 40 41 below
		MakeSprite("WDirectBow", DEF_SPRID_WEAPON_W + 64 * 42, 56, true);
		MakeSprite("WFireBow", DEF_SPRID_WEAPON_W + 64 * 43, 56, true);
		m_cLoading = 92;
	}
	break;
	case 92:
	{
		MakeSprite("Wmantle01", DEF_SPRID_MANTLE_W + 15 * 1, 12, true);
		MakeSprite("Wmantle02", DEF_SPRID_MANTLE_W + 15 * 2, 12, true);
		MakeSprite("Wmantle03", DEF_SPRID_MANTLE_W + 15 * 3, 12, true);
		MakeSprite("Wmantle04", DEF_SPRID_MANTLE_W + 15 * 4, 12, true);
		MakeSprite("Wmantle05", DEF_SPRID_MANTLE_W + 15 * 5, 12, true);
		MakeSprite("Wmantle06", DEF_SPRID_MANTLE_W + 15 * 6, 12, true);
		MakeSprite("WHelm1", DEF_SPRID_HEAD_W + 15 * 1, 12, true);
		MakeSprite("WHelm4", DEF_SPRID_HEAD_W + 15 * 4, 12, true);
		MakeSprite("WHHelm1", DEF_SPRID_HEAD_W + 15 * 9, 12, true);
		MakeSprite("WHHelm2", DEF_SPRID_HEAD_W + 15 * 10, 12, true);
		MakeSprite("WHCap1", DEF_SPRID_HEAD_W + 15 * 11, 12, true);
		MakeSprite("WHCap2", DEF_SPRID_HEAD_W + 15 * 12, 12, true);
		MakeSprite("NWHelm1", DEF_SPRID_HEAD_W + 15 * 5, 12, true);
		MakeSprite("NWHelm2", DEF_SPRID_HEAD_W + 15 * 6, 12, true);
		MakeSprite("NWHelm3", DEF_SPRID_HEAD_W + 15 * 7, 12, true);
		MakeSprite("NWHelm4", DEF_SPRID_HEAD_W + 15 * 8, 12, true);
		m_cLoading = 96;
	}
	break;
	case 96:
	{
		MakeSprite("Wbo", DEF_SPRID_WEAPON_W + 64 * 40, 56, true);// Bow
		m_hPakFile = CreateFile("sprites\\Wbo.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 41] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wbo", i + 56 * 1, true);
			CloseHandle(m_hPakFile);
		}
		m_hPakFile = CreateFile("sprites\\Wsh.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 1] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 0, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 2] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 1, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 3] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 2, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 4] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 3, true);
			for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 5] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 4, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 6] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 5, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 7] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 6, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 8] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 7, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 9] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "Wsh", i + 7 * 8, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 100;
	}
	break;
	case 100:
	{
		MakeEffectSpr("effect", 0, 10, false);
		MakeEffectSpr("effect2", 10, 3, false);
		MakeEffectSpr("effect3", 13, 6, false);
		MakeEffectSpr("effect4", 19, 5, false);
		m_hPakFile = CreateFile("sprites\\effect5.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i <= 6; i++) // Because effectn�0 is EnergySphere
				m_pEffectSpr[i + 24] = new class CSprite(m_hPakFile, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer()), "effect5", i + 1, false);
			CloseHandle(m_hPakFile);
		}
		MakeEffectSpr("CruEffect1", 31, 9, false);
		MakeEffectSpr("effect6", 40, 5, false);
		MakeEffectSpr("effect7", 45, 12, false);
		MakeEffectSpr("effect8", 57, 9, false);
		MakeEffectSpr("effect9", 66, 21, false);

		MakeEffectSpr("effect10", 87, 2, false); // Effets Hero items
		MakeEffectSpr("effect11", 89, 14, false); // Cancel, stormBlade, resu, GateHeldenian....etc
		//NB: Charge 15 du client 3.51, mais il n'y a que 14 ds le PAK
		MakeEffectSpr("effect11s", 104, 1, false); // effet sort mais je ne sais pas lequel
		// Manque des effets ici .....
		// MakeEffectSpr( "effect13", 108, 2, false); // not loaded by client 351 (Heldenian gates death)
		//MakeEffectSpr( "yseffect2", 141, 8, false); // Wrong in 351 client...
		MakeEffectSpr("yseffect2", 140, 8, false); // Abaddon's death
		MakeEffectSpr("effect12", 148, 4, false); // Slates auras
		MakeEffectSpr("yseffect3", 152, 16, false); // Fumerolles ou ame qui s'envole
		//MakeEffectSpr( "yseffect4", 167, 7, false); // Wrong in 351 client
		MakeEffectSpr("yseffect4", 133, 7, false); // Abaddon's map thunder.

		// Initialize EffectManager with loaded sprites
		m_pEffectManager->SetEffectSprites(m_pEffectSpr);

		// Pre-load all sound effects into memory
		AudioManager::Get().LoadSounds();

		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
	break;
	}
}
/*********************************************************************************************************************
** 	void CGame::UpdateScreen_OnLoading_Progress()																	**
**  description			:: loading becomes progressbar																**
**********************************************************************************************************************/
void CGame::UpdateScreen_OnLoading_Progress()
{
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOADING, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawVersion();
	int iBarWidth;
	iBarWidth = (int)m_cLoading;
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING]->DrawWidth(472 + SCREENX, 442 + SCREENY, 1, iBarWidth);
}

void CGame::OnTimer()
{
	if (m_cGameMode < 0) return;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameMode != DEF_GAMEMODE_ONLOADING) {
		if ((dwTime - m_dwCheckSprTime) > 8000)
		{
			m_dwCheckSprTime = dwTime;
			if (m_bIsProgramActive) ReleaseUnusedSprites();
		}
		if ((dwTime - m_dwCheckConnectionTime) > 1000)
		{
			m_dwCheckConnectionTime = dwTime;
			if ((m_pGSock != 0) && (m_pGSock->m_bIsAvailable == true))
				bSendCommand(MSGID_COMMAND_CHECKCONNECTION, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
		}
	}

	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{
		if ((dwTime - m_dwCheckConnTime) > 5000)
		{
			m_dwCheckConnTime = dwTime;
			if ((m_bIsCrusadeMode) && (m_iCrusadeDuty == 0)) m_dialogBoxManager.EnableDialogBox(DialogBoxId::CrusadeJob, 1, 0, 0);
		}

		if ((dwTime - m_dwCheckChatTime) > 2000)
		{
			m_dwCheckChatTime = m_dwTime;
			ReleaseTimeoverChatMsg();
			if (m_cCommandCount >= 6)
			{
				m_iNetLagCount++;
				if (m_iNetLagCount >= 7)
				{
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
					delete m_pGSock;
					m_pGSock = 0;
					return;
				}
			}
			else m_iNetLagCount = 0;
		}

		if ((G_bIsCalcSocketConnected == false) && ((dwTime - G_dwCalcSocketTime) > 5000))
		{
			delete m_pGSock;
			m_pGSock = 0;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			InputManager::Get().ClearEscPressed();
			PlaySound('E', 14, 5);
			AudioManager::Get().StopSound(SoundType::Effect, 38);
			AudioManager::Get().StopMusic();
			return;
		}

		if ((G_pCalcSocket != 0) && (G_bIsCalcSocketConnected == true)) {
			if ((dwTime - G_dwCalcSocketSendTime) > 1000 * 5) {
				if (memcmp(G_cCmdLineTokenA_Lowercase, "wisetop", 7) == 0)
				{
				}
				else
				{
					hb::net::PacketCalcSocketPing ping{};
					ping.key = 0;
					ping.length = static_cast<std::uint16_t>(sizeof(ping));
					ping.reserved = 0;
					G_pCalcSocket->iSendMsgBlockingMode(reinterpret_cast<char*>(&ping), sizeof(ping));
				}
				G_dwCalcSocketSendTime = dwTime;
			}
		}
	}
}


bool CGame::_bCheckDlgBoxClick(short msX, short msY)
{
	int i;
	char         cDlgID;
	InputManager::Get().ClearWheelDelta();
	// Snoopy: 41->61
	for (i = 0; i < 61; i++)
		// Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			// Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
				(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
			{
				switch (cDlgID) {
				case 1: // DialogBoxId::CharacterInfo
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CharacterInfo))
						pDlg->OnClick(msX, msY);
					break;
				case 2: // DialogBoxId::Inventory
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Inventory))
						pDlg->OnClick(msX, msY);
					break;
				case 3: // DialogBoxId::Magic
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Magic))
						pDlg->OnClick(msX, msY);
					break;
				case 4: // DialogBoxId::ItemDropConfirm
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropConfirm))
						pDlg->OnClick(msX, msY);
					break;
				case 6: // DialogBoxId::WarningBattleArea
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::WarningBattleArea))
						pDlg->OnClick(msX, msY);
					break;
				case 7: // DialogBoxId::GuildMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 8: // DialogBoxId::GuildOperation
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildOperation))
						pDlg->OnClick(msX, msY);
					break;
				case 9: // DialogBoxId::GuideMap
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuideMap))
						pDlg->OnClick(msX, msY);
					break;
				case 11: // DialogBoxId::SaleMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SaleMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 12: // DialogBoxId::LevelUpSetting
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::LevelUpSetting))
						pDlg->OnClick(msX, msY);
					break;
				case 13:
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CityHallMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 14: // DialogBoxId::Bank
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Bank))
						pDlg->OnClick(msX, msY);
					break;
				case 15: // DialogBoxId::Skill
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Skill))
						pDlg->OnClick(msX, msY);
					break;
				case 16: // DialogBoxId::MagicShop
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::MagicShop))
						pDlg->OnClick(msX, msY);
					break;
				case 18: // DialogBoxId::Text
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Text))
						pDlg->OnClick(msX, msY);
					break;
				case 19: // DialogBoxId::SystemMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SystemMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 20: // DialogBoxId::NpcActionQuery
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcActionQuery))
						pDlg->OnClick(msX, msY);
					break;
				case 21: // DialogBoxId::NpcTalk
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcTalk))
						pDlg->OnClick(msX, msY);
					break;
				case 23: // DialogBoxId::SellOrRepair
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellOrRepair))
						pDlg->OnClick(msX, msY);
					break;
				case 24: // DialogBoxId::Fishing
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Fishing))
						pDlg->OnClick(msX, msY);
					break;
				case 25: // DialogBoxId::Noticement
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Noticement))
						pDlg->OnClick(msX, msY);
					break;
				case 26: // DialogBoxId::Manufacture
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Manufacture))
						pDlg->OnClick(msX, msY);
					break;
				case 27: // DialogBoxId::Exchange
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Exchange))
						pDlg->OnClick(msX, msY);
					break;
				case 28: // DialogBoxId::Quest
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Quest))
						pDlg->OnClick(msX, msY);
					break;
				case 29: // DialogBoxId::HudPanel
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
						pDlg->OnClick(msX, msY);
					break;
				case 31: // DialogBoxId::SellList
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellList))
						pDlg->OnClick(msX, msY);
					break;
				case 32: // DialogBoxId::Party
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Party))
						pDlg->OnClick(msX, msY);
					break;
				case 33: // DialogBoxId::CrusadeJob
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeJob))
						pDlg->OnClick(msX, msY);
					break;
				case 34: // DialogBoxId::ItemUpgrade
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemUpgrade))
						pDlg->OnClick(msX, msY);
					break;
				case 35: // DialogBoxId::Help
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Help))
						pDlg->OnClick(msX, msY);
					break;

				case 36: // DialogBoxId::CrusadeCommander
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeCommander))
						pDlg->OnClick(msX, msY);
					break;

				case 37: // DialogBoxId::CrusadeConstructor
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeConstructor))
						pDlg->OnClick(msX, msY);
					break;

				case 38: // DialogBoxId::CrusadeSoldier
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeSoldier))
						pDlg->OnClick(msX, msY);
					break;

				case 40: // DialogBoxId::Slates
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Slates))
						pDlg->OnClick(msX, msY);
					break;
					// Snoopy: Boite de dialogue de confirmation d'�change
				case 41: // DialogBoxId::ConfirmExchange
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ConfirmExchange))
						pDlg->OnClick(msX, msY);
					break;
				case 42: // DialogBoxId::ChangeStatsMajestic
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ChangeStatsMajestic))
						pDlg->OnClick(msX, msY);
					break;
				case 50: // DialogBoxId::Resurrect
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Resurrect))
						pDlg->OnClick(msX, msY);
					break;
				case 51: // DialogBoxId::GuildHallMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildHallMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 52: // DialogBoxId::RepairAll
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::RepairAll))
						pDlg->OnClick(msX, msY);
					break;
				}

				return true;
			}
		}

	return false;
}

bool CGame::_bCheckDlgBoxDoubleClick(short msX, short msY)
{
	int i;
	char cDlgID;
	//	if (m_iHP <= 0) return false;
		//Snoopy: 41->61
	for (i = 0; i < 61; i++)
		//Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			//Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
				(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY)) {
				switch (cDlgID) {
				case 1:
					DlbBoxDoubleClick_Character(msX, msY);
					break;
				case 2:
					DlbBoxDoubleClick_Inventory(msX, msY);
					break;
				case 9:
					DlbBoxDoubleClick_GuideMap(msX, msY);
					break;
				}
				return true;
			}
		}
	return false;
}


bool CGame::bDlgBoxPress_Inventory(short msX, short msY)
{
	int i;
	char  cItemID;
	short sX, sY, x1, x2, y1, y2;

#ifdef _DEBUG
	AddEventList("Press Inventory", 10);
#endif

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Inventory) == false) return false;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return false;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true) return false;

	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1) {
			cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];

			if (m_pItemList[cItemID] != 0)
			{
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + 32 + m_pItemList[cItemID]->m_sX,
					sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((m_bIsItemDisabled[cItemID] == false) && (m_bIsItemEquipped[cItemID] == false) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {

					if (m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->CheckCollision(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame, msX, msY) == true)
					{
						_SetItemOrder(0, cItemID);
						if ((m_bIsGetPointingMode == true) && (m_iPointCommandType < 100) && (m_iPointCommandType >= 0)
							&& (m_pItemList[m_iPointCommandType] != 0)
							&& (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)
							&& (m_iPointCommandType != cItemID))
						{
							PointCommandHandler(0, 0, cItemID);
							//m_bCommandAvailable  = false;
							m_bIsGetPointingMode = false;
						}
						else
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
							m_stMCursor.sSelectedObjectID = cItemID;
							m_stMCursor.sDistX = msX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
							m_stMCursor.sDistY = msY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
						}
						return true;
					}
				}
			}
		}
	return false;
}

void CGame::_SetItemOrder(char cWhere, char cItemID)
{
	int i;

	switch (cWhere) {
	case 0:
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_cItemOrder[i] == cItemID)
				m_cItemOrder[i] = -1;

		for (i = 1; i < DEF_MAXITEMS; i++)
			if ((m_cItemOrder[i - 1] == -1) && (m_cItemOrder[i] != -1)) {
				m_cItemOrder[i - 1] = m_cItemOrder[i];
				m_cItemOrder[i] = -1;
			}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_cItemOrder[i] == -1) {
				m_cItemOrder[i] = cItemID;
				return;
			}
		break;
	}
}

bool CGame::_bCheckDraggingItemRelease(short msX, short msY)
{
	int i;
	char         cDlgID;
	//Snoopy: 41->61
	for (i = 0; i < 61; i++)
		//Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			//Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX)
				&& (m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
			{
				m_dialogBoxManager.EnableDialogBox(cDlgID, 0, 0, 0);
				switch (cDlgID) {
				case 1:
					bItemDrop_Character();
					break;

				case 2:
					bItemDrop_Inventory(msX, msY);
					break;

				case 14:
					bItemDrop_Bank(msX, msY);
					break;

				case 26: // Alchim / Manuf
					bItemDrop_SkillDialog();
					break;

				case 27:
					bItemDrop_ExchangeDialog(msX, msY);
					break;

				case 30:
					bItemDrop_IconPannel(msX, msY);
					break;

				case 31:
					bItemDrop_SellList(msX, msY);
					break;

				case 34:
					bItemDrop_ItemUpgrade();
					break;

				case 40:
					bItemDrop_Slates();
					break;
				}
				return true;
			}
		}
	bItemDrop_ExternalScreen((char)m_stMCursor.sSelectedObjectID, msX, msY);
	return false;
}

void CGame::bItemDrop_ExternalScreen(char cItemID, short msX, short msY)
{
	char  cName[21];
	short sType, tX, tY;
	int iStatus;

	if (bCheckItemOperationEnabled(cItemID) == false) return;

	if ((m_sMCX != 0) && (m_sMCY != 0) && (abs(m_sPlayerX - m_sMCX) <= 8) && (abs(m_sPlayerY - m_sMCY) <= 8))
	{
		std::memset(cName, 0, sizeof(cName));
		m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sType, &iStatus, &m_wCommObjectID);
		if (memcmp(m_cPlayerName, cName, 10) == 0)
		{
		}
		else
		{
			if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))
				&& (m_pItemList[cItemID]->m_dwCount > 1))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
				if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sMCX;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sMCY;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = sType;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = m_wCommObjectID;
				std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
				if (sType < 10)
					memcpy(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, cName, 10);
				else
				{
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr);
				}
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
			}
			else
			{
				switch (sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 1, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					strcpy(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, cName);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); //v1.4
					break;

				case 20: // Howard
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 3, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID; // v1.4
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;

				case 15: // ShopKeeper-W
				case 24: // Tom
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 2, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID; // v1.4
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
					break;

				default:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;
				}
				//m_bIsItemDisabled[cItemID] = true;
			}
			m_bIsItemDisabled[cItemID] = true;
		}
	}
	else
	{
		if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))
			&& (m_pItemList[cItemID]->m_dwCount > 1))
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
			if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0)		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = 0;
			std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		}
		else
		{
			if (_ItemDropHistory(m_pItemList[cItemID]->m_cName))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sX = msX - 140;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY = msY - 70;
				if (m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY < 0)	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV1 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV2 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV3 = 1;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV4 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV5 = cItemID;
				std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).cStr));
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropConfirm, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
			}
			else
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, 0, cItemID, 1, 0, m_pItemList[cItemID]->m_cName);
			}
		}
		m_bIsItemDisabled[cItemID] = true;
	}
}


void CGame::CommonEventHandler(char* pData)
{
	WORD wEventType;
	short sX, sY, sV1, sV2, sV3, sV4;
	uint32_t dwV4;

	const auto* base = hb::net::PacketCast<hb::net::PacketEventCommonBase>(pData, sizeof(hb::net::PacketEventCommonBase));
	if (!base) return;
	wEventType = base->header.msg_type;
	sX = base->x;
	sY = base->y;
	sV1 = base->v1;
	sV2 = base->v2;
	sV3 = base->v3;

	switch (wEventType) {
	case DEF_COMMONTYPE_ITEMDROP:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonItem>(pData, sizeof(hb::net::PacketEventCommonItem));
		if (!pkt) return;
		dwV4 = pkt->v4;
	}
	if ((sV1 == 6) && (sV2 == 0)) {
		m_pEffectManager->AddEffect(4, sX, sY, 0, 0, 0);
	}
	m_pMapData->bSetItem(sX, sY, sV1, (char)sV3, dwV4);
	break;

	case DEF_COMMONTYPE_SETITEM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonItem>(pData, sizeof(hb::net::PacketEventCommonItem));
		if (!pkt) return;
		dwV4 = pkt->v4;
	}
	m_pMapData->bSetItem(sX, sY, sV1, (char)sV3, dwV4, false); // v1.4 color
	break;

	case DEF_COMMONTYPE_MAGIC:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonMagic>(pData, sizeof(hb::net::PacketEventCommonMagic));
		if (!pkt) return;
		sV4 = pkt->v4;
	}
	m_pEffectManager->AddEffect(sV3, sX, sY, sV1, sV2, 0, sV4);
	break;

	case DEF_COMMONTYPE_CLEARGUILDNAME:
		ClearGuildNameList();
		break;
	}
}

void CGame::ClearGuildNameList()
{
	for (int i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}
}

void CGame::InitGameSettings()
{
	int i;

	m_bForceAttack = false;
	m_dwCommandTime = 0;
	m_dwCheckConnectionTime = 0;

	m_bInputStatus = false;
	m_pInputBuffer = 0;

	m_iPDBGSdivX = 0;
	m_iPDBGSdivY = 0;
	m_bIsRedrawPDBGS = true;

	m_iCameraShakingDegree = 0;

	m_cCommand = DEF_OBJECTSTOP;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1; //v2.15 0 -> -1

	m_bIsCombatMode = false;

	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	m_bSkillUsingStatus = false;
	m_bItemUsingStatus = false;
	m_bUsingSlate = false;

	m_bIsWhetherEffect = false;
	m_cWhetherEffectType = 0;

	m_iDownSkillIndex = -1;
	m_dialogBoxManager.Info(DialogBoxId::Skill).bFlag = false;

	m_bIsConfusion = false;

	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;

	m_iDrawFlag = 0;
	m_bSkipFrame = false;
	m_bDrawFlagDir = false;
	m_bIsCrusadeMode = false;
	m_iCrusadeDuty = 0;
	m_bIsAvatarMode = false;
	m_bIsAvatarMessenger = false;

	m_iNetLagCount = 0;
	m_iLatencyMs = -1;
	m_dwLastNetMsgId = 0;
	m_dwLastNetMsgTime = 0;
	m_dwLastNetMsgSize = 0;
	m_dwLastNetRecvTime = 0;
	m_dwLastNpcEventTime = 0;

	m_dwEnvEffectTime = GameClock::GetTimeMS();

	for (i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}
	//Snoopy: 61
	for (i = 0; i < 61; i++)
		m_dialogBoxManager.SetEnabled(i, false);

	//Snoopy: 58 because 2 last ones alreaddy defined
	for (i = 0; i < 58; i++)
		m_dialogBoxManager.SetOrderAt(i, 0);
	m_dialogBoxManager.SetOrderAt(60, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetOrderAt(59, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetEnabled(DialogBoxId::HudPanel, true);
	m_dialogBoxManager.SetEnabled(DialogBoxId::HudPanel, true);

	if (m_pEffectManager) m_pEffectManager->ClearAllEffects();

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = 0;
	}

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) {
		if (m_pChatScrollList[i] != 0) delete m_pChatScrollList[i];
		m_pChatScrollList[i] = 0;
	}

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) {
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];
		m_pWhisperMsg[i] = 0;
	}

	std::memset(m_cLocation, 0, sizeof(m_cLocation));

	std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	m_iTotalGuildsMan = 0;

	for (i = 0; i < 100; i++) {
		m_stGuildOpList[i].cOpMode = 0;
		std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
	}

	for (i = 0; i < 6; i++) {
		std::memset(m_stEventHistory[i].cTxt, 0, sizeof(m_stEventHistory[i].cTxt));
		m_stEventHistory[i].dwTime = G_dwGlobalTime;

		std::memset(m_stEventHistory2[i].cTxt, 0, sizeof(m_stEventHistory2[i].cTxt));
		m_stEventHistory2[i].dwTime = G_dwGlobalTime;
	}

	for (i = 0; i < DEF_MAXMENUITEMS; i++) {
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];
		m_pItemForSaleList[i] = 0;
	}

	for (i = 0; i < 41; i++) {
		m_dialogBoxManager.Info(i).bFlag = false;
		m_dialogBoxManager.Info(i).sView = 0;
		m_dialogBoxManager.Info(i).bIsScrollSelected = false;
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0) {
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < DEF_MAXSELLLIST; i++) {
		m_stSellItemList[i].iIndex = -1;
		m_stSellItemList[i].iAmount = 0;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0) {
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_cMagicMastery[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_cSkillMastery[i] = 0;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;

		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;

		if (m_pAgreeMsgTextList[i] != 0)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = 0;
	}

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
		m_stPartyMember[i].cStatus = 0;
		std::memset(m_stPartyMember[i].cName, 0, sizeof(m_stPartyMember[i].cName));
	}

	m_iLU_Point = 0;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
	m_cWhetherStatus = 0;
	m_cLogOutCount = -1;
	m_dwLogOutCountTime = 0;
	m_iSuperAttackLeft = 0;
	m_bSuperAttackMode = false;
	m_iFightzoneNumber = 0;
	std::memset(m_cBGMmapName, 0, sizeof(m_cBGMmapName));
	m_dwWOFtime = 0;
	m_stQuest.sWho = 0;
	m_stQuest.sQuestType = 0;
	m_stQuest.sContribution = 0;
	m_stQuest.sTargetType = 0;
	m_stQuest.sTargetCount = 0;
	m_stQuest.sCurrentCount = 0;
	m_stQuest.sX = 0;
	m_stQuest.sY = 0;
	m_stQuest.sRange = 0;
	m_stQuest.bIsQuestCompleted = false;
	std::memset(m_stQuest.cTargetName, 0, sizeof(m_stQuest.cTargetName));
	m_bIsObserverMode = false;
	m_bIsObserverCommanded = false;
	m_bIsPoisoned = false;
	m_bIsPrevMoveBlocked = false;
	m_iPrevMoveX = m_iPrevMoveY = -1;
	m_sDamageMove = 0;
	m_sDamageMoveAmount = 0;
	m_bForceDisconn = false;
	m_bIsSpecialAbilityEnabled = false;
	m_iSpecialAbilityType = 0;
	m_dwSpecialAbilitySettingTime = 0;
	m_iSpecialAbilityTimeLeftSec = 0;
	m_stMCursor.cSelectedObjectType = 0;
	m_bIsF1HelpWindowEnabled = false;
	m_bIsTeleportRequested = false;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
	{
		m_stCrusadeStructureInfo[i].cType = 0;
		m_stCrusadeStructureInfo[i].cSide = 0;
		m_stCrusadeStructureInfo[i].sX = 0;
		m_stCrusadeStructureInfo[i].sY = 0;
	}
	std::memset(m_cStatusMapName, 0, sizeof(m_cStatusMapName));
	m_dwCommanderCommandRequestedTime = 0;
	std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	m_iTopMsgLastSec = 0;
	m_dwTopMsgTime = 0;
	m_iConstructionPoint = 0;
	m_iWarContribution = 0;
	std::memset(m_cTeleportMapName, 0, sizeof(m_cTeleportMapName));
	m_iTeleportLocX = m_iTeleportLocY = -1;
	std::memset(m_cConstructMapName, 0, sizeof(m_cConstructMapName));
	m_iConstructLocX = m_iConstructLocY = -1;

	//Snoopy: Apocalypse Gate
	std::memset(m_cGateMapName, 0, sizeof(m_cGateMapName));
	m_iGatePositX = m_iGatePositY = -1;
	m_iHeldenianAresdenLeftTower = -1;
	m_iHeldenianElvineLeftTower = -1;
	m_iHeldenianAresdenFlags = -1;
	m_iHeldenianElvineFlags = -1;
	m_bIsXmas = false;
	m_iTotalPartyMember = 0;
	m_iPartyStatus = 0;
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
	m_iGizonItemUpgradeLeft = 0;
	cStateChange1 = 0;
	cStateChange2 = 0;
	cStateChange3 = 0;
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuideMap, 0, 0, 0);
}

void CGame::_GetHairColorRGB(int iColorType, int* pR, int* pG, int* pB)
{
	switch (iColorType) {
	case 0: // rouge fonc�
		*pR = 14; *pG = -5; *pB = -5; break;
	case 1: // Orange
		*pR = 20; *pG = 0; *pB = 0; break;
	case 2: // marron tres clair
		*pR = 22; *pG = 13; *pB = -10; break;
	case 3: // vert
		*pR = 0; *pG = 10; *pB = 0; break;
	case 4: // Bleu flashy
		*pR = 0; *pG = 0; *pB = 22; break;
	case 5: // Bleu fonc�
		*pR = -5; *pG = -5; *pB = 15; break;
	case 6: //Mauve
		*pR = 15; *pG = -5; *pB = 16; break;
	case 7: // Noir
		*pR = -6; *pG = -6; *pB = -6; break;
	case 8:
		*pR = 10; *pG = 3; *pB = 10; break;
	case 9:
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10:
		*pR = -10; *pG = 3; *pB = 10; break;
	case 11:
		*pR = 10; *pG = 3; *pB = 20; break;
	case 12:
		*pR = 21; *pG = 3; *pB = 3; break;
	case 13:
		*pR = 3; *pG = 3; *pB = 25; break;
	case 14:
		*pR = 3; *pG = 11; *pB = 3; break;
	case 15:
		*pR = 6; *pG = 8; *pB = 0; break;
	}
}

void CGame::CreateNewGuildResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		m_iGuildRank = 0;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 3;
		break;
	case DEF_MSGTYPE_REJECT:
		m_iGuildRank = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 4;
		break;
	}
}

void CGame::InitPlayerCharacteristics(char* pData)
{
	// Snoopy: Angels
	m_iAngelicStr = 0;
	m_iAngelicDex = 0;
	m_iAngelicInt = 0;
	m_iAngelicMag = 0;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponsePlayerCharacterContents>(
		pData, sizeof(hb::net::PacketResponsePlayerCharacterContents));
	if (!pkt) return;

	m_iHP = pkt->hp;
	m_iMP = pkt->mp;
	m_iSP = pkt->sp;
	m_iAC = pkt->ac;		//? m_iDefenseRatio
	m_iTHAC0 = pkt->thac0;    //? m_iHitRatio
	m_iLevel = pkt->level;
	m_iStr = pkt->str;
	m_iInt = pkt->intel;
	m_iVit = pkt->vit;
	m_iDex = pkt->dex;
	m_iMag = pkt->mag;
	m_iCharisma = pkt->chr;

	// CLEROTH - LU
	m_iLU_Point = pkt->lu_point - 3;

	m_iExp = pkt->exp;
	m_iEnemyKillCount = pkt->enemy_kills;
	m_iPKCount = pkt->pk_count;
	m_iRewardGold = pkt->reward_gold;

	memcpy(m_cLocation, pkt->location, sizeof(pkt->location));
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else
	{
		m_bAresden = true;
		m_bCitizen = false;
		m_bHunter = true;
	}

	memcpy(m_cGuildName, pkt->guild_name, sizeof(pkt->guild_name));

	if (strcmp(m_cGuildName, "NONE") == 0)
		std::memset(m_cGuildName, 0, sizeof(m_cGuildName));

	CMisc::ReplaceString(m_cGuildName, '_', ' ');
	m_iGuildRank = pkt->guild_rank;
	m_iSuperAttackLeft = pkt->super_attack_left;
	m_iFightzoneNumber = pkt->fightzone_number;
	iMaxStats = pkt->max_stats;
	iMaxLevel = pkt->max_level;
	iMaxBankItems = pkt->max_bank_items;
}



void CGame::DisbandGuildResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
		m_iGuildRank = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 7;
		break;
	case DEF_MSGTYPE_REJECT:
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 8;
		break;
	}
}


void CGame::_PutGuildOperationList(char* pName, char cOpMode)
{
	int i;
	for (i = 0; i < 100; i++)
		if (m_stGuildOpList[i].cOpMode == 0)
		{
			m_stGuildOpList[i].cOpMode = cOpMode;
			std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
			memcpy(m_stGuildOpList[i].cName, pName, 20);
			return;
		}
}

void CGame::_ShiftGuildOperationList()
{
	int i;
	std::memset(m_stGuildOpList[0].cName, 0, sizeof(m_stGuildOpList[0].cName));
	m_stGuildOpList[0].cOpMode = 0;

	for (i = 1; i < 100; i++)
		if ((m_stGuildOpList[i - 1].cOpMode == 0) && (m_stGuildOpList[i].cOpMode != 0)) {
			m_stGuildOpList[i - 1].cOpMode = m_stGuildOpList[i].cOpMode;
			std::memset(m_stGuildOpList[i - 1].cName, 0, sizeof(m_stGuildOpList[i - 1].cName));
			memcpy(m_stGuildOpList[i - 1].cName, m_stGuildOpList[i].cName, 20);

			std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
			m_stGuildOpList[i].cOpMode = 0;
		}
}



void CGame::AddEventList(char* pTxt, char cColor, bool bDupAllow)
{
	int i;
	if ((bDupAllow == false) && (strcmp(m_stEventHistory[5].cTxt, pTxt) == 0)) return;
	if (cColor == 10)
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory2[i - 1].cTxt, m_stEventHistory2[i].cTxt);
			m_stEventHistory2[i - 1].cColor = m_stEventHistory2[i].cColor;
			m_stEventHistory2[i - 1].dwTime = m_stEventHistory2[i].dwTime;
		}
		std::memset(m_stEventHistory2[5].cTxt, 0, sizeof(m_stEventHistory2[5].cTxt));
		strcpy(m_stEventHistory2[5].cTxt, pTxt);
		m_stEventHistory2[5].cColor = cColor;
		m_stEventHistory2[5].dwTime = m_dwCurTime;
	}
	else
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory[i - 1].cTxt, m_stEventHistory[i].cTxt);
			m_stEventHistory[i - 1].cColor = m_stEventHistory[i].cColor;
			m_stEventHistory[i - 1].dwTime = m_stEventHistory[i].dwTime;
		}
		std::memset(m_stEventHistory[5].cTxt, 0, sizeof(m_stEventHistory[5].cTxt));
		strcpy(m_stEventHistory[5].cTxt, pTxt);
		m_stEventHistory[5].cColor = cColor;
		m_stEventHistory[5].dwTime = m_dwCurTime;
	}
}

int _iAttackerHeight[] = { 0, 35, 35,35,35,35,35, 0,0,0,
5,  // Slime
35, // Skeleton
40, // Stone-Golem
45, // Cyclops
35,// OrcMage
35,// ShopKeeper
5, // GiantAnt
8, // Scorpion
35,// Zombie
35,// Gandalf
35,// Howard
35,// Guard
10,// Amphis
38,// Clay-Golem
35,// Tom
35,// William
35,// Kennedy
35,// Hellhound
50,// Troll
45,// Orge
55,// Liche
65,// Demon
46,// Unicorn
49,// WereWolf
55,// Dummy
35,// Energysphere
75,// Arrow Guard Tower
75,// Cannon Guard Tower
50,// Mana Collector
50,// Detector
50,// Energy Shield Generator
50,// Grand Magic Generator
50,// ManaStone 42
40,// Light War Beetle
35,// GHK
40,// GHKABS
35,// TK
60,// BG
40,// Stalker
70,// HellClaw
85,// Tigerworm
50,// Catapult
85,// Gargoyle
70,// Beholder
40,// Dark-Elf
20,// Bunny
20,// Cat
40,// Giant-Frog
80,// Mountain-Giant
85,// Ettin
50,// Cannibal-Plant
50, // Rudolph 61 //Snoopy....
80, // Direboar 62
90, // Frost 63
40, // Crops 64
80, // IceGolem 65
190, // Wyvern 66
35, // npc 67
35, // npc 68
35, // npc 69
100, // Dragon 70
90, // Centaur 71
75, // ClawTurtle 72
200, // FireWyvern 73
80, // GiantCrayfish 74
120, // Gi Lizard 75
100, // Gi Tree 76
100, // Master Orc 77
80, // Minaus 78
100, // Nizie 79
25,  // Tentocle 80
200, // Abaddon	 81
60, // Sorceress 82
60, // ATK 83
70, // MasterElf 84
60, // DSK 85
50, // HBT 86
60, // CT 87
60, // Barbarian 88
60, // AGC 89
35, // ncp 90 Gail
35  // Gate 91
};

void CGame::bItemDrop_IconPannel(short msX, short msY)
{
	short sX, sY, sItemIndex;
	sX = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX;	sY = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY;

	sItemIndex = m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[sItemIndex] == true) return;
	if (m_cCommand < 0) return;
	if ((453 < msX) && (486 > msX) && (440 < msY) && (475 > msY))
	{
		bItemDrop_Inventory(m_dialogBoxManager.Info(DialogBoxId::Inventory).sX + (rand() % 148), m_dialogBoxManager.Info(DialogBoxId::Inventory).sY + (rand() % 55));
		return;
	}
	if ((425 < msX) && (448 > msX) && (440 < msY) && (475 > msY))
	{
		bItemDrop_Character();
		return;
	}
}

void CGame::_LoadShopMenuContents(char cType)
{
	// Request shop contents from server using NPC type
	_RequestShopContents(static_cast<int16_t>(cType));
}

void CGame::_RequestShopContents(int16_t npcType)
{
	// Clear existing shop items
	for (int i = 0; i < DEF_MAXSELLLIST; i++) {
		if (m_pItemForSaleList[i] != nullptr) {
			delete m_pItemForSaleList[i];
			m_pItemForSaleList[i] = nullptr;
		}
	}

	// Build and send shop request packet
	char cData[sizeof(hb::net::PacketShopRequest)];
	std::memset(cData, 0, sizeof(cData));

	auto* req = reinterpret_cast<hb::net::PacketShopRequest*>(cData);
	req->header.msg_id = MSGID_REQUEST_SHOP_CONTENTS;
	req->header.msg_type = DEF_MSGTYPE_CONFIRM;
	req->npcType = npcType;

	m_pGSock->iSendMsg(cData, sizeof(hb::net::PacketShopRequest));
}

void CGame::ResponseShopContentsHandler(char* pData)
{
	const auto* resp = hb::net::PacketCast<hb::net::PacketShopResponseHeader>(
		pData, sizeof(hb::net::PacketShopResponseHeader));
	if (!resp) {
		printf("[SHOP] Response: invalid packet\n");
		return;
	}

	uint16_t itemCount = resp->itemCount;
	printf("[SHOP] Response received: NPC type %d, shop %d, %d items\n",
		resp->npcType, resp->shopId, itemCount);

	// Debug: Count how many items are in the config list
	int configCount = 0;
	for (int i = 0; i < 5000; i++) {
		if (m_pItemConfigList[i] != nullptr) configCount++;
	}
	printf("[SHOP] Client has %d items in m_pItemConfigList\n", configCount);

	if (itemCount > DEF_MAXMENUITEMS) {
		itemCount = DEF_MAXMENUITEMS;
	}

	// Clear existing shop items
	for (int i = 0; i < DEF_MAXMENUITEMS; i++) {
		if (m_pItemForSaleList[i] != nullptr) {
			delete m_pItemForSaleList[i];
			m_pItemForSaleList[i] = nullptr;
		}
	}

	// Get item IDs from packet (they follow the header)
	const int16_t* itemIds = reinterpret_cast<const int16_t*>(pData + sizeof(hb::net::PacketShopResponseHeader));

	// Populate shop list from item configs
	int shopIndex = 0;
	int skippedCount = 0;
	int notFoundCount = 0;
	for (uint16_t i = 0; i < itemCount && shopIndex < DEF_MAXMENUITEMS; i++) {
		int16_t itemId = itemIds[i];
		if (itemId <= 0 || itemId >= 5000) {
			if (skippedCount < 5) printf("[SHOP] Skipping invalid item ID: %d\n", itemId);
			skippedCount++;
			continue;
		}
		if (m_pItemConfigList[itemId] == nullptr) {
			if (notFoundCount < 10) printf("[SHOP] Item ID %d not in m_pItemConfigList\n", itemId);
			notFoundCount++;
			skippedCount++;
			continue;
		}

		// Create new item for shop based on config
		CItem* pItem = new CItem();
		CItem* pConfig = m_pItemConfigList[itemId];

		// Copy item data from config
		pItem->m_sIDnum = itemId;
		std::memcpy(pItem->m_cName, pConfig->m_cName, sizeof(pItem->m_cName));
		pItem->m_cItemType = pConfig->m_cItemType;
		pItem->m_cEquipPos = pConfig->m_cEquipPos;
		pItem->m_sSprite = pConfig->m_sSprite;
		pItem->m_sSpriteFrame = pConfig->m_sSpriteFrame;
		pItem->m_wPrice = pConfig->m_wPrice;
		pItem->m_wWeight = pConfig->m_wWeight;
		pItem->m_sItemEffectValue1 = pConfig->m_sItemEffectValue1;
		pItem->m_sItemEffectValue2 = pConfig->m_sItemEffectValue2;
		pItem->m_sItemEffectValue3 = pConfig->m_sItemEffectValue3;
		pItem->m_sItemEffectValue4 = pConfig->m_sItemEffectValue4;
		pItem->m_sItemEffectValue5 = pConfig->m_sItemEffectValue5;
		pItem->m_sItemEffectValue6 = pConfig->m_sItemEffectValue6;
		pItem->m_wMaxLifeSpan = pConfig->m_wMaxLifeSpan;
		pItem->m_sLevelLimit = pConfig->m_sLevelLimit;
		pItem->m_cGenderLimit = pConfig->m_cGenderLimit;
		pItem->m_sSpecialEffect = pConfig->m_sSpecialEffect;
		pItem->m_cSpeed = pConfig->m_cSpeed;

		// Copy display name
		pItem->SetDisplayName(pConfig->GetDisplayName());

		m_pItemForSaleList[shopIndex] = pItem;
		shopIndex++;
	}

	printf("[SHOP] Populated: %d items added, %d skipped (%d not found in config list)\n", shopIndex, skippedCount, notFoundCount);

	// Only show shop dialog if we have items and there was a pending request
	if (shopIndex > 0 && m_sPendingShopType != 0) {
		// Enable the SaleMenu dialog - this will call EnableDialogBox which sets up the dialog
		EnableDialogBox(static_cast<int>(DialogBoxId::SaleMenu), m_sPendingShopType, 0, 0, nullptr);
		m_sPendingShopType = 0;  // Clear pending request
	} else if (m_sPendingShopType != 0) {
		// No items available - show message to user
		AddEventList("This shop has no items available.", 10);
		m_sPendingShopType = 0;
	}
}

static char __cSpace[] = { 8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8, 8,6,8,7,8,8,9,10,9,7, 8,8,8,8,8, 8,8,
						  15,16,12,17,14,15,14,16,10,13, 19,10,17,17,15,14,15,16,13,17, 16,16,20,17,16,14,
						  8,8,8,8,8,8,	8,6,7,8,7,7,7,7,4,7,7,  4,11,7,8,8,7,8,6,5,8,9,14,8,9,8, 8,8,8,8,
						  8,8,8,8,8,8,8 };
void CGame::PutString_SprFont(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[100];

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos + 1, iY, cTmpStr[iCnt] - 33, SpriteLib::DrawParams::Tint(sR + 11, sG + 7, sB + 6));
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos, iY, cTmpStr[iCnt] - 33);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos, iY, cTmpStr[iCnt] - 33, SpriteLib::DrawParams::Tint(sR, sG, sB));
			iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont2(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos, iR, iG, iB;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[200];

	static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->ColorTransferRGB(RGB(sR, sG, sB), &iR, &iG, &iB);

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos + 1, iY, cTmpStr[iCnt] - 33);
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos + 1, iY + 1, cTmpStr[iCnt] - 33);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos, iY, cTmpStr[iCnt] - 33);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->Draw(iXpos, iY, cTmpStr[iCnt] - 33, SpriteLib::DrawParams::Tint(iR, iG, iB));
			iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont3(int iX, int iY, char* pStr, short sR, short sG, short sB, bool bTrans, int iType)
{
	int iXpos, iAdd;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[128];

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	if (iType != -1) {
		iAdd = 95 * iType;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == false) {
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->Draw(iXpos, iY + 1, cTmpStr[iCnt] - 32 + iAdd);
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->Draw(iXpos + 1, iY + 1, cTmpStr[iCnt] - 32 + iAdd);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd);
					else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, SpriteLib::DrawParams::Tint(sR, sG, sB));

				}
				else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, SpriteLib::DrawParams::TintedAlpha(sR, sG, sB, 0.7f));

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->m_stBrush[cTmpStr[iCnt] - 32 + iAdd].szx);
			}
			else iXpos += 5;
		}
	}
	else {
		iAdd = 0;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == false) {
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->Draw(iXpos, iY + 1, cTmpStr[iCnt] - 32 + iAdd);
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->Draw(iXpos + 1, iY + 1, cTmpStr[iCnt] - 32 + iAdd);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						m_pSprite[DEF_SPRID_INTERFACE_FONT2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd);
					else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, SpriteLib::DrawParams::Tint(sR, sG, sB));

				}
				else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->Draw(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, SpriteLib::DrawParams::TintedAlpha(sR, sG, sB, 0.7f));

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_FONT2]->m_stBrush[cTmpStr[iCnt] - 32 + iAdd].szx);
			}
			else iXpos += 5;
		}
	}
}

static char __cSpace2[] = { 6,4,6,6,6,6,6,6,6,6,6 }; //{8,6,9,8,8,9,8,8,8,8};
void CGame::PutString_SprNum(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos;
	unsigned char iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[200];
	uint16_t wR, wG, wB;
	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(sR, sG, sB), &wR, &wG, &wB);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++)
	{
		if ((cTmpStr[iCnt] >= 0x30) && (cTmpStr[iCnt] <= 0x39))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->Draw(iXpos + 2, iY, cTmpStr[iCnt] - 0x30 + 6, SpriteLib::DrawParams::Alpha(0.5f));
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->Draw(iXpos + 1, iY + 1, cTmpStr[iCnt] - 0x30 + 6, SpriteLib::DrawParams::Alpha(0.5f));
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->Draw(iXpos, iY, cTmpStr[iCnt] - 0x30 + 6, SpriteLib::DrawParams::Alpha(0.5f));
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->Draw(iXpos, iY, cTmpStr[iCnt] - 0x30 + 6, SpriteLib::DrawParams::TintedAlpha(wR, wG, wB, 0.7f));
			iXpos += __cSpace2[cTmpStr[iCnt] - 0x30];
		}
	}
}

void CGame::PutString(int iX, int iY, char* pString, COLORREF color, bool bHide, char cBGtype, bool bIsPreDC)
{
	char* pTmp;
	int i;
	if (strlen(pString) == 0) return;
	if (bIsPreDC == false) m_Renderer->BeginTextBatch();
	if (bHide == false)
	{
		switch (cBGtype) {
		case 0:
			m_Renderer->DrawText(iX + 1, iY, pString, color);
			break;
		case 1:
			m_Renderer->DrawText(iX, iY + 1, pString, RGB(5, 5, 5));
			m_Renderer->DrawText(iX + 1, iY + 1, pString, RGB(5, 5, 5));
			m_Renderer->DrawText(iX + 1, iY, pString, RGB(5, 5, 5));
			break;
		}
		m_Renderer->DrawText(iX, iY, pString, color);
	}
	else
	{
		pTmp = new char[strlen(pString) + 2];
		std::memset(pTmp, 0, strlen(pString) + 2);
		strcpy(pTmp, pString);
		for (i = 0; i < (int)strlen(pString); i++)
			if (pTmp[i] != 0) pTmp[i] = '*';

		switch (cBGtype) {
		case 0:
			m_Renderer->DrawText(iX + 1, iY, pTmp, color);
			break;
		case 1:
			m_Renderer->DrawText(iX, iY + 1, pTmp, RGB(5, 5, 5));
			m_Renderer->DrawText(iX + 1, iY + 1, pTmp, RGB(5, 5, 5));
			m_Renderer->DrawText(iX + 1, iY, pTmp, RGB(5, 5, 5));
			break;
		}
		m_Renderer->DrawText(iX, iY, pTmp, color);
		delete[] pTmp;
	}
	if (bIsPreDC == false) m_Renderer->EndTextBatch();
}


void CGame::PutString(int iX, int iY, char* pString, COLORREF color)
{
	m_Renderer->BeginTextBatch();
	m_Renderer->DrawText(iX, iY, pString, color);
	m_Renderer->EndTextBatch();
}

void CGame::PutString2(int iX, int iY, char* pString, short sR, short sG, short sB)
{
	m_Renderer->BeginTextBatch();
	m_Renderer->DrawText(iX + 1, iY, pString, RGB(0, 0, 0));
	m_Renderer->DrawText(iX, iY + 1, pString, RGB(0, 0, 0));
	m_Renderer->DrawText(iX + 1, iY + 1, pString, RGB(0, 0, 0));
	m_Renderer->DrawText(iX, iY, pString, RGB(sR, sG, sB));
	m_Renderer->EndTextBatch();
}

void CGame::PutAlignedString(int iX1, int iX2, int iY, char* pString, short sR, short sG, short sB)
{
	RECT rt;
	m_Renderer->BeginTextBatch();
	SetRect(&rt, iX1, iY, iX2, iY + 15);
	m_Renderer->DrawTextRect(&rt, pString, RGB(sR, sG, sB));
	m_Renderer->EndTextBatch();
}

bool CGame::bInitMagicCfgList()
{
	char cFn[255], cTemp[255];
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicCfgListIndex = 0;
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFn, 0, sizeof(cFn));

	// CLEROTH - MAGIC CFG
	strcpy(cTemp, "magiccfg.txt");

	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (m_pMagicCfgList[atoi(token)] != 0)
					{
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[atoi(token)] = new class CMagic;
					iMagicCfgListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					std::memset(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, 0, sizeof(m_pMagicCfgList[iMagicCfgListIndex]->m_cName));
					memcpy(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_sValue1
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_sValue2	// INT
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // m_sValue3	// COST
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 6;
					break;

					// CLEROTH MAGIC CFG
				case 6: // m_sValue4	// STR
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // m_sValue5
					cReadModeB = 8;
					break;

				case 8: // m_sValue6
					cReadModeB = 9;
					break;

				case 9: // m_bIsVisible
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (atoi(token) == 0) m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = false;
					else m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = true;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return false;
	}

	return true;
}

bool CGame::bCheckImportantFile()
{
	HANDLE hFile;

#ifndef _DEBUG
	hFile = CreateFile("CONTENTS\\badword.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	CloseHandle(hFile);
#endif

	hFile = CreateFile("SPRITES\\TREES1.PAK", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	//	// FileSize : 1846406.... Anti Tree1.pak hack....inutile ca peut se modifier sans changer la taille!
	//	if( GetFileSize( hFile, 0 ) != 2945524 )
	//	{	CloseHandle( hFile );
	//		return false;
	//	}

	CloseHandle(hFile);
	return true;
}

bool CGame::bInitSkillCfgList()
{
	char cFn[255], cTemp[255];
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillCfgListIndex = 0;
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFn, 0, sizeof(cFn));

	strcpy(cTemp, "Skillcfg.txt");
	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (m_pSkillCfgList[atoi(token)] != 0)
					{
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[atoi(token)] = new class CSkill;
					iSkillCfgListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					std::memset(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, 0, sizeof(m_pSkillCfgList[iSkillCfgListIndex]->m_cName));
					memcpy(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_bIsUseable
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_bIsUseable = (bool)atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_cUseMethod
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_cUseMethod = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return false;
	}

	return true;
}


bool CGame::_bGetIsStringIsNumber(char* pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}


void CGame::RequestFullObjectData(uint16_t wObjectID)
{
	int     iRet;
	hb::net::PacketHeader header{};
	header.msg_id = MSGID_REQUEST_FULLOBJECTDATA;
	header.msg_type = wObjectID;

	iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&header), sizeof(header));

	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);

		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = 0;

		if (G_pCalcSocket != 0) {
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		break;
	}
}


bool   CGame::DrawObject_OnAttack(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	default:
		if (_tmp_sAppr2 != 0)
		{
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			_tmp_cFrame = _tmp_sAppr2 - 1;
		}
		else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
				{
					m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame);
				}
				else
				{
					m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame - 1, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // FireWyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))
			{
				m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else
				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
					case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame);
				else m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame - 1, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel((_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 8, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->Draw(sX - 50, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[155]->Draw(sX - 20, sY - 80, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[156]->Draw(sX + 70, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[157]->Draw(sX - 30, sY, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[158]->Draw(sX - 60, sY + 90, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[159]->Draw(sX + 65, sY + 85, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->Draw(sX, sY + 108, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 50, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 2:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 70, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 3:
			m_pEffectSpr[153]->Draw(sX, sY + 105, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 90, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 4:
			m_pEffectSpr[153]->Draw(sX - 35, sY + 100, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 80, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 5:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 65, sY - 5, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 6:
			m_pEffectSpr[153]->Draw(sX + 45, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 31, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 7:
			m_pEffectSpr[153]->Draw(sX + 40, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 30, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 8:
			m_pEffectSpr[153]->Draw(sX + 20, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 20, sY + 16, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		}
	}

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}


bool   CGame::DrawObject_OnAttackMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex, dx, dy, dsx, dsy;
	int cFrameMoveDots;
	bool bInv = false, bDashDraw = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_cFrame) {
	case 4:  _tmp_cFrame = 4; break;
	case 5:  _tmp_cFrame = 4; break;
	case 6:  _tmp_cFrame = 4; break;
	case 7:  _tmp_cFrame = 4; break;
	case 8:  _tmp_cFrame = 4; break;
	case 9:  _tmp_cFrame = 4; break;
	case 10: _tmp_cFrame = 5; break;
	case 11: _tmp_cFrame = 6; break;
	case 12: _tmp_cFrame = 7; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;
	default:
		iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if ((_tmp_cFrame >= 1) && (_tmp_cFrame <= 3))
	{
		switch (_tmp_cFrame) {
		case 1: cFrameMoveDots = 26; break;
		case 2: cFrameMoveDots = 16; break;
		case 3: cFrameMoveDots = 0;  break;
		}
		switch (_tmp_cDir) {
		case 1: dy = cFrameMoveDots; break;
		case 2: dy = cFrameMoveDots; dx = -cFrameMoveDots; break;
		case 3: dx = -cFrameMoveDots; break;
		case 4: dx = -cFrameMoveDots; dy = -cFrameMoveDots; break;
		case 5: dy = -cFrameMoveDots; break;
		case 6: dy = -cFrameMoveDots; dx = cFrameMoveDots; break;
		case 7: dx = cFrameMoveDots; break;
		case 8: dx = cFrameMoveDots; dy = cFrameMoveDots; break;
		}
		switch (_tmp_cFrame) {
		case 1: dy++;    break;
		case 2: dy += 2; break;
		case 3: dy++;    break;
		}
		switch (_tmp_cFrame) {
		case 2: bDashDraw = true; cFrameMoveDots = 26; break;
		case 3: bDashDraw = true; cFrameMoveDots = 16; break;
		}
		dsx = 0;
		dsy = 0;
		switch (_tmp_cDir) {
		case 1: dsy = cFrameMoveDots; break;
		case 2: dsy = cFrameMoveDots; dsx = -cFrameMoveDots; break;
		case 3: dsx = -cFrameMoveDots; break;
		case 4: dsx = -cFrameMoveDots; dsy = -cFrameMoveDots; break;
		case 5: dsy = -cFrameMoveDots; break;
		case 6: dsy = -cFrameMoveDots; dsx = cFrameMoveDots; break;
		case 7: dsx = cFrameMoveDots; break;
		case 8: dsx = cFrameMoveDots; dsy = cFrameMoveDots; break;
		}
	}
	else if (_tmp_cFrame > 3)
	{
		dx = 0;
		dy = 0;
	}
	else
	{
		switch (_tmp_cDir) {
		case 1: dy = 32; break;
		case 2: dy = 32; dx = -32; break;
		case 3: dx = -32; break;
		case 4: dx = -32; dy = -32; break;
		case 5: dy = -32; break;
		case 6: dy = -32; dx = 32; break;
		case 7: dx = 32; break;
		case 8: dx = 32; dy = 32; break;
		}
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX + dx, sY + dy, _tmp_cFrame);

	if (_tmp_iEffectType != 0) {
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX + dx, sY + dy, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX + dx, sY + dy, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX + dx, sY + dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame);
				else m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame - 1, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

				else m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;

			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}


			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(sX - 13 + dx, sY - 34 + dy, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame);
				else m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame - 1, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			}
		}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(8 + (_tmp_cDir - 1), sX + dx + 20, sY + dy - 20, _tmp_cFrame % 8, dwTime);
		CheckActiveAura2(sX + dx, sY + dy, dwTime, _tmp_sOwnerType);

		if (bDashDraw == true) {
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dsx, sY + dsy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			if (iWeaponIndex != -1) m_pSprite[iWeaponIndex]->Draw(sX + dsx, sY + dsy, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
			if (iShieldIndex != -1) m_pSprite[iShieldIndex]->Draw(sX + dsx, sY + dsy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f));
		}
	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX + dx, sY + dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX + dx, sY + dy, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX + dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY + dy;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;

	return false;
}


bool   CGame::DrawObject_OnMagic(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
			bInv = true;
		else
		{
			if (_tmp_iChatIndex != 0)
			{
				if (m_pChatMsgList[_tmp_iChatIndex] != 0)
				{
					m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
					m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
				}
				else
				{
					m_pMapData->ClearChatMsg(indexX, indexY);
				}
			}
			return false;
		}
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 8;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 8;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 8;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 8;
		break;
	}

	/*
	switch (_tmp_cFrame) {
	case 15:
		_tmp_cFrame = 14;
		break;
	case 16:
		_tmp_cFrame = 14;
		break;
	case 17:
		_tmp_cFrame = 15;
		break;
	case 18:
		_tmp_cFrame = 15;
		break;
	case 19:
		_tmp_cFrame = 15;
		break;
	case 20:
		_tmp_cFrame = 15;
		break;
	case 21:
		_tmp_cFrame = 15;
		break;
	case 22:
		_tmp_cFrame = 15;
		break;
	case 23:
		_tmp_cFrame = 14;
		break;
	}
	*/
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
		else {
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}

		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
		}

		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}

		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
		}

		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
		}

		if (iMantleIndex != -1)
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(32 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 16, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool   CGame::DrawObject_OnGetItem(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (9 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 9;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 9; 		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (9 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 9;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 9;
		break;
	default:
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
		else {
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1)
		{
			if (bInv) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}
		}

		if (iPantsIndex != -1)
		{
			if (bInv) m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}
		}

		if (iArmArmorIndex != -1)
		{
			if (bInv) m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}
		}

		if (iBodyArmorIndex != -1)
		{
			if (bInv) m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}
		}

		if (iHelmIndex != -1)
		{
			if (bInv) m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}
		}

		if (iMantleIndex != -1)
		{
			if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(40 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnDamage(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB;
	int iAdd, iDrawMode, iMantleIndex;
	char cFrame;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	cFrame = _tmp_cFrame;
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 4)
		{
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
			iDrawMode = 0;
		}
		else
		{
			cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 10;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
			iDrawMode = 1;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if (cFrame < 4)
		{
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
			iDrawMode = 0;
		}
		else
		{
			cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 10;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
			iDrawMode = 1;
		}
		break;

	default:
		if (cFrame < 4)
		{
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		}
		else
		{
			cFrame -= 4;
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
		}
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		iDrawMode = 0;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (iDrawMode == 1) // Etrange, 1 semble impossible avec des mobs !
		{
			if (_cDrawingOrder[_tmp_cDir] == 1)
			{
				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				else
				{
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
					case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}
			else
			{
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				else
				{
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
					case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}
			}

			if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
			DrawAngel(16 + (_tmp_cDir - 1), sX + 20, sY - 20, cFrame % 4, dwTime);
			CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

		}
		else // DrawMode != 1
		{
			if (_cDrawingOrder[_tmp_cDir] == 1)
			{
				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
					{
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
					case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}
			else
			{
				switch (_tmp_sOwnerType) {
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame);
				}

				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
					case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}

				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
					}
				}
			}

			if ((_tmp_iStatus & 0x20) != 0)	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
			DrawAngel(16 + (_tmp_cDir - 1), sX + 20, sY - 20, cFrame % 4, dwTime);
			CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);
		}
	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->Draw(sX - 50, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[155]->Draw(sX - 20, sY - 80, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[156]->Draw(sX + 70, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[157]->Draw(sX - 30, sY, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[158]->Draw(sX - 60, sY + 90, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[159]->Draw(sX + 65, sY + 85, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->Draw(sX, sY + 108, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 50, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 2:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 70, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 3:
			m_pEffectSpr[153]->Draw(sX, sY + 105, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 90, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 4:
			m_pEffectSpr[153]->Draw(sX - 35, sY + 100, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 80, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 5:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 65, sY - 5, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 6:
			m_pEffectSpr[153]->Draw(sX + 45, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 31, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 7:
			m_pEffectSpr[153]->Draw(sX + 40, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 30, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 8:
			m_pEffectSpr[153]->Draw(sX + 20, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 20, sY + 16, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;

	return false;
}

bool CGame::DrawObject_OnDying(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;
	char cFrame;
	int randFrame;

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	cFrame = _tmp_cFrame;

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 6)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		else
		{
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 11;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if (cFrame < 6)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		else
		{
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 11;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		}
		break;

	default:
		if (cFrame < 4)
		{
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			iUndiesIndex = -1;
			iHairIndex = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex = -1;
			switch (_tmp_sOwnerType) {
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT
			case 40: // ESG
			case 41: // GMG
			case 42: // ManaStone
				if (_tmp_sAppr2 == 0) cFrame = 0;
				break;
			case 51: cFrame = 0; break;
			}
		}
		else
		{
			switch (_tmp_sOwnerType) {
			case 51: cFrame = 0; break;
			default: cFrame -= 4; break;
			}
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			iUndiesIndex = -1;
			iHairIndex = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex = -1;
		}
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (ConfigManager::Get().GetDetailLevel() != 0)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Shadow());
			}
			break;
		}
		if (_tmp_sOwnerType == 81)
		{
			m_pEffectSpr[152]->Draw(sX - 80, sY - 15, _tmp_iEffectFrame % 27, SpriteLib::DrawParams::Alpha(0.7f)); // Explosion Abaddon
			m_pEffectSpr[152]->Draw(sX, sY - 15, _tmp_iEffectFrame % 27, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[152]->Draw(sX - 40, sY, _tmp_iEffectFrame % 27, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[163]->Draw(sX - 90, sY - 80, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f)); // Ames qui s'envolent
			m_pEffectSpr[160]->Draw(sX - 60, sY - 50, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[161]->Draw(sX - 30, sY - 20, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[162]->Draw(sX, sY - 100, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[163]->Draw(sX + 30, sY - 30, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[162]->Draw(sX + 60, sY - 90, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[163]->Draw(sX + 90, sY - 50, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.7f));
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[140]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break; // Abbadon dying
			case 2: m_pEffectSpr[141]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break; // fixed sprit IDs
			case 3: m_pEffectSpr[142]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 4: m_pEffectSpr[143]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 5: m_pEffectSpr[144]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 6: m_pEffectSpr[145]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 7: m_pEffectSpr[146]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 8: m_pEffectSpr[147]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			}
		}
		else if (_tmp_sOwnerType == 66) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
		else if (_tmp_sOwnerType == 73)
		{	//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			m_pSprite[33]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[141]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break; // Abbadon qui meurt
			case 2: m_pEffectSpr[142]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 3: m_pEffectSpr[143]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 4: m_pEffectSpr[144]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 5: m_pEffectSpr[145]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 6: m_pEffectSpr[146]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 7: m_pEffectSpr[147]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break;
				//case 8: m_pEffectSpr[148]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
			case 8: m_pEffectSpr[141]->Draw(sX, sY, cFrame + 8, SpriteLib::DrawParams::Alpha(0.7f)); break; //due to buggy Sprite nb
			}
		}
		else
		{
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame);
		}

		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}

		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
		}

		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}

		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
		}

		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
		}

		if (iMantleIndex != -1)
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(24 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool   CGame::DrawObject_OnDead(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iFrame, iMantleIndex, iHelmIndex;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 66) return false;

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 11;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 11;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		break;
	default:
		switch (_tmp_sOwnerType) {
		case 28: // Troll
		case 29: // Ogre
		case 30: // Liche
		case 31: // DD		// les 2 dernieres sont pas bonnes pour un mort !
		case 63: // Frost	// les 2 dernieres sont pas bonnes pour un mort !
			iFrame = 5;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 32: // Uni
		case 33: // WW
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
		case 48: // SK
		case 49: // HC
		case 50: // TW
		case 53: // BB
		case 54: // DE
		case 55: // Rabbit
		case 56: // Cat
		case 57: // Frog
		case 58: // MG
		case 59: // Ettin
		case 60: // Plant
		case 61: // Rudolph
		case 62: // Direboar
		case 64: // Crops  ----------- Crop ici! etonant, pourtant !
		case 65: // IceGolem
		case 70: // Dragon..........Ajouts par Snoopy
		case 71: // Centaur
		case 72: // ClawTurtle
		case 74: // GiantCrayfish
		case 75: // Gi Lizard
		case 76: // Gi Tree
		case 77: // Master Orc
		case 78: // Minaus
		case 79: // Nizie
		case 80: // Tentocle
		case 82: // Sorceress
		case 83: // ATK
		case 84: // MasterElf
		case 85: // DSK
		case 88: // Barbarian
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 86: // HBT
		case 87: // CT
		case 89: // AGC
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			break;

		case 66: // Wyvern
			iFrame = 15;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			break;

		case 73: // FireWyvern
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			bTrans = true; // Prevents showing hugly corpse
			break;

		case 81: // Abaddon
			iFrame = 0;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			bTrans = true; // Prevents showing hugly corpse
			break;

		case 51: // CP
			iFrame = 0;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 52: // GG
			iFrame = 11;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 91: // Gate
			iFrame = 5;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			break;

		default: // 40*4 (10...27)
			iFrame = 3;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;
		}
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (bTrans == false)
	{
		if (_tmp_cFrame == -1)
		{
			_tmp_cFrame = 7;
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, iFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, iFrame);

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if (iMantleIndex != -1)
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
				else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}
		}
		else if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, iFrame, SpriteLib::DrawParams::TintedAlpha(-2 * _tmp_cFrame + 5, -2 * _tmp_cFrame - 5, -2 * _tmp_cFrame - 5, 0.7f));
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, iFrame, SpriteLib::DrawParams::TintedAlpha(-2 * _tmp_cFrame, -2 * _tmp_cFrame, -2 * _tmp_cFrame, 0.7f));

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearDeadChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		Abaddon_corpse(sX, sY); // By Snoopy....
	}
	else if (_tmp_sOwnerType == 73)
	{	//m_pEffectSpr[35]->Draw(sX+120, sY+120, rand(), SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[35]->Draw(sX + 20, sY - 15, rand() % 10, SpriteLib::DrawParams::Alpha(0.7f));
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}



bool   CGame::DrawObject_OnMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /* || _tmp_sOwnerType == 66 || _tmp_sOwnerType == 73*/)	bInv = true; //Energy-Ball, Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else  iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;

	default:
		if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;
	int value_2 = 30;
	switch (_tmp_cDir) {
	case 1: dy = value_2 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = value_2 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 3: dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 4: dx = (_tmp_cFrame << 2) + value - value_2; dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 5: dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 6: dy = (_tmp_cFrame << 2) + value - value_2; dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = value_2 - (_tmp_cFrame << 2) - value; dy = value_2 - (_tmp_cFrame << 2) - value; break;
	}

	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:

	case 28: // Troll.
	case 29: // Orge.
	case 30: // Liche
	case 31: // DD
	case 32: // Uni
	case 33: // ww

	case 43: // LWB
	case 44: // GHK
	case 45: // GHKABS
	case 46: // TK
	case 47: // BG
	case 48: // SK
	case 49: // HC
	case 50: // TW

	case 52: // GG
	case 53: // BB
	case 54: // DE
	case 55: // Rabbit
	case 56: // Cat
	case 57: // Frog
	case 58: // MG
	case 59: // Ettin
	case 60: // Plant
	case 61: // Rudolph
	case 62: // DireBoar
	case 63: // Frost

	case 65: // Ice-Golem
	case 66: // Wyvern

	case 70: // Dragon..........Ajouts par Snoopy
	case 71: // Centaur
	case 72: // ClawTurtle
	case 73: // FireWyvern
	case 74: // GiantCrayfish
	case 75: // Gi Lizard
	case 76: // Gi Tree
	case 77: // Master Orc
	case 78: // Minaus
	case 79: // Nizie
	case 80: // Tentocle
	case 81: // Abaddon
	case 82: // Sorceress
	case 83: // ATK
	case 84: // MasterElf
	case 85: // DSK
	case 86: // HBT
	case 87: // CT
	case 88: // Barbarian
	case 89: // AGC
	case 90: // Gail
		break;

	default:
		_tmp_cFrame = _tmp_cFrame / 2;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (_tmp_sOwnerType == 65) // IceGolem
	{	/*m_pEffectSpr[77]->Draw(sX+dx, sY+dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.7f));*/
		switch (rand() % 3) {
		case 0:	m_pEffectSpr[76]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
		case 1:	m_pEffectSpr[77]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
		case 2:	m_pEffectSpr[78]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.7f)); break;
		}
	}
	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv) {
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(fix_x, fix_y, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else if (bInv == true)
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX+dx, sY+dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(fix_x, fix_y, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.7f));
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
		}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(40 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_iEffectFrame % 12;
		m_pEffectSpr[154]->Draw(sX - 50, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[155]->Draw(sX - 20, sY - 80, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[156]->Draw(sX + 70, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[157]->Draw(sX - 30, sY, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[158]->Draw(sX - 60, sY + 90, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[159]->Draw(sX + 65, sY + 85, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->Draw(fix_x, fix_y + 108, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 50, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 2:
			m_pEffectSpr[153]->Draw(fix_x, fix_y + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 70, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 3:
			m_pEffectSpr[153]->Draw(fix_x, fix_y + 105, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 90, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 4:
			m_pEffectSpr[153]->Draw(fix_x - 35, fix_y + 100, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 80, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 5:
			m_pEffectSpr[153]->Draw(fix_x, fix_y + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 65, fix_y - 5, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 6:
			m_pEffectSpr[153]->Draw(fix_x + 45, fix_y + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 31, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 7:
			m_pEffectSpr[153]->Draw(fix_x + 40, fix_y + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 30, fix_y + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 8:
			m_pEffectSpr[153]->Draw(fix_x + 20, fix_y + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(fix_x - 20, fix_y + 16, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnDamageMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int cFrame, cDir;
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 67 || _tmp_sOwnerType == 68 || _tmp_sOwnerType == 69 || _tmp_sOwnerType == 81) return false;
	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	cDir = _tmp_cDir;
	switch (_tmp_cDir) {
	case 1: _tmp_cDir = 5; break;
	case 2: _tmp_cDir = 6; break;
	case 3: _tmp_cDir = 7; break;
	case 4: _tmp_cDir = 8; break;
	case 5: _tmp_cDir = 1; break;
	case 6: _tmp_cDir = 2; break;
	case 7: _tmp_cDir = 3; break;
	case 8: _tmp_cDir = 4; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 10;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 10;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
		break;
	default:
		if (_tmp_sOwnerType == 66)      iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);// Ne devrait pas arriver!
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);// Ne devrait pas arriver!
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;

	switch (_tmp_cDir) {
	case 1: dy = 30 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = 30 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - 30; break;
	case 3: dx = (_tmp_cFrame << 2) + value - 30; break;
	case 4: dx = (_tmp_cFrame << 2) + value - 30; dy = (_tmp_cFrame << 2) + value - 30; break;
	case 5: dy = (_tmp_cFrame << 2) + value - 30; break;
	case 6: dy = (_tmp_cFrame << 2) + value - 30; dx = 30 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = 30 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = 30 - (_tmp_cFrame << 2) - value; dy = 30 - (_tmp_cFrame << 2) - value; break;
	}

	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}
	cFrame = _tmp_cFrame;
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, cFrame);
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame);
				else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}

			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + cFrame);
				else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame);
				else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame);
				else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(16 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnMove_ForMenu(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	short dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
	iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
	iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
	iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
	iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
	iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
	iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
	iHelmColor = (_tmp_iApprColor & 0x0000000F);

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else
				{
					iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
				}
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			else  iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;
	default:
		iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if (_cDrawingOrder[_tmp_cDir] == 1)
	{
		if (iWeaponIndex != -1)
		{
			if (iWeaponColor == 0)
				m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame);
			else m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
		}
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
			}
			break;
		}
		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame);


		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}
		if (iUndiesIndex != -1)
		{
			if (bInv) m_pSprite[iUndiesIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else m_pSprite[iUndiesIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}
		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
		}
		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}
		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
		}
		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}

		if (iShieldIndex != -1)
		{
			if (iShieldColor == 0)
				m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}
	}
	else
	{
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX + dx, sY + dy, _tmp_cFrame);

		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}
		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}
		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iPantsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
		}
		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iArmArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBootsIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
		}
		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iBodyArmorIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
		}
		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}

		if (iShieldIndex != -1)
		{
			if (iShieldColor == 0)
				m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iShieldIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			else m_pSprite[iMantleIndex]->Draw(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
		}
		if (iWeaponIndex != -1)
		{
			if (iWeaponColor == 0)
				m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame);
			else m_pSprite[iWeaponIndex]->Draw(sX + dx, sY + dy, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
		}
	}

	if (_tmp_iChatIndex != 0)
	{
		if (m_pChatMsgList[_tmp_iChatIndex] != 0)
		{
			DrawChatMsgBox(sX + dx, sY + dy, _tmp_iChatIndex, false);
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}


bool   CGame::DrawObject_OnStop(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iBodyArmorIndex, iArmArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/ || _tmp_sOwnerType == 81) bInv = true; //Energy-Ball, Wyvern
	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	// CLEROTH - Single-direction monsters
	switch (_tmp_sOwnerType) {
	case 110: // Air Elemental
		_tmp_cDir = 1; // North
		break;
	case 91: // Snoopy: Gate
		if (_tmp_cDir <= 3) _tmp_cDir = 3;
		else  _tmp_cDir = 5;
		break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		_tmp_cFrame = _tmp_cFrame / 2;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 1;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 1;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		break;

	case 4:
	case 5:
	case 6:
		_tmp_cFrame = _tmp_cFrame / 2;
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 1;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 1;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		break;
	default:
		if (_tmp_sAppr2 != 0)
		{
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			_tmp_cFrame = (_tmp_sAppr2 & 0x00FF) - 1;
		}
		/*	else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);*/
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	switch (_tmp_sOwnerType) { // hum? la lumiere en dessous ?
	case 15: // ShopKeeper
	case 19: // Gandalf
	case 20: // Howard
	case 24: // Tom
	case 25: // William
	case 26: // Kenedy
	case 51: // CP
	case 86: // HBT
	case 90: // Gail
		m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));
		break;
	}
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(sX, sY, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}
	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));

			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->Draw(sX, sY, 1, SpriteLib::DrawParams::Alpha(0.5f));
			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else if (bInv == true)
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(sX - 13, sY - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
		}
		if (_tmp_sOwnerType == 64) // crop
		{
			switch (_tmp_cFrame) {
			case 0: // color effect for crop
				m_pEffectSpr[84]->Draw(sX + 52, sY + 54, (dwTime % 3000) / 120, SpriteLib::DrawParams::Alpha(0.5f));
				break;
			case 1: // color effect for crop
				m_pEffectSpr[83]->Draw(sX + 53, sY + 59, (dwTime % 3000) / 120, SpriteLib::DrawParams::Alpha(0.5f));
				break;
			case 2: // color effect for crop
				m_pEffectSpr[82]->Draw(sX + 53, sY + 65, (dwTime % 3000) / 120, SpriteLib::DrawParams::Alpha(0.5f));
				break;
			}
		}
		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX, sY, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(40 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->Draw(sX - 50, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[155]->Draw(sX - 20, sY - 80, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[156]->Draw(sX + 70, sY - 50, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[157]->Draw(sX - 30, sY, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[158]->Draw(sX - 60, sY + 90, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		m_pEffectSpr[159]->Draw(sX + 65, sY + 85, randFrame, SpriteLib::DrawParams::Alpha(0.7f));
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->Draw(sX, sY + 108, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 50, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 2:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 70, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 3:
			m_pEffectSpr[153]->Draw(sX, sY + 105, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 90, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 4:
			m_pEffectSpr[153]->Draw(sX - 35, sY + 100, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 80, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 5:
			m_pEffectSpr[153]->Draw(sX, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 65, sY - 5, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 6:
			m_pEffectSpr[153]->Draw(sX + 45, sY + 95, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 31, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 7:
			m_pEffectSpr[153]->Draw(sX + 40, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 30, sY + 10, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		case 8:
			m_pEffectSpr[153]->Draw(sX + 20, sY + 110, _tmp_iEffectFrame % 28, SpriteLib::DrawParams::Alpha(0.7f));
			m_pEffectSpr[164]->Draw(sX - 20, sY + 16, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

void CGame::_ReadMapData(short sPivotX, short sPivotY, const char* pData)
{
	int i;
	const char* cp;
	char ucHeader, cDir, cName[12], cItemColor;
	short sTotal, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sDynamicObjectType;
	int iStatus;
	int iApprColor;
	uint16_t wObjectID;
	uint16_t wDynamicObjectID;
	short sItemID;
	uint32_t dwItemAttr;

	cp = pData;
	m_sVDL_X = sPivotX; // Valid Data Loc-X
	m_sVDL_Y = sPivotY;

	const auto* mapHeader = hb::net::PacketCast<hb::net::PacketMapDataHeader>(cp, sizeof(hb::net::PacketMapDataHeader));
	if (!mapHeader) return;
	sTotal = mapHeader->total;
	cp += sizeof(hb::net::PacketMapDataHeader);
	for (i = 1; i <= sTotal; i++)
	{
		const auto* entry = hb::net::PacketCast<hb::net::PacketMapDataEntryHeader>(cp, sizeof(hb::net::PacketMapDataEntryHeader));
		if (!entry) return;
		sX = entry->x;
		sY = entry->y;
		ucHeader = entry->flags;
		cp += sizeof(hb::net::PacketMapDataEntryHeader);
		if (ucHeader & 0x01) // object ID
		{
			const auto* objBase = hb::net::PacketCast<hb::net::PacketMapDataObjectBase>(cp, sizeof(hb::net::PacketMapDataObjectBase));
			if (!objBase) return;
			if (objBase->object_id < 10000)
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectPlayer>(cp, sizeof(hb::net::PacketMapDataObjectPlayer));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = obj->appr1;
				sAppr2 = obj->appr2;
				sAppr3 = obj->appr3;
				sAppr4 = obj->appr4;
				iApprColor = obj->appr_color;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectPlayer);
			}
			else // NPC
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectNpc>(cp, sizeof(hb::net::PacketMapDataObjectNpc));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = sAppr3 = sAppr4 = 0;
				sAppr2 = obj->appr2;
				iApprColor = 0;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectNpc);
			}
			m_pMapData->bSetOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		}
		if (ucHeader & 0x02) // object ID
		{
			const auto* objBase = hb::net::PacketCast<hb::net::PacketMapDataObjectBase>(cp, sizeof(hb::net::PacketMapDataObjectBase));
			if (!objBase) return;
			if (objBase->object_id < 10000)
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectPlayer>(cp, sizeof(hb::net::PacketMapDataObjectPlayer));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = obj->appr1;
				sAppr2 = obj->appr2;
				sAppr3 = obj->appr3;
				sAppr4 = obj->appr4;
				iApprColor = obj->appr_color;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectPlayer);
			}
			else // NPC
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectNpc>(cp, sizeof(hb::net::PacketMapDataObjectNpc));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = sAppr3 = sAppr4 = 0;
				sAppr2 = obj->appr2;
				iApprColor = 0;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectNpc);
			}
			m_pMapData->bSetDeadOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName);
		}
		if (ucHeader & 0x04)
		{
			const auto* item = hb::net::PacketCast<hb::net::PacketMapDataItem>(cp, sizeof(hb::net::PacketMapDataItem));
			if (!item) return;
			sItemID = item->item_id;
			cItemColor = static_cast<char>(item->color);
			dwItemAttr = item->attribute;
			cp += sizeof(hb::net::PacketMapDataItem);
			m_pMapData->bSetItem(sPivotX + sX, sPivotY + sY, sItemID, cItemColor, dwItemAttr, false);
		}
		if (ucHeader & 0x08) // Dynamic object
		{
			const auto* dyn = hb::net::PacketCast<hb::net::PacketMapDataDynamicObject>(cp, sizeof(hb::net::PacketMapDataDynamicObject));
			if (!dyn) return;
			wDynamicObjectID = dyn->object_id;
			sDynamicObjectType = dyn->type;
			cp += sizeof(hb::net::PacketMapDataDynamicObject);
			m_pMapData->bSetDynamicObject(sPivotX + sX, sPivotY + sY, wDynamicObjectID, sDynamicObjectType, false);
		}
	}
}


void CGame::LogEventHandler(char* pData)
{
	WORD wEventType, wObjectID;
	short sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4;
	int iStatus;
	char cDir, cName[12];
	int iApprColor = 0;

	const auto* base = hb::net::PacketCast<hb::net::PacketEventLogBase>(pData, sizeof(hb::net::PacketEventLogBase));
	if (!base) return;
	wEventType = base->header.msg_type;
	wObjectID = base->object_id;
	sX = base->x;
	sY = base->y;
	sType = base->type;
	cDir = static_cast<char>(base->dir);
	std::memset(cName, 0, sizeof(cName));
	if (wObjectID < 10000)
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventLogPlayer>(pData, sizeof(hb::net::PacketEventLogPlayer));
		if (!pkt) return;
		memcpy(cName, pkt->name, sizeof(pkt->name));
		sAppr1 = pkt->appr1;
		sAppr2 = pkt->appr2;
		sAppr3 = pkt->appr3;
		sAppr4 = pkt->appr4;
		iApprColor = pkt->appr_color;
		iStatus = pkt->status;
	}
	else 	// NPC
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventLogNpc>(pData, sizeof(hb::net::PacketEventLogNpc));
		if (!pkt) return;
		memcpy(cName, pkt->name, sizeof(pkt->name));
		sAppr1 = sAppr3 = sAppr4 = 0;
		sAppr2 = pkt->appr2;
		iStatus = pkt->status;
	}

	switch (wEventType) {
	case DEF_MSGTYPE_CONFIRM:
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		switch (sType) {
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
			m_pEffectManager->AddEffect(64, (sX) * 32, (sY) * 32, 0, 0, 0);
			break;
		}
		break;

	case DEF_MSGTYPE_REJECT:
		m_pMapData->bSetOwner(wObjectID, -1, -1, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		break;
	}

	_RemoveChatMsgListByObjectID(wObjectID);
}

// MODERNIZED: No longer a window message handler - polls socket directly
void CGame::OnLogSocketEvent()
{
	int iRet;
	char* pData;
	uint32_t dwMsgSize;
	if (m_pLSock == 0) return;

	// MODERNIZED: Poll() instead of iOnSocketEvent()
	iRet = m_pLSock->Poll();
	switch (iRet) {
	case 0:
		// No events
		return;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_LOG);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		pData = m_pLSock->pGetRcvDataPointer(&dwMsgSize);
		LogRecvMsgHandler(pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = 0;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pLSock;
		m_pLSock = 0;
		break;
	}
}

void CGame::LogResponseHandler(char* pData)
{
	WORD wResponse;
	char cCharName[12];
	int i;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResponse = header->msg_type;

	switch (wResponse) {
	case DEF_LOGRESMSGTYPE_CHARACTERDELETED:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogCharacterListHeader>(
			pData, sizeof(hb::net::PacketLogCharacterListHeader));
		if (!list) return;
		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0)
			{
				delete m_pCharList[i];
				m_pCharList[i] = 0;
			}

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogCharacterListHeader));
		for (i = 0; i < m_iTotalChar; i++) {
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3A");
	}
	break;

	case DEF_LOGRESMSGTYPE_CONFIRM:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogCharacterListHeader>(
			pData, sizeof(hb::net::PacketLogCharacterListHeader));
		if (!list) return;
		m_iAccntYear = 0;
		m_iAccntMonth = 0;
		m_iAccntDay = 0;
		m_iIpYear = 0;
		m_iIpMonth = 0;
		m_iIpDay = 0;
		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0)
			{
				delete m_pCharList[i];
				m_pCharList[i] = 0;
			}

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogCharacterListHeader));
		for (i = 0; i < m_iTotalChar; i++)
		{
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		ClearContents_OnSelectCharacter();
	}
	break;

	case DEF_LOGRESMSGTYPE_REJECT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseReject>(pData, sizeof(hb::net::PacketLogResponseReject));
		if (!pkt) return;
		m_iBlockYear = pkt->block_year;
		m_iBlockMonth = pkt->block_month;
		m_iBlockDay = pkt->block_day;

		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7H");
	}
	break;

	case DEF_LOGRESMSGTYPE_NOTENOUGHPOINT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7I");
		break;

	case DEF_LOGRESMSGTYPE_ACCOUNTLOCKED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7K");
		break;

	case DEF_LOGRESMSGTYPE_SERVICENOTAVAILABLE:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7L");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGESUCCESS:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6B");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGEFAIL:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6C");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDMISMATCH:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "11");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "12");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTCREATED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "54");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "05");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "06");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "Not existing character!");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERCREATED:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogNewCharacterCreatedHeader>(
			pData, sizeof(hb::net::PacketLogNewCharacterCreatedHeader));
		if (!list) return;
		std::memset(cCharName, 0, sizeof(cCharName));
		memcpy(cCharName, list->character_name, sizeof(list->character_name));

		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0) delete m_pCharList[i];

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogNewCharacterCreatedHeader));
		for (i = 0; i < m_iTotalChar; i++) {
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "47");
	}
	break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "28");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "29");
		break;

	case DEF_ENTERGAMERESTYPE_PLAYING:
		ChangeGameMode(DEF_GAMEMODE_ONQUERYFORCELOGIN);
		break;

	case DEF_ENTERGAMERESTYPE_CONFIRM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogEnterGameConfirm>(
			pData, sizeof(hb::net::PacketLogEnterGameConfirm));
		if (!pkt) return;
		int iGameServerPort = pkt->game_server_port;
		char cGameServerAddr[16];
		std::memset(cGameServerAddr, 0, sizeof(cGameServerAddr));
		memcpy(cGameServerAddr, pkt->game_server_addr, sizeof(pkt->game_server_addr));
		std::memset(m_cGameServerName, 0, sizeof(m_cGameServerName));
		memcpy(m_cGameServerName, pkt->game_server_name, sizeof(pkt->game_server_name));
		(void)iGameServerPort;

		m_pGSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
		m_pGSock->bConnect(m_cLogServerAddr, m_iGameServerPort);
		m_pGSock->bInitBufferSize(30000);
	}
	break;

	case DEF_ENTERGAMERESTYPE_REJECT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseCode>(pData, sizeof(hb::net::PacketLogResponseCode));
		if (!pkt) return;
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		switch (pkt->code) {
		case 1:	strcpy(m_cMsg, "3E"); break;
		case 2:	strcpy(m_cMsg, "3F"); break;
		case 3:	strcpy(m_cMsg, "33"); break;
		case 4: strcpy(m_cMsg, "3D"); break;
		case 5: strcpy(m_cMsg, "3G"); break;
		case 6: strcpy(m_cMsg, "3Z"); break;
		case 7: strcpy(m_cMsg, "3J"); break;
		}
	}
	break;

	case DEF_ENTERGAMERESTYPE_FORCEDISCONN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3X");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGWORLDSERVER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1Y");
		break;

	case DEF_LOGRESMSGTYPE_INPUTKEYCODE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseCode>(pData, sizeof(hb::net::PacketLogResponseCode));
		if (!pkt) return;
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		switch (pkt->code) {
		case 1:	strcpy(m_cMsg, "8U"); break; //MainMenu, Keycode registration success
		case 2:	strcpy(m_cMsg, "82"); break; //MainMenu, Not existing Account
		case 3:	strcpy(m_cMsg, "81"); break; //MainMenu, Password wrong
		case 4: strcpy(m_cMsg, "8V"); break; //MainMenu, Invalid Keycode
		case 5: strcpy(m_cMsg, "8W"); break; //MainMenu, Already Used Keycode
		}
	}
	break;

	case DEF_LOGRESMSGTYPE_FORCECHANGEPASSWORD:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6M");
		break;

	case DEF_LOGRESMSGTYPE_INVALIDKOREANSSN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1a");
		break;

	case DEF_LOGRESMSGTYPE_LESSTHENFIFTEEN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1b");
		break;
	}
	delete m_pLSock;
	m_pLSock = 0;
}


void CGame::LogRecvMsgHandler(char* pData)
{
	LogResponseHandler(pData);
}


void CGame::_InitOnCreateNewCharacter()
{
	m_cGender = rand() % 2 + 1;
	m_cSkinCol = rand() % 3 + 1;
	m_cHairStyle = rand() % 8;
	m_cHairCol = rand() % 16;
	m_cUnderCol = rand() % 8;
	m_ccStr = 10;
	m_ccVit = 10;
	m_ccDex = 10;
	m_ccInt = 10;
	m_ccMag = 10;
	m_ccChr = 10;
}

void CGame::ClearContents_OnCreateNewAccount()
{
	std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
	std::memset(m_cAccountAge, 0, sizeof(m_cAccountAge));
	std::memset(m_cAccountCountry, 0, sizeof(m_cAccountCountry));
	std::memset(m_cAccountSSN, 0, sizeof(m_cAccountSSN));
	std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
	//v1.4334
	std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
	std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
}

void CGame::ChangeGameMode(char cMode)
{
	m_cGameMode = cMode;
	m_cGameModeCount = 0;
	m_dwTime = G_dwGlobalTime;

#ifndef DEF_SELECTSERVER
	if (cMode == DEF_GAMEMODE_ONSELECTSERVER)
	{
		std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
		strcpy(m_cWorldServerName, NAME_WORLDNAME1);
		m_cGameMode = DEF_GAMEMODE_ONLOGIN;
	}
#endif
}

// Overlay system methods
void CGame::ShowOverlay(OverlayType type, char context, char message)
{
	m_activeOverlay = type;
	m_cOverlayContext = context;
	m_cOverlayMessage = message;
	m_dwOverlayStartTime = G_dwGlobalTime;
}

void CGame::HideOverlay()
{
	m_activeOverlay = OverlayType::None;
	m_cOverlayContext = 0;
	m_cOverlayMessage = 0;
}

void CGame::UpdateOverlay()
{
	// Handle input for the active overlay
	// This will be filled in when we convert each overlay screen
	switch (m_activeOverlay)
	{
	case OverlayType::Connecting:
		// ESC to cancel connection
		if (InputManager::Get().IsEscPressed())
		{
			InputManager::Get().ClearEscPressed();
			HideOverlay();
			if (m_pGSock) m_pGSock->_CloseConn();
			if (m_pLSock) m_pLSock->_CloseConn();
		}
		break;

	case OverlayType::WaitingResponse:
		// ESC to cancel waiting
		if (InputManager::Get().IsEscPressed())
		{
			InputManager::Get().ClearEscPressed();
			HideOverlay();
			if (m_pGSock) m_pGSock->_CloseConn();
			if (m_pLSock) m_pLSock->_CloseConn();
		}
		break;

	case OverlayType::LogResMsg:
		// Click to dismiss
		// Will be handled in the Draw phase click detection
		break;

	case OverlayType::QueryForceLogin:
		// Yes/No button handling
		break;

	case OverlayType::QueryDeleteCharacter:
		// Yes/No button handling
		break;

	default:
		break;
	}
}

void CGame::DrawOverlay()
{
	// Draw the overlay on top of the base screen
	// This will be filled in when we convert each overlay screen
	switch (m_activeOverlay)
	{
	case OverlayType::Connecting:
		// Draw "Connecting..." message
		break;

	case OverlayType::WaitingResponse:
		// Draw "Waiting for response..." message
		break;

	case OverlayType::LogResMsg:
		// Draw login response message
		break;

	case OverlayType::QueryForceLogin:
		// Draw force login confirmation dialog
		break;

	case OverlayType::QueryDeleteCharacter:
		// Draw delete character confirmation dialog
		break;

	default:
		break;
	}
}

bool CGame::bReadIp()
{
	std::memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, DEF_SERVER_IP);
	m_iLogServerPort = DEF_SERVER_PORT;
	m_iGameServerPort = DEF_GSERVER_PORT;
	return true;
}


void CGame::ReleaseUnusedSprites()
{
	int i;
	for (i = 0; i < DEF_MAXSPRITES; i++)
		if ((m_pSprite[i] != 0))
		{
			if ((m_pSprite[i]->m_bIsSurfaceEmpty == false) && (m_pSprite[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pSprite[i]->m_dwRefTime) > 60000) m_pSprite[i]->Unload();

			}
		}
	for (i = 0; i < DEF_MAXTILES; i++)
		if ((m_pTileSpr[i] != 0))
		{
			if ((m_pTileSpr[i]->m_bIsSurfaceEmpty == false) && (m_pTileSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pTileSpr[i]->m_dwRefTime) > 60000) m_pTileSpr[i]->Unload();
			}
		}
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
		if ((m_pEffectSpr[i] != 0))
		{
			if ((m_pEffectSpr[i]->m_bIsSurfaceEmpty == false) && (m_pEffectSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pEffectSpr[i]->m_dwRefTime) > 60000) m_pEffectSpr[i]->Unload();
			}
		}

	// Stale sound buffer release is now handled by AudioManager::Update()
	AudioManager::Get().Update(G_dwGlobalTime);
}

void CGame::PutChatScrollList(char* pMsg, char cType)
{
	int i;
	if (m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] != 0)
	{
		delete m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1];
		m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] = 0;
	}
	for (i = DEF_MAXCHATSCROLLMSGS - 2; i >= 0; i--)
	{
		m_pChatScrollList[i + 1] = m_pChatScrollList[i];
		m_pChatScrollList[i] = 0;
	}
	m_pChatScrollList[0] = new class CMsg(1, pMsg, cType);
}

void CGame::ChatMsgHandler(char* pData)
{
	int i, iObjectID, iLoc;
	short sX, sY;
	char cMsgType, cName[21], cTemp[100], cMsg[100], cTxt1[100], cTxt2[100];
	uint32_t dwTime;
	bool bFlag;

	char cHeadMsg[200];

	dwTime = m_dwCurTime;

	std::memset(cTxt1, 0, sizeof(cTxt1));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	std::memset(cMsg, 0, sizeof(cMsg));

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandChatMsgHeader>(
		pData, sizeof(hb::net::PacketCommandChatMsgHeader));
	if (!pkt) return;
	iObjectID = static_cast<int>(pkt->header.msg_type);
	sX = pkt->x;
	sY = pkt->y;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, sizeof(pkt->name));
	cMsgType = static_cast<char>(pkt->chat_type);

	if (bCheckExID(cName) == true) return;

	std::memset(cTemp, 0, sizeof(cTemp));
	strcpy(cTemp, pData + sizeof(hb::net::PacketCommandChatMsgHeader));

	if ((cMsgType == 0) || (cMsgType == 2) || (cMsgType == 3))
	{
		if (CMisc::bCheckIMEString(cTemp) == false) return;
	}
	if (!m_bWhisper)
	{
		if (cMsgType == 20) return;
	}
	if (!m_bShout)
	{
		if (cMsgType == 2 || cMsgType == 3) return;
	}

	std::memset(cMsg, 0, sizeof(cMsg));
	wsprintf(cMsg, "%s: %s", cName, cTemp);
	m_Renderer->BeginTextBatch();
	bFlag = false;
	short sCheckByte = 0;
	while (bFlag == false)
	{
		iLoc = CMisc::iGetTextLengthLoc(static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_hDC, cMsg, 305);
		for (int i = 0; i < iLoc; i++) if (cMsg[i] < 0) sCheckByte++;
		if (iLoc == 0)
		{
			PutChatScrollList(cMsg, cMsgType);
			bFlag = true;
		}
		else
		{
			if ((sCheckByte % 2) == 0)
			{
				std::memset(cTemp, 0, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc);
				PutChatScrollList(cTemp, cMsgType);
				std::memset(cTemp, 0, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc);
				std::memset(cMsg, 0, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
			else
			{
				std::memset(cTemp, 0, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc + 1);
				PutChatScrollList(cTemp, cMsgType);
				std::memset(cTemp, 0, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc + 1);
				std::memset(cMsg, 0, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
		}
	}

	m_Renderer->EndTextBatch();

	_RemoveChatMsgListByObjectID(iObjectID);

	const char* cp = pData + sizeof(hb::net::PacketCommandChatMsgHeader);
	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == 0) {
			m_pChatMsgList[i] = new class CMsg(1, (char*)(cp), dwTime);
			m_pChatMsgList[i]->m_iObjectID = iObjectID;

			if (m_pMapData->bSetChatMsgOwner(iObjectID, sX, sY, i) == false) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = 0;
			}

			if ((cMsgType != 0) && (m_dialogBoxManager.IsEnabled(DialogBoxId::ChatHistory) != true)) {
				std::memset(cHeadMsg, 0, sizeof(cHeadMsg));
				wsprintf(cHeadMsg, "%s:%s", cName, cp);
				AddEventList(cHeadMsg, cMsgType);
			}
			return;
		}
}

void CGame::ReleaseTimeoverChatMsg()
{
	int i;
	uint32_t dwTime;
	dwTime = G_dwGlobalTime;
	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0) {

			if ((m_pChatMsgList[i]->m_cType >= 1) && (m_pChatMsgList[i]->m_cType <= 20)) {
				if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
			}
			else
				if ((m_pChatMsgList[i]->m_cType >= 21) && (m_pChatMsgList[i]->m_cType <= 40)) {
					if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_B) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
				}
				else
					if ((m_pChatMsgList[i]->m_cType >= 41) && (m_pChatMsgList[i]->m_cType <= 60)) {
						if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_C) {
							delete m_pChatMsgList[i];
							m_pChatMsgList[i] = 0;
						}
					}
					else if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
		}
}

void CGame::DrawBackground(short sDivX, short sModX, short sDivY, short sModY)
{
	int indexX, indexY, ix, iy;
	short sSpr, sSprFrame;
	if (sDivX < 0 || sDivY < 0) return;
	if ((m_bIsRedrawPDBGS == true) || (m_iPDBGSdivX != sDivX) || (m_iPDBGSdivY != sDivY)) {
		// Pre-Draw Background Surface
		m_bIsRedrawPDBGS = false;
		m_iPDBGSdivX = sDivX;
		m_iPDBGSdivY = sDivY;
		SetRect(&static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_rcClipArea, 0, 0, LOGICAL_WIDTH + 32, LOGICAL_HEIGHT + 32);
		indexY = sDivY + m_pMapData->m_sPivotY;
		for (iy = -sModY; iy < LOGICAL_MAX_Y + 48; iy += 32) // LOGICAL_HEIGHT 
		{
			indexX = sDivX + m_pMapData->m_sPivotX;
			for (ix = -sModX; ix < LOGICAL_MAX_X + 48; ix += 32)
			{
				sSpr = m_pMapData->m_tile[indexX][indexY].m_sTileSprite;
				sSprFrame = m_pMapData->m_tile[indexX][indexY].m_sTileSpriteFrame;
				m_pTileSpr[sSpr]->DrawToSurface(static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lpPDBGS, ix - 16 + sModX, iy - 16 + sModY, sSprFrame, SpriteLib::DrawParams::NoColorKey());
				indexX++;
			}
			indexY++;
		}
		SetRect(&static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_rcClipArea, 0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
	}
	RECT rcRect;
	SetRect(&rcRect, sModX, sModY, LOGICAL_WIDTH + sModX, LOGICAL_HEIGHT + sModY); // our fictitious sprite bitmap is
	static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lpBackB4->BltFast(0, 0, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lpPDBGS, &rcRect, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);

	// Grid overlay removed.

	if (m_bIsCrusadeMode)
	{
		if (m_iConstructLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iConstructLocX * 32 - m_sViewPointX, m_iConstructLocY * 32 - m_sViewPointY, 41);
		if (m_iTeleportLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iTeleportLocX * 32 - m_sViewPointX, m_iTeleportLocY * 32 - m_sViewPointY, 42);
	}
}




bool   CGame::DrawObject_OnRun(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (ConfigManager::Get().GetDetailLevel() == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (4 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 4;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{
			iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 4;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (4 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 4;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{
			iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 4;
		break;

	default:
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;
	int value_2 = 30;
	switch (_tmp_cDir) {
	case 1: dy = value_2 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = value_2 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 3: dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 4: dx = (_tmp_cFrame << 2) + value - value_2; dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 5: dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 6: dy = (_tmp_cFrame << 2) + value - value_2; dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = value_2 - (_tmp_cFrame << 2) - value; dy = value_2 - (_tmp_cFrame << 2) - value; break;
	}


	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->Draw(fix_x, fix_y, _tmp_iEffectFrame, SpriteLib::DrawParams::Alpha(0.5f)); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}

			if (bInv == true)
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(sX+dx, sY+dy, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.5f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f)); // GM effect
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (ConfigManager::Get().GetDetailLevel() != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Shadow());
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2));
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				m_pSprite[iUndiesIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(iR, iG, iB));
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iPantsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0]));
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iArmArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0]));
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBootsIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0]));
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iBodyArmorIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0]));
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iHelmIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0]));
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0]));
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->Draw(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 1: m_pEffectSpr[45]->Draw(fix_x - 13, fix_y - 34, 0, SpriteLib::DrawParams::Alpha(0.5f));
				case 2: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame);
					else m_pSprite[iMantleIndex]->Draw(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0]));
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Alpha(0.25f));
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame);
					else m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::Tint(m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0]));
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_iDrawFlag, 0, 0, 0.7f)); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, m_iDrawFlag, 0, 0.7f)); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, 0, m_iDrawFlag, 0.7f)); break; // Blue Glare
				}
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(0, -5, -5, 0.7f));
		DrawAngel(40 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

		// Centuu : Haste effect
		if ((_tmp_iStatus & 0x40000) != 0) {
			for (int i = 1; i <= 5; i++)
			{
				switch (_tmp_cDir) {
				case 1: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y + (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 2: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x - (i * 5), fix_y + (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 3: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x - (i * 5), fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 4: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x - (i * 5), fix_y - (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 5: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x, fix_y - (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 6: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x + (i * 5), fix_y - (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 7: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x + (i * 5), fix_y, _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				case 8: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->Draw(fix_x + (i * 5), fix_y + (i * 5), _tmp_cFrame, SpriteLib::DrawParams::TintedAlpha(m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), 0.7f)); break;
				}
			}
		}

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

void CGame::GetPlayerTurn()
{
	char cDir;
	short sX, sY, sCnt1, sCnt2;
	int   iError;

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt1 = 0;
	m_cPlayerTurn = 0;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt1++;
		if (sCnt1 > 30) break;
	}

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt2 = 0;
	m_cPlayerTurn = 1;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt2++;
		if (sCnt2 > 30) break;
	}

	if (sCnt1 > sCnt2)
		m_cPlayerTurn = 0;
	else m_cPlayerTurn = 1;
}


int CGame::_iCheckDlgBoxFocus(short msX, short msY, char cButtonSide)
{
	int i;
	char         cDlgID;
	short        sX, sY;
	uint32_t dwTime = m_dwCurTime;
	if (cButtonSide == 1) {
		// Snoopy: 41->61
		for (i = 0; i < 61; i++)
			// Snoopy: 40->60
			if (m_dialogBoxManager.OrderAt(60 - i) != 0) 	// Snoopy: 40->60
			{
				cDlgID = m_dialogBoxManager.OrderAt(60 - i);
				if ((m_dialogBoxManager.Info(cDlgID).sX <= msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) >= msX) &&
					(m_dialogBoxManager.Info(cDlgID).sY <= msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) >= msY))
				{
					m_dialogBoxManager.EnableDialogBox(cDlgID, 0, 0, 0);

					m_stMCursor.sPrevX = msX;
					m_stMCursor.sPrevY = msY;
					m_stMCursor.sDistX = msX - m_dialogBoxManager.Info(cDlgID).sX;
					m_stMCursor.sDistY = msY - m_dialogBoxManager.Info(cDlgID).sY;

					switch (cDlgID) {
					case 1:
						if (bDlgBoxPress_Character(msX, msY) == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:

					case 12:
					case 13:
					case 16:
					case 17:
					case 20:
					case 22:
					case 23:
					case 24:
					case 25:
					case 28:
					case 29:
					case 30:
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
					case 36:
					case 37:
					case 38:
					case 40:
					case 50: // resur
						// NPC
					case 67:
					case 68:
					case 69:
					case 44:
					case 49:
					case 54:
					case 58:
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 2:	// (Sell Item)
						if (bDlgBoxPress_Inventory(msX, msY) == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 10:
						sX = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sY;
						if ((msX >= sX + 340) && (msX <= sX + 360) && (msY >= sY + 22) && (msY <= sY + 138)) {
							m_dialogBoxManager.Info(DialogBoxId::ChatHistory).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::ChatHistory).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 11:
						sX = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sY;
						if ((m_dialogBoxManager.Info(DialogBoxId::SaleMenu).cMode == 0) && (msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 20) && (msY <= sY + 330)) {
							m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bIsScrollSelected = true;
							return -1;
						}

						if ((m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bIsScrollSelected == false)) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 14:
						sX = m_dialogBoxManager.Info(DialogBoxId::Bank).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Bank).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::Bank).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::Bank).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 15:
						sX = m_dialogBoxManager.Info(DialogBoxId::Skill).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Skill).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320))
						{
							m_dialogBoxManager.Info(DialogBoxId::Skill).bIsScrollSelected = true;
							return -1;
						}
						if (m_dialogBoxManager.Info(DialogBoxId::Skill).bIsScrollSelected == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 18:
						sX = m_dialogBoxManager.Info(DialogBoxId::Text).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Text).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::Text).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::Text).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 19:
						sX = m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sY;
						if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY + 122) && (msY <= sY + 138)) {
							m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected = true;
							return -1;
						}
						if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY + 139) && (msY <= sY + 155)) {
							m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 21:
						sX = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::NpcTalk).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::NpcTalk).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 26:
						if (bDlgBoxPress_SkillDlg(msX, msY) == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 27:
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 41: //Snoopy: Drag exchange confirmation dialog
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 42:  // Snoopy: Drag majestic stats
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 51:  // Snoopy: Drag Gail menu
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;
					}
					return 1;
				}
			}
		return 0;
	}
	else if (cButtonSide == 2)
	{
		if ((dwTime - m_dwDialogCloseTime) < 300) return 0;
		// Snoopy: 40->60
		for (i = 0; i < 61; i++)
			// Snoopy: 40->60
			if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
				// Snoopy: 40->60
				cDlgID = m_dialogBoxManager.OrderAt(60 - i);
				if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
					(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
				{
					if ((cDlgID != 5) && (cDlgID != 6) && (cDlgID != 8) && (cDlgID != 12) && ((cDlgID != 23) || (m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode < 3)) && (cDlgID != 24) && (cDlgID != 27) && (cDlgID != 34) &&
						(cDlgID != 33) && !((cDlgID == 32) && ((m_dialogBoxManager.Info(cDlgID).cMode == 1) || (m_dialogBoxManager.Info(cDlgID).cMode == 3))))
						m_dialogBoxManager.DisableDialogBox(cDlgID);
					m_dwDialogCloseTime = dwTime;
					return 1;
				}
			}
	}
	return 0;
}



void CGame::InitItemList(char* pData)
{
	int     i, iAngelValue;
	uint8_t cTotalItems;
	const char* cp;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_cItemOrder[i] = -1;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		m_sItemEquipmentStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_bIsItemDisabled[i] = false;

	const auto* header = hb::net::PacketCast<hb::net::PacketResponseItemListHeader>(
		pData, sizeof(hb::net::PacketResponseItemListHeader));
	if (!header) return;
	cTotalItems = header->item_count;
	cp = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseItemListHeader);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	const auto* itemEntries = reinterpret_cast<const hb::net::PacketResponseItemListEntry*>(cp);
	for (i = 0; i < cTotalItems; i++)
	{
		const auto& entry = itemEntries[i];
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, entry.name, 20);
		m_pItemList[i]->m_dwCount = entry.count;
		m_pItemList[i]->m_sX = 40;
		m_pItemList[i]->m_sY = 30;
		m_pItemList[i]->m_cItemType = entry.item_type;
		m_pItemList[i]->m_cEquipPos = entry.equip_pos;
		if (entry.is_equipped == 0) m_bIsItemEquipped[i] = false;
		else m_bIsItemEquipped[i] = true;
		if (m_bIsItemEquipped[i] == true)
		{
			m_sItemEquipmentStatus[m_pItemList[i]->m_cEquipPos] = i;
		}
		m_pItemList[i]->m_sLevelLimit = entry.level_limit;
		m_pItemList[i]->m_cGenderLimit = entry.gender_limit;
		m_pItemList[i]->m_wCurLifeSpan = entry.cur_lifespan;
		m_pItemList[i]->m_wWeight = entry.weight;
		m_pItemList[i]->m_sSprite = entry.sprite;
		m_pItemList[i]->m_sSpriteFrame = entry.sprite_frame;
		m_pItemList[i]->m_cItemColor = entry.item_color;
		m_pItemList[i]->m_sItemSpecEffectValue2 = static_cast<short>(entry.spec_value2); // v1.41
		m_pItemList[i]->m_dwAttribute = entry.attribute;
		m_pItemList[i]->m_sIDnum = entry.item_id;
		m_pItemList[i]->m_wMaxLifeSpan = entry.max_lifespan;
		/*
		m_pItemList[i]->m_bIsCustomMade = (bool)*cp;
		cp++;
		*/
		// Populate display name from the shared item display name map
		m_pItemList[i]->PopulateDisplayName();
		m_cItemOrder[i] = i;
		// Snoopy: Add Angelic Stats
		if ((m_pItemList[i]->m_cItemType == 1)
			&& (m_bIsItemEquipped[i] == true)
			&& (m_pItemList[i]->m_cEquipPos >= 11))
		{
			if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicStr = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicDex = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicInt = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicMag = 1 + iAngelValue;
			}
		}
	}

	cp = reinterpret_cast<const char*>(itemEntries + cTotalItems);
	cTotalItems = static_cast<uint8_t>(*cp);
	cp++;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	const auto* bankEntries = reinterpret_cast<const hb::net::PacketResponseBankItemEntry*>(cp);
	for (i = 0; i < cTotalItems; i++)
	{
		const auto& entry = bankEntries[i];
		m_pBankList[i] = new class CItem;
		memcpy(m_pBankList[i]->m_cName, entry.name, 20);
		m_pBankList[i]->m_dwCount = entry.count;

		m_pBankList[i]->m_sX = 40;
		m_pBankList[i]->m_sY = 30;

		m_pBankList[i]->m_cItemType = entry.item_type;
		m_pBankList[i]->m_cEquipPos = entry.equip_pos;
		m_pBankList[i]->m_sLevelLimit = entry.level_limit;
		m_pBankList[i]->m_cGenderLimit = entry.gender_limit;
		m_pBankList[i]->m_wCurLifeSpan = entry.cur_lifespan;
		m_pBankList[i]->m_wWeight = entry.weight;
		m_pBankList[i]->m_sSprite = entry.sprite;
		m_pBankList[i]->m_sSpriteFrame = entry.sprite_frame;
		m_pBankList[i]->m_cItemColor = entry.item_color;
		m_pBankList[i]->m_sItemSpecEffectValue2 = static_cast<short>(entry.spec_value2); // v1.41
		m_pBankList[i]->m_dwAttribute = entry.attribute;
		m_pBankList[i]->m_sIDnum = entry.item_id;
		m_pBankList[i]->m_wMaxLifeSpan = entry.max_lifespan;
		/*
		m_pBankList[i]->m_bIsCustomMade = (bool)*cp;
		cp++;
		*/
		// Populate display name from the shared item display name map
		m_pBankList[i]->PopulateDisplayName();
	}

	cp = reinterpret_cast<const char*>(bankEntries + cTotalItems);
	// Magic, Skill Mastery
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	{
		m_cMagicMastery[i] = *cp;
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	{
		m_cSkillMastery[i] = (unsigned char)*cp;
		if (m_pSkillCfgList[i] != 0)
			m_pSkillCfgList[i]->m_iLevel = (int)*cp;
		cp++;
	}
}

void CGame::DrawDialogBoxs(short msX, short msY, short msZ, char cLB)
{
	int i;
	if (m_bIsObserverMode == true) return;
	// Note: Dialogs that handle scroll should read InputManager::Get().GetWheelDelta() and clear it after processing
	//Snoopy: 41->61
	bool bIconPanelDrawn = false;
	for (i = 0; i < 61; i++)
		if (m_dialogBoxManager.OrderAt(i) != 0)
		{
			switch (m_dialogBoxManager.OrderAt(i)) {
			case DialogBoxId::CharacterInfo:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CharacterInfo))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Inventory:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Inventory))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Magic:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Magic))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemDropConfirm:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropConfirm))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::WarningBattleArea:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::WarningBattleArea))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuildMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuildOperation:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildOperation))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuideMap:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuideMap))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ChatHistory:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ChatHistory))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SaleMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SaleMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::LevelUpSetting:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::LevelUpSetting))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CityHallMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CityHallMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Bank:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Bank))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Skill:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Skill))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::MagicShop:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::MagicShop))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemDropExternal:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropExternal))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Text:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Text))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SystemMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SystemMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::NpcActionQuery:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcActionQuery))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::NpcTalk:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcTalk))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Map:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Map))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SellOrRepair:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellOrRepair))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Fishing:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Fishing))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Noticement:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Noticement))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Manufacture:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Manufacture))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Exchange:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Exchange))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Quest:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Quest))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::HudPanel:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				bIconPanelDrawn = true;
				break;
			case DialogBoxId::SellList:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellList))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Party:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Party))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CrusadeJob:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeJob))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemUpgrade:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemUpgrade))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Help:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Help))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CrusadeCommander:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeCommander))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CrusadeConstructor:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeConstructor))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CrusadeSoldier:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeSoldier))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Slates:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Slates))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ConfirmExchange:	//Snoopy: Confirmation Exchange
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ConfirmExchange))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ChangeStatsMajestic:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ChangeStatsMajestic))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Resurrect: // Snoopy: Resurection?
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Resurrect))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuildHallMenu: // Gail
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuildHallMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::RepairAll: //50Cent - Repair All
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::RepairAll))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			}
		}
	if (bIconPanelDrawn == false)
	{
		if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
			pDlg->OnDraw(msX, msY, msZ, cLB);
	}
	int resy = 0;
	int resx = 0;
	short iconX = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX;
	short iconY = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY;
	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
	{
		if (m_iSuperAttackLeft > 0)
		{
			if (InputManager::Get().IsAltDown())
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->Draw(iconX + 368 + resx + 7, iconY + 440 + resy, 3, SpriteLib::DrawParams::Alpha(0.5f));
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(iconX + 380 + resx + 10 - 5, iconY + 454 + resy, G_cTxt, 255, 255, 255);
		}
	}
	else
	{
		if (m_iSuperAttackLeft > 0)
		{
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont(iconX + 380 + resx + 10 - 5, iconY + 454 + resy, G_cTxt, 10, 10, 10);
		}
	}
}

void CGame::_Draw_CharacterBody(short sX, short sY, short sType)
{
	uint32_t dwTime = m_dwCurTime;
	int  iR, iG, iB;

	if (sType <= 3)
	{
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->Draw(sX, sY, sType - 1);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->Draw(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, SpriteLib::DrawParams::Tint(iR, iG, iB));

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->Draw(sX, sY, (_tmp_sAppr1 & 0x000F));
	}
	else
	{
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->Draw(sX, sY, sType - 4);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 + 40]->Draw(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, SpriteLib::DrawParams::Tint(iR, iG, iB));
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 + 40]->Draw(sX, sY, (_tmp_sAppr1 & 0x000F));
	}
}


void CGame::EnableDialogBox(int iBoxID, int cType, int sV1, int sV2, char* pString)
{
	int i;
	short sX, sY;

	switch (iBoxID) {
	case DialogBoxId::RepairAll: //50Cent - Repair all
		m_dialogBoxManager.Info(DialogBoxId::RepairAll).cMode = cType;
		break;
	case DialogBoxId::SaleMenu:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) == false)
		{
			switch (cType) {
			case 0:
				break;
			default:
				// Check if shop items are already loaded (called from ResponseShopContentsHandler)
				if (m_pItemForSaleList[0] != nullptr) {
					// Items already loaded - just show the dialog
					m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV1 = cType;
					m_dialogBoxManager.Info(DialogBoxId::SaleMenu).cMode = 0;
					m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sView = 0;
					m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bFlag = true;
					m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV3 = 1;
				} else {
					// Request contents from server - dialog will be shown when response arrives
					m_sPendingShopType = cType;
					_LoadShopMenuContents(cType);
				}
				break;
			}
		}
		break;

	case DialogBoxId::LevelUpSetting: // levelup diag
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sV1 = m_iLU_Point;
		}
		break;

	case DialogBoxId::Magic: // Magic Dialog
		break;

	case DialogBoxId::ItemDropConfirm:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == false) {
			m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sView = cType;
		}
		break;

	case DialogBoxId::WarningBattleArea:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::WarningBattleArea) == false) {
			m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sView = cType;
		}
		break;

	case DialogBoxId::GuildMenu:
		if (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1) {
			sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
		}
		break;

	case DialogBoxId::ItemDropExternal: // demande quantit�
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == false)
		{
			m_dialogBoxManager.Info(iBoxID).cMode = 1;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView = cType;
			EndInputString();
			std::memset(m_cAmountString, 0, sizeof(m_cAmountString));
			wsprintf(m_cAmountString, "%d", sV1);
			sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
			StartInputString(sX + 40, sY + 57, 11, m_cAmountString, false);
		}
		else
		{
			if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1)
			{
				sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
				sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
				EndInputString();
				StartInputString(sX + 40, sY + 57, 11, m_cAmountString, false);
			}
		}
		break;

	case DialogBoxId::Text:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Text) == false)
		{
			switch (cType) {
			case 0:
				m_dialogBoxManager.Info(DialogBoxId::Text).cMode = 0;
				m_dialogBoxManager.Info(DialogBoxId::Text).sView = 0;
				break;
			default:
				_LoadTextDlgContents(cType);
				m_dialogBoxManager.Info(DialogBoxId::Text).cMode = 0;
				m_dialogBoxManager.Info(DialogBoxId::Text).sView = 0;
				break;
			}
		}
		break;

	case DialogBoxId::SystemMenu:
		break;

	case DialogBoxId::NpcActionQuery: // Talk to npc or unicorn
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1] = false;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV1 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV2 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV3 =
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV4 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV5 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV6 = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV2 = sV2;
		}
		break;

	case DialogBoxId::NpcTalk:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcTalk) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV1 = _iLoadTextDlgContents2(sV1 + 20);
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV2 = sV1 + 20;
		}
		break;

	case DialogBoxId::Map:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Map) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Map).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Map).sV2 = sV2;

			m_dialogBoxManager.Info(DialogBoxId::Map).sSizeX = 290;
			m_dialogBoxManager.Info(DialogBoxId::Map).sSizeY = 290;
		}
		break;

	case DialogBoxId::SellOrRepair:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) {
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1 = sV1;		// ItemID
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV2 = sV2;
			if (cType == 2)
			{
				m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sX;
				m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sY;
			}
		}
		break;

	case DialogBoxId::Skill:
		break;

	case DialogBoxId::Fishing:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Fishing) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Fishing).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Fishing).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Fishing).sV2 = sV2;
			m_bSkillUsingStatus = true;
		}
		break;

	case DialogBoxId::Noticement:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Noticement) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Noticement).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Noticement).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Noticement).sV2 = sV2;
		}
		break;

	case DialogBoxId::Manufacture:
		switch (cType) {
		case DialogBoxId::CharacterInfo:
		case DialogBoxId::Inventory: //
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_bSkillUsingStatus = true;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 195;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 215;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;

		case DialogBoxId::Magic:	//
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = 0;
				m_bSkillUsingStatus = true;
				_bCheckBuildItemStatus();
				//m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX = 0;
				//m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 270;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 381;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;

		case DialogBoxId::WarningBattleArea:
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[2] = sV1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[3] = sV2;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 270;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 381;
				m_bSkillUsingStatus = true;
				_bCheckBuildItemStatus();
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;
			// Crafting
		case DialogBoxId::GuildMenu:
		case DialogBoxId::GuildOperation:
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_bSkillUsingStatus = true;
				//_bCheckCraftItemStatus();
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 195;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 215;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;
		}
		break;

	case DialogBoxId::Exchange: // Snoopy: 7 mar 06 (multitrade) case rewriten
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Exchange).cMode = cType;
			for (i = 0; i < 8; i++)
			{
				std::memset(m_stDialogBoxExchangeInfo[i].cStr1, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
				std::memset(m_stDialogBoxExchangeInfo[i].cStr2, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
				m_stDialogBoxExchangeInfo[i].sV1 = -1;
				m_stDialogBoxExchangeInfo[i].sV2 = -1;
				m_stDialogBoxExchangeInfo[i].sV3 = -1;
				m_stDialogBoxExchangeInfo[i].sV4 = -1;
				m_stDialogBoxExchangeInfo[i].sV5 = -1;
				m_stDialogBoxExchangeInfo[i].sV6 = -1;
				m_stDialogBoxExchangeInfo[i].sV7 = -1;
				m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			}
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		}
		break;

	case DialogBoxId::ConfirmExchange: // Snoopy: 7 mar 06 (MultiTrade) Confirmation dialog
		break;

	case DialogBoxId::Quest:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Quest) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Quest).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Quest).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::Quest).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
		}
		break;

	case DialogBoxId::Party:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Party) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Party).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::Party).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
		}
		break;

	case DialogBoxId::CrusadeJob:
		if ((m_iHP <= 0) || (m_bCitizen == false)) return;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::CrusadeJob) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sX = 360 + SCREENX;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sY = 65 + SCREENY;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sV1 = sV1;
		}
		break;

	case DialogBoxId::ItemUpgrade:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
		}
		else if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == false)
		{
			int iSoX, iSoM;
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pItemList[i] != 0)
				{
					if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
					if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
				}
			if ((iSoX > 0) || (iSoM > 0))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 6; // Stone upgrade
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV2 = iSoX;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV3 = iSoM;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
			}
			else if (m_iGizonItemUpgradeLeft > 0)
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
			}
			else
			{
				AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10); // "Stone of Xelima or Merien is not present."
				return;
			}
		}
		break;

	case DialogBoxId::MagicShop:
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			if (m_cSkillMastery[4] == 0) {
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::MagicShop);
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, 0, 480, 0);
				return;
			}
			else {
				m_dialogBoxManager.Info(iBoxID).cMode = 0;
				m_dialogBoxManager.Info(iBoxID).sView = 0;
			}
		}
		break;

	case DialogBoxId::Bank:
		EndInputString();
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			m_dialogBoxManager.Info(iBoxID).cMode = 0;
			m_dialogBoxManager.Info(iBoxID).sView = 0;
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Inventory, 0, 0, 0);
		}
		break;

	case DialogBoxId::Slates: // Slates
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Slates) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Slates).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV5 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV6 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[1] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[4] = 0;

			m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeX = 180;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeY = 183;

			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		}
		break;
	case DialogBoxId::ChangeStatsMajestic: // Diuuude: Change stats window
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ChangeStatsMajestic) == false) {
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX = m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sX + 10;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY = m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sY + 10;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).cMode = 0;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sView = 0;
			m_bSkillUsingStatus = false;
		}
		break;
	case DialogBoxId::Resurrect: // Snoopy: Resurection
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Resurrect) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sX = 185;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sY = 100;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).cMode = 0;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sView = 0;
			m_bSkillUsingStatus = false;
		}
		break;

	default:
		EndInputString();
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			m_dialogBoxManager.Info(iBoxID).cMode = 0;
			m_dialogBoxManager.Info(iBoxID).sView = 0;
		}
		break;
	}
	if (iBoxID != 30)
	{
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false)
		{
			int tmpx = 720;
			int tmpy = 520;
			if (m_dialogBoxManager.Info(iBoxID).sY > tmpy) m_dialogBoxManager.Info(iBoxID).sY = tmpy + 10;
			if (m_dialogBoxManager.Info(iBoxID).sX > tmpx) m_dialogBoxManager.Info(iBoxID).sX = tmpx;
			if ((m_dialogBoxManager.Info(iBoxID).sX + m_dialogBoxManager.Info(iBoxID).sSizeX) < 10) m_dialogBoxManager.Info(iBoxID).sX += 20;
			if ((m_dialogBoxManager.Info(iBoxID).sY + m_dialogBoxManager.Info(iBoxID).sSizeY) < 10) m_dialogBoxManager.Info(iBoxID).sY += 20;
		}
	}
	m_dialogBoxManager.SetEnabled(iBoxID, true);
	if (pString != 0) strcpy(m_dialogBoxManager.Info(iBoxID).cStr, pString);
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == iBoxID) m_dialogBoxManager.SetOrderAt(i, 0);
	//Snoopy: 39->59
	for (i = 1; i < 59; i++)
		if ((m_dialogBoxManager.OrderAt(i - 1) == 0) && (m_dialogBoxManager.OrderAt(i) != 0)) {
			m_dialogBoxManager.SetOrderAt(i - 1, m_dialogBoxManager.OrderAt(i));
			m_dialogBoxManager.SetOrderAt(i, 0);
		}
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == 0) {
			m_dialogBoxManager.SetOrderAt(i, static_cast<char>(iBoxID));
			return;
		}
}

void CGame::DisableDialogBox(int iBoxID)
{
	int i;

	switch (iBoxID) {
	case DialogBoxId::ItemDropConfirm:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sView] = false;
		break;

	case DialogBoxId::WarningBattleArea:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sView] = false;
		break;

	case DialogBoxId::GuildMenu:
		if (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1)
			EndInputString();
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
		break;

	case DialogBoxId::SaleMenu:
		for (i = 0; i < DEF_MAXMENUITEMS; i++)
			if (m_pItemForSaleList[i] != 0) {
				delete m_pItemForSaleList[i];
				m_pItemForSaleList[i] = 0;
			}
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 0;
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = 0; // v1.4
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = 0;
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = 0;
		break;

	case DialogBoxId::Bank:
		if (m_dialogBoxManager.Info(DialogBoxId::Bank).cMode < 0) return;
		break;

	case DialogBoxId::ItemDropExternal:
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1) {
			EndInputString();
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = false;
		}
		break;

	case DialogBoxId::NpcActionQuery: // v1.4
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1] = false;
		break;

	case DialogBoxId::NpcTalk:
		if (m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV2 == 500)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GETMAGICABILITY, 0, 0, 0, 0, 0);
		}
		break;

	case DialogBoxId::Fishing:
		m_bSkillUsingStatus = false;
		break;

	case DialogBoxId::Manufacture:
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] = false;
		m_bSkillUsingStatus = false;
		break;

	case DialogBoxId::Exchange: //Snoopy: 7 mar 06 (multiTrade) case rewriten
		for (i = 0; i < 8; i++)
		{
			std::memset(m_stDialogBoxExchangeInfo[i].cStr1, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
			std::memset(m_stDialogBoxExchangeInfo[i].cStr2, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
			m_stDialogBoxExchangeInfo[i].sV1 = -1;
			m_stDialogBoxExchangeInfo[i].sV2 = -1;
			m_stDialogBoxExchangeInfo[i].sV3 = -1;
			m_stDialogBoxExchangeInfo[i].sV4 = -1;
			m_stDialogBoxExchangeInfo[i].sV5 = -1;
			m_stDialogBoxExchangeInfo[i].sV6 = -1;
			m_stDialogBoxExchangeInfo[i].sV7 = -1;
			m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			if (m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] == true)
				m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] = false;
		}
		break;


	case DialogBoxId::SellList:
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		{
			if (m_stSellItemList[i].iIndex != -1) m_bIsItemDisabled[m_stSellItemList[i].iIndex] = false;
			m_stSellItemList[i].iIndex = -1;
			m_stSellItemList[i].iAmount = 0;
		}
		break;

	case DialogBoxId::ItemUpgrade:
		if (m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 != -1)
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		break;

	case DialogBoxId::Slates:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV1] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV2] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV3] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV4] = false;

		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr2, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr2));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr3, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr3));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr4, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr4));
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV5 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV6 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV9 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV10 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV11 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV12 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV13 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV14 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).dwV1 = 0;
		m_dialogBoxManager.Info(DialogBoxId::Slates).dwV2 = 0;
		break;

	case DialogBoxId::ChangeStatsMajestic:
		cStateChange1 = 0;
		cStateChange2 = 0;
		cStateChange3 = 0;
		/*	m_cLU_Str = 0;
			m_cLU_Vit = 0;
			m_cLU_Dex = 0;
			m_cLU_Int = 0;
			m_cLU_Mag = 0;
			m_cLU_Char = 0;*/
		break;

	}

	// Call OnDisable for migrated dialogs
	if (auto* pDlg = m_dialogBoxManager.GetDialogBox(iBoxID))
		pDlg->OnDisable();

	m_dialogBoxManager.SetEnabled(iBoxID, false);
	// Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == iBoxID)
			m_dialogBoxManager.SetOrderAt(i, 0);

	// Snoopy: 39->59
	for (i = 1; i < 59; i++)
		if ((m_dialogBoxManager.OrderAt(i - 1) == 0) && (m_dialogBoxManager.OrderAt(i) != 0))
		{
			m_dialogBoxManager.SetOrderAt(i - 1, m_dialogBoxManager.OrderAt(i));
			m_dialogBoxManager.SetOrderAt(i, 0);
		}
}


int CGame::iGetTopDialogBoxIndex()
{
	int i;
	//Snoopy: 38->58
	for (i = 58; i >= 0; i--)
		if (m_dialogBoxManager.OrderAt(i) != 0)
			return m_dialogBoxManager.OrderAt(i);

	return 0;
}

void CGame::DrawChatMsgs(short sX, short sY, short dX, short dY)
{
	int i;

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY)) {

				switch (m_pChatMsgList[i]->m_cType) {
				case 41:
				case 42:
				case 21:
				case 22:
				case 23:
					DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, false);
					break;
				}
			}

	m_Renderer->BeginTextBatch();
	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY)) {

				switch (m_pChatMsgList[i]->m_cType) {
				case 41:
				case 42:
				case 21:
				case 22:
				case 23:
					break;

				case 20:
				default:
					DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, true);
					break;
				}
			}
	m_Renderer->EndTextBatch();
}



void CGame::_LoadTextDlgContents(int cType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	// cType
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else
	{
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0)
	{
		m_pMsgTextList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
}



int CGame::_iLoadTextDlgContents2(int iType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;
	}
	// cType
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", iType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");
	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return -1;
	else
	{
		pContents = new char[dwFileSize + 1];
		if (pContents == 0) return -1;
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0)
	{
		m_pMsgTextList2[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
	return iIndex;
}




void CGame::_LoadGameMsgTextContents()
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = ";\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;

	for (i = 0; i < DEF_MAXGAMEMSGS; i++) {
		if (m_pGameMsgList[i] != 0)
			delete m_pGameMsgList[i];
		m_pGameMsgList[i] = 0;
	}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	strcpy(cTemp, "GameMsgList");

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);

	token = strtok(pContents, seps);
	while (token != 0) {
		m_pGameMsgList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}

	delete[] pContents;
}


void CGame::_RequestMapStatus(char* pMapName, int iMode)
{
	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_MAPSTATUS, 0, iMode, 0, 0, pMapName);
}

void CGame::AddMapStatusInfo(char* pData, bool bIsLastData)
{
	char cTotal;
	short sIndex;
	int i;

	std::memset(m_cStatusMapName, 0, sizeof(m_cStatusMapName));

	const auto* header = hb::net::PacketCast<hb::net::PacketNotifyMapStatusHeader>(
		pData, sizeof(hb::net::PacketNotifyMapStatusHeader));
	if (!header) return;
	memcpy(m_cStatusMapName, header->map_name, sizeof(header->map_name));
	sIndex = header->index;
	cTotal = header->total;

	const auto* entries = reinterpret_cast<const hb::net::PacketNotifyMapStatusEntry*>(header + 1);

	for (i = 1; i <= cTotal; i++) {
		m_stCrusadeStructureInfo[sIndex].cType = entries->type;
		m_stCrusadeStructureInfo[sIndex].sX = entries->x;
		m_stCrusadeStructureInfo[sIndex].sY = entries->y;
		m_stCrusadeStructureInfo[sIndex].cSide = entries->side;
		entries++;

		sIndex++;
	}

	if (bIsLastData == true) {
		while (sIndex < DEF_MAXCRUSADESTRUCTURES) {
			m_stCrusadeStructureInfo[sIndex].cType = 0;
			m_stCrusadeStructureInfo[sIndex].sX = 0;
			m_stCrusadeStructureInfo[sIndex].sY = 0;
			m_stCrusadeStructureInfo[sIndex].cSide = 0;
			sIndex++;
		}
	}
}

bool CGame::GetText(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	int len;
	HIMC hIMC = 0;
	if (m_pInputBuffer == 0) return false;
	switch (msg) {
	case WM_IME_COMPOSITION:
		std::memset(m_cEdit, 0, sizeof(m_cEdit));
		if (lparam & GCS_RESULTSTR)
		{
			hIMC = ImmGetContext(hWnd);
			len = ImmGetCompositionString(hIMC, GCS_RESULTSTR, 0, 0);
			if (len > 4) len = 4;
			ImmGetCompositionString(hIMC, GCS_RESULTSTR, m_cEdit, len);
			ImmReleaseContext(hWnd, hIMC);
			len = strlen(m_pInputBuffer) + strlen(m_cEdit);
			if (len < m_cInputMaxLen) strcpy(m_pInputBuffer + strlen(m_pInputBuffer), m_cEdit);
			std::memset(m_cEdit, 0, sizeof(m_cEdit));
		}
		else if (lparam & GCS_COMPSTR)
		{
			hIMC = ImmGetContext(hWnd);
			len = ImmGetCompositionString(hIMC, GCS_COMPSTR, 0, 0);
			if (len > 4) len = 4;
			ImmGetCompositionString(hIMC, GCS_COMPSTR, m_cEdit, len);
			ImmReleaseContext(hWnd, hIMC);
			len = strlen(m_pInputBuffer) + strlen(m_cEdit);
			if (len >= m_cInputMaxLen) std::memset(m_cEdit, 0, sizeof(m_cEdit));
		}
		return true;

	case WM_CHAR:
		if (wparam == 8)
		{
			if (strlen(m_pInputBuffer) > 0)
			{
				len = strlen(m_pInputBuffer);
				switch (GetCharKind(m_pInputBuffer, len - 1)) {
				case 1:
					m_pInputBuffer[len - 1] = 0;
					break;
				case 2:
				case 3:
					m_pInputBuffer[len - 2] = 0;
					m_pInputBuffer[len - 1] = 0;
					break;
				}
				std::memset(m_cEdit, 0, sizeof(m_cEdit));
			}
		}
		else if ((wparam != 9) && (wparam != 13) && (wparam != 27))
		{
			len = strlen(m_pInputBuffer);
			if (len >= m_cInputMaxLen - 1) return false;
			m_pInputBuffer[len] = wparam & 0xff;
			m_pInputBuffer[len + 1] = 0;
		}
		return true;
	}
	return false;
}

int CGame::GetCharKind(char* str, int index)
{
	int kind = 1;
	do
	{
		if (kind == 2) kind = 3;
		else
		{
			if ((unsigned char)*str < 128) kind = 1;
			else kind = 2;
		}
		str++;
		index--;
	} while (index >= 0);
	return kind;
}

void CGame::ShowReceivedString(bool bIsHide)
{
	// Safety check: m_pInputBuffer may not be initialized yet
	if (m_pInputBuffer == nullptr) return;

	std::memset(G_cTxt, 0, sizeof(G_cTxt));

	strcpy(G_cTxt, m_pInputBuffer);
	if ((m_cEdit[0] != 0) && (strlen(m_pInputBuffer) + strlen(m_cEdit) + 1 <= m_cInputMaxLen))
	{
		strcpy(G_cTxt + strlen(m_pInputBuffer), m_cEdit);
	}

	if (bIsHide == true)
	{
		for (unsigned char i = 0; i < strlen(G_cTxt); i++)
			if (G_cTxt[i] != 0) G_cTxt[i] = '*';
	}

	if ((G_dwGlobalTime % 400) < 210) G_cTxt[strlen(G_cTxt)] = '_';

	PutString(m_iInputX + 1, m_iInputY + 1, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX, m_iInputY + 1, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX + 1, m_iInputY, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX, m_iInputY, G_cTxt, RGB(255, 255, 255));
}

void CGame::ClearInputString()
{
	if (m_pInputBuffer != 0)	std::memset(m_pInputBuffer, 0, sizeof(m_pInputBuffer));
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
}

void CGame::StartInputString(int sX, int sY, unsigned char iLen, char* pBuffer, bool bIsHide)
{
	m_bInputStatus = true;
	m_iInputX = sX;
	m_iInputY = sY;
	m_pInputBuffer = pBuffer;
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
	m_cInputMaxLen = iLen;
}

void CGame::EndInputString()
{
	m_bInputStatus = false;
	int len = strlen(m_cEdit);
	if (len > 0)
	{
		m_cEdit[len] = 0;
		strcpy(m_pInputBuffer + strlen(m_pInputBuffer), m_cEdit);
		std::memset(m_cEdit, 0, sizeof(m_cEdit));
	}
}

void CGame::ReceiveString(char* pString)
{
	strcpy(pString, m_pInputBuffer);
}

void CGame::DrawNewDialogBox(char cType, int sX, int sY, int iFrame, bool bIsNoColorKey, bool bIsTrans)
{
	uint32_t dwTime = G_dwGlobalTime;

	if (m_pSprite[cType] == 0) return;
	if (bIsNoColorKey == false)
	{
		if (bIsTrans == true)
			m_pSprite[cType]->Draw(sX, sY, iFrame, SpriteLib::DrawParams::Alpha(0.25f));
		else m_pSprite[cType]->Draw(sX, sY, iFrame);
	}
	else m_pSprite[cType]->Draw(sX, sY, iFrame, SpriteLib::DrawParams::NoColorKey());
}

void CGame::SetCameraShakingEffect(short sDist, int iMul)
{
	int iDegree;

	iDegree = 5 - sDist;
	if (iDegree <= 0) iDegree = 0;
	iDegree *= 2;

	if (iMul != 0) iDegree *= iMul;

	if (iDegree <= 2) return;

	m_iCameraShakingDegree = iDegree;
}

void CGame::MeteorStrikeComing(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[0]->m_pMsg, 5);
		break;
	case 2: //
		SetTopMsg(m_pGameMsgList[10]->m_pMsg, 10);
		break;
	case 3: //
		SetTopMsg(m_pGameMsgList[91]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[11]->m_pMsg, 10);
		break;
	}
}

void CGame::DrawObjectFOE(int ix, int iy, int iFrame)
{
	if (_iGetFOE(_tmp_iStatus) < 0) // red crusade circle
	{
		if (iFrame <= 4) m_pEffectSpr[38]->Draw(ix, iy, iFrame, SpriteLib::DrawParams::Alpha(0.5f));
	}
}

void CGame::SetTopMsg(char* pString, unsigned char iLastSec)
{
	std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	strcpy(m_cTopMsg, pString);

	m_iTopMsgLastSec = iLastSec;
	m_dwTopMsgTime = G_dwGlobalTime;
}

void CGame::DrawTopMsg()
{
	if (strlen(m_cTopMsg) == 0) return;
	m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, 30);

	if ((((G_dwGlobalTime - m_dwTopMsgTime) / 250) % 2) == 0)
		PutAlignedString(0, LOGICAL_MAX_X, 10, m_cTopMsg, 255, 255, 0);

	if (G_dwGlobalTime > (m_iTopMsgLastSec * 1000 + m_dwTopMsgTime)) {
		std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	}
}

void CGame::CannotConstruct(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[18]->m_pMsg, 5);
		break;

	case 2: //
		wsprintf(G_cTxt, "%s XY(%d, %d)", m_pGameMsgList[19]->m_pMsg, m_iConstructLocX, m_iConstructLocY);
		SetTopMsg(G_cTxt, 5);
		break;

	case 3: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;

	}
}

void CGame::DisplayCommaNumber_G_cTxt(uint32_t iGold)
{
	char cGold[20];
	int iStrLen;
	std::memset(cGold, 0, sizeof(cGold));
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	ltoa(iGold, cGold, 10);
#ifdef DEF_COMMA_GOLD
	iStrLen = strlen(cGold);
	iStrLen--;
	int cnt = 0;
	for (int i = 0; i < iStrLen + 1; i++)
	{
		if ((cnt != 0) && ((cnt + 1) % 4 == 0))
		{
			G_cTxt[cnt] = ',';
			i--;
		}
		else G_cTxt[cnt] = cGold[iStrLen - i];
		cnt++;
	}
	iStrLen = strlen(G_cTxt);
	G_cTxt[iStrLen] = '\0';
	strrev(G_cTxt);
#else
	strcpy(G_cTxt, cGold);
#endif
}

void CGame::CrusadeContributionResult(int iWarContribution)
{
	int i;
	char cTemp[120];
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (iWarContribution > 0)
	{
		PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[22]->m_pMsg, 0); // Congratulations! Your nation
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[23]->m_pMsg, 0); // was victory in the battle!
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, m_pGameMsgList[24]->m_pMsg, 0); // As a victorious citizen
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[25]->m_pMsg, 0); // You will receive
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[26]->m_pMsg, 0); // a prize
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[27]->m_pMsg, 0); // Experience point of the battle contribution:
		std::memset(cTemp, 0, sizeof(cTemp));											//
		wsprintf(cTemp, "+%dExp Points!", iWarContribution);
		m_pMsgTextList[8] = new class CMsg(0, cTemp, 0);
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);

	}
	else if (iWarContribution < 0)
	{
		PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[28]->m_pMsg, 0); // Unfortunately! Your country
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[29]->m_pMsg, 0); // have lost the all out war.
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, m_pGameMsgList[30]->m_pMsg, 0); // As a losser citizen;
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[31]->m_pMsg, 0); // the prize that accomplishes
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[32]->m_pMsg, 0); // will not be given.
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[33]->m_pMsg, 0); // I hope you to win
		m_pMsgTextList[8] = new class CMsg(0, m_pGameMsgList[34]->m_pMsg, 0); // in the next battle
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else if (iWarContribution == 0)
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[50]->m_pMsg, 0); // The battle that you have participated
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[51]->m_pMsg, 0); // is already finished;
		m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[52]->m_pMsg, 0); //
		m_pMsgTextList[3] = new class CMsg(0, " ", 0);
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[53]->m_pMsg, 0); // You must connect after finishing
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[54]->m_pMsg, 0); // the previous and before starting
		m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[55]->m_pMsg, 0); // the next battle so you can receive
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[56]->m_pMsg, 0); // the prize
		for (i = 8; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
}


void CGame::CrusadeWarResult(int iWinnerSide)
{
	int i, iPlayerSide;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (m_bCitizen == false) iPlayerSide = 0;
	else if (m_bAresden == true) iPlayerSide = 1;
	else if (m_bAresden == false) iPlayerSide = 2;
	if (iPlayerSide == 0)
	{
		switch (iWinnerSide) {
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[36]->m_pMsg, 0); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[37]->m_pMsg, 0); // battle
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		}
		for (i = 4; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (iWinnerSide == 0)
		{
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[36]->m_pMsg, 0); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[37]->m_pMsg, 0); // battle
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			for (i = 4; i < 18; i++)
				m_pMsgTextList[i] = new class CMsg(0, " ", 0);
		}
		else
		{
			if (iWinnerSide == iPlayerSide)
			{
				PlaySound('E', 23, 0, 0);
				PlaySound('C', 21, 0, 0);
				PlaySound('C', 22, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!;
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[42]->m_pMsg, 0); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[43]->m_pMsg, 0); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[44]->m_pMsg, 0); // You will receive
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[45]->m_pMsg, 0); // a prize
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[42]->m_pMsg, 0); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[43]->m_pMsg, 0); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[44]->m_pMsg, 0); // You will receive
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[45]->m_pMsg, 0); // a prize
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if (iWinnerSide != iPlayerSide)
			{
				PlaySound('E', 24, 0, 0);
				PlaySound('C', 12, 0, 0);
				PlaySound('C', 13, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[46]->m_pMsg, 0); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[47]->m_pMsg, 0); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[48]->m_pMsg, 0); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[49]->m_pMsg, 0); // will not be given.
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[46]->m_pMsg, 0); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[47]->m_pMsg, 0); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[48]->m_pMsg, 0); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[49]->m_pMsg, 0); // will not be given.
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
		}
	}
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeSoldier);
}

void CGame::_Draw_UpdateScreen_OnCreateNewAccount()
{
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, SCREENX, SCREENY, 0, true);
	PutString2(329 + SCREENX, 110 + SCREENY, m_cAccountName, 200, 200, 200);
	PutString(329 + SCREENX, 125 + SCREENY, m_cAccountPassword, RGB(200, 200, 200), true, 1);
	PutString(329 + SCREENX, 140 + SCREENY, m_cAccountPassword, RGB(200, 200, 200), true, 1);
	PutString2(300 + SCREENX, 202 + SCREENY, m_cAccountCountry, 200, 200, 200);
	PutString2(300 + SCREENX, 218 + SCREENY, m_cAccountSSN, 200, 200, 200);
	PutString2(194 + SCREENX, 257 + SCREENY, m_cEmailAddr, 200, 200, 200);
}

void CGame::DrawChatMsgBox(short sX, short sY, int iChatIndex, bool bIsPreDC)
{
	char cMsg[100], cMsgA[22], cMsgB[22], cMsgC[22], * cp;
	int  iRet, iLines, i, iSize, iSize2, iLoc, iFontSize;
	uint32_t dwTime;
	COLORREF rgb;
	bool bIsTrans;
	RECT rcRect;
	SIZE Size;

	std::memset(cMsg, 0, sizeof(cMsg));
	std::memset(cMsgA, 0, sizeof(cMsgA));
	std::memset(cMsgB, 0, sizeof(cMsgB));
	std::memset(cMsgC, 0, sizeof(cMsgC));

	dwTime = m_pChatMsgList[iChatIndex]->m_dwTime;
	strcpy(cMsg, m_pChatMsgList[iChatIndex]->m_pMsg);
	cp = (char*)cMsg;
	iLines = 0;

	rgb = RGB(255, 255, 255);
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 1:
		rgb = RGB(255, 255, 255);
		break;
	case 20:
		rgb = RGB(255, 255, 20);
		// �޽��� ǥ�ÿ� �����̰� �ɸ���.
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	case 41:
		rgb = RGB(255, 80, 80);
		break;

	case 42:
		rgb = RGB(255, 80, 80);
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgA, cp, 20);

		iRet = GetCharKind(cMsgA, 19);
		if (iRet == CODE_HAN1) {
			cMsgA[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 1;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgB, cp, 20);

		iRet = GetCharKind(cMsgB, 19);
		if (iRet == CODE_HAN1) {
			cMsgB[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 2;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgC, cp, 20);

		iRet = GetCharKind(cMsgC, 19);
		if (iRet == CODE_HAN1) {
			cMsgC[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 3;
	}

	iSize = 0;
	for (i = 0; i < 20; i++)
		if (cMsgA[i] != 0)

			if ((unsigned char)cMsgA[i] >= 128) {
				iSize += 5;	//6
				i++;
			}
			else iSize += 4;

	iLoc = m_dwCurTime - dwTime;
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 21:
	case 22:
	case 23://...
		if (iLoc > 80) iLoc = 10;
		else iLoc = iLoc >> 3;
		break;
	default://
		if (iLoc > 352) iLoc = 9;
		else if (iLoc > 320) iLoc = 10;
		else iLoc = iLoc >> 5;
		break;
	}

	if (ConfigManager::Get().GetDetailLevel() == 0)
		bIsTrans = false;
	else bIsTrans = true;

	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 41:
	case 42:
		iSize2 = 0;
		for (i = 0; i < 100; i++)
			if (cMsg[i] != 0)
				if ((unsigned char)cMsg[i] >= 128) {
					iSize2 += 5;
					i++;
				}
				else iSize2 += 4;
		if (CMisc::bCheckIMEString(cMsg) == false)
		{
			PutString(sX - iSize2, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
			PutString(sX - iSize2 + 1, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
		}
		else PutString_SprFont3(sX - iSize2, sY - 65 - iLoc, cMsg, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, false, 0);
		break;

	case 21:
	case 22:
	case 23:
		iFontSize = 23 - (int)m_pChatMsgList[iChatIndex]->m_cType;
		switch (iLines) {
		case 1:
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		case 2:
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgB, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		case 3:
			PutString_SprFont3(sX - iSize, sY - 97 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgB, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgC, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		}
		break;

	case 20:
	default:
		if (bIsPreDC == false)
			m_Renderer->BeginTextBatch();

		GetTextExtentPoint32(static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_hDC, cMsg, strlen(cMsg), &Size);

		switch (Size.cx / 160) {
		case 0:
			SetRect(&rcRect, sX - 80 + 1, sY - 65 - iLoc, sX + 80 + 1, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 65 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 65 - iLoc, sX + 80, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, rgb);
			break;

		case 1:
			SetRect(&rcRect, sX - 80 + 1, sY - 83 - iLoc, sX + 80 + 1, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 83 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 83 - iLoc, sX + 80, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, rgb);
			break;

		case 2:
			SetRect(&rcRect, sX - 80 + 1, sY - 101 - iLoc, sX + 80 + 1, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 101 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 101 - iLoc, sX + 80, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, rgb);
			break;

		case 3:
			SetRect(&rcRect, sX - 80 + 1, sY - 119 - iLoc, sX + 80 + 1, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 119 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_Renderer->DrawTextRect(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 119 - iLoc, sX + 80, sY - iLoc);
			m_Renderer->DrawTextRect(&rcRect, cMsg, rgb);
			break;
		}

		if (bIsPreDC == false)
			m_Renderer->EndTextBatch();
		break;
	}
}

void CGame::ClearContents_OnSelectCharacter()
{
	m_cCurFocus = 1;
}



void CGame::UpdateScreen_OnSelectCharacter()
{
	short sX, sY, msX, msY, msZ;
	char  cLB, cRB, cTotalChar;
	char  cMIresult;
	static class CMouseInterface* pMI;
	uint32_t dwTime;
	static DWORD dwCTime;

	int iMIbuttonNum;

	dwTime = GameClock::GetTimeMS();
	sX = 0;
	sY = 0;
	cTotalChar = 0;

	if (m_cGameModeCount == 0)
	{
		G_cSpriteAlphaDegree = 1;
		InitGameSettings();
		pMI = new class CMouseInterface;
		pMI->AddRect(100 + SCREENX, 50 + SCREENY, 210 + SCREENX, 250 + SCREENY);
		pMI->AddRect(211 + SCREENX, 50 + SCREENY, 321 + SCREENX, 250 + SCREENY);
		pMI->AddRect(322 + SCREENX, 50 + SCREENY, 431 + SCREENX, 250 + SCREENY);
		pMI->AddRect(432 + SCREENX, 50 + SCREENY, 542 + SCREENX, 250 + SCREENY);

		pMI->AddRect(360 + SCREENX, 283 + SCREENY, 545 + SCREENX, 315 + SCREENY);
		pMI->AddRect(360 + SCREENX, 316 + SCREENY, 545 + SCREENX, 345 + SCREENY);
		pMI->AddRect(360 + SCREENX, 346 + SCREENY, 545 + SCREENX, 375 + SCREENY);
		pMI->AddRect(360 + SCREENX, 376 + SCREENY, 545 + SCREENX, 405 + SCREENY);
		pMI->AddRect(360 + SCREENX, 406 + SCREENY, 545 + SCREENX, 435 + SCREENY);

		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1)		   m_cCurFocus = 1;

		m_cArrowPressed = 0;
		InputManager::Get().ClearEnterPressed();

		dwCTime = GameClock::GetTimeMS();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEscPressed() == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus - 1] != 0)
		{
			if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
			{
				std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
				m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
				if (CMisc::bCheckValidString(m_cPlayerName) == true)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
					m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
					m_pLSock->bInitBufferSize(30000);
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					std::memset(m_cMsg, 0, sizeof(m_cMsg));
					strcpy(m_cMsg, "33");
					std::memset(m_cMapName, 0, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
					delete pMI;
					return;
				}
			}
		}
		else
		{
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete pMI;
			return;
		}
	}

	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(sX, sY, msX, msY);

	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(msX, msY, 0);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else
			{
				if (m_pCharList[m_cCurFocus - 1] != 0)
				{
					if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
					{
						std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
						if (CMisc::bCheckValidString(m_cPlayerName) == true)
						{
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
							m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
							m_pLSock->bInitBufferSize(30000);
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							std::memset(m_cMsg, 0, sizeof(m_cMsg));
							strcpy(m_cMsg, "33");
							std::memset(m_cMapName, 0, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
							delete pMI;
							return;
						}
					}
				}
				else
				{
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete pMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
				{
					std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;

					if (CMisc::bCheckValidString(m_cPlayerName) == true) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
						m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
						m_pLSock->bInitBufferSize(30000);
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						std::memset(m_cMsg, 0, sizeof(m_cMsg));
						strcpy(m_cMsg, "33");
						std::memset(m_cMapName, 0, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
						delete pMI;
						return;
					}
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4)
			{
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete pMI;
				return;
			}
			break;

		case 7:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus;
				delete pMI;
				return;
			}
			break;

		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete pMI;
			return;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	//	if (m_cGameModeCount < 6) m_Renderer->DrawShadowBox(0,0,639,479);
	//	if (m_cGameModeCount < 2) m_Renderer->DrawShadowBox(0,0,639,479);
}

bool CGame::bDlgBoxPress_Character(short msX, short msY)
{
	int i;
	short sX, sY, sSprH, sFrame;
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS];

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return false;

	sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY;
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) cEquipPoiStatus[i] = -1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}

	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 72, sY + 135, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 98, sY + 182, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 90, sY + 170, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 41, sY + 137, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 72, sY + 139, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 98, sY + 182, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 84, sY + 175, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if ((cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1))
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 45, sY + 143, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	return false;
}

void CGame::CivilRightAdmissionHandler(char* pData)
{
	uint16_t wResult;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResult = header->msg_type;

	switch (wResult) {
	case 0:
		m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).cMode = 4;
		break;

	case 1:
		m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).cMode = 3;
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseCivilRight>(
			pData, sizeof(hb::net::PacketResponseCivilRight));
		if (!pkt) return;
		std::memset(m_cLocation, 0, sizeof(m_cLocation));
		memcpy(m_cLocation, pkt->location, 10);
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{
			m_bAresden = true;
			m_bCitizen = true;
			m_bHunter = false;
		}
		else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{
			m_bAresden = true;
			m_bCitizen = true;
			m_bHunter = true;
		}
		else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{
			m_bAresden = false;
			m_bCitizen = true;
			m_bHunter = false;
		}
		else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{
			m_bAresden = false;
			m_bCitizen = true;
			m_bHunter = true;
		}
		else
		{
			m_bAresden = true;
			m_bCitizen = false;
			m_bHunter = true;
		}
		break;
	}
}

void CGame::_RemoveChatMsgListByObjectID(int iObjectID)
{
	int i;

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if ((m_pChatMsgList[i] != 0) && (m_pChatMsgList[i]->m_iObjectID == iObjectID)) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = 0;
		}
}

void CGame::PlaySound(char cType, int iNum, int iDist, long lPan)
{
	// Forward to AudioManager
	SoundType type;
	switch (cType)
	{
	case 'C':
		type = SoundType::Character;
		break;
	case 'M':
		type = SoundType::Monster;
		break;
	case 'E':
		type = SoundType::Effect;
		break;
	default:
		return;
	}
	AudioManager::Get().PlaySound(type, iNum, iDist, static_cast<int>(lPan));
}


bool CGame::_bCheckItemByType(char cType)
{
	int i;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_pItemList[i]->m_cItemType == cType)) return true;

	return false;
}


void CGame::DynamicObjectHandler(char* pData)
{
	short sX, sY, sV1, sV2, sV3;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseDynamicObject>(
		pData, sizeof(hb::net::PacketResponseDynamicObject));
	if (!pkt) return;
	sX = pkt->x;
	sY = pkt->y;
	sV1 = pkt->v1;
	sV2 = pkt->v2;
	sV3 = pkt->v3;

	switch (pkt->header.msg_type) {
	case DEF_MSGTYPE_CONFIRM:// Dynamic Object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, sV1, true);
		break;

	case DEF_MSGTYPE_REJECT:// Dynamic object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, 0, true);
		break;
	}
}

bool CGame::_bIsItemOnHand() // Snoopy: Fixed to remove ShieldCast
{
	int i;
	uint16_t wWeaponType;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if ((m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
				return true;
		}
	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
			{
				wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
				// Snoopy 34 for all wands.
				if ((wWeaponType >= 34) && (wWeaponType < 40)) return false;
				//else if( wWeaponType == 27 ) return false; // Farming's hoe !
				else return true;
			}
		}
	return false;
}

int CGame::_iCalcTotalWeight()
{
	int i, iWeight, iCnt, iTemp;
	iCnt = 0;
	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			if ((m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				|| (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW))
			{
				iTemp = m_pItemList[i]->m_wWeight * m_pItemList[i]->m_dwCount;
				if (m_pItemList[i]->m_sIDnum == hb::item::ItemId::Gold) iTemp = iTemp / 20;
				iWeight += iTemp;
			}
			else iWeight += m_pItemList[i]->m_wWeight;
			iCnt++;
		}

	return iWeight;
}
uint32_t CGame::iGetLevelExp(int iLevel)
{
	return CalculateLevelExp(iLevel);
}

int CGame::_iGetTotalItemNum()
{
	int i, iCnt;
	iCnt = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0) iCnt++;
	return iCnt;
}

bool CGame::bCheckExID(char* pName)
{
	if (m_pExID == 0) return false;
	if (memcmp(m_cPlayerName, pName, 10) == 0) return false;
	char cTxt[12];
	std::memset(cTxt, 0, sizeof(cTxt));
	memcpy(cTxt, m_pExID->m_pMsg, strlen(m_pExID->m_pMsg));
	if (memcmp(cTxt, pName, 10) == 0) return true;
	else return false;
}

void CGame::DrawWhetherEffects()
{
#define MAXNUM 1000
	static int ix1[MAXNUM];
	static int iy2[MAXNUM];
	static int iFrame[MAXNUM];
	static int iNum = 0;
	int i;
	short dX, dY, sCnt;
	char cTempFrame;
	uint32_t dwTime = m_dwCurTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}

		for (i = 0; i < sCnt; i++)
		{
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20) && (m_stWhetherObject[i].sX != 0))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				cTempFrame = 16 + (m_stWhetherObject[i].cStep / 6);
				m_pEffectSpr[11]->Draw(dX, dY, cTempFrame, SpriteLib::DrawParams::Alpha(0.5f));
			}
			else if ((m_stWhetherObject[i].cStep >= 20) && (m_stWhetherObject[i].cStep < 25) && (m_stWhetherObject[i].sX != 0))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				m_pEffectSpr[11]->Draw(dX, dY, m_stWhetherObject[i].cStep, SpriteLib::DrawParams::Alpha(0.5f));
			}
		}
		break;

	case 4:
	case 5:
	case 6: // Snow
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;

				// Snoopy: Snow on lower bar
				if (dY >= 460)
				{
					cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20) * 3;
					dX = m_stWhetherObject[i].sBX;
					dY = 426;
				}
				else cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20) * 3 + (rand() % 3);

				m_pEffectSpr[11]->Draw(dX, dY, cTempFrame, SpriteLib::DrawParams::Alpha(0.5f));

				if (m_bIsXmas == true)
				{
					if (dY == 478 - 53)
					{
						ix1[iNum] = dX;
						iy2[iNum] = dY + (rand() % 5);
						iFrame[iNum] = cTempFrame;
						iNum++;
					}
					if (iNum >= MAXNUM) iNum = 0;
				}
			}
		}
		if (m_bIsXmas == true)
		{
			for (i = 0; i <= MAXNUM; i++)
			{
				if (iy2[i] > 10) m_pEffectSpr[11]->Draw(ix1[i], iy2[i], iFrame[i], SpriteLib::DrawParams::Alpha(0.5f));
			}
		}
		break;
	}
}

void CGame::WhetherObjectFrameCounter()
{
	int i;
	short sCnt;
	char  cAdd;
	uint32_t dwTime = m_dwCurTime;

	if ((dwTime - m_dwWOFtime) < 30) return;
	m_dwWOFtime = dwTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // Rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20))
			{
				cAdd = (40 - m_stWhetherObject[i].cStep);
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;
				if (cAdd != 0)
					m_stWhetherObject[i].sX = m_stWhetherObject[i].sX - 1;
			}
			else if (m_stWhetherObject[i].cStep >= 25)
			{
				if (m_bIsWhetherEffect == false)
				{
					m_stWhetherObject[i].sX = 0;
					m_stWhetherObject[i].sY = 0;
					m_stWhetherObject[i].cStep = 30;
				}
				else
				{
					m_stWhetherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % LOGICAL_WIDTH) - LOGICAL_HEIGHT) + 240;
					m_stWhetherObject[i].cStep = -1 * (rand() % 10);
				}
			}
		}
		break;

	case 4:
	case 5:
	case 6:
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{
				cAdd = (80 - m_stWhetherObject[i].cStep) / 10;
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;

				//Snoopy: Snow on lower bar
				if (m_stWhetherObject[i].sY > (426 + m_sViewPointY))
				{
					m_stWhetherObject[i].sY = 470 + m_sViewPointY;
					if ((rand() % 10) != 2) m_stWhetherObject[i].cStep--;
					if (m_stWhetherObject[i].sBX == 0) m_stWhetherObject[i].sBX = m_stWhetherObject[i].sX - m_sViewPointX;


				}
				else m_stWhetherObject[i].sX += 1 - (rand() % 3);
			}
			else if (m_stWhetherObject[i].cStep >= 80)
			{
				if (m_bIsWhetherEffect == false)
				{
					m_stWhetherObject[i].sX = 0;
					m_stWhetherObject[i].sY = 0;
					m_stWhetherObject[i].sBX = 0;
					m_stWhetherObject[i].cStep = 80;
				}
				else
				{
					m_stWhetherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % LOGICAL_WIDTH) - LOGICAL_HEIGHT) + LOGICAL_HEIGHT;
					m_stWhetherObject[i].cStep = -1 * (rand() % 10);
					m_stWhetherObject[i].sBX = 0;
				}
			}
		}
		break;
	}
}

void CGame::SetWhetherStatus(bool bStart, char cType)
{
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);

	// Always stop weather sounds first when changing weather
	AudioManager::Get().StopSound(SoundType::Effect, 38);

	if (bStart == true)
	{
		m_bIsWhetherEffect = true;
		m_cWhetherEffectType = cType;

		// Rain sound (types 1-3)
		if (AudioManager::Get().IsSoundEnabled() && (cType >= 1) && (cType <= 3))
			AudioManager::Get().PlaySoundLoop(SoundType::Effect, 38);

		for (int i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
		{
			m_stWhetherObject[i].sX = 1;
			m_stWhetherObject[i].sBX = 1;
			m_stWhetherObject[i].sY = 1;
			m_stWhetherObject[i].cStep = -1 * (rand() % 40);
		}

		// Snow BGM (types 4-6)
		if (cType >= 4 && cType <= 6)
		{
			if (AudioManager::Get().IsMusicEnabled()) StartBGM();
		}
	}
	else
	{
		m_bIsWhetherEffect = false;
		m_cWhetherEffectType = 0;
	}
}

void CGame::DrawLine(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
	int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
	int iResultX, iResultY;
	WORD* pDst;

	if ((x0 == x1) && (y0 == y1)) return;
	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1 - x0;
	dy = y1 - y0;
	if (dx >= 0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}
	if (dy >= 0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}
	if (dx > dy)
	{
		for (index = 0; index <= dx; index++)
		{
			error += dy;
			if (error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_pBackB4Addr + iResultX + ((iResultY)*static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_sBackB4Pitch);
				switch (m_Renderer->GetPixelFormat()) {
				case 1:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG100[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG100[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
	else
	{
		for (index = 0; index <= dy; index++)
		{
			error += dx;
			if (error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_pBackB4Addr + iResultX + ((iResultY)*static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_sBackB4Pitch);
				switch (m_Renderer->GetPixelFormat()) {
				case 1:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG100[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG100[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
}


void CGame::DrawLine2(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
	int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
	int iResultX, iResultY;
	WORD* pDst;
	if ((x0 == x1) && (y0 == y1)) return;

	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1 - x0;
	dy = y1 - y0;
	if (dx >= 0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}
	if (dy >= 0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}
	if (dx > dy)
	{
		for (index = 0; index <= dx; index++)
		{
			error += dy;
			if (error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_pBackB4Addr + iResultX + ((iResultY)*static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_sBackB4Pitch);
				switch (m_Renderer->GetPixelFormat()) {
				case 1:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG50[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG50[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
	else
	{
		for (index = 0; index <= dy; index++)
		{
			error += dx;
			if (error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_pBackB4Addr + iResultX + ((iResultY)*static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_sBackB4Pitch);
				switch (m_Renderer->GetPixelFormat()) {
				case 1:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG50[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransG50[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
}

void CGame::_DrawThunderEffect(int sX, int sY, int dX, int dY, int rX, int rY, char cType)
{
	int j, iErr, pX1, pY1, iX1, iY1, tX, tY;
	char cDir;
	uint32_t dwTime;
	uint16_t wR1, wG1, wB1, wR2, wG2, wB2, wR3, wG3, wB3, wR4, wG4, wB4;
	dwTime = m_dwCurTime;
	sX = pX1 = iX1 = tX = sX;
	sY = pY1 = iY1 = tY = sY;
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(50, 50, 100), &wR1, &wG1, &wB1);
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(30, 30, 100), &wR2, &wG2, &wB2);
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(0, 0, 30), &wR3, &wG3, &wB3);
	CMisc::ColorTransfer(m_Renderer->GetPixelFormat(), RGB(50, 50, 200), &wR4, &wG4, &wB4);

	for (j = 0; j < 100; j++)
	{
		switch (cType) {
		case 1:
			DrawLine(pX1, pY1, iX1, iY1, 15, 15, 20);
			DrawLine(pX1 - 1, pY1, iX1 - 1, iY1, wR1, wG1, wB1);
			DrawLine(pX1 + 1, pY1, iX1 + 1, iY1, wR1, wG1, wB1);
			DrawLine(pX1, pY1 - 1, iX1, iY1 - 1, wR1, wG1, wB1);
			DrawLine(pX1, pY1 + 1, iX1, iY1 + 1, wR1, wG1, wB1);

			DrawLine(pX1 - 2, pY1, iX1 - 2, iY1, wR2, wG2, wB2);
			DrawLine(pX1 + 2, pY1, iX1 + 2, iY1, wR2, wG2, wB2);
			DrawLine(pX1, pY1 - 2, iX1, iY1 - 2, wR2, wG2, wB2);
			DrawLine(pX1, pY1 + 2, iX1, iY1 + 2, wR2, wG2, wB2);

			DrawLine(pX1 - 1, pY1 - 1, iX1 - 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 - 1, pY1 + 1, iX1 - 1, iY1 + 1, wR3, wG3, wB3);
			break;

		case 2:
			DrawLine2(pX1, pY1, iX1, iY1, wR4, wG4, wB4);
			break;
		}
		iErr = 0;
		CMisc::GetPoint(sX, sY, dX, dY, &tX, &tY, &iErr, j * 10);
		pX1 = iX1;
		pY1 = iY1;
		cDir = CMisc::cGetNextMoveDir(iX1, iY1, tX, tY);
		switch (cDir) {
		case 1:	rY -= 5; break;
		case 2: rY -= 5; rX += 5; break;
		case 3:	rX += 5; break;
		case 4: rX += 5; rY += 5; break;
		case 5: rY += 5; break;
		case 6: rX -= 5; rY += 5; break;
		case 7: rX -= 5; break;
		case 8: rX -= 5; rY -= 5; break;
		}
		if (rX < -20) rX = -20;
		if (rX > 20) rX = 20;
		if (rY < -20) rY = -20;
		if (rY > 20) rY = 20;
		iX1 = iX1 + rX;
		iY1 = iY1 + rY;
		if ((abs(tX - dX) < 5) && (abs(tY - dY) < 5)) break;
	}
	switch (cType) {
	case 1:
		m_pEffectSpr[6]->Draw(iX1, iY1, (rand() % 2), SpriteLib::DrawParams::Alpha(0.5f));
		break;
	}
}

bool CGame::bDlgBoxPress_SkillDlg(short msX, short msY)
{
	int i, iAdjX, iAdjY;
	char  cItemID;
	short sX, sY, x1, y1, x2, y2, sArray[10];
	sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
	iAdjX = 5;
	iAdjY = 10;
	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					return true;
				}
			}
		break;

	case 4:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
					return true;
				}
			}
		break;
		// Crafting
	case 7:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 40, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 65 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 65, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 115, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + iAdjX + 75 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					return true;
				}
			}
		break;
	}

	return false;
}
// Snoopy: added StormBlade
int CGame::_iGetAttackType()
{
	uint16_t wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[5] >= 100)) return 20;
		else return 1;		// Boxe
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[7] >= 100)) return 21;
		else return 1;		//Dag, SS
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Added Kloness Esterk
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[9] >= 100)) return 22;
			else return 1;  // Esterk
		}
		else if (wWeaponType == 15)
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 30;
			else return 5;  // StormBlade
		}
		else
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 23;
			else return 1;	// LongSwords
		}
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[10] >= 100)) return 24;
		else return 1;		// Haches
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[14] >= 100)) return 26;
		else return 1;		// Hammers
	}
	else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[21] >= 100)) return 27;
		else return 1;		// Wands
	}
	else if (wWeaponType >= 40)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[6] >= 100)) return 25;
		else return 2;		// Bows
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 23;
		else return 1;		// LS
	}
	return 0;
}

int CGame::_iGetWeaponSkillType()
{
	uint16_t wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{
		return 5; // Openhand
	}
	else if ((wWeaponType >= 1) && (wWeaponType < 3))
	{
		return 7; // SS
	}
	else if ((wWeaponType >= 3) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Esterk or KlonessEsterk
			return 9; // Fencing
		else return 8; // LS
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		return 10; // Axe (20..28)
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		return 14; // Hammer (30,31,32)
	}
	else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{
		return 21; // Wand
	}
	else if (wWeaponType >= 40)
	{
		return 6;  // Bow
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		return 8;  // LS LightingBlade || BlackShadow
	}
	return 1; // Fishing !
}

bool CGame::_bCheckBadWords(char* pMsg)
{
	char cStr[500];
	int i, iLen;
	std::memset(cStr, 0, sizeof(cStr));
	strcpy(cStr, pMsg);
	iLen = strlen(cStr);

	for (i = 0; i < iLen; i++) {
		if (m_pCGameMonitor->bCheckBadWord((char*)(cStr + i)) == true) return true;
		if ((unsigned char)cStr[i] >= 128) i++;
	}

	return false;
}

/*********************************************************************************************************************
**  void CGame::bItemDrop_ExchangeDialog(short msX, short msY)	(snoopy)											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void CGame::bItemDrop_ExchangeDialog(short msX, short msY)
{
	char cItemID;
	if (m_cCommand < 0) return;
	if (m_stDialogBoxExchangeInfo[3].sV1 != -1) return; //Do not accept item's drop if already 4 items.

	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1000;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = cItemID;
		//m_dialogBoxManager.Info(DialogBoxId::Exchange).sView = cItemID;
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		return;
	}
	else // hum? d�j� on affiche? , bon je d�sactive, ca devrait plut�t s'afficher lors du retour du serveur.
	{	/*m_dialogBoxManager.Info(DialogBoxId::Exchange).sV1 = m_pItemList[cItemID]->m_sSprite;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV2 = m_pItemList[cItemID]->m_sSpriteFrame;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV3 = 1;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV4 = m_pItemList[cItemID]->m_cItemColor;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sView = cItemID;*/
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		m_bIsItemDisabled[cItemID] = true;
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, 0, cItemID, 1, 0, 0);
		//	   :bSendCommand(DWORD dwMsgID,        WORD wCommand,             char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
		return;
	}
}

int CGame::_iGetBankItemCount()
{
	int i, iCnt;

	iCnt = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0) iCnt++;

	return iCnt;
}

bool CGame::_bDecodeBuildItemContents()
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;
	char* pBuffer;
	bool   bRet;
	int    i;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{
			delete m_pBuildItemList[i];
			m_pBuildItemList[i] = 0;
		}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	strcpy(cTemp, "BItemcfg");
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return false;
	else
	{
		pBuffer = new char[dwFileSize + 1];
		std::memset(pBuffer, 0, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);
		bRet = __bDecodeBuildItemContents(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
	return bRet;
}

bool CGame::_bCheckBuildItemStatus()
{
	int iIndex, i, j, iMatch, iCount;
	char cTempName[21];
	int  iItemCount[DEF_MAXITEMS];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0)
		{
			delete m_pDispBuildItemList[i];
			m_pDispBuildItemList[i] = 0;
		}
	iIndex = 0;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{	// Skill-Limit
			if (m_cSkillMastery[13] >= m_pBuildItemList[i]->m_iSkillLimit)
			{
				iMatch = 0;
				m_pDispBuildItemList[iIndex] = new class CBuildItem;
				memcpy(m_pDispBuildItemList[iIndex]->m_cName, m_pBuildItemList[i]->m_cName, 20);

				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName1, m_pBuildItemList[i]->m_cElementName1, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName2, m_pBuildItemList[i]->m_cElementName2, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName3, m_pBuildItemList[i]->m_cElementName3, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName4, m_pBuildItemList[i]->m_cElementName4, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName5, m_pBuildItemList[i]->m_cElementName5, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName6, m_pBuildItemList[i]->m_cElementName6, 20);

				m_pDispBuildItemList[iIndex]->m_iElementCount[1] = m_pBuildItemList[i]->m_iElementCount[1];
				m_pDispBuildItemList[iIndex]->m_iElementCount[2] = m_pBuildItemList[i]->m_iElementCount[2];
				m_pDispBuildItemList[iIndex]->m_iElementCount[3] = m_pBuildItemList[i]->m_iElementCount[3];
				m_pDispBuildItemList[iIndex]->m_iElementCount[4] = m_pBuildItemList[i]->m_iElementCount[4];
				m_pDispBuildItemList[iIndex]->m_iElementCount[5] = m_pBuildItemList[i]->m_iElementCount[5];
				m_pDispBuildItemList[iIndex]->m_iElementCount[6] = m_pBuildItemList[i]->m_iElementCount[6];

				m_pDispBuildItemList[iIndex]->m_iSprH = m_pBuildItemList[i]->m_iSprH;
				m_pDispBuildItemList[iIndex]->m_iSprFrame = m_pBuildItemList[i]->m_iSprFrame;
				m_pDispBuildItemList[iIndex]->m_iMaxSkill = m_pBuildItemList[i]->m_iMaxSkill;
				m_pDispBuildItemList[iIndex]->m_iSkillLimit = m_pBuildItemList[i]->m_iSkillLimit;

				// ItemCount
				for (j = 0; j < DEF_MAXITEMS; j++)
					if (m_pItemList[j] != 0)
						iItemCount[j] = m_pItemList[j]->m_dwCount;
					else iItemCount[j] = 0;

				// Element1
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName1, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[1];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0) {
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[1] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP2;
							}
						}
				}

			CBIS_STEP2:;
				// Element2
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName2, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[2];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[2] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP3;
							}
						}
				}

			CBIS_STEP3:;
				// Element3
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName3, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[3];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[3] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP4;
							}
						}
				}

			CBIS_STEP4:;
				// Element4 �˻�
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName4, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[4];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[4] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP5;
							}
						}
				}

			CBIS_STEP5:;

				// Element5
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName5, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[5];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[5] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP6;
							}
						}
				}

			CBIS_STEP6:;

				// Element6
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName6, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[6];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[6] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP7;
							}
						}
				}

			CBIS_STEP7:;

				if (iMatch == 6) m_pDispBuildItemList[iIndex]->m_bBuildEnabled = true;
				iIndex++;
			}
		}
	return true;
}

bool CGame::_ItemDropHistory(char* ItemName)
{
	bool bFlag = false;
	if (m_iItemDropCnt == 0)
	{
		strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
		m_iItemDropCnt++;
		return true;
	}
	if ((1 <= m_iItemDropCnt) && (20 >= m_iItemDropCnt))
	{
		for (int i = 0; i < m_iItemDropCnt; i++)
		{
			if (strcmp(m_cItemDrop[i], ItemName) == 0)
			{
				bFlag = true;
				break;
			}
		}
		if (bFlag)
		{
			if (m_bItemDrop)
				return false;
			else
				return true;
		}

		if (20 < m_iItemDropCnt)
		{
			for (int i = 0; i < m_iItemDropCnt; i++)
				strcpy(m_cItemDrop[i - 1], ItemName);
			strcpy(m_cItemDrop[20], ItemName);
			m_iItemDropCnt = 21;
		}
		else
		{
			strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
			m_iItemDropCnt++;
		}
	}
	return true;
}


bool CGame::__bDecodeBuildItemContents(char* pBuffer)
{
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iIndex = 0;
	pContents = pBuffer;
	token = strtok(pContents, seps);

	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					std::memset(m_pBuildItemList[iIndex]->m_cName, 0, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // m_cElementName1
					std::memset(m_pBuildItemList[iIndex]->m_cElementName1, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName1));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName1, token, strlen(token));
					cReadModeB = 4;
					break;
				case 4: // m_iElementCount1
					m_pBuildItemList[iIndex]->m_iElementCount[1] = atoi(token);
					cReadModeB = 5;
					break;
				case 5: // m_cElementName2
					std::memset(m_pBuildItemList[iIndex]->m_cElementName2, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName2));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName2, token, strlen(token));
					cReadModeB = 6;
					break;
				case 6: // m_iElementCount2
					m_pBuildItemList[iIndex]->m_iElementCount[2] = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_cElementName3
					std::memset(m_pBuildItemList[iIndex]->m_cElementName3, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName3));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName3, token, strlen(token));
					cReadModeB = 8;
					break;
				case 8: // m_iElementCount3
					m_pBuildItemList[iIndex]->m_iElementCount[3] = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_cElementName4
					std::memset(m_pBuildItemList[iIndex]->m_cElementName4, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName4));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName4, token, strlen(token));
					cReadModeB = 10;
					break;
				case 10: // m_iElementCount4
					m_pBuildItemList[iIndex]->m_iElementCount[4] = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_cElementName5
					std::memset(m_pBuildItemList[iIndex]->m_cElementName5, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName5));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName5, token, strlen(token));
					cReadModeB = 12;
					break;
				case 12: // m_iElementCount5
					m_pBuildItemList[iIndex]->m_iElementCount[5] = atoi(token);
					cReadModeB = 13;
					break;
				case 13: // m_cElementName6
					std::memset(m_pBuildItemList[iIndex]->m_cElementName6, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName6));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName6, token, strlen(token));
					cReadModeB = 14;
					break;
				case 14: // m_iElementCount6
					m_pBuildItemList[iIndex]->m_iElementCount[6] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					m_pBuildItemList[iIndex]->m_iSprH = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					m_pBuildItemList[iIndex]->m_iSprFrame = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					iIndex++;
					break;
				}
				break;

			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "BuildItem", 9) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
		}
		token = strtok(NULL, seps);
	}
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}


bool CGame::_bCheckCurrentBuildItemStatus()
{
	int i, iCount2, iMatch, iIndex, iItemIndex[7];
	int iCount;
	int iItemCount[7];
	char cTempName[21];
	bool bItemFlag[7];

	iIndex = m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0];

	if (m_pBuildItemList[iIndex] == 0) return false;

	iItemIndex[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
	iItemIndex[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
	iItemIndex[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
	iItemIndex[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
	iItemIndex[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
	iItemIndex[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;

	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1)
			iItemCount[i] = m_pItemList[iItemIndex[i]]->m_dwCount;
		else iItemCount[i] = 0;
	iMatch = 0;
	for (i = 1; i <= 6; i++) bItemFlag[i] = false;

	// Element1
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName1, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[1];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP2;
			}
		}
	}

CCBIS_STEP2:;

	// Element2
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName2, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[2];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP3;
			}
		}
	}

CCBIS_STEP3:;


	// Element3
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName3, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[3];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP4;
			}
		}
	}

CCBIS_STEP4:;

	// Element4
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName4, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[4];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP5;
			}
		}
	}

CCBIS_STEP5:;

	// Element5
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName5, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[5];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP6;
			}
		}
	}

CCBIS_STEP6:;

	// Element6
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName6, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[6];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP7;
			}
		}
	}

CCBIS_STEP7:;

	iCount = 0;
	for (i = 1; i <= 6; i++)
		if (m_pDispBuildItemList[iIndex]->m_iElementCount[i] != 0) iCount++;
	iCount2 = 0;
	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1) iCount2++;
	if ((iMatch == 6) && (iCount == iCount2)) return true;
	return false;
}

void CGame::GetItemName(CItem* pItem, char* pStr1, char* pStr2, char* pStr3)
{
	char cTxt[256], cTxt2[256];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	std::memset(pStr1, 0, 64);
	std::memset(pStr2, 0, 64);
	std::memset(pStr3, 0, 64);

	// Use the display name from the item (populated from ItemDisplayNames.h)
	const char* cName = pItem->GetDisplayName();

	if (0 == memcmp(pItem->m_cName, "AcientTablet", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "NecklaceOf", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DarkElfBow", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DarkExecutor", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "The_Devastator", 14)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DemonSlayer", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "LightingBlade", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "5thAnniversary", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "RubyRing", 8)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "SapphireRing", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Ringof", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicNecklace", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicWand(M.Shield)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicWand(MS30-LLF)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Merien", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "BerserkWand", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "ResurWand", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Blood", 5)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Swordof", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "StoneOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "ZemstoneofSacrifice", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "StormBringer", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Aresden", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Elvine", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "EmeraldRing", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Excaliber", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Xelima", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Kloness", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "aHeroOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "eHeroOf", 7)) m_bIsSpecial = true;

	if ((pItem->m_dwAttribute & 0x00000001) != 0)
	{
		m_bIsSpecial = true;
		strcpy(pStr1, cName);
		if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
			wsprintf(pStr2, GET_ITEM_NAME1, pItem->m_sItemSpecEffectValue2);
		else
		{
			if (pItem->m_cEquipPos == DEF_EQUIPPOS_LFINGER)
			{
				wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2);
			}
			else
			{
				wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2 + 100);
			}
		}
	}
	else
	{
		if (pItem->m_dwCount == 1)
			wsprintf(G_cTxt, "%s", cName);
		else wsprintf(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, pItem->m_dwCount, cName);
		strcpy(pStr1, G_cTxt);
	}

	if ((pItem->m_dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		dwType2 = (pItem->m_dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (pItem->m_dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3);   break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4);   break;
			case 3: strcpy(cTxt, GET_ITEM_NAME5);   break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6);   break;
			case 6: strcpy(cTxt, GET_ITEM_NAME7);   break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8);   break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9);   break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10);  break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			std::memset(pStr1, 0, 64);
			strcpy(pStr1, cTxt);

			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break;
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0) {
				std::memset(cTxt, 0, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2 * 7); break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2 * 7); break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2 * 7); break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2 * 7); break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2 * 7); break;
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2 * 7); break;
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2 * 7); break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2 * 3); break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2 * 3); break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);   break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (pItem->m_dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char*)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			std::memset(cTxt, 0, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			std::memset(cTxt2, 0, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			std::memset(pStr1, 0, 64);
			strcpy(pStr1, cTxt2);
		}
		else
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}

	// Display mana save effect if present
	auto effectType = pItem->GetItemEffectType();
	int iManaSaveValue = 0;
	if (effectType == hb::item::ItemEffectType::AttackManaSave)
	{
		iManaSaveValue = pItem->m_sItemEffectValue4;
	}
	else if (effectType == hb::item::ItemEffectType::AddEffect &&
	         pItem->m_sItemEffectValue1 == hb::item::ToInt(hb::item::AddEffectType::ManaSave))
	{
		iManaSaveValue = pItem->m_sItemEffectValue2;
	}

	if (iManaSaveValue > 0)
	{
		m_bIsSpecial = true;
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "Mana Save +%d%%", iManaSaveValue);
		// Add to pStr2 if empty, otherwise pStr3
		if (pStr2[0] == '\0')
			strcpy(pStr2, cTxt);
		else if (pStr3[0] == '\0')
			strcpy(pStr3, cTxt);
	}
}

void CGame::GetItemName(short sItemId, uint32_t dwAttribute, char* pStr1, char* pStr2, char* pStr3)
{
	char cTxt[256], cTxt2[256];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	std::memset(pStr1, 0, 64);
	std::memset(pStr2, 0, 64);
	std::memset(pStr3, 0, 64);

	// Look up item config by ID to get display name (m_cName now contains display names)
	const char* cName = nullptr;
	if (sItemId > 0 && sItemId < 5000 && m_pItemConfigList[sItemId] != nullptr) {
		cName = m_pItemConfigList[sItemId]->m_cName;
	}
	if (cName == nullptr || cName[0] == '\0') {
		// Fallback to "Unknown Item" if no display name found
		strcpy(pStr1, "Unknown Item");
		return;
	}
	strcpy(pStr1, cName);

	if ((dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (dwAttribute & 0x000F0000) >> 16;
		dwType2 = (dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3); break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4); break;
			case 3: strcpy(cTxt, GET_ITEM_NAME5); break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6); break;
			case 6: strcpy(cTxt, GET_ITEM_NAME7); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8); break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10); break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			std::memset(pStr1, 0, 64);
			strcpy(pStr1, cTxt);

			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break;
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2 * 7);  break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2 * 7);  break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2 * 7);  break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2 * 7);  break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2 * 7);  break;
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2 * 7);  break;
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2 * 7);  break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2 * 3);  break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2 * 3);  break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);    break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char*)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			std::memset(cTxt, 0, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			std::memset(cTxt2, 0, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			std::memset(pStr1, 0, 64);
			strcpy(pStr1, cTxt2);
		}
		else
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

short CGame::FindItemIdByName(const char* cItemName)
{
	if (cItemName == nullptr) return 0;
	for (int i = 1; i < 5000; i++) {
		if (m_pItemConfigList[i] != nullptr &&
			memcmp(m_pItemConfigList[i]->m_cName, cItemName, 20) == 0) {
			return static_cast<short>(i);
		}
	}
	return 0; // Not found
}

void CGame::NoticementHandler(char* pData)
{
	FILE* pFile;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
	case DEF_MSGTYPE_REJECT:
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseNoticementText>(
			pData, sizeof(hb::net::PacketResponseNoticementText));
		if (!pkt) return;
		pFile = fopen("contents\\contents1000.txt", "wt");
		if (pFile == 0) return;
		fwrite(pkt->text, strlen(pkt->text), 1, pFile);
		fclose(pFile);
		m_dialogBoxManager.Info(DialogBoxId::Text).sX = 20;
		m_dialogBoxManager.Info(DialogBoxId::Text).sY = 65;
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 1000, 0, 0);
		break;
	}
	AddEventList("Press F1 for news and help.", 10);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Help, 0, 0, 0);

}

int CGame::_iGetFOE(int iStatus)
{
	bool bPK, bCitizen, bAresden, bHunter;
	if (m_iPKCount != 0) return -1;
	//	CLEROTH			0x00000000 status is int NOT short ( 3.51 )
	if (iStatus & 0x80000000) bPK = true;
	else bPK = false;
	if (iStatus & 0x40000000) bCitizen = true;
	else bCitizen = false;
	if (iStatus & 0x20000000) bAresden = true;
	else bAresden = false;
	if (iStatus & 0x10000000) bHunter = true;
	else bHunter = false;
	if (bPK == true) return -2;
	if (bCitizen == false) return 0;
	if (m_bCitizen == false) return 0;
	if ((m_bAresden == true) && (bAresden == true)) return 1;
	if ((m_bAresden == false) && (bAresden == false)) return 1;
	if (m_bIsCrusadeMode == true) return -1;
	else
	{
		if ((m_bHunter == false) && (bHunter == false)) return -1;
		else return 0;
	}
}

void CGame::_SetIlusionEffect(int iOwnerH)
{
	char cDir;

	m_iIlusionOwnerH = iOwnerH;

	std::memset(m_cName_IE, 0, sizeof(m_cName_IE));
	m_pMapData->GetOwnerStatusByObjectID(iOwnerH, &m_cIlusionOwnerType, &cDir, &m_sAppr1_IE, &m_sAppr2_IE, &m_sAppr3_IE, &m_sAppr4_IE, &m_iStatus_IE, &m_iApprColor_IE, m_cName_IE);
}

void CGame::ResponsePanningHandler(char* pData)
{
	char cDir;
	short sX, sY;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponsePanningHeader>(
		pData, sizeof(hb::net::PacketResponsePanningHeader));
	if (!pkt) return;
	sX = pkt->x;
	sY = pkt->y;
	cDir = static_cast<char>(pkt->dir);

	switch (cDir) {
	case 1: m_sViewDstY -= 32; m_sPlayerY--; break;
	case 2: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX += 32; m_sPlayerX++; break;
	case 3: m_sViewDstX += 32; m_sPlayerX++; break;
	case 4: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX += 32; m_sPlayerX++; break;
	case 5: m_sViewDstY += 32; m_sPlayerY++; break;
	case 6: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX -= 32; m_sPlayerX--; break;
	case 7: m_sViewDstX -= 32; m_sPlayerX--; break;
	case 8: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX -= 32; m_sPlayerX--; break;
	}

	m_pMapData->ShiftMapData(cDir);
	const char* mapData = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponsePanningHeader);
	_ReadMapData(sX, sY, mapData);

	m_bIsRedrawPDBGS = true;

	m_bIsObserverCommanded = false;
}

/*********************************************************************************************************************
** void CGame::CreateScreenShot()										(snoopy)									**
**  description			:: Fixed Screen Shots																		**
**********************************************************************************************************************/
void CGame::CreateScreenShot()
{	//HelShot20060307_173003_Warehouse000.jpg
	int i;
	FILE* pFile;
	char cFn[256];
	char LongMapName[128];
	char SStime[32];
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	std::memset(LongMapName, 0, sizeof(LongMapName));
	GetOfficialMapName(m_cMapName, LongMapName);
	std::memset(SStime, 0, sizeof(SStime));
	wsprintf(SStime, "%02d:%02d - %02d:%02d:%02d"
		, SysTime.wMonth, SysTime.wDay
		, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
		, LongMapName);
	PutAlignedString(500 + SCREENX, 650 + SCREENY, 30, SStime, 255, 255, 255); //ScreenShot time

	for (i = 0; i < 1000; i++)
	{
		std::memset(cFn, 0, sizeof(cFn));
		wsprintf(cFn, "Save\\HelShot%04d%02d%02d_%02d%02d%02d_%s%03d.bmp"
			, SysTime.wYear, SysTime.wMonth, SysTime.wDay
			, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
			, LongMapName
			, i);
		_mkdir("SAVE");
		pFile = fopen(cFn, "rb");
		if (pFile == 0)
		{
			static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->Screenshot(cFn, static_cast<DXC_ddraw*>(m_Renderer->GetNativeRenderer())->m_lpBackB4);

			wsprintf(G_cTxt, NOTIFYMSG_CREATE_SCREENSHOT1, cFn);
			AddEventList(G_cTxt, 10);
			return;
		}
		fclose(pFile);
	}
	AddEventList(NOTIFYMSG_CREATE_SCREENSHOT2, 10);
}




bool CGame::_bDraw_OnCreateNewCharacter(char* pName, short msX, short msY, int iPoint)
{
	bool bFlag = true;
	uint32_t dwTime = GameClock::GetTimeMS();
	int i = 0;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWCHAR, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 69, true);
	PutAlignedString(64 + SCREENX, 282 + SCREENX, 90 + SCREENY, _BDRAW_ON_CREATE_NEW_CHARACTER1, 5, 5, 5);//"
	PutAlignedString(57 + SCREENX, 191 + SCREENX, 110 + SCREENY, DEF_MSG_CHARACTERNAME, 5, 5, 5);//"Character Name"
	if (m_cCurFocus != 1) PutString(197 + SCREENX, 112 + SCREENY, pName, RGB(25, 35, 25));
	PutAlignedString(64 + SCREENX, 282 + SCREENX, 140 + SCREENY, _BDRAW_ON_CREATE_NEW_CHARACTER2, 5, 5, 5);//"
	PutString(100 + SCREENX, 160 + SCREENY, DEF_MSG_GENDER, RGB(5, 5, 5));//"Gender"
	PutString(100 + SCREENX, 175 + SCREENY, DEF_MSG_SKINCOLOR, RGB(5, 5, 5));//"Skin Color"
	PutString(100 + SCREENX, 190 + SCREENY, DEF_MSG_HAIRSTYLE, RGB(5, 5, 5));//"Hair Style"
	PutString(100 + SCREENX, 205 + SCREENY, DEF_MSG_HAIRCOLOR, RGB(5, 5, 5));//"Hair Color"
	PutString(100 + SCREENX, 220 + SCREENY, DEF_MSG_UNDERWEARCOLOR, RGB(5, 5, 5));//"Underwear Color"
	//PutAlignedString(64, 282, 245, _BDRAW_ON_CREATE_NEW_CHARACTER3, 5,5,5);
	//wsprintf(G_cTxt, _BDRAW_ON_CREATE_NEW_CHARACTER4,  iPoint);//" %d points"
	//PutAlignedString(64, 282, 260, G_cTxt, 15,10,10);
	PutString(100 + SCREENX, 275 + SCREENY, DEF_MSG_STRENGTH, RGB(5, 5, 5));//"Strength"
	PutString(100 + SCREENX, 292 + SCREENY, DEF_MSG_VITALITY, RGB(5, 5, 5));//"Vitality"
	PutString(100 + SCREENX, 309 + SCREENY, DEF_MSG_DEXTERITY, RGB(5, 5, 5));//"Dexterity"
	PutString(100 + SCREENX, 326 + SCREENY, DEF_MSG_INTELLIGENCE, RGB(5, 5, 5));//"Intelligence"
	PutString(100 + SCREENX, 343 + SCREENY, DEF_MSG_MAGIC, RGB(5, 5, 5));//"Magic"
	PutString(100 + SCREENX, 360 + SCREENY, DEF_MSG_CHARISMA, RGB(5, 5, 5));//"Charisma"

	wsprintf(G_cTxt, "%d", m_ccStr);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccVit);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccDex);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccInt);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccMag);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccChr);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	if (strlen(pName) <= 0) bFlag = false;
	if (iPoint > 0) bFlag = false;
	if (CMisc::bCheckValidName(pName) == false) bFlag = false;
	if (_bCheckBadWords(pName) == true) bFlag = false;

	if ((bFlag == true) && (m_cCurFocus == 2)) m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(384 + SCREENX, 445 + SCREENY, 25);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(384 + SCREENX, 445 + SCREENY, 24);
	if (m_cCurFocus == 3)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(500 + SCREENX, 445 + SCREENY, 17);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(500 + SCREENX, 445 + SCREENY, 16);
	if (m_cCurFocus == 4)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(60 + SCREENX, 445 + SCREENY, 68);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(60 + SCREENX, 445 + SCREENY, 67);
	if (m_cCurFocus == 5)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(145 + SCREENX, 445 + SCREENY, 66);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(145 + SCREENX, 445 + SCREENY, 65);
	if (m_cCurFocus == 6)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(230 + SCREENX, 445 + SCREENY, 64);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(230 + SCREENX, 445 + SCREENY, 63);
	/*if (m_cCurFocus == 4)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(60, 245, 68);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(60, 245, 67);
	if (m_cCurFocus == 5)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(145, 245, 66);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(145, 245, 65);
	if (m_cCurFocus == 6)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(230, 245, 64);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(230, 245, 63);*/

	ShowReceivedString();

	switch (m_cGender) {
	case 1:	_tmp_sOwnerType = 1; break;
	case 2:	_tmp_sOwnerType = 4; break; //@@@@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!!
	}
	_tmp_sOwnerType += m_cSkinCol - 1;
	_tmp_cDir = m_cMenuDir;
	_tmp_sAppr1 = 0;
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cUnderCol);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairStyle << 8);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairCol << 4);
	_tmp_sAppr2 = 0;
	_tmp_sAppr3 = 0;
	_tmp_sAppr4 = 0;
	std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
	memcpy(_tmp_cName, m_cPlayerName, 10);
	_tmp_cAction = DEF_OBJECTMOVE;
	_tmp_cFrame = m_cMenuFrame;

	_Draw_CharacterBody(507 + SCREENX, 267 + SCREENY, _tmp_sOwnerType);

	DrawObject_OnMove_ForMenu(0 + SCREENX, 0 + SCREENY, 500 + SCREENX, 174 + SCREENY, false, dwTime, msX, msY);

	i = 0;

	PutString(445 + SCREENX, 192 + SCREENY, DEF_MSG_HITPOINT, RGB(5, 5, 5));//"Hit Point"
	wsprintf(G_cTxt, "%d", m_ccVit * 3 + 2 + m_ccStr / 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	PutString(445 + SCREENX, 208 + SCREENY, DEF_MSG_MANAPOINT, RGB(5, 5, 5));//"Mana Point"
	wsprintf(G_cTxt, "%d", m_ccMag * 2 + 2 + m_ccInt / 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	PutString(445 + SCREENX, 224 + SCREENY, DEF_MSG_STAMINARPOINT, RGB(5, 5, 5));//"Staminar Point"
	wsprintf(G_cTxt, "%d", m_ccStr * 2 + 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	return bFlag;
}


#ifdef DEF_MAKE_ACCOUNT

void CGame::_LoadAgreementTextContents(char cType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pAgreeMsgTextList[i] != 0)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = 0;
	}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0) {
		m_pAgreeMsgTextList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
}

void CGame::UpdateScreen_OnAgreement()
{
	short sX, sY, msX, msY, msZ;
	char  cLB, cRB;
	char  cMIresult;
	static class CMouseInterface* pMI;
	int i, iTotalLines, iPointerLoc;
	uint32_t dwTime = GameClock::GetTimeMS();
	double d1, d2, d3;
	int iMIbuttonNum;

	sX = 121;
	sY = 22;

	if (m_cGameModeCount == 0) {
		m_iAgreeView = 0;
		_LoadAgreementTextContents(0);

		pMI = new class CMouseInterface;
		pMI->AddRect(sX + 82 - 105, sY + 355, sX + 131 - 105, sY + 374);
		pMI->AddRect(sX + 235 - 105, sY + 355, sX + 303 - 105, sY + 375);
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	if (InputManager::Get().IsEnterPressed() == true) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
		ClearContents_OnCreateNewAccount();
		delete pMI;
		return;
	}
	if (InputManager::Get().IsEscPressed() == true) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}
	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1: // Agree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			ClearContents_OnCreateNewAccount();
			delete pMI;
			return;

		case 2:	// Disagree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_AGREEMENT, 0, 0, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 43, 38, 12, false);

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
		if (m_pAgreeMsgTextList[i] != 0) iTotalLines++;

	d1 = (double)m_iAgreeView;
	d2 = (double)(iTotalLines - 20);
	d3 = (double)d1 / d2;
	d1 = 338.0f * d3;
	iPointerLoc = (int)d1;
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->Draw(sX + 361 - 112, sY + 37 + 13 + iPointerLoc, 7);

	for (i = 0; i < 20; i++)
		if (m_pAgreeMsgTextList[i + m_iAgreeView] != 0) {
			PutAlignedString(60, 360, sY + 65 + i * 13, m_pAgreeMsgTextList[i + m_iAgreeView]->m_pMsg, 45, 25, 25);
		}

	if (msZ != 0)
	{
		m_iAgreeView = m_iAgreeView - msZ / 60;
		InputManager::Get().ClearWheelDelta();
	}
	if (cLB != 0 && iTotalLines > 20)
	{
		if ((msX >= sX + 345 - 112) && (msX <= sX + 380 - 112) && (msY >= sY + 50) && (msY <= sY + 395))
		{
			d1 = (double)(msY - (sY + 37 + 13));
			d2 = (double)(iTotalLines - 17);
			d3 = (double)(d1 * d2) / (338.0f);
			m_iAgreeView = (int)d3;
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->Draw(sX + 361 - 112, sY + 37 + 13 + iPointerLoc, 4, SpriteLib::DrawParams::Alpha(0.5f));
		}
	}
	if (m_iAgreeView < 0) m_iAgreeView = 0;
	if (iTotalLines > 20 && m_iAgreeView > iTotalLines - 20) m_iAgreeView = iTotalLines - 20;

	if ((msX > sX + 82 - 105) && (msX < sX + 131 - 105) && (msY > sY + 355 - 3) && (msY < sY + 374 + 3))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 - 23 + 45 - 105, sY + 265 + 90, 13);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 - 23 + 45 - 105, sY + 265 + 90, 12);

	if ((msX > sX + 235 - 105) && (msX < sX + 303 - 105) && (msY > sY + 355 - 3) && (msY < sY + 375 + 3))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 - 23 + 45 - 105, sY + 265 + 90, 15);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 - 23 + 45 - 105, sY + 265 + 90, 14);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(msX, msY, 0);

	//	if (m_cGameModeCount < 6) m_Renderer->DrawShadowBox(0,0,639,479);
	//	if (m_cGameModeCount < 2) m_Renderer->DrawShadowBox(0,0,639,479);
}

#endif //endif from #ifdef DEF_MAKE_ACCOUNT



void CGame::OnKeyUp(WPARAM wParam)
{
	if (HotkeyManager::Get().HandleKeyUp(static_cast<int>(wParam))) {
		return;
	}

	switch (wParam) {
	case 107: //'+'
		Hotkey_Simple_ZoomIn();
		break;
	case 109: //'-'
		Hotkey_Simple_ZoomOut();
		break;

	case VK_F2:
		Hotkey_Simple_UseShortcut2();
		break;

	case VK_F3:
		Hotkey_Simple_UseShortcut3();
		break;

	case VK_INSERT:
		Hotkey_Simple_UseHealthPotion();
		break;

	case VK_DELETE:
		Hotkey_Simple_UseManaPotion();
		break;

	case VK_END:
		Hotkey_Simple_LoadBackupChat();
		break;

	case VK_F4:
		Hotkey_Simple_UseMagicShortcut();
		break;

	case VK_F5:
		Hotkey_Simple_ToggleCharacterInfo();
		break;

	case VK_F6:
		Hotkey_Simple_ToggleInventory();
		break;

	case VK_F7:
		Hotkey_Simple_ToggleMagic();
		break;

	case VK_F8:
		Hotkey_Simple_ToggleSkill();
		break;

	case VK_F9:
		Hotkey_Simple_ToggleChatHistory();
		break;

	case VK_F12:
		Hotkey_Simple_ToggleSystemMenu();
		break;

	case VK_F1:
		//if (m_bInputStatus) return;
		//if (m_dialogBoxManager.IsEnabled(DialogBoxId::Help) == false) // 35 CLEROTH
		//	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Help, 0, 0, 0);
		//else
		//{	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Help);
		//	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
		//}
		Hotkey_Simple_UseShortcut1();
		break;

	case VK_UP:
		Hotkey_Simple_WhisperCycleUp();
		break;

	case VK_RIGHT:
		Hotkey_Simple_ArrowRight();
		break;

	case VK_DOWN:
		Hotkey_Simple_WhisperCycleDown();
		break;

	case VK_LEFT:
		Hotkey_Simple_ArrowLeft();
		break;

	case VK_SNAPSHOT:
		Hotkey_Simple_Screenshot();
		break;

	case VK_TAB:
		Hotkey_Simple_TabToggleCombat();
		break;

	case VK_HOME:
		Hotkey_Simple_ToggleSafeAttack();
		break;

	case VK_ESCAPE:
		Hotkey_Simple_Escape();
		break;

	case 33:
		Hotkey_Simple_SpecialAbility();
		break;
	default:
		return;
	}
}

void CGame::OnKeyDown(WPARAM wParam)
{
	switch (wParam) {
	case VK_INSERT:
	case VK_DELETE:
	case VK_TAB:
	case VK_RETURN:
	case VK_ESCAPE:
	case VK_END:
	case VK_HOME:
	case VK_F1:
	case VK_F2:
	case VK_F3:
	case VK_F4:
	case VK_F5:
	case VK_F6:
	case VK_F7:
	case VK_F8:
	case VK_F9:
	case VK_F10:
	case VK_F11:
	case VK_F12:
	case VK_PRIOR: // Page-Up
	case VK_NEXT: // Page-Down
	case VK_LWIN:
	case VK_RWIN:
	case VK_MULTIPLY:
	case VK_ADD: //'+'
	case VK_SEPARATOR:
	case VK_SUBTRACT: //'-'
	case VK_DECIMAL:
	case VK_DIVIDE:
	case VK_NUMLOCK:
	case VK_SCROLL:
		return;
	}

	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{
		if (InputManager::Get().IsCtrlDown())
		{
			switch (wParam) {
			case 48: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 9; break; // 0
			case 49: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 0; break; // 1
			case 50: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 1; break; // 2
			case 51: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 2; break; // 3
			case 52: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 3; break; // 4
			case 53: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 4; break; // 5
			case 54: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 5; break; // 6
			case 55: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 6; break; // 7
			case 56: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 7; break; // 8
			case 57: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 8; break; // 9
			}
		}
		else if ((m_bInputStatus == false) && (!InputManager::Get().IsAltDown()))
		{
			StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
			ClearInputString();
		}
	}
}


// ============================================================================
// Separated Update/Draw Methods (Phase 3 refactor)
// ============================================================================

// Quit screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Quit()
{
	char cMIresult;
	int  iMIbuttonNum;

	static class CMouseInterface* pMI;

	if (m_cGameModeCount == 0) {
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pGSock != 0)
		{
			delete m_pGSock;
			m_pGSock = 0;
		}
		InputManager::Get().ClearEscPressed();
		InputManager::Get().ClearEnterPressed();
		pMI = new class CMouseInterface;
		pMI->AddRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
		InputManager::Get().ClearEnterPressed();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	// Handle escape/enter to quit immediately
	if (InputManager::Get().IsEscPressed() == true || InputManager::Get().IsEnterPressed() == true) {
		InputManager::Get().ClearEscPressed();
		InputManager::Get().ClearEnterPressed();
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Auto-quit after timeout
	if (m_cGameModeCount == 100)
	{
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Check for click
	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1)) {
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		delete pMI;
		return;
	}
}

// Quit screen - Draw phase (rendering only)
void CGame::DrawScreen_Quit()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0 + SCREENX, 0 + SCREENY, 0, true);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 255 + SCREENX, 123 + SCREENY, 1, true);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT]->Draw(255 + SCREENX, 123 + SCREENY, 1, SpriteLib::DrawParams::Alpha(0.25f));
	DrawVersion();

	// Draw cursor at position captured during Update phase
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// VersionNotMatch screen - Update phase (logic/input handling)
void CGame::UpdateScreen_VersionNotMatch()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;

	if (m_cGameModeCount == 0)
	{
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pGSock != 0)
		{
			delete m_pGSock;
			m_pGSock = 0;
		}
		pMI = new class CMouseInterface;
		pMI->AddRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
		InputManager::Get().ClearEnterPressed();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	if (InputManager::Get().IsEscPressed() == true || InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEscPressed();
		InputManager::Get().ClearEnterPressed();
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1))
	{
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}
}

// VersionNotMatch screen - Draw phase (rendering only)
void CGame::DrawScreen_VersionNotMatch()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0, 0, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162, 125, 2);
	PutAlignedString(168, 474, 160, UPDATE_SCREEN_ON_VERSION_NO_MATCH1);
	PutAlignedString(168, 474, 180, UPDATE_SCREEN_ON_VERSION_NO_MATCH2);
	DrawVersion();

	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// ConnectionLost screen - Update phase (logic/input handling)
void CGame::UpdateScreen_ConnectionLost()
{
	static DWORD dwTime;
	if (m_cGameModeCount == 0)
	{
		dwTime = GameClock::GetTimeMS();
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Auto-transition after 5 seconds
	if ((GameClock::GetTimeMS() - m_dwTime) > 5000)
	{
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		}
	}
}

// ConnectionLost screen - Draw phase (rendering only)
void CGame::DrawScreen_ConnectionLost()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	PutString_SprFont(172 + 54 + SCREENX, 180 + SCREENY, "Connection Lost!", 7, 0, 0);
	PutString(172 + 50 + SCREENX, 180 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTION_LOST, RGB(0, 0, 0));
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// Msg screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Msg()
{
	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Auto-transition after 1.5 seconds
	if ((G_dwGlobalTime - m_dwTime) > 1500)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
}

// Msg screen - Draw phase (rendering only)
void CGame::DrawScreen_Msg()
{
	uint32_t dwTime = G_dwGlobalTime;
	PutString(10, 10, m_cMsg, RGB(255, 155, 155), false, 1);
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// WaitingResponse screen - Update phase (logic/input handling)
void CGame::UpdateScreen_WaitingResponse()
{
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		InputManager::Get().ClearEnterPressed();
		InputManager::Get().ClearEscPressed();
		dwCTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true)
	{
		if ((dwTime - m_dwTime) > 7000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		InputManager::Get().ClearEscPressed();
		return;
	}

	// Animation frame updates
	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// WaitingResponse screen - Draw phase (rendering only)
void CGame::DrawScreen_WaitingResponse()
{
	short sX, sY;
	uint32_t dwTime = GameClock::GetTimeMS();

	m_bIsHideLocalCursor = true;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;
	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;
	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;
	case '4':// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '5':
		break;
	}
	m_bIsHideLocalCursor = false;

	m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	PutString_SprFont(172 + 44 - 17 + SCREENX, 190 + SCREENY, "Connected. Waiting for response...", 7, 0, 0);

	if ((dwTime - m_dwTime) > 7000)
	{
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE1);
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 45 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE2);
	}
	else PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE3);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 8);
}

// Connecting screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Connecting()
{
	static DWORD dwMTime, dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		InputManager::Get().ClearEnterPressed();
		InputManager::Get().ClearEscPressed();
		dwCTime = dwMTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true) {
		if ((dwTime - m_dwTime) > 1000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		InputManager::Get().ClearEscPressed();
		return;
	}

	if ((dwTime - dwMTime) > 150) dwMTime = dwTime;

	// Animation frame updates
	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// Connecting screen - Draw phase (rendering only)
void CGame::DrawScreen_Connecting()
{
	short sX, sY;
	uint32_t dwTime = GameClock::GetTimeMS();

	m_bIsHideLocalCursor = true;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;
	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;
	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;
	case '4':
		// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '5':
		break;
	}
	m_bIsHideLocalCursor = false;

	m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	wsprintf(G_cTxt, "Connecting to Server... %3dSec", (dwTime - m_dwTime) / 1000);
	PutString_SprFont(172 + 35 + SCREENX, 190 + SCREENY, G_cTxt, 7, 0, 0);

	if ((dwTime - m_dwTime) > 7000)
	{
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTING1);
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 45 + SCREENY, UPDATE_SCREEN_ON_CONNECTING2);
	}
	else PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTING3);
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 8);
}

// QueryForceLogin screen - Update phase (logic/input handling)
void CGame::UpdateScreen_QueryForceLogin()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(200 + SCREENX, 244 + SCREENY, 200 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		pMI->AddRect(370 + SCREENX, 244 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		InputManager::Get().ClearEnterPressed();
		InputManager::Get().ClearEscPressed();
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Animation frame updates
	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
			m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NOENTER_FORCEDISCONN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}
}

// QueryForceLogin screen - Draw phase (rendering only)
void CGame::DrawScreen_QueryForceLogin()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}
	else if (m_cGameModeCount >= 6) {
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 130 + SCREENY, 2);

	PutString_SprFont(172 + 86 + SCREENX, 160 + SCREENY, "Character on Use", 7, 0, 0);
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN1);
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 215 + SCREENY, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN2);

	if ((m_sFrameMouseX >= 200 + SCREENX) && (m_sFrameMouseX <= 200 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 18);

	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 2);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// QueryDeleteCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_QueryDeleteCharacter()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		pMI = new class CMouseInterface;
		pMI->AddRect(200 + SCREENX, 244 + SCREENY, 200 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		pMI->AddRect(370 + SCREENX, 244 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	// Poll mouse input and store for Draw phase
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Animation frame updates
	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_DELETECHARACTER;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}
}

// QueryDeleteCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_QueryDeleteCharacter()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	UpdateScreen_OnSelectCharacter(0, 0, 500, 70);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6))
	{
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}
	else if (m_cGameModeCount >= 6)
	{
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
		m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	PutString_SprFont(172 + 86 + SCREENX, 160 + SCREENY, "Delete Character", 7, 0, 0);
	PutString(215 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER1, RGB(5, 5, 5));
	PutString(335 + SCREENX, 199 + SCREENY, "__________", RGB(5, 5, 5));
	PutString(335 + SCREENX, 195 + SCREENY, m_pCharList[m_wEnterGameType - 1]->m_cName, RGB(25, 35, 25));
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER2);

	if ((m_sFrameMouseX >= 200 + SCREENX) && (m_sFrameMouseX <= 200 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 18);

	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 2);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// MainMenu screen - Update phase (logic/input handling)
void CGame::UpdateScreen_MainMenu()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;

	m_iItemDropCnt = 0;
	m_bItemDrop = false;

	if (m_cGameModeCount == 0)
	{
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != 0)
		{
			delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = 0;
		}
		EndInputString();
		pMI = new class CMouseInterface;

		pMI->AddRect(384 + SCREENX, 177 + SCREENY, 548 + SCREENX, 198 + SCREENY);
		pMI->AddRect(384 + SCREENX, 215 + SCREENY, 548 + SCREENX, 236 + SCREENY);
		pMI->AddRect(384 + SCREENX, 254 + SCREENY, 548 + SCREENX, 275 + SCREENY);
		InputManager::Get().SetMousePosition(400, 240);

		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Poll mouse input
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Update focus based on mouse position
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 177 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 198 + SCREENY)) m_cCurFocus = 1;
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 215 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 236 + SCREENY)) m_cCurFocus = 2;
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 254 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 275 + SCREENY)) m_cCurFocus = 3;

	if (m_cArrowPressed != 0) {
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEnterPressed() == true) {
		PlaySound('E', 14, 5);
		InputManager::Get().ClearEnterPressed();
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
#else
			GoHomepage();
#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);
		m_cCurFocus = iMIbuttonNum;
		switch (iMIbuttonNum)
		{
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;
		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
#else
			GoHomepage();
#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
}

// MainMenu screen - Draw phase (rendering only)
void CGame::DrawScreen_MainMenu()
{
	uint32_t dwTime = G_dwGlobalTime;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, 0 + SCREENX, 0 + SCREENY, 0, true);

	switch (m_cCurFocus) {
	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Draw(384 + SCREENX, 177 + SCREENY, 1);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Draw(384 + SCREENX, 215 + SCREENY, 2);
		break;
	case 3:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Draw(384 + SCREENX, 254 + SCREENY, 3);
		break;
	}

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// WaitInitData screen - Update phase (logic/input handling)
void CGame::UpdateScreen_WaitInitData()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		InputManager::Get().ClearEnterPressed();
		InputManager::Get().ClearEscPressed();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true) {
		if ((dwTime - m_dwTime) > 7000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		InputManager::Get().ClearEscPressed();
		return;
	}

	// Poll mouse input
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// WaitInitData screen - Draw phase (rendering only)
void CGame::DrawScreen_WaitInitData()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	wsprintf(G_cTxt, "Waiting for response... %dsec", (dwTime - m_dwTime) / 1000);
	PutString_SprFont(172 + 44 + SCREENX, 190 + SCREENY, G_cTxt, 7, 0, 0);
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(174 + SCREENX, 467 + SCREENX, 190 + 30 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA1);
		PutAlignedString(174 + SCREENX, 467 + SCREENX, 190 + 45 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA2);
	}
	else PutAlignedString(174 + SCREENX, 467 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA3);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 8);
}

// SelectServer screen - Update phase (logic/input handling)
void CGame::UpdateScreen_SelectServer()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static char cPrevFocus;

	if (m_cGameModeCount == 0) {
		EndInputString();

		pMI = new class CMouseInterface;
		pMI->AddRect(130, 177, 270, 198);
		pMI->AddRect(130, 199, 270, 225);
		pMI->AddRect(256, 279, 331, 308);

		cPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();
		PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
			if (strlen(m_cWorldServerName) == 0)
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, NAME_WORLDNAME1);
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;
		case 2:
			std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS2");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;
		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if (InputManager::Get().IsEscPressed() == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{
		cPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			if (m_cCurFocus == 1) {
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, NAME_WORLDNAME1);
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 1;
			break;
		case 2:
			if (m_cCurFocus == 2) {
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS2");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 2;
			break;
		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 130) && (m_sFrameMouseX <= 295) && (m_sFrameMouseY >= 175) && (m_sFrameMouseY <= 198)) m_cCurFocus = 1;
	if ((m_sFrameMouseX >= 130) && (m_sFrameMouseX <= 295) && (m_sFrameMouseY >= 199) && (m_sFrameMouseY <= 225)) m_cCurFocus = 2;
	if ((m_sFrameMouseX >= 256) && (m_sFrameMouseX <= 331) && (m_sFrameMouseY >= 279) && (m_sFrameMouseY <= 308)) m_cCurFocus = 3;
}

// SelectServer screen - Draw phase (rendering only)
void CGame::DrawScreen_SelectServer()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0, 0, 0, true);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 40, 121, 1, true);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Draw(40, 121, 1, SpriteLib::DrawParams::Alpha(0.25f));

	if (m_cGameModeCount > 20)
	{
		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 138, 177, 5, true);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 130, 205, 6, true);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256, 282, 4, true);
	}
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// File-scope static variables for Login screen input buffers
// Shared between UpdateScreen_Login and DrawScreen_Login
static char s_cLoginName[12];
static char s_cLoginPassword[12];

// Login screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Login()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static char cPrevFocus;

	if (m_cGameModeCount == 0)
	{
		EndInputString();
		pMI = new class CMouseInterface;
		pMI->AddRect(80 + SCREENX, 151 + SCREENY, 337 + SCREENX, 179 + SCREENY);
		pMI->AddRect(80 + SCREENX, 180 + SCREENY, 337 + SCREENX, 205 + SCREENY);
		pMI->AddRect(80 + SCREENX, 280 + SCREENY, 163 + SCREENX, 302 + SCREENY);
		pMI->AddRect(258 + SCREENX, 280 + SCREENY, 327 + SCREENX, 302 + SCREENY);
		cPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 4;
		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;
		std::memset(s_cLoginName, 0, sizeof(s_cLoginName));
		std::memset(s_cLoginPassword, 0, sizeof(s_cLoginPassword));
		StartInputString(180 + SCREENX, 162 + SCREENY, 11, s_cLoginName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 2:
		case 3:
			if ((strlen(s_cLoginName) == 0) || (strlen(s_cLoginPassword) == 0)) break;
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, s_cLoginName);
			strcpy(m_cAccountPassword, s_cLoginPassword);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;
		case 4:
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
		}
	}

	if (InputManager::Get().IsEscPressed() == true)
	{
		EndInputString();
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(180 + SCREENX, 162 + SCREENY, 11, s_cLoginName);
			break;
		case 2:
			StartInputString(180 + SCREENX, 185 + SCREENY, 11, s_cLoginPassword, true);
			break;
		case 3:
		case 4:
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cCurFocus = 2;
			break;
		case 3:
			if ((strlen(s_cLoginName) == 0) || (strlen(s_cLoginPassword) == 0)) break;
			EndInputString();
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, s_cLoginName);
			strcpy(m_cAccountPassword, s_cLoginPassword);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;
		case 4:
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 80 + SCREENX) && (m_sFrameMouseX <= 163 + SCREENX) && (m_sFrameMouseY >= 280 + SCREENY) && (m_sFrameMouseY <= 302 + SCREENY)) m_cCurFocus = 3;
	if ((m_sFrameMouseX >= 258 + SCREENX) && (m_sFrameMouseX <= 327 + SCREENX) && (m_sFrameMouseY >= 280 + SCREENY) && (m_sFrameMouseY <= 302 + SCREENY)) m_cCurFocus = 4;
}

// Login screen - Draw phase (rendering only)
void CGame::DrawScreen_Login()
{
	// Use shared static buffers from UpdateScreen_Login
	_Draw_OnLogin(s_cLoginName, s_cLoginPassword, m_sFrameMouseX, m_sFrameMouseY, m_cGameModeCount);
}

// Loading screen - Update phase (resource loading)
void CGame::UpdateScreen_Loading()
{
	// The loading screen loads resources progressively
	// All the resource loading happens in UpdateScreen_OnLoading
	// We call it here since it needs to happen
	UpdateScreen_OnLoading(false);
}

// Loading screen - Draw phase (progress display)
void CGame::DrawScreen_Loading()
{
	// Draw progress
	UpdateScreen_OnLoading_Progress();

	// Poll mouse for cursor
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	uint32_t dwTime = GameClock::GetTimeMS();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// LogResMsg screen - Update phase (logic/input handling)
void CGame::UpdateScreen_LogResMsg()
{
	// This screen is complex - handled in DrawScreen_LogResMsg via original method
}

// LogResMsg screen - Draw phase (rendering only)
void CGame::DrawScreen_LogResMsg()
{
	// This screen is complex - delegate to original combined method
	UpdateScreen_OnLogResMsg();
}

// File-scope static variables for ChangePassword screen input buffers
// Shared between UpdateScreen_ChangePassword and DrawScreen_ChangePassword
static char s_cChgPwdName[12];
static char s_cChgPwdPassword[12];
static char s_cChgPwdNewPassword[12];
static char s_cChgPwdNewPassConfirm[12];
static char s_cChgPwdPrevFocus;
static DWORD s_dwChgPwdCTime;
static class CMouseInterface* s_pChgPwdMI;

// ChangePassword screen - Update phase (logic/input handling)
void CGame::UpdateScreen_ChangePassword()
{
	char cMIresult;
	int  iMIbuttonNum;

	if (m_cGameModeCount == 0) {
		EndInputString();

		s_pChgPwdMI = new class CMouseInterface;
		s_pChgPwdMI->AddRect(300 + SCREENX, 148 + SCREENY, 425 + SCREENX, 170 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 172 + SCREENY, 425 + SCREENX, 194 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 196 + SCREENY, 425 + SCREENX, 218 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 220 + SCREENY, 425 + SCREENX, 242 + SCREENY);

		s_pChgPwdMI->AddRect(197 + SCREENX, 320 + SCREENY, 197 + DEF_BTNSZX + SCREENX, 320 + DEF_BTNSZY + SCREENY);
		s_pChgPwdMI->AddRect(370 + SCREENX, 320 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 320 + DEF_BTNSZY + SCREENY);

		s_cChgPwdPrevFocus = 2;
		m_cCurFocus = 2;
		m_cMaxFocus = 6;
		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;

		std::memset(s_cChgPwdName, 0, sizeof(s_cChgPwdName));
		std::memset(s_cChgPwdPassword, 0, sizeof(s_cChgPwdPassword));
		std::memset(s_cChgPwdNewPassword, 0, sizeof(s_cChgPwdNewPassword));
		std::memset(s_cChgPwdNewPassConfirm, 0, sizeof(s_cChgPwdNewPassConfirm));

		strcpy(s_cChgPwdName, m_cAccountName);
		StartInputString(314 + SCREENX, 179 + SCREENY, 11, s_cChgPwdPassword);
		ClearInputString();
		s_dwChgPwdCTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	uint32_t dwTime = GameClock::GetTimeMS();
	if ((dwTime - s_dwChgPwdCTime) > 100) {
		m_cMenuFrame++;
		s_dwChgPwdCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEnterPressed() == true)
	{
		PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 5:	// Connect
			if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
				(CMisc::bCheckValidName(s_cChgPwdNewPassword) == false) || (CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) == false) ||
				(strlen(s_cChgPwdNewPassword) == 0) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0)) break;

			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
			std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, s_cChgPwdName);
			strcpy(m_cAccountPassword, s_cChgPwdPassword);
			strcpy(m_cNewPassword, s_cChgPwdNewPassword);
			strcpy(m_cNewPassConfirm, s_cChgPwdNewPassConfirm);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete s_pChgPwdMI;
			return;

		case 6:	// Cancel
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pChgPwdMI;
			return;
		}
		InputManager::Get().ClearEnterPressed();
	}

	if (InputManager::Get().IsEscPressed() == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pChgPwdMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	if (s_cChgPwdPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(314 + SCREENX, 155 + SCREENY, 11, s_cChgPwdName);
			break;
		case 2:
			StartInputString(314 + SCREENX, 179 + SCREENY, 11, s_cChgPwdPassword);
			break;
		case 3:
			StartInputString(314 + SCREENX, 203 + SCREENY, 11, s_cChgPwdNewPassword);
			break;
		case 4:
			StartInputString(314 + SCREENX, 227 + SCREENY, 11, s_cChgPwdNewPassConfirm);
			break;
		}
		s_cChgPwdPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	InputManager::Get().GetLegacyState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = s_pChgPwdMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus = iMIbuttonNum;
			break;

		case 5:
			if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
				(CMisc::bCheckValidName(s_cChgPwdNewPassword) == false) || (CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) == false) ||
				(strlen(s_cChgPwdNewPassword) == 0) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0)) break;

			EndInputString();
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
			std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, s_cChgPwdName);
			strcpy(m_cAccountPassword, s_cChgPwdPassword);
			strcpy(m_cNewPassword, s_cChgPwdNewPassword);
			strcpy(m_cNewPassConfirm, s_cChgPwdNewPassConfirm);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete s_pChgPwdMI;
			return;

		case 6:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pChgPwdMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 197 + SCREENX) && (m_sFrameMouseX <= 197 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 320 + SCREENY) && (m_sFrameMouseY <= 320 + DEF_BTNSZY + SCREENY)) m_cCurFocus = 5;
	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 320 + SCREENY) && (m_sFrameMouseY <= 320 + DEF_BTNSZY + SCREENY)) m_cCurFocus = 6;
}

// ChangePassword screen - Draw phase (rendering only)
void CGame::DrawScreen_ChangePassword()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	bool bFlag = true;

	// Draw background (SelectCharacter screen)
	UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
	m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	// Draw dialog boxes
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + SCREENX, 112 + SCREENY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 153 + SCREENX, 112 + SCREENY, 13);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157 + SCREENX, 112 + 109 + SCREENY, 7);

	// Draw labels
	PutString(206 + SCREENX, 155 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD1, RGB(25, 35, 25));
	PutString(206 + SCREENX, 179 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD2, RGB(25, 35, 25));
	PutString(206 + SCREENX, 203 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD3, RGB(25, 35, 25));
	PutString(206 + SCREENX, 227 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD4, RGB(25, 35, 25));

	// Draw input field values
	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidString(s_cChgPwdName) != false)
			PutString(314 + SCREENX, 155 + SCREENY, s_cChgPwdName, RGB(25, 35, 25));
		else PutString(314 + SCREENX, 155 + SCREENY, s_cChgPwdName, RGB(55, 18, 13));
	}
	if ((CMisc::bCheckValidString(s_cChgPwdName) == false) || (strlen(s_cChgPwdName) == 0)) bFlag = false;

	if (m_cCurFocus != 2) {
		if ((CMisc::bCheckValidString(s_cChgPwdPassword) != false))
			PutString(314 + SCREENX, 179 + SCREENY, s_cChgPwdPassword, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 179 + SCREENY, s_cChgPwdPassword, RGB(55, 18, 13), true, 3);
	}

	if (m_cCurFocus != 3) {
		if ((CMisc::bCheckValidName(s_cChgPwdNewPassword) != false))
			PutString(314 + SCREENX, 203 + SCREENY, s_cChgPwdNewPassword, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 203 + SCREENY, s_cChgPwdNewPassword, RGB(55, 18, 13), true, 3);
	}

	if (m_cCurFocus != 4) {
		if ((CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) != false))
			PutString(314 + SCREENX, 227 + SCREENY, s_cChgPwdNewPassConfirm, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 227 + SCREENY, s_cChgPwdNewPassConfirm, RGB(55, 18, 13), true, 3);
	}

	if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
		(strlen(s_cChgPwdNewPassword) < 8) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0) ||
		(memcmp(s_cChgPwdPassword, s_cChgPwdNewPassword, 10) == 0)) bFlag = false;

	// Show active input string
	if (m_cCurFocus == 1) ShowReceivedString();
	else if ((m_cCurFocus == 2) || (m_cCurFocus == 3) || (m_cCurFocus == 4)) ShowReceivedString(true);

	// Help text
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 258 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD5);
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 273 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD6);
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 288 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD7);

	// Buttons
	if ((bFlag == true) && (m_cCurFocus == 5))
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(197 + SCREENX, 320 + SCREENY, 21);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(197 + SCREENX, 320 + SCREENY, 20);

	if (m_cCurFocus == 6)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(370 + SCREENX, 320 + SCREENY, 17);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(370 + SCREENX, 320 + SCREENY, 16);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
}

// File-scope static variables for CreateNewAccount screen input buffers
// Shared between UpdateScreen_CreateNewAccount and DrawScreen_CreateNewAccount
static char s_cNewAcctName[12];
static char s_cNewAcctPassword[12];
static char s_cNewAcctConfirm[12];
static char s_cNewAcctSSN_A[8];
static char s_cNewAcctSSN_B[8];
static char s_cNewAcctQuiz[44];
static char s_cNewAcctTempQuiz[44];
static char s_cNewAcctAnswer[20];
static char s_cNewAcctPrevFocus;
static class CMouseInterface* s_pNewAcctMI;
static short s_sNewAcctMsX;
static short s_sNewAcctMsY;
static char s_cNewAcctPrevLB;

// CreateNewAccount screen - Update phase (logic/input handling)
void CGame::UpdateScreen_CreateNewAccount()
{
#ifdef DEF_MAKE_ACCOUNT
	char cMIresult;
	int iMIbuttonNum;
	short msX, msY, msZ;
	char cLB, cRB;

	if (m_cGameModeCount == 0)
	{
		EndInputString();

		s_pNewAcctMI = new class CMouseInterface;
		// Input field areas
		s_pNewAcctMI->AddRect(427 + SCREENX, 84 + SCREENY - 5, 550 + SCREENX, 84 + SCREENY + 15);   // 1: Account
		s_pNewAcctMI->AddRect(427 + SCREENX, 106 + SCREENY - 5, 550 + SCREENX, 106 + SCREENY + 15); // 2: Password
		s_pNewAcctMI->AddRect(427 + SCREENX, 129 + SCREENY - 5, 550 + SCREENX, 129 + SCREENY + 15); // 3: Confirm
		s_pNewAcctMI->AddRect(311 + SCREENX, 215 + SCREENY - 5, 550 + SCREENX, 215 + SCREENY + 15); // 4: Email
		s_pNewAcctMI->AddRect(311 + SCREENX, 253 + SCREENY - 5, 550 + SCREENX, 253 + SCREENY + 15); // 5: Quiz
		s_pNewAcctMI->AddRect(311 + SCREENX, 291 + SCREENY - 5, 550 + SCREENX, 291 + SCREENY + 15); // 6: Answer
		// Button areas (left to right: Create, Clear, Cancel)
		s_pNewAcctMI->AddRect(297 + SCREENX, 398 + SCREENY, 297 + 72 + SCREENX, 398 + 20 + SCREENY); // 7: Create (left)
		s_pNewAcctMI->AddRect(392 + SCREENX, 398 + SCREENY, 392 + 72 + SCREENX, 398 + 20 + SCREENY); // 8: Clear (center)
		s_pNewAcctMI->AddRect(488 + SCREENX, 398 + SCREENY, 488 + 72 + SCREENX, 398 + 20 + SCREENY); // 9: Cancel (right)

		s_cNewAcctPrevFocus = 1;
		s_cNewAcctPrevLB = 0;
		m_cCurFocus = 1;
		m_cMaxFocus = 9;
		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;

		std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
		std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
		std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
		std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
		std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
		std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));

		StartInputString(427 + SCREENX, 84 + SCREENY, 11, s_cNewAcctName);
		ClearInputString();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Handle arrow key navigation
	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1: // Up
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3: // Down
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	// Handle focus change - switch input field
	if (s_cNewAcctPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1: StartInputString(427 + SCREENX, 84 + SCREENY, 11, s_cNewAcctName); break;
		case 2: StartInputString(427 + SCREENX, 106 + SCREENY, 11, s_cNewAcctPassword); break;
		case 3: StartInputString(427 + SCREENX, 129 + SCREENY, 11, s_cNewAcctConfirm); break;
		case 4: StartInputString(311 + SCREENX, 215 + SCREENY, 50, m_cEmailAddr); break;
		case 5: StartInputString(311 + SCREENX, 253 + SCREENY, 43, s_cNewAcctQuiz); break;
		case 6: StartInputString(311 + SCREENX, 291 + SCREENY, 19, s_cNewAcctAnswer); break;
		}
		s_cNewAcctPrevFocus = m_cCurFocus;
	}

	// Handle Enter key
	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();
		PlaySound('E', 14, 5);

		if (m_cCurFocus <= 6)
		{
			// Move to next input field
			m_cCurFocus++;
			if (m_cCurFocus > 6) m_cCurFocus = 7; // Move to Create button
		}
		else if (m_cCurFocus == 7)
		{
			// Create button - validate and submit
			wsprintf(s_cNewAcctTempQuiz, "%s", s_cNewAcctQuiz);
			CMisc::ReplaceString(s_cNewAcctTempQuiz, ' ', '_');
			bool bValid = true;
			if (strlen(s_cNewAcctName) == 0) bValid = false;
			if (strlen(s_cNewAcctPassword) == 0) bValid = false;
			if (strlen(s_cNewAcctConfirm) == 0) bValid = false;
			if (CMisc::bIsValidEmail(m_cEmailAddr) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctName) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctPassword) == false) bValid = false;
			if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) != 0) bValid = false;
			if (strlen(s_cNewAcctTempQuiz) == 0) bValid = false;
			if (strlen(s_cNewAcctAnswer) == 0) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctAnswer) == false) bValid = false;

			if (bValid)
			{
				// Copy to game account fields
				std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
				std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
				std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
				std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
				strcpy(m_cAccountName, s_cNewAcctName);
				strcpy(m_cAccountPassword, s_cNewAcctPassword);
				strcpy(m_cAccountQuiz, s_cNewAcctQuiz);
				strcpy(m_cAccountAnswer, s_cNewAcctAnswer);

				// Connect to server
				m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort);
				m_pLSock->bInitBufferSize(30000);
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
				std::memset(m_cMsg, 0, sizeof(m_cMsg));
				strcpy(m_cMsg, "01");
				delete s_pNewAcctMI;
				return;
			}
		}
		else if (m_cCurFocus == 8)
		{
			// Clear - clear all input fields (center button)
			EndInputString();
			std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
			std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
			std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
			std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
			std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
			std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));
			m_cCurFocus = 1;
			s_cNewAcctPrevFocus = 0; // Force focus switch to restart input
		}
		else if (m_cCurFocus == 9)
		{
			// Cancel - go back to main menu (right button)
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pNewAcctMI;
			return;
		}
	}

	// Handle Escape key
	if (InputManager::Get().IsEscPressed() == true)
	{
		InputManager::Get().ClearEscPressed();
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pNewAcctMI;
		return;
	}

	// Poll mouse input
	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);
	m_sFrameMouseX = msX;
	m_sFrameMouseY = msY;
	s_sNewAcctMsX = msX;
	s_sNewAcctMsY = msY;

	// Detect mouse click (button was down, now released)
	bool bMouseClick = (s_cNewAcctPrevLB != 0 && cLB == 0);
	s_cNewAcctPrevLB = cLB;

	// Handle mouse clicks on input fields via CMouseInterface
	iMIbuttonNum = s_pNewAcctMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		if (iMIbuttonNum >= 1 && iMIbuttonNum <= 6)
		{
			// Clicked on an input field
			PlaySound('E', 14, 5);
			m_cCurFocus = iMIbuttonNum;
		}
	}

	// Handle mouse clicks on buttons using direct position check
	// Button order left to right: Create, Clear, Cancel
	if (bMouseClick)
	{
		// Button 7: Create (at 297, 398 - size 72x20) - LEFT
		bool bOverCreate = (msX >= 297 + SCREENX && msX <= 297 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);
		// Button 8: Clear (at 392, 398 - size 72x20) - CENTER
		bool bOverClear = (msX >= 392 + SCREENX && msX <= 392 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);
		// Button 9: Cancel (at 488, 398 - size 72x20) - RIGHT
		bool bOverCancel = (msX >= 488 + SCREENX && msX <= 488 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);

		if (bOverCreate)
		{
			PlaySound('E', 14, 5);
			m_cCurFocus = 7;
			InputManager::Get().SetEnterPressed(); // Trigger Enter handling
		}
		else if (bOverClear)
		{
			PlaySound('E', 14, 5);
			EndInputString();
			std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
			std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
			std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
			std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
			std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
			std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));
			m_cCurFocus = 1;
			s_cNewAcctPrevFocus = 0; // Force focus switch to restart input
		}
		else if (bOverCancel)
		{
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pNewAcctMI;
			return;
		}
	}
#endif
}

// CreateNewAccount screen - Draw phase (rendering only)
void CGame::DrawScreen_CreateNewAccount()
{
#ifdef DEF_MAKE_ACCOUNT
	uint32_t dwTime = GameClock::GetTimeMS();
	int iFlag = 0;

	// Compute validation flags for display
	wsprintf(s_cNewAcctTempQuiz, "%s", s_cNewAcctQuiz);
	CMisc::ReplaceString(s_cNewAcctTempQuiz, ' ', '_');

	if (CMisc::bCheckValidName(s_cNewAcctAnswer) == false)		iFlag = 13;
	if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) == false)	iFlag = 12;
	if (strlen(s_cNewAcctAnswer) == 0)							iFlag = 11;
	if (strlen(s_cNewAcctTempQuiz) == 0)						iFlag = 10;
	if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) != 0)	iFlag = 9;
	if (CMisc::bCheckValidName(s_cNewAcctPassword) == false)	iFlag = 7;
	if (CMisc::bCheckValidName(s_cNewAcctName) == false)		iFlag = 6;
	if (CMisc::bIsValidEmail(m_cEmailAddr) == false)			iFlag = 5;
	if (strlen(s_cNewAcctConfirm) == 0)							iFlag = 3;
	if (strlen(s_cNewAcctPassword) == 0)						iFlag = 2;
	if (strlen(s_cNewAcctName) == 0)							iFlag = 1;

	// Draw background
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0 + SCREENX, 0 + SCREENY, 0, true);

	// Draw labels
	PutString(377 + SCREENX, 84 + SCREENY, "Account:", RGB(100, 100, 200));
	PutString(372 + SCREENX, 106 + SCREENY, "Password:", RGB(100, 100, 200));
	PutString(372 + SCREENX, 129 + SCREENY, "(confirm)", RGB(100, 100, 200));
	PutString(271 + SCREENX, 215 + SCREENY, "eMail:", RGB(100, 100, 200));
	PutString(276 + SCREENX, 253 + SCREENY, "Quiz:", RGB(100, 100, 200));
	PutString(266 + SCREENX, 291 + SCREENY, "Answer:", RGB(100, 100, 200));

	// Show active input string
	if ((m_cCurFocus == 2) || (m_cCurFocus == 3))
		ShowReceivedString(true);
	else if ((m_cCurFocus == 1) || (m_cCurFocus == 4) || (m_cCurFocus == 5) || (m_cCurFocus == 6))
		ShowReceivedString();

	// Draw input field values
	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidName(s_cNewAcctName) != false)
			PutString2(427 + SCREENX, 84 + SCREENY, s_cNewAcctName, 100, 200, 100);
		else PutString2(427 + SCREENX, 84 + SCREENY, s_cNewAcctName, 200, 100, 100);
	}
	if (m_cCurFocus != 2) {
		if (CMisc::bCheckValidName(s_cNewAcctPassword) != false)
			PutString(427 + SCREENX, 106 + SCREENY, s_cNewAcctPassword, RGB(100, 200, 100), true, 1);
		else PutString(427 + SCREENX, 106 + SCREENY, s_cNewAcctPassword, RGB(200, 100, 100), true, 1);
	}
	if (m_cCurFocus != 3) {
		if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) == 0)
			PutString(427 + SCREENX, 129 + SCREENY, s_cNewAcctConfirm, RGB(100, 200, 100), true, 1);
		else PutString(427 + SCREENX, 129 + SCREENY, s_cNewAcctConfirm, RGB(200, 100, 100), true, 1);
	}
	if (m_cCurFocus != 4) {
		if (CMisc::bIsValidEmail(m_cEmailAddr))
			PutString2(311 + SCREENX, 48 + 190 - 25 + 2 + SCREENY, m_cEmailAddr, 100, 200, 100);
		else PutString2(311 + SCREENX, 48 + 190 - 25 + 2 + SCREENY, m_cEmailAddr, 200, 100, 100);
	}
	if (m_cCurFocus != 5) {
		if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) != false)
			PutString2(311 + SCREENX, 48 + 226 - 25 + 4 + SCREENY, s_cNewAcctQuiz, 100, 200, 100);
	}
	if (m_cCurFocus != 6) {
		if (CMisc::bCheckValidName(s_cNewAcctAnswer) != false)
			PutString2(311 + SCREENX, 291 + SCREENY, s_cNewAcctAnswer, 100, 200, 100);
	}

	// Draw help text based on focus
	switch (m_cCurFocus) {
	case 1:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT1);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT2);
		break;
	case 2:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT4);
		break;
	case 3:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT8);
		break;
	case 4:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT21);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT22);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 360 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT23);
		break;
	case 5:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT25);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT26);
		break;
	case 6:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT29);
		break;
	case 7:
		switch (iFlag) {
		case 0:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT33);
			break;
		case 1:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT35);
			break;
		case 2:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT38);
			break;
		case 3:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT42);
			break;
		case 5:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT50);
			break;
		case 6:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT52);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT53);
			break;
		case 7:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT56);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT57);
			break;
		case 9:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT63);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT64);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 360 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT65);
			break;
		case 10:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT67);
			break;
		case 11:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT69);
			break;
		case 12:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT73);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT74);
			break;
		case 13:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT77);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT78);
			break;
		}
		break;
	case 8:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT80);
		break;
	case 9:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT81);
		break;
	}

	// Draw buttons - highlight on focus OR mouse hover
	// Button order left to right: Create, Clear, Cancel

	// Button 7: Create (at 297, 398 - size 72x20) - LEFT
	bool bHoverCreate = (s_sNewAcctMsX >= 297 + SCREENX && s_sNewAcctMsX <= 297 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if ((iFlag == 0) && (m_cCurFocus == 7 || bHoverCreate))
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(199 + 98 + SCREENX, 398 + SCREENY, 25);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(199 + 98 + SCREENX, 398 + SCREENY, 24);

	// Button 8: Clear (at 392, 398 - size 72x20) - CENTER
	bool bHoverClear = (s_sNewAcctMsX >= 392 + SCREENX && s_sNewAcctMsX <= 392 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if (m_cCurFocus == 8 || bHoverClear)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(294 + 98 + SCREENX, 398 + SCREENY, 27);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(294 + 98 + SCREENX, 398 + SCREENY, 26);

	// Button 9: Cancel (at 488, 398 - size 72x20) - RIGHT
	bool bHoverCancel = (s_sNewAcctMsX >= 488 + SCREENX && s_sNewAcctMsX <= 488 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if (m_cCurFocus == 9 || bHoverCancel)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(390 + 98 + SCREENX, 398 + SCREENY, 17);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(390 + 98 + SCREENX, 398 + SCREENY, 16);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(m_sFrameMouseX, m_sFrameMouseY, 0);
#endif
}

// File-scope static variables for SelectCharacter screen
// Shared between UpdateScreen_SelectCharacter and DrawScreen_SelectCharacter
static class CMouseInterface* s_pSelCharMI;
static DWORD s_dwSelCharCTime;
static short s_sSelCharMsX;
static short s_sSelCharMsY;

// SelectCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_SelectCharacter()
{
	short msX, msY, msZ;
	char cLB, cRB;
	char cMIresult;
	int iMIbuttonNum;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		G_cSpriteAlphaDegree = 1;
		InitGameSettings();
		s_pSelCharMI = new class CMouseInterface;
		s_pSelCharMI->AddRect(100 + SCREENX, 50 + SCREENY, 210 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(211 + SCREENX, 50 + SCREENY, 321 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(322 + SCREENX, 50 + SCREENY, 431 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(432 + SCREENX, 50 + SCREENY, 542 + SCREENX, 250 + SCREENY);

		s_pSelCharMI->AddRect(360 + SCREENX, 283 + SCREENY, 545 + SCREENX, 315 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 316 + SCREENY, 545 + SCREENX, 345 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 346 + SCREENY, 545 + SCREENX, 375 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 376 + SCREENY, 545 + SCREENX, 405 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 406 + SCREENY, 545 + SCREENX, 435 + SCREENY);

		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1) m_cCurFocus = 1;

		m_cArrowPressed = 0;
		InputManager::Get().ClearEnterPressed();

		s_dwSelCharCTime = GameClock::GetTimeMS();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (InputManager::Get().IsEscPressed() == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pSelCharMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus - 1] != 0)
		{
			if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
			{
				std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
				m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
				if (CMisc::bCheckValidString(m_cPlayerName) == true)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
					m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
					m_pLSock->bInitBufferSize(30000);
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					std::memset(m_cMsg, 0, sizeof(m_cMsg));
					strcpy(m_cMsg, "33");
					std::memset(m_cMapName, 0, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
					delete s_pSelCharMI;
					return;
				}
			}
		}
		else
		{
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete s_pSelCharMI;
			return;
		}
	}

	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);
	s_sSelCharMsX = msX;
	s_sSelCharMsY = msY;

	if ((dwTime - s_dwSelCharCTime) > 100)
	{
		m_cMenuFrame++;
		s_dwSelCharCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = s_pSelCharMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else
			{
				if (m_pCharList[m_cCurFocus - 1] != 0)
				{
					if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
					{
						std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
						if (CMisc::bCheckValidString(m_cPlayerName) == true)
						{
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
							m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
							m_pLSock->bInitBufferSize(30000);
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							std::memset(m_cMsg, 0, sizeof(m_cMsg));
							strcpy(m_cMsg, "33");
							std::memset(m_cMapName, 0, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
							delete s_pSelCharMI;
							return;
						}
					}
				}
				else
				{
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete s_pSelCharMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
				{
					std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;

					if (CMisc::bCheckValidString(m_cPlayerName) == true) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Unload();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->Unload();
						m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
						m_pLSock->bInitBufferSize(30000);
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						std::memset(m_cMsg, 0, sizeof(m_cMsg));
						strcpy(m_cMsg, "33");
						std::memset(m_cMapName, 0, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
						delete s_pSelCharMI;
						return;
					}
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4)
			{
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete s_pSelCharMI;
				return;
			}
			break;

		case 7:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus;
				delete s_pSelCharMI;
				return;
			}
			break;

		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete s_pSelCharMI;
			return;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pSelCharMI;
			return;
		}
	}
}

// SelectCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_SelectCharacter()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	// Call the parametered draw version with stored mouse coordinates
	UpdateScreen_OnSelectCharacter(0, 10, s_sSelCharMsX, s_sSelCharMsY);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(s_sSelCharMsX, s_sSelCharMsY, 0);
}

// File-scope static variables for CreateNewCharacter screen
// Shared between UpdateScreen_CreateNewCharacter and DrawScreen_CreateNewCharacter
static class CMouseInterface* s_pNewCharMI;
static int s_iNewCharPoint;
static char s_cNewCharName[12];
static char s_cNewCharPrevFocus;
static DWORD s_dwNewCharMTime;
static short s_sNewCharMsX;
static short s_sNewCharMsY;
static bool s_bNewCharFlag;

// CreateNewCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_CreateNewCharacter()
{
	int iMIbuttonNum;
	char cLB, cRB, cMIresult;
	short msX, msY, msZ;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		s_pNewCharMI = new class CMouseInterface;
		s_pNewCharMI->AddRect(65 + 4 + SCREENX, 65 + 45 + SCREENY, 275 + 4 + SCREENX, 82 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 111 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 124 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 111 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 124 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 126 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 139 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 126 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 139 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 141 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 154 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 141 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 154 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 156 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 169 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 156 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 169 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 171 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 184 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 171 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 184 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 231 + 45 + SCREENY, 253 + 4 + SCREENX, 244 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 231 + 45 + SCREENY, 276 + 4 + SCREENX, 244 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 246 + 45 + SCREENY, 253 + 4 + SCREENX, 259 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 246 + 45 + SCREENY, 276 + 4 + SCREENX, 259 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 261 + 45 + SCREENY, 253 + 4 + SCREENX, 274 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 261 + 45 + SCREENY, 276 + 4 + SCREENX, 274 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 276 + 45 + SCREENY, 253 + 4 + SCREENX, 289 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 276 + 45 + SCREENY, 276 + 4 + SCREENX, 289 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 291 + 45 + SCREENY, 253 + 4 + SCREENX, 304 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 291 + 45 + SCREENY, 276 + 4 + SCREENX, 304 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 306 + 45 + SCREENY, 253 + 4 + SCREENX, 319 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 306 + 45 + SCREENY, 276 + 4 + SCREENX, 319 + 45 + SCREENY);

		s_pNewCharMI->AddRect(384 + SCREENX, 445 + SCREENY, 384 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(500 + SCREENX, 445 + SCREENY, 500 + 72 + SCREENX, 445 + 15 + SCREENY);

		s_pNewCharMI->AddRect(60 + SCREENX, 445 + SCREENY, 60 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(145 + SCREENX, 445 + SCREENY, 145 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(230 + SCREENX, 445 + SCREENY, 230 + 72 + SCREENX, 445 + 15 + SCREENY);

		s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
		s_iNewCharPoint = 70 - s_iNewCharPoint;
		s_cNewCharPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 6;
		InputManager::Get().ClearEnterPressed();
		m_cArrowPressed = 0;
		s_dwNewCharMTime = GameClock::GetTimeMS();
		std::memset(s_cNewCharName, 0, sizeof(s_cNewCharName));
		StartInputString(193 + 4 + SCREENX, 65 + 45 + SCREENY, 11, s_cNewCharName);
		ClearInputString();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (s_cNewCharPrevFocus != m_cCurFocus) {
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(193 + 4 + SCREENX, 65 + 45 + SCREENY, 11, s_cNewCharName);
			break;
		}
		s_cNewCharPrevFocus = m_cCurFocus;
	}

	if (InputManager::Get().IsEscPressed() == true) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete s_pNewCharMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);
	s_sNewCharMsX = msX;
	s_sNewCharMsY = msY;

	// Compute whether character creation is valid (drawing moved to DrawScreen)
	s_bNewCharFlag = true;
	if (strlen(s_cNewCharName) <= 0) s_bNewCharFlag = false;
	if (s_iNewCharPoint > 0) s_bNewCharFlag = false;
	if (CMisc::bCheckValidName(s_cNewCharName) == false) s_bNewCharFlag = false;
	if (_bCheckBadWords(s_cNewCharName) == true) s_bNewCharFlag = false;

	if ((dwTime - s_dwNewCharMTime) > 100)
	{
		m_cMenuFrame++;
		s_dwNewCharMTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = s_pNewCharMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cGender--;
			if (m_cGender < 1) m_cGender = 2;
			break;
		case 3:
			m_cGender++;
			if (m_cGender > 2) m_cGender = 1;
			break;
		case 4:
			m_cSkinCol--;
			if (m_cSkinCol < 1) m_cSkinCol = 3;
			break;
		case 5:
			m_cSkinCol++;
			if (m_cSkinCol > 3) m_cSkinCol = 1;
			break;
		case 6:
			m_cHairStyle--;
			if (m_cHairStyle < 0) m_cHairStyle = 7;
			break;
		case 7:
			m_cHairStyle++;
			if (m_cHairStyle > 7) m_cHairStyle = 0;
			break;
		case 8:
			m_cHairCol--;
			if (m_cHairCol < 0) m_cHairCol = 15;
			break;
		case 9:
			m_cHairCol++;
			if (m_cHairCol > 15) m_cHairCol = 0;
			break;
		case 10:
			m_cUnderCol--;
			if (m_cUnderCol < 0) m_cUnderCol = 7;
			break;
		case 11:
			m_cUnderCol++;
			if (m_cUnderCol > 7) m_cUnderCol = 0;
			break;
		case 12:
			if (s_iNewCharPoint > 0) {
				if (m_ccStr < 14) {
					m_ccStr++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 13:
			if (m_ccStr > 10) {
				m_ccStr--;
				s_iNewCharPoint++;
			}
			break;
		case 14:
			if (s_iNewCharPoint > 0) {
				if (m_ccVit < 14) {
					m_ccVit++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 15:
			if (m_ccVit > 10) {
				m_ccVit--;
				s_iNewCharPoint++;
			}
			break;
		case 16:
			if (s_iNewCharPoint > 0) {
				if (m_ccDex < 14) {
					m_ccDex++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 17:
			if (m_ccDex > 10) {
				m_ccDex--;
				s_iNewCharPoint++;
			}
			break;
		case 18:
			if (s_iNewCharPoint > 0) {
				if (m_ccInt < 14) {
					m_ccInt++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 19:
			if (m_ccInt > 10) {
				m_ccInt--;
				s_iNewCharPoint++;
			}
			break;
		case 20:
			if (s_iNewCharPoint > 0) {
				if (m_ccMag < 14) {
					m_ccMag++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 21:
			if (m_ccMag > 10) {
				m_ccMag--;
				s_iNewCharPoint++;
			}
			break;
		case 22:
			if (s_iNewCharPoint > 0) {
				if (m_ccChr < 14) {
					m_ccChr++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 23:
			if (m_ccChr > 10)
			{
				m_ccChr--;
				s_iNewCharPoint++;
			}
			break;

		case 24:
			if (m_cCurFocus != 2)
			{
				m_cCurFocus = 2;
				return;
			}
			if (s_bNewCharFlag == false) return;
			if (CMisc::bCheckValidName(s_cNewCharName) == false) break;
			std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
			strcpy(m_cPlayerName, s_cNewCharName);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWCHARACTER;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "22");
			delete s_pNewCharMI;
			return;

		case 25:
			if (m_cCurFocus != 3)
			{
				m_cCurFocus = 3;
				return;
			}
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pNewCharMI;
			return;

		case 26: // WARRIOR
			if (m_cCurFocus != 4)
			{
				m_cCurFocus = 4;
				return;
			}

			m_ccMag = 10;
			m_ccInt = 10;
			m_ccChr = 10;
			m_ccStr = 14;
			m_ccVit = 12;
			m_ccDex = 14;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;

		case 27: // MAGE
			if (m_cCurFocus != 5) {
				m_cCurFocus = 5;
				return;
			}

			m_ccMag = 14;
			m_ccInt = 14;
			m_ccChr = 10;
			m_ccStr = 10;
			m_ccVit = 12;
			m_ccDex = 10;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;

		case 28: // PRIEST
			if (m_cCurFocus != 6) {
				m_cCurFocus = 6;
				return;
			}

			m_ccMag = 12;
			m_ccInt = 10;
			m_ccChr = 14;
			m_ccStr = 14;
			m_ccVit = 10;
			m_ccDex = 10;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;
		}
	}
}

// CreateNewCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_CreateNewCharacter()
{
	int i = 0;
	short msX = s_sNewCharMsX;
	short msY = s_sNewCharMsY;
	uint32_t dwTime = GameClock::GetTimeMS();

	// Draw the main character creation UI
	_bDraw_OnCreateNewCharacter(s_cNewCharName, msX, msY, s_iNewCharPoint);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(msX, msY, 0);

	// Tooltip drawing based on mouse position
	if ((msX >= 65 + 4 - 127 + SCREENX) && (msX <= 275 + 4 + SCREENX) && (msY >= 65 + 45 + SCREENY) && (msY <= 82 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER1);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 111 + 45 + SCREENY) && (msY <= 124 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER2);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 126 + 45 + SCREENY) && (msY <= 139 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER3);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 141 + 45 + SCREENY) && (msY <= 154 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER4);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 156 + 45 + SCREENY) && (msY <= 169 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER5);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 171 + 45 + SCREENY) && (msY <= 184 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER6);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 231 + 45 + SCREENY) && (msY <= 244 + 45 + SCREENY)) {
		// Str tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER7);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER8);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER9);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER10);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER11);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 246 + 45 + SCREENY) && (msY <= 259 + 45 + SCREENY)) {
		// Vit tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER12);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER13);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER14);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER15);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER16);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 261 + 45 + SCREENY) && (msY <= 274 + 45 + SCREENY)) {
		// Dex tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER17);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER18);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER19);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER20);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 276 + 45 + SCREENY) && (msY <= 289 + 45 + SCREENY)) {
		// Int tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER21);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER22);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER23);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER24);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 291 + 45 + SCREENY) && (msY <= 304 + 45 + SCREENY)) {
		// Mag tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER25);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER26);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER27);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER28);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 306 + 45 + SCREENY) && (msY <= 319 + 45 + SCREENY)) {
		// Charisma tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER29);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER30);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER31);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER32);
	}
	else if ((msX >= 384 + SCREENX) && (msX <= 384 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 2;
		if (strlen(s_cNewCharName) <= 0)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER35);
		}
		else if (s_iNewCharPoint > 0)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER36);
		}
		else if (CMisc::bCheckValidName(s_cNewCharName) == false)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER39);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER40);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41);
		}
		else if (_bCheckBadWords(s_cNewCharName) == true)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER42);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER43);
		}
		else
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER44);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER45);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER46);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER47);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48);
		}
	}
	else if ((msX >= 500 + SCREENX) && (msX <= 500 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY))
	{
		m_cCurFocus = 3;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER49);
	}

	if ((msX >= 60 + SCREENX) && (msX <= 60 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 4;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER50);
	}

	if ((msX >= 145 + SCREENX) && (msX <= 145 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 5;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER51);
	}

	if ((msX >= 230 + SCREENX) && (msX <= 230 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 6;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER52);
	}
}


void CGame::UpdateScreen_OnSelectCharacter(short sX, short sY, short msX, short msY, bool bIgnoreFocus)
{
	int i;
	int iYear, iMonth, iDay, iHour, iMinute;
	__int64 iTemp1, iTemp2;
	char cTotalChar = 0;
	uint32_t dwTime = GameClock::GetTimeMS();
	sY = 10;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_SELECTCHAR, 0 + SCREENX, 0 + SCREENY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 50);

	iTemp1 = 0;
	iTemp2 = 0;
	iYear = iMonth = iDay = iHour = iMinute = 0;
	for (i = 0; i < 4; i++)
	{
		if ((m_cCurFocus - 1 == i) && (bIgnoreFocus == false))
			m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(sX + 110 + i * 109 - 7 + SCREENX, 63 - 9 + SCREENY, 62);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->Draw(sX + 110 + i * 109 - 7 + SCREENX, 63 - 9 + SCREENY, 61);

		if (m_pCharList[i] != 0)
		{
			cTotalChar++;
			switch (m_pCharList[i]->m_sSex) {
			case 1:	_tmp_sOwnerType = 1; break;
			case 2:	_tmp_sOwnerType = 4; break;
			}
			_tmp_sOwnerType += m_pCharList[i]->m_sSkinCol - 1;
			_tmp_cDir = m_cMenuDir;
			_tmp_sAppr1 = m_pCharList[i]->m_sAppr1;
			_tmp_sAppr2 = m_pCharList[i]->m_sAppr2;
			_tmp_sAppr3 = m_pCharList[i]->m_sAppr3;
			_tmp_sAppr4 = m_pCharList[i]->m_sAppr4;
			_tmp_iApprColor = m_pCharList[i]->m_iApprColor; // v1.4

			std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
			memcpy(_tmp_cName, m_pCharList[i]->m_cName, 10);
			// CLEROTH - NO USE
			_tmp_cAction = DEF_OBJECTMOVE;
			_tmp_cFrame = m_cMenuFrame;

			if (m_pCharList[i]->m_sSex != 0)
			{
				if (CMisc::bCheckValidString(m_pCharList[i]->m_cName) == true)
				{
					m_pEffectSpr[0]->Draw(sX + 157 + i * 109 + SCREENX, sY + 138 + SCREENY, 1, SpriteLib::DrawParams::Alpha(0.5f));
					DrawObject_OnMove_ForMenu(0, 0, sX + 157 + i * 109 + SCREENX, sY + 138 + SCREENY, false, dwTime, 0, 0);
					PutString(sX + 112 + i * 109 + SCREENX, sY + 179 - 9 + SCREENY, m_pCharList[i]->m_cName, RGB(51, 0, 51));//25,35,25);
					int	_sLevel = m_pCharList[i]->m_sLevel;
					wsprintf(G_cTxt, "%d", _sLevel);
					PutString(sX + 138 + i * 109 + SCREENX, sY + 196 - 10 + SCREENY, G_cTxt, RGB(51, 0, 51)); //25,35,25);

					DisplayCommaNumber_G_cTxt(m_pCharList[i]->m_iExp);
					PutString(sX + 138 + i * 109 + SCREENX, sY + 211 - 10 + SCREENY, G_cTxt, RGB(51, 0, 51)); //25,35,25);
				}
				iTemp2 = m_pCharList[i]->m_iYear * 1000000 + m_pCharList[i]->m_iMonth * 60000 + m_pCharList[i]->m_iDay * 1700 + m_pCharList[i]->m_iHour * 70 + m_pCharList[i]->m_iMinute;
				if (iTemp1 < iTemp2)
				{
					iYear = m_pCharList[i]->m_iYear;
					iMonth = m_pCharList[i]->m_iMonth;
					iDay = m_pCharList[i]->m_iDay;
					iHour = m_pCharList[i]->m_iHour;
					iMinute = m_pCharList[i]->m_iMinute;
					iTemp1 = iTemp2;
				}
			}
		}
	}
	i = 0;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 51);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 52);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 53);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 54);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 55);

	if ((msX > 360 + SCREENX) && (msY >= 283 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 315 + SCREENY)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 56);
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER1);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER2);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER3);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER4);//"
	}
	else
		if ((msX > 360 + SCREENX) && (msY >= 316 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 345 + SCREENY)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 57);
			PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER5);//"

		}
		else
			if ((msX > 360 + SCREENX) && (msY >= 346 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 375 + SCREENY)) {

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 58);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER6);//"
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER7);//"

			}
			else if ((msX > 360 + SCREENX) && (msY >= 376 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 405 + SCREENY))
			{
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 59);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER12);//"
			}
			else if ((msX > 360 + SCREENX) && (msY >= 406 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 435 + SCREENY)) {
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 60);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"
			}
			else
			{
				if (cTotalChar == 0)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER14);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER15);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER16);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER17);//"New Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER18);//"
				}
				else if (cTotalChar < 4)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER19);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER20);//"Play�
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER21);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER22);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER23);//"Delete Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 350 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER24);//"
				}
				if (cTotalChar == 4)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER25);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER26);//"Play
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER27);//"Delete Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER28);//"
				}
			}
	int iTempMon, iTempDay, iTempHour, iTempMin;
	iTempMon = iTempDay = iTempHour = iTempMin = 0;

	if (m_iAccntYear != 0)
	{
		iTempMin = (m_iTimeLeftSecAccount / 60);
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
	}
	else
	{
		if (m_iTimeLeftSecAccount > 0)
		{
			iTempDay = (m_iTimeLeftSecAccount / (60 * 60 * 24));
			iTempHour = (m_iTimeLeftSecAccount / (60 * 60)) % 24;
			iTempMin = (m_iTimeLeftSecAccount / 60) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER39);
	}
	PutAlignedString(98 + SCREENX, 357 + SCREENX, 385 + 10 + SCREENY, G_cTxt);

	if (m_iIpYear != 0)
	{
		iTempHour = (m_iTimeLeftSecIP / (60 * 60));
		iTempMin = (m_iTimeLeftSecIP / 60) % 60;
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER40, m_iIpYear, m_iIpMonth, m_iIpDay, iTempHour, iTempMin);
	}
	else
	{
		if (m_iTimeLeftSecIP > 0)
		{
			iTempDay = (m_iTimeLeftSecIP / (60 * 60 * 24));
			iTempHour = (m_iTimeLeftSecIP / (60 * 60)) % 24;
			iTempMin = (m_iTimeLeftSecIP / 60) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER41, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER42);
	}
	PutAlignedString(98 + SCREENX, 357 + SCREENX, 400 + 10 + SCREENY, G_cTxt);
	if (iYear != 0)
	{
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER43, iYear, iMonth, iDay, iHour, iMinute);
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 415 + 10 + SCREENY, G_cTxt);
	}

	PutAlignedString(122, 315, 456, UPDATE_SCREEN_ON_SELECT_CHARACTER36);//"Test Server"
}


void CGame::ReserveFightzoneResponseHandler(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseFightzoneReserve>(
		pData, sizeof(hb::net::PacketResponseFightzoneReserve));
	if (!pkt) return;
	switch (pkt->header.msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER1, 10);
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 14;
		m_iFightzoneNumber = m_iFightzoneNumberTemp;
		break;

	case DEF_MSGTYPE_REJECT:
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER2, 10);
		m_iFightzoneNumberTemp = 0;

		if (pkt->result == 0) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 15;
		}
		else if (pkt->result == -1) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 16;
		}
		else if (pkt->result == -2) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 17;
		}
		else if (pkt->result == -3) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 21;
		}
		else if (pkt->result == -4) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 22;
		}
		break;
	}
}

void CGame::UpdateScreen_OnLogResMsg()
{
	short msX, msY, msZ, sX, sY;
	char  cLB, cRB;
	uint32_t dwTime = GameClock::GetTimeMS();
	static DWORD dwCTime;
	static class CMouseInterface* pMI;
	int   iMIbuttonNum;
	char  cMIresult;


	if (m_cGameModeCount == 0)
	{
		pMI = new class CMouseInterface;
		pMI->AddRect(370 + SCREENX, 240 + SCREENY, 370 + SCREENX + DEF_BTNSZX, 240 + SCREENY + DEF_BTNSZY);
		InputManager::Get().ClearEnterPressed();
		InputManager::Get().ClearEscPressed();
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		AudioManager::Get().StopSound(SoundType::Effect, 38);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (InputManager::Get().IsEscPressed() == true || InputManager::Get().IsEnterPressed()) {
		switch (m_cMsg[0]) {
		case '0':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			break;
		case '1':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '2':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			break;
		case '3':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '4':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '5':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '6':
			switch (m_cMsg[1]) {
			case 'B':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			}
			break;
		case '7':
		case '8':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		}

		delete pMI;
		InputManager::Get().ClearEscPressed();
		return;
	}

	InputManager::Get().GetLegacyState(&msX, &msY, &msZ, &cLB, &cRB);

	switch (m_cMsg[0]) {
	case '0':
	case '5':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
	case '7':
		sX = 146;
		sY = 114;

		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;

	case '2':
	case '4':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		sX = 0;
		sY = 0;
		UpdateScreen_OnSelectCharacter(sX, sY, 0, 0);
		break;

	case '6':
		sX = 146;
		sY = 114;

		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '8':
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, true);
		break;
	}

	m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	if ((msX >= 370 + SCREENX) && (msX <= 370 + DEF_BTNSZX + SCREENX) && (msY >= 244 + SCREENY) && (msY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 0);

	switch (m_cMsg[1]) {
	case '1':
		PutString_SprFont(172 + 70 + SCREENX, 165 + SCREENY, "Password is not correct!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG5);//"
		break;

	case '2':
		PutString_SprFont(172 + 70 + SCREENX, 165 + SCREENY, "Not existing account!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG6);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 215 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG7);//"
		break;

	case '3':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG8);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG9);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 225 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG10);//"
		break;

	case '4':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "New account created.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG11);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG12);//"
		break;

	case '5':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "Can not create new account!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG13);//"
		break;

	case '6':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not create new account!", 7, 0, 0);
		PutString_SprFont(172 + 24 + SCREENX, 180 + SCREENY, "Already existing account name.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 205 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG14);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG15);//"
		break;

	case '7':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "New character created.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG16);//"
		break;

	case '8':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "Can not create new character!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG17);//"
		break;

	case '9':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not create new character!", 7, 0, 0);
		PutString_SprFont(172 + 24 + SCREENX, 180 + SCREENY, "Already existing character name.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 205 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG18);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG19);//"
		break;

	case 'A':
		PutString_SprFont(172 + 36 + 45 + SCREENX, 165 + SCREENY, "Character deleted.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG20);//"

		break;
	case 'B':
		PutString_SprFont(172 + 36 + 45 + SCREENX, 165 + SCREENY, "Password changed.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG21);//"
		break;
	case 'C':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not change password!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG22);//"
		break;

	case 'D':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG23);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG24);//"
		break;

	case 'E':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG25);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG26);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 225 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG27);//"
		break;

	case 'F':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG28);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG29);//"
		break;

	case 'G':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG30);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG31);//"
		break;

	case 'H':
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Connection Rejected!", 7, 0, 0);
		if (m_iBlockYear == 0) {
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG32);//"
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG33);//"
		}
		else {
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG34);//"
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_LOG_MSG35, m_iBlockYear, m_iBlockMonth, m_iBlockDay);//"
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, G_cTxt);
		}
		break;

	case 'I': //
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Not Enough Point!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "�I�ƨϥδ����w����, �Ц�GD2S.gamania.com�����ϥδ���");

		break;

	case 'J': // v2.15 2002-5-21
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "World Server Full", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Please ! Try Other World Server");
		break;

	case 'M': 	// v2.18
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Your password expired", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Please! Change password");
		break;


	case 'U': // v2.15
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Keycode input Success!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Keycode Registration successed.");

		break;

	case 'X':
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG38);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG39);//"
		break;

	case 'Y':
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG40);//"
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;

	case 'Z':
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG42);//"
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1:
			switch (m_cMsg[0]) {
			case '0':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
				break;
			case '1':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '2':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				break;
			case '3':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '4':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '5':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '6':
				switch (m_cMsg[1]) {
				case 'B':
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
					break;
				case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				}
				break;
			case '7':
			case '8':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			}
			delete pMI;
			return;
		}
	}

	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(msX, msY, 0);
}

void CGame::RetrieveItemHandler(char* pData)
{
	char cBankItemIndex, cItemIndex, cTxt[120];
	int j;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	if (header->msg_type != DEF_MSGTYPE_REJECT)
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseRetrieveItem>(
			pData, sizeof(hb::net::PacketResponseRetrieveItem));
		if (!pkt) return;
		cBankItemIndex = static_cast<char>(pkt->bank_index);
		cItemIndex = static_cast<char>(pkt->item_index);

		if (m_pBankList[cBankItemIndex] != 0) {
			// v1.42
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pBankList[cBankItemIndex], cStr1, cStr2, cStr3);

			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//""You took out %s."
			AddEventList(cTxt, 10);

			if ((m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW))
			{
				if (m_pItemList[cItemIndex] == 0) goto RIH_STEP2;
				delete m_pBankList[cBankItemIndex];
				m_pBankList[cBankItemIndex] = 0;
				for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{
					if ((m_pBankList[j + 1] != 0) && (m_pBankList[j] == 0))
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
			else
			{
			RIH_STEP2:;
				if (m_pItemList[cItemIndex] != 0) return;
				short nX, nY;
				nX = 40;
				nY = 30;
				for (j = 0; j < DEF_MAXITEMS; j++)
				{
					if ((m_pItemList[j] != 0) && (memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0))
					{
						nX = m_pItemList[j]->m_sX + 1;
						nY = m_pItemList[j]->m_sY + 1;
						break;
					}
				}
				m_pItemList[cItemIndex] = m_pBankList[cBankItemIndex];
				m_pItemList[cItemIndex]->m_sX = nX;
				m_pItemList[cItemIndex]->m_sY = nY;
				bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemIndex, nX, nY, 0, 0);

				for (j = 0; j < DEF_MAXITEMS; j++)
					if (m_cItemOrder[j] == -1)
					{
						m_cItemOrder[j] = cItemIndex;
						break;
					}
				m_bIsItemEquipped[cItemIndex] = false;
				m_bIsItemDisabled[cItemIndex] = false;
				m_pBankList[cBankItemIndex] = 0;
				for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{
					if ((m_pBankList[j + 1] != 0) && (m_pBankList[j] == 0))
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
		}
	}
	m_dialogBoxManager.Info(DialogBoxId::Bank).cMode = 0;
}

void CGame::EraseItem(char cItemID)
{
	int i;
	char cStr1[64], cStr2[64], cStr3[64];
	std::memset(cStr1, 0, sizeof(cStr1));
	std::memset(cStr2, 0, sizeof(cStr2));
	std::memset(cStr3, 0, sizeof(cStr3));
	for (i = 0; i < 6; i++)
	{
		if (m_sShortCut[i] == cItemID)
		{
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
			if (i < 3) wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 1);
			else wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 7);
			AddEventList(G_cTxt, 10);
			m_sShortCut[i] = -1;
		}
	}

	if (cItemID == m_sRecentShortCut)
		m_sRecentShortCut = -1;
	// ItemOrder
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == cItemID)
			m_cItemOrder[i] = -1;
	for (i = 1; i < DEF_MAXITEMS; i++)
		if ((m_cItemOrder[i - 1] == -1) && (m_cItemOrder[i] != -1))
		{
			m_cItemOrder[i - 1] = m_cItemOrder[i];
			m_cItemOrder[i] = -1;
		}
	// ItemList
	delete m_pItemList[cItemID];
	m_pItemList[cItemID] = 0;
	m_bIsItemEquipped[cItemID] = false;
	m_bIsItemDisabled[cItemID] = false;
}

void CGame::DlbBoxDoubleClick_Character(short msX, short msY)
{
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS], cItemID = -1;
	short sX, sY, sSprH, sFrame;
	int i;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return;
	sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 41, sY + 137, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 90, sY + 170, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 98, sY + 182, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->CheckCollision(sX + 72, sY + 135, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6)) {
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 45, sY + 143, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 84, sY + 175, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 98, sY + 182, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->CheckCollision(sX + 72, sY + 139, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}

	if (cItemID == -1 || m_pItemList[cItemID] == 0) return;
	if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) || (m_pItemList[cItemID]->m_dwCount > 1)) return;
	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) == true) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 == 24))
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, 0, cItemID, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3, 0, m_pItemList[cItemID]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); // v1.4
	else {
		if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
		{
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
			std::memset(G_cTxt, 0, sizeof(G_cTxt));
			wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"
			AddEventList(G_cTxt, 10);
			if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
			else PlaySound('E', 29, 0);

			// Remove Angelic Stats
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
			{
				char cItemID = m_stMCursor.sSelectedObjectID;
				if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
				{
					m_iAngelicStr = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
				{
					m_iAngelicDex = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
				{
					m_iAngelicInt = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
				{
					m_iAngelicMag = 0;
				}
			}
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
			m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
			m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
			m_stMCursor.cSelectedObjectType = 0;
			m_stMCursor.sSelectedObjectID = 0;
		}
	}
}

void CGame::DlbBoxDoubleClick_GuideMap(short msX, short msY)
{
	short si = m_stMCursor.sCursorFrame;
	if (si != 0) return;
	if (m_cMapIndex < 0) return;

	short sX, sY, shX, shY, szX, szY;
	sX = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX;
	szY = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY;
	if (sX < 20) sX = 0;
	if (sY < 20) sY = 0;
	if (sX > LOGICAL_MAX_X - 128 - 20) sX = LOGICAL_MAX_X - 128;
	if (sY > 547 - 128 - 20) sY = 547 - 128;
	if (ConfigManager::Get().IsZoomMapEnabled())
	{
		shX = m_sPlayerX - 64;
		shY = m_sPlayerY - 64;
		if (shX < 0) shX = 0;
		if (shY < 0) shY = 0;
		if (shX > m_pMapData->m_sMapSizeX - 128) shX = m_pMapData->m_sMapSizeX - 128;
		if (shY > m_pMapData->m_sMapSizeY - 128) shY = m_pMapData->m_sMapSizeY - 128;
		shX = shX + msX - sX;
		shY = shY + msY - sY;
	}
	else
	{
		shX = (m_pMapData->m_sMapSizeX * (msX - sX)) / 128;
		shY = (m_pMapData->m_sMapSizeX * (msY - sY)) / 128;
	}
	if (shX < 30 || shY < 30) return;
	if (shX > m_pMapData->m_sMapSizeX - 30 || shY > m_pMapData->m_sMapSizeY - 30) return;
	if ((ConfigManager::Get().IsRunningModeEnabled() == true) && (m_iSP > 0))
		m_cCommand = DEF_OBJECTRUN;
	else m_cCommand = DEF_OBJECTMOVE;
	m_sCommX = shX;
	m_sCommY = shY;
	GetPlayerTurn();
}

void CGame::DlbBoxDoubleClick_Inventory(short msX, short msY)
{
	int i;
	char  cItemID, cTxt[120];
	short sX, sY, x1, x2, y1, y2;
	char cStr1[64], cStr2[64], cStr3[64];
	//if (m_iHP <= 0) return;
	if (m_bItemUsingStatus == true)
	{
		AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY1, 10);
		return;
	}
	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] == -1) continue;
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
		if (m_pItemList[cItemID] == 0) continue;

		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->GetFrameRect(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
		// Order
		x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
		y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
		x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
		y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

		if ((m_bIsItemDisabled[cItemID] == false) && (m_bIsItemEquipped[cItemID] == false) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
		{	// Order
			_SetItemOrder(0, cItemID);
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);

			if (m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 == 24))
			{
				if (m_pItemList[cItemID]->m_cEquipPos != DEF_EQUIPPOS_NONE)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, 0, cItemID, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3, 0, m_pItemList[cItemID]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); // v1.4
					return;
				}
			}

			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Bank))
			{	// centu - wh
				bItemDrop_Bank(msX, msY);
				return;
			}
			else if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellList))
			{	// centu - sell
				bItemDrop_SellList(msX, msY);
				return;
			}
			else if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade))
			{	// centu - upgrade
				bItemDrop_ItemUpgrade();
				return;
			}

			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_PERM)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT))
			{
				if (bCheckItemOperationEnabled(cItemID) == false) return;
				if ((GameClock::GetTimeMS() - m_dwDamagedTime) < 10000)
				{
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 9))
					{
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
					}
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 89))
					{
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
					}
				}
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, cItemID, 0, 0, 0);

				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)
					|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT))
				{
					m_bIsItemDisabled[cItemID] = true;
					m_bItemUsingStatus = true;
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					m_bIsGetPointingMode = true;
					m_iPointCommandType = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY7, cStr1);//"Item %s: Select a position which you want to use."
					AddEventList(cTxt, 10);
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY13, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					m_bIsGetPointingMode = true;
					m_iPointCommandType = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY8, cStr1);//"Item %s: Select an item which you want to use."
					AddEventList(cTxt, 10);
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}

				if (m_bSkillUsingStatus == true) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}

				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					switch (m_pItemList[cItemID]->m_sSpriteFrame) {
					case 55: // Alchemy pot
						if (m_cSkillMastery[12] == 0)
						{
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY9, 10);//"You should learn alchemy skill to use this item."
						}
						else
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 1, 0, 0, 0);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);//"Using alchemy skill..."
						}
						break;
					case 113: // Smith's Anvil
						if (m_cSkillMastery[13] == 0)
						{
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY11, 10);//"You should learn manufacturing skill to use this item.."
						}
						else
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 3, 0, 0, 0);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"Using a manufacturing skill..."
						}
						break;

						// Crafting
					case 0:
						//if (m_pItemList[i]->m_sSprite == 22)
					{
						m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 7, 0, 0, 0);
						AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY17, 10);	//  "Initiating item Crafting..."
					}
					break;

					case 151:
					case 152:
					case 153:
					case 154:
						m_dialogBoxManager.EnableDialogBox(DialogBoxId::Slates, 1, 0, 0, 0);
						break;
					}
				}
			}
			// Dblclick Alchemy bowl
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 1))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			// Dblclick Manuf box
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 4))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			// Crafting
			// Dblclick Crafting box
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 7))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = (short)cItemID;
				bItemDrop_Character();
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
			}
			return;
		}
	}
}



void CGame::DrawNpcName(short sX, short sY, short sOwnerType, int iStatus)
{
	char cTxt[32], cTxt2[64];
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	GetNpcName(sOwnerType, cTxt);
	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"
	PutString2(sX, sY, cTxt, 255, 255, 255);
	if (m_bIsObserverMode == true) PutString2(sX, sY + 14, cTxt, 50, 50, 255);
	else if (m_bIsConfusion || (m_iIlusionOwnerH != 0))
	{
		std::memset(cTxt, 0, sizeof(cTxt));
		strcpy(cTxt, DRAW_OBJECT_NAME87);//"(Unknown)"
		PutString2(sX, sY + 14, cTxt, 150, 150, 150); // v2.171
	}/*else
	{	switch( _iGetFOE(iStatus) ){
		case -2:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
		case -1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
		case 0:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME88, 50,50,255); // "Neutral"
			break;
		case 1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME89, 30,255,30); // "(Friendly)"
			break;
	}	}*/
#ifdef _DEBUG
	wsprintf(cTxt2, "Status: 0x%.8X ", iStatus);
	PutString2(sX, sY + 42, cTxt2, 30, 255, 30);
	std::memset(cTxt2, 0, sizeof(cTxt2));
#endif

	switch ((iStatus & 0x0F00) >> 8) {
	case 0: break;
	case 1: strcpy(cTxt2, DRAW_OBJECT_NAME52); break;//"Clairvoyant"
	case 2: strcpy(cTxt2, DRAW_OBJECT_NAME53); break;//"Destruction of Magic Protection"
	case 3: strcpy(cTxt2, DRAW_OBJECT_NAME54); break;//"Anti-Physical Damage"
	case 4: strcpy(cTxt2, DRAW_OBJECT_NAME55); break;//"Anti-Magic Damage"
	case 5: strcpy(cTxt2, DRAW_OBJECT_NAME56); break;//"Poisonous"
	case 6: strcpy(cTxt2, DRAW_OBJECT_NAME57); break;//"Critical Poisonous"
	case 7: strcpy(cTxt2, DRAW_OBJECT_NAME58); break;//"Explosive"
	case 8: strcpy(cTxt2, DRAW_OBJECT_NAME59); break;//"Critical Explosive"
	}
	if (CMisc::bCheckIMEString(cTxt2)) PutString_SprFont3(sX, sY + 22, cTxt2, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
	else PutString2(sX, sY + 28, cTxt2, 240, 240, 70);

	// centu: no muestra la barra de hp de algunos npc
	switch (sOwnerType) {
	case 15:
	case 19:
	case 20:
	case 24:
	case 25:
	case 26:
	case 42:
	case 55:
	case 56:
	case 67:
	case 68:
	case 69:
	case 64:
	{
		switch ((_tmp_sAppr2 & 0xFF00) >> 8) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		default:
			break;
		}
	}
	case 90:
		break;
	default:
		if (iNpcHP > 0)
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS]->DrawWidth(sX, sY + 16, 18, 75);
			int iBarWidth2 = (iNpcHP * 75) / iNpcMaxHP;
			if (iBarWidth2 < 0) iBarWidth2 = 0;
			if (iBarWidth2 > 75) iBarWidth2 = 75;
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS]->DrawWidth(sX, sY + 16, 19, iBarWidth2); // 16
		}
		break;
	}
}

void CGame::DrawObjectName(short sX, short sY, char* pName, int iStatus)
{
	char cTxt[64], cTxt2[64];
	short sR, sG, sB;
	int i, iGuildIndex, iFOE, iAddY = 0;
	bool bPK, bCitizen, bAresden, bHunter;
	iFOE = _iGetFOE(iStatus);
	if (iFOE < 0)
	{
		sR = 255; sG = 0; sB = 0;
	}
	else if (iFOE == 0)
	{
		sR = 50; sG = 50; sB = 255;
	}
	else
	{
		sR = 30; sG = 200; sB = 30;
	}
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));

	if (m_iIlusionOwnerH == 0)
	{
		if (m_bIsCrusadeMode == false) wsprintf(cTxt, "%s", pName);
		else
		{
			if (_tmp_wObjectID >= 10000) strcpy(cTxt, NPC_NAME_MERCENARY); //"Mercenary"
			else
			{
				if (iFOE == -1) wsprintf(cTxt, "%d", _tmp_wObjectID);
				else strcpy(cTxt, pName);
			}
		}
		if (m_iPartyStatus != 0)
		{
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			{
				if (strcmp(m_stPartyMemberNameList[i].cName, pName) == 0)
				{
					strcat(cTxt, BGET_NPC_NAME23); // ", Party Member"
					break;
				}
			}
		}
	}
	else strcpy(cTxt, "?????");

	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255, 255, 255);
	std::memset(cTxt, 0, sizeof(cTxt));

	if (memcmp(m_cPlayerName, pName, 10) == 0)
	{
		if (m_iGuildRank == 0)
		{
			wsprintf(G_cTxt, DEF_MSG_GUILDMASTER, m_cGuildName);//" Guildmaster)"
			PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
			iAddY = 14;
		}
		if (m_iGuildRank > 0)
		{
			wsprintf(G_cTxt, DEF_MSG_GUILDSMAN, m_cGuildName);//" Guildsman)"
			PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
			iAddY = 14;
		}
		if (m_iPKCount != 0)
		{
			bPK = true;
			sR = 255; sG = 0; sB = 0;
		}
		else
		{
			bPK = false;
			sR = 30; sG = 200; sB = 30;
		}
		bCitizen = m_bCitizen;
		bAresden = m_bAresden;
		bHunter = m_bHunter;
	}
	else
	{	// CLEROTH - CRASH BUG ( STATUS )
		if (iStatus & 0x80000000) bPK = true;
		else bPK = false;
		if (iStatus & 0x40000000) bCitizen = true;
		else bCitizen = false;
		if (iStatus & 0x20000000) bAresden = true;
		else bAresden = false;
		if (iStatus & 0x10000000) bHunter = true;
		else bHunter = false;
		if (m_bIsCrusadeMode == false || iFOE >= 0)
		{
			if (FindGuildName(pName, &iGuildIndex) == true)
			{
				if (m_stGuildName[iGuildIndex].cGuildName[0] != 0)
				{
					if (strcmp(m_stGuildName[iGuildIndex].cGuildName, "NONE") != 0)
					{
						if (m_stGuildName[iGuildIndex].iGuildRank == 0)
						{
							wsprintf(G_cTxt, DEF_MSG_GUILDMASTER, m_stGuildName[iGuildIndex].cGuildName);//
							PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
						else if (m_stGuildName[iGuildIndex].iGuildRank > 0)
						{
							wsprintf(G_cTxt, DEF_MSG_GUILDSMAN, m_stGuildName[iGuildIndex].cGuildName);//"
							PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
					}
					else
					{
						m_stGuildName[iGuildIndex].dwRefTime = 0;
					}
				}
			}
			else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQGUILDNAME, 0, _tmp_wObjectID, iGuildIndex, 0, 0);
		}
	}

	if (bCitizen == false)	strcpy(cTxt, DRAW_OBJECT_NAME60);// "Traveller"
	else
	{
		if (bAresden)
		{
			if (bHunter == true) strcpy(cTxt, DEF_MSG_ARECIVIL); // "Aresden Civilian"
			else strcpy(cTxt, DEF_MSG_ARESOLDIER); // "Aresden Combatant"
		}
		else
		{
			if (bHunter == true) strcpy(cTxt, DEF_MSG_ELVCIVIL);// "Elvine Civilian"
			else strcpy(cTxt, DEF_MSG_ELVSOLDIER);	// "Elvine Combatant"
		}
	}
	if (bPK == true)
	{
		if (bCitizen == false) strcpy(cTxt, DEF_MSG_PK);	//"Criminal"
		else
		{
			if (bAresden) strcpy(cTxt, DEF_MSG_AREPK);// "Aresden Criminal"
			else strcpy(cTxt, DEF_MSG_ELVPK);  // "Elvine Criminal"
		}
	}
	PutString2(sX, sY + 14 + iAddY, cTxt, sR, sG, sB);

#ifdef _DEBUG
	wsprintf(cTxt2, "Status: 0x%.8X ", iStatus);
	PutString2(sX, sY + 42, cTxt2, 30, 255, 30);
	std::memset(cTxt2, 0, sizeof(cTxt2));
#endif
}

bool CGame::FindGuildName(char* pName, int* ipIndex)
{
	int i, iRet = 0;
	uint32_t dwTmpTime;
	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		if (memcmp(m_stGuildName[i].cCharName, pName, 10) == 0)
		{
			m_stGuildName[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return true;
		}
	}
	dwTmpTime = m_stGuildName[0].dwRefTime;
	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		if (m_stGuildName[i].dwRefTime < dwTmpTime)
		{
			iRet = i;
			dwTmpTime = m_stGuildName[i].dwRefTime;
		}
	}
	std::memset(m_stGuildName[iRet].cGuildName, 0, sizeof(m_stGuildName[iRet].cGuildName));
	memcpy(m_stGuildName[iRet].cCharName, pName, 10);
	m_stGuildName[iRet].dwRefTime = m_dwCurTime;
	m_stGuildName[iRet].iGuildRank = -1;
	*ipIndex = iRet;
	return false;
}


void CGame::DrawVersion()
{
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Ver: %s", hb::version::GetDisplayString());
	PutString2(12 + SCREENX, (LOGICAL_HEIGHT - 12 - 14) + SCREENY, G_cTxt, 200, 200, 200);
}

char CGame::GetOfficialMapName(char* pMapName, char* pName)
{	// MapIndex
	if (strcmp(pMapName, "middleland") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME28);	// Middleland
		return 4;
	}
	else if (strcmp(pMapName, "huntzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME31);	// Death Valley
		return 0;
	}
	else if (strcmp(pMapName, "huntzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME29);	// Rocky Highland
		return 1;
	}
	else if (strcmp(pMapName, "elvuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME57);	// Eldiniel Garden
		return 2;
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME24);	// Elvine City
		return 3;
	}
	else if (strcmp(pMapName, "elvfarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME2);	// Elvine Farm
		return 5;
	}
	else if (strcmp(pMapName, "arefarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME1);	// Aresden Farm
		return 6;
	}
	else if (strcmp(pMapName, "default") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME3);	// Beginner Zone
		return 7;
	}
	else if (strcmp(pMapName, "huntzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME32);	// Silent Wood
		return 8;
	}
	else if (strcmp(pMapName, "huntzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME30);	// Eternal Field
		return 9;
	}
	else if (strcmp(pMapName, "areuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME56);	// Aresien Garden
		return 10;
	}
	else if (strcmp(pMapName, "aresden") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME22);	// Aresden City
		return 11;
	}
	else if (strcmp(pMapName, "dglv2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME25);	// Dungeon L2
		return 12;
	}
	else if (strcmp(pMapName, "dglv3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME26);	// Dungeon L3
		return 13;
	}
	else if (strcmp(pMapName, "dglv4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME53);	// Dungeon L4
		return 14;
	}
	else if (strcmp(pMapName, "elvined1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME23);	// Elvine Dungeon
		return 15;
	}
	else if (strcmp(pMapName, "aresdend1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME21);	// Aresden Dungeon
		return 16;
	}
	else if (strcmp(pMapName, "bisle") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME27);	// Bleeding Island
		return 17;
	}
	else if (strcmp(pMapName, "toh1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME60);	// Tower of Hell 1
		return 18;
	}
	else if (strcmp(pMapName, "toh2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME61);	// Tower of Hell 2
		return 19;
	}
	else if (strcmp(pMapName, "toh3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME62);	// Tower of Hell 3
		return 20;
	}
	else if (strcmp(pMapName, "middled1x") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME58);	// Middleland Mine
		return 21;
	}
	else if (strcmp(pMapName, "middled1n") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME59);	// Middleland Dungeon
		return 22;
	}
	else if (strcmp(pMapName, "2ndmiddle") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME65);	// Promiseland
		return 23;
	}
	else if (strcmp(pMapName, "icebound") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME66);	// Ice Map
		return 24;
		// Snoopy:
	}
	else if (strcmp(pMapName, "druncncity") == 0) // Snoopy: Apocalypse maps
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME70);
		return 25;
	}
	else if (strcmp(pMapName, "inferniaA") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME71);
		return 26;
	}
	else if (strcmp(pMapName, "inferniaB") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME72);
		return 27;
	}
	else if (strcmp(pMapName, "maze") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME73);
		return 28;
	}
	else if (strcmp(pMapName, "procella") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME74);
		return 29;
	}
	else if (strcmp(pMapName, "abaddon") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME75);
		return 30;
	}
	else if (strcmp(pMapName, "BtField") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME76);
		return 35;
	}
	else if (strcmp(pMapName, "GodH") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME77);
		return 36;
	}
	else if (strcmp(pMapName, "HRampart") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME78);
		return 37;
	}
	else if (strcmp(pMapName, "cityhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME35);	// Aresden Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "cityhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME36);	// Elvine Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME37);	// Aresden Guildhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME38);	// Elvine Guildhall
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_1", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME33);	// Aresden Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_2", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME34);	// Elvine Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "gshop_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME39);	// Aresden Shop
		return -1;
	}
	else if (memcmp(pMapName, "gshop_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME40);	// Elvine Shop
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME43);	// Aresden Warehouse
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME44);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "arewrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME45);	// Aresden Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "elvwrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME46);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME41);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME42);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "cath_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME47);	// Aresien Church
		return -1;
	}
	else if (strcmp(pMapName, "cath_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME48);	// Eldiniel Church
		return -1;
	}
	else if (strcmp(pMapName, "resurr1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME54);	// Revival Zone
		return -1;
	}
	else if (strcmp(pMapName, "resurr2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME55);	// Revival Zone
		return -1;
	}
	else if (strcmp(pMapName, "arebrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME4);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME5);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME6);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "arebrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME7);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME8);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME9);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME10);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME11);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME12);	// Arena 1
		return -1;
	}
	else if (strcmp(pMapName, "fightzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME13);	// Arena 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME14);	// Arena 3
		return -1;
	}
	else if (strcmp(pMapName, "fightzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME15);	// Arena 4
		return -1;
	}
	else if (strcmp(pMapName, "fightzone5") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME16);	// Arena 5
		return -1;
	}
	else if (strcmp(pMapName, "fightzone6") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME17);	// Arena 6
		return -1;
	}
	else if (strcmp(pMapName, "fightzone7") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME18);	// Arena 7
		return -1;
	}
	else if (strcmp(pMapName, "fightzone8") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME19);	// Arena 8
		return -1;
	}
	else if (strcmp(pMapName, "fightzone9") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME20);	// Arena 9
		return -1;
	}
	else if (strcmp(pMapName, "arejail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME63);	// Aresden Jail
		return -1;
	}
	else if (strcmp(pMapName, "elvjail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME64);	// Elvine Jail
		return -1;
	}
	else if (strcmp(pMapName, "CmdHall_1") == 0) // Snoopy: Commander Halls
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
	else if (strcmp(pMapName, "CmdHall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
	else
	{
		strcpy(pName, pMapName);
		return -1;
	}
}

bool CGame::bCheckLocalChatCommand(char* pMsg)
{
	return ChatCommandManager::Get().ProcessCommand(pMsg);
}

bool CGame::bCheckItemOperationEnabled(char cItemID)
{
	if (m_pItemList[cItemID] == 0) return false;
	if (m_cCommand < 0) return false;
	if (m_bIsTeleportRequested == true) return false;
	if (m_bIsItemDisabled[cItemID] == true) return false;

	if ((m_pItemList[cItemID]->m_sSpriteFrame == 155) && (m_bUsingSlate == true))
	{
		if ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37))
		{
			AddEventList(DEF_MSG_NOTIFY_SLATE_WRONG_MAP, 10); // "You cannot use it right here."
			return false;
		}
		AddEventList(DEF_MSG_NOTIFY_SLATE_ALREADYUSING, 10); // Already Using Another Slate
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellList) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	return true;
}

void CGame::ClearSkillUsingStatus()
{
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(CLEAR_SKILL_USING_STATUS1, 10);//"
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/) {
			m_cCommand = DEF_OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
		}
	}
	m_bSkillUsingStatus = false;
}


void CGame::NpcTalkHandler(char* pData)
{
	char cRewardName[21], cTargetName[21], cTemp[21], cTxt[250];
	short sType, sResponse;
	int iAmount, iIndex, iContribution, iX, iY, iRange;
	int iTargetType, iTargetCount, iQuestionType;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNpcTalk>(
		pData, sizeof(hb::net::PacketNotifyNpcTalk));
	if (!pkt) return;

	sType = pkt->type;
	sResponse = pkt->response;
	iAmount = pkt->amount;
	iContribution = pkt->contribution;
	iTargetType = pkt->target_type;
	iTargetCount = pkt->target_count;
	iX = pkt->x;
	iY = pkt->y;
	iRange = pkt->range;

	std::memset(cRewardName, 0, sizeof(cRewardName));
	memcpy(cRewardName, pkt->reward_name, 20);
	std::memset(cTargetName, 0, sizeof(cTargetName));
	memcpy(cTargetName, pkt->target_name, 20);

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, sResponse, sType, 0);

	if ((sType >= 1) && (sType <= 100))
	{
		iIndex = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
		iQuestionType = 0;
		switch (sType) {
		case 1: //Monster Hunt
			std::memset(cTemp, 0, sizeof(cTemp));
			GetNpcName(iTargetType, cTemp);
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, NPC_TALK_HANDLER16, iTargetCount, cTemp);
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER17);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER18, cTemp);//"Map : %s"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				if (iX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER19, iX, iY, iRange);//"Position: %d,%d within %d blocks"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}

				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER20, iContribution);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 7: //
			std::memset(cTxt, 0, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER21, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER22);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER23, cTemp);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				if (iX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER24, iX, iY, iRange);
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}

				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER25, iContribution);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 10: // Crusade
			std::memset(cTxt, 0, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER26, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER27);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER28);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER29);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER30);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, " ");
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER31);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER32, cTemp);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 2;
			break;
		}

		switch (iQuestionType) {
		case 1:
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER33, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER34, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			break;

		case 2:
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER35, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			break;

		default: break;
		}
	}
}

void CGame::GetNpcName(short sType, char* pName)
{
	switch (sType)
	{
	case 10: strcpy(pName, NPC_NAME_SLIME); break;
	case 11: strcpy(pName, NPC_NAME_SKELETON); break;
	case 12: strcpy(pName, NPC_NAME_STONEGOLEM); break;
	case 13: strcpy(pName, NPC_NAME_CYCLOPS); break;
	case 14: strcpy(pName, NPC_NAME_ORC); break;
	case 15: strcpy(pName, NPC_NAME_SHOP_KEEPER); break;
	case 16: strcpy(pName, NPC_NAME_GIANTANT); break;
	case 17: strcpy(pName, NPC_NAME_GIANTSCORPION); break;
	case 18: strcpy(pName, NPC_NAME_ZOMBIE); break;
	case 19: strcpy(pName, NPC_NAME_MAGICIAN); break;
	case 20: strcpy(pName, NPC_NAME_WAREHOUSE_KEEPER); break;
	case 21: strcpy(pName, NPC_NAME_GUARD); break;
	case 22: strcpy(pName, NPC_NAME_SNAKE); break;
	case 23: strcpy(pName, NPC_NAME_CLAYGOLEM); break;
	case 24: strcpy(pName, NPC_NAME_BLACKSMITH_KEEPER); break;
	case 25: strcpy(pName, NPC_NAME_CITYHALL_OFFICER); break;
	case 26: strcpy(pName, NPC_NAME_GUILDHALL_OFFICER); break;
	case 27: strcpy(pName, NPC_NAME_HELHOUND); break;
	case 28: strcpy(pName, NPC_NAME_TROLL); break;
	case 29: strcpy(pName, NPC_NAME_OGRE); break;
	case 30: strcpy(pName, NPC_NAME_LICHE); break;
	case 31: strcpy(pName, NPC_NAME_DEMON); break;
	case 32: strcpy(pName, NPC_NAME_UNICORN); break;
	case 33: strcpy(pName, NPC_NAME_WEREWOLF); break;
	case 34: strcpy(pName, NPC_NAME_DUMMY); break;
	case 35: strcpy(pName, NPC_NAME_ENERGYSPHERE); break;
	case 36:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_ARROWGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_ARROWGUARDTOWER);
		break;
	case 37:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_CANNONGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_CANNONGUARDTOWER);
		break;
	case 38:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_MANACOLLECTOR_CK);
		else strcpy(pName, NPC_NAME_MANACOLLECTOR);
		break;
	case 39:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_DETECTOR_CK);
		else strcpy(pName, NPC_NAME_DETECTOR);
		break;
	case 40: strcpy(pName, NPC_NAME_ENERGYSHIELD); break;
	case 41: strcpy(pName, NPC_NAME_GRANDMAGICGENERATOR); break;
	case 42: strcpy(pName, NPC_NAME_MANASTONE); break;
	case 43: strcpy(pName, NPC_NAME_LIGHTWARBEETLE); break;
	case 44: strcpy(pName, NPC_NAME_GODSHANDKNIGHT); break;
	case 45: strcpy(pName, NPC_NAME_GODSHANDKNIGHT_CK); break;
	case 46: strcpy(pName, NPC_NAME_TEMPLEKNIGHT); break;
	case 47: strcpy(pName, NPC_NAME_BATTLEGOLEM); break;
	case 48: strcpy(pName, NPC_NAME_STALKER); break;
	case 49: strcpy(pName, NPC_NAME_HELLCLAW); break;
	case 50: strcpy(pName, NPC_NAME_TIGERWORM); break;
	case 51: strcpy(pName, NPC_NAME_CATAPULT); break;
	case 52: strcpy(pName, NPC_NAME_GARGOYLE); break;
	case 53: strcpy(pName, NPC_NAME_BEHOLDER); break;
	case 54: strcpy(pName, NPC_NAME_DARKELF); break;
	case 55: strcpy(pName, NPC_NAME_RABBIT); break;
	case 56: strcpy(pName, NPC_NAME_CAT); break;
	case 57: strcpy(pName, NPC_NAME_FROG); break;
	case 58: strcpy(pName, NPC_NAME_MOUNTAIN_GIANT); break;
	case 59: strcpy(pName, NPC_NAME_ETTIN); break;
	case 60: strcpy(pName, NPC_NAME_CANNIBAL); break;
	case 61: strcpy(pName, NPC_NAME_RUDOLPH); break;
	case 62: strcpy(pName, NPC_NAME_DIREBOAR); break;
	case 63: strcpy(pName, NPC_NAME_FROST); break;
	case 64:
	{
		switch ((_tmp_sAppr2 & 0xFF00) >> 8) {
		case 1:	strcpy(pName, NPC_NAME_WATERMELON);	break;
		case 2: strcpy(pName, NPC_NAME_PUMPKIN); break;
		case 3: strcpy(pName, NPC_NAME_GARLIC); break;
		case 4: strcpy(pName, NPC_NAME_BARLEY); break;
		case 5:	strcpy(pName, NPC_NAME_CARROT); break;
		case 6: strcpy(pName, NPC_NAME_RADISH); break;
		case 7: strcpy(pName, NPC_NAME_CORN); break;
		case 8: strcpy(pName, NPC_NAME_BFLOWER); break;
		case 9: strcpy(pName, NPC_NAME_MELON); break;
		case 10: strcpy(pName, NPC_NAME_TOMATO); break;
		case 11: strcpy(pName, NPC_NAME_GRAPPE); break;
		case 12: strcpy(pName, NPC_NAME_BLUEGRAPPE); break;
		case 13: strcpy(pName, NPC_NAME_MUSHROM); break;
		case 14: strcpy(pName, NPC_NAME_GINSENG); break;
		default: strcpy(pName, NPC_NAME_CROP); break;
		}
	}
	break;
	case 65: strcpy(pName, NPC_NAME_ICEGOLEM); break;
	case 66: strcpy(pName, NPC_NAME_WYVERN); break;
	case 67: strcpy(pName, NPC_NAME_MCGAFFIN); break;
	case 68: strcpy(pName, NPC_NAME_PERRY); break;
	case 69: strcpy(pName, NPC_NAME_DEVLIN); break;

	case 70: strcpy(pName, NPC_NAME_DRAGON); break;
	case 71: strcpy(pName, NPC_NAME_CENTAUR); break;
	case 72: strcpy(pName, NPC_NAME_CLAWTUR); break;
	case 73: strcpy(pName, NPC_NAME_FIREWYV); break;
	case 74: strcpy(pName, NPC_NAME_GICRAYF); break;
	case 75: strcpy(pName, NPC_NAME_GILIZAR); break;
	case 76: strcpy(pName, NPC_NAME_GITREE); break;
	case 77: strcpy(pName, NPC_NAME_MASTORC); break;
	case 78: strcpy(pName, NPC_NAME_MINAUS); break;
	case 79: strcpy(pName, NPC_NAME_NIZIE); break;

	case 80: strcpy(pName, NPC_NAME_TENTOCL); break;
	case 81: strcpy(pName, NPC_NAME_ABADDON); break;
	case 82: strcpy(pName, NPC_NAME_SORCERS); break;
	case 83: strcpy(pName, NPC_NAME_ATK); break;
	case 84: strcpy(pName, NPC_NAME_MASTELF); break;
	case 85: strcpy(pName, NPC_NAME_DSK); break;
	case 86: strcpy(pName, NPC_NAME_HBT); break;
	case 87: strcpy(pName, NPC_NAME_CT); break;
	case 88: strcpy(pName, NPC_NAME_BARBAR); break;
	case 89: strcpy(pName, NPC_NAME_AGC); break;
	case 90: strcpy(pName, NPC_NAME_GAIL); break;
	case 91: strcpy(pName, NPC_NAME_GATE); break;

		// CLEROTH - NEW MONSTERS
	case 110: strcpy(pName, NPC_NAME_AIRLEMENTAL); break;
	}
}

void CGame::_CalcSocketClosed()
{
	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{
		delete m_pGSock;
		m_pGSock = 0;
		InputManager::Get().ClearEscPressed();
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		ChangeGameMode(DEF_GAMEMODE_ONQUIT);
	}
}

void CGame::PointCommandHandler(int indexX, int indexY, char cItemID)
{
	char cTemp[31];
	if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200))
	{
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_MAGIC, 0, indexX, indexY, m_iPointCommandType, 0);
	}
	else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50))
	{
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, m_iPointCommandType, indexX, indexY, cTemp, cItemID); // v1.4

		if (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			m_bSkillUsingStatus = true;
	}
	else if (m_iPointCommandType == 200) // Normal Hand
	{
		if ((strlen(m_cMCName) == 0) || (strcmp(m_cMCName, m_cPlayerName) == 0) || (m_cMCName[0] == '_'))
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			PlaySound('E', 14, 5);
			AddEventList(POINT_COMMAND_HANDLER1, 10);
		}
		else
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 3;
			PlaySound('E', 14, 5);
			std::memset(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Party).cStr));
			strcpy(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, m_cMCName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, 0, 1, 0, 0, m_cMCName);
			return;
		}
	}
}

// File-scope static variables for OnGame screen
// Shared between UpdateScreen_OnGame and DrawScreen_OnGame
static short s_sOnGameMsX, s_sOnGameMsY, s_sOnGameMsZ;
static char s_cOnGameLB, s_cOnGameRB;
static uint32_t s_dwOnGameTime;
static short s_sOnGameDivX, s_sOnGameModX, s_sOnGameDivY, s_sOnGameModY;
static short s_sOnGamePivotX, s_sOnGamePivotY;
static short s_sOnGameVPXsave, s_sOnGameVPYsave;
static DWORD s_dwOnGamePrevChatTime = 0;

// OnGame screen - Update phase (logic/input handling)
void CGame::UpdateScreen_OnGame()
{
	short sVal, absX, absY, tX, tY;
	int i, iAmount;

	s_dwOnGameTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		m_dwFPStime = m_dwCheckConnTime = m_dwCheckSprTime = m_dwCheckChatTime = s_dwOnGameTime;
		m_sFrameCount = 0;
		if (AudioManager::Get().IsMusicEnabled()) StartBGM();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 20) m_cGameModeCount = 20;

	InputManager::Get().GetLegacyState(&s_sOnGameMsX, &s_sOnGameMsY, &s_sOnGameMsZ, &s_cOnGameLB, &s_cOnGameRB);
	m_dwCurTime = GameClock::GetTimeMS();

	// Sync manager singletons with game state
	// Camera: sync view position (pixel coords to tile coords)
	Camera::Get().SetViewPosition(m_sViewPointX / 32, m_sViewPointY / 32);

	// AudioManager: update listener position to player location
	AudioManager::Get().SetListenerPosition(m_sPlayerX, m_sPlayerY);

	// WeatherManager: sync with legacy weather status
	WeatherType currentWeather = WeatherManager::FromLegacyWeather(m_cWhetherStatus);
	if (WeatherManager::Get().GetCurrentWeather() != currentWeather)
	{
		WeatherManager::Get().SetWeatherImmediate(currentWeather);
	}

	// Enter key handling
	if (InputManager::Get().IsEnterPressed() == true)
	{
		InputManager::Get().ClearEnterPressed();

		if ((m_dialogBoxManager.IsEnabled(DialogBoxId::GuildMenu) == true) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::GuildMenu)) {
			EndInputString();
			InputManager::Get().ClearEnterPressed();
			if (strlen(m_cGuildName) == 0) return;
			if (strcmp(m_cGuildName, "NONE") != 0) {
				bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
				m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 2;
			}
		}
		else if ((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::ItemDropExternal)) {
			EndInputString();

			if (m_bSkillUsingStatus == true) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) && ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2))) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true) || (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true) || (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true)) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if (strlen(m_cAmountString) == 0) return;
			iAmount = atoi(m_cAmountString);

			if ((int)(m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount) < iAmount) {
				iAmount = m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount;
			}

			if (iAmount != 0) {
				if ((int)(m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount) >= iAmount) {
					if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 != 0) {
						absX = abs(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 - m_sPlayerX);
						absY = abs(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 - m_sPlayerY);

						if ((absX == 0) && (absY == 0))
							AddEventList(UPDATE_SCREEN_ONGAME5, 10);
						else if ((absX <= 8) && (absY <= 8)) {
							switch (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3) {
							case 1: case 2: case 3: case 4: case 5: case 6:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 1, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								strcpy(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr);
								break;
							case 20:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 3, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								GetNpcName(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
								break;
							case 15: case 24:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 2, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								GetNpcName(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
								break;
							case 1000:
								if (m_stDialogBoxExchangeInfo[0].sV1 == -1) m_stDialogBoxExchangeInfo[0].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[1].sV1 == -1) m_stDialogBoxExchangeInfo[1].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[2].sV1 == -1) m_stDialogBoxExchangeInfo[2].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[3].sV1 == -1) m_stDialogBoxExchangeInfo[3].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else return;
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, 0, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4, iAmount, 0, 0);
								break;
							case 1001:
								for (i = 0; i < DEF_MAXSELLLIST; i++)
									if (m_stSellItemList[i].iIndex == -1) {
										m_stSellItemList[i].iIndex = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
										m_stSellItemList[i].iAmount = iAmount;
										m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4] = true;
										break;
									}
								if (i == DEF_MAXSELLLIST) AddEventList(UPDATE_SCREEN_ONGAME6, 10);
								break;
							case 1002:
								if (_iGetBankItemCount() >= (iMaxBankItems - 1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
								else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, iAmount, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4);
								break;
							default:
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, (char)(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView), iAmount, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_cName);
								break;
							}
							m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = true;
						}
						else AddEventList(UPDATE_SCREEN_ONGAME7, 10);
					}
					else {
						if (iAmount <= 0) AddEventList(UPDATE_SCREEN_ONGAME8, 10);
						else {
							bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, 0, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, iAmount, 0, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_cName);
							m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = true;
						}
					}
				}
				else AddEventList(UPDATE_SCREEN_ONGAME9, 10);
			}
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
		}
		else
		{
			if (!m_bInputStatus) {
				switch (m_cBackupChatMsg[0]) {
				case '!': case '@': case '#': case '$': case '^':
					std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
					m_cChatMsg[0] = m_cBackupChatMsg[0];
					StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
					break;
				default:
					StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
					ClearInputString();
					break;
				}
			}
			else {
				EndInputString();
				std::memset(G_cTxt, 0, sizeof(G_cTxt));
				ReceiveString((char*)G_cTxt);
				std::memset(m_cBackupChatMsg, 0, sizeof(m_cBackupChatMsg));
				strcpy(m_cBackupChatMsg, G_cTxt);
				if ((m_dwCurTime - s_dwOnGamePrevChatTime) >= 700) {
					s_dwOnGamePrevChatTime = m_dwCurTime;
					m_curse.ConvertString(G_cTxt, strlen(G_cTxt));
					if (strlen(G_cTxt) > 0) {
						if ((G_cTxt[0] == '!') || (G_cTxt[0] == '~')) {
							if (CMisc::bCheckIMEString(G_cTxt) == false) return;
						}
						bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, G_cTxt);
					}
				}
			}
		}
	}

	// Save viewport and apply camera shake
	s_sOnGameVPXsave = m_sViewPointX;
	s_sOnGameVPYsave = m_sViewPointY;

	if (m_iCameraShakingDegree > 0) {
		m_sViewPointX += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree * 2);
		m_sViewPointY += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree * 2);
		m_iCameraShakingDegree--;
		if (m_iCameraShakingDegree <= 0) m_iCameraShakingDegree = 0;
	}

	// Calculate viewport tile coordinates
	s_sOnGamePivotX = m_pMapData->m_sPivotX;
	s_sOnGamePivotY = m_pMapData->m_sPivotY;
	sVal = m_sViewPointX - (s_sOnGamePivotX * 32);
	s_sOnGameDivX = sVal / 32;
	s_sOnGameModX = sVal % 32;
	sVal = m_sViewPointY - (s_sOnGamePivotY * 32);
	s_sOnGameDivY = sVal / 32;
	s_sOnGameModY = sVal % 32;

	// Logout countdown
	if (m_cLogOutCount > 0) {
		if ((s_dwOnGameTime - m_dwLogOutCountTime) > 1000) {
			m_cLogOutCount--;
			m_dwLogOutCountTime = s_dwOnGameTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME13, m_cLogOutCount);
			AddEventList(G_cTxt, 10);
		}
	}
	if (m_cLogOutCount == 0) {
		WriteSettings(); // Save settings on logout
		delete m_pGSock;
		m_pGSock = 0;
		InputManager::Get().ClearEscPressed();
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}

	// Restart countdown
	if (m_cRestartCount > 0) {
		if ((s_dwOnGameTime - m_dwRestartCountTime) > 1000) {
			m_cRestartCount--;
			m_dwRestartCountTime = s_dwOnGameTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME14, m_cRestartCount);
			AddEventList(G_cTxt, 10);
		}
	}
	if (m_cRestartCount == 0) {
		m_cRestartCount = -1;
		bSendCommand(MSGID_REQUEST_RESTART, 0, 0, 0, 0, 0, 0);
		return;
	}

	// Update frame counters and process commands
	int iUpdateRet = m_pMapData->iObjectFrameCounter(m_cPlayerName, m_sViewPointX, m_sViewPointY);
	if (m_pEffectManager) m_pEffectManager->Update();
	if (iUpdateRet == 2) {
		m_bCommandAvailable = true;
		m_dwCommandTime = 0;
	}
	CommandProcessor(s_sOnGameMsX, s_sOnGameMsY,
		((s_sOnGameDivX + s_sOnGamePivotX) * 32 + s_sOnGameModX + s_sOnGameMsX - 17) / 32 + 1,
		((s_sOnGameDivY + s_sOnGamePivotY) * 32 + s_sOnGameModY + s_sOnGameMsY - 17) / 32 + 1,
		s_cOnGameLB, s_cOnGameRB);

	// Restore viewport
	m_sViewPointX = s_sOnGameVPXsave;
	m_sViewPointY = s_sOnGameVPYsave;

	if (iUpdateRet > 0) CalcViewPoint();

	// Observer mode camera
	if (m_bIsObserverMode) {
		if ((s_dwOnGameTime - m_dwObserverCamTime) > 25) {
			m_dwObserverCamTime = s_dwOnGameTime;
			CalcViewPoint();
		}
	}

	// Draw flag animation
	if (m_bDrawFlagDir == false) {
		m_iDrawFlag++;
		if (m_iDrawFlag >= 25) { m_iDrawFlag = 25; m_bDrawFlagDir = true; }
	}
	else {
		m_iDrawFlag--;
		if (m_iDrawFlag < 0) { m_iDrawFlag = 0; m_bDrawFlagDir = false; }
	}
}

// OnGame screen - Draw phase (rendering only)
void CGame::DrawScreen_OnGame()
{
	char cItemColor;

	// Update all dialog boxes first (before drawing)
	m_dialogBoxManager.UpdateDialogBoxs();

	// Main scene rendering
	FrameTiming::BeginProfile(ProfileStage::DrawBackground);
	DrawBackground(s_sOnGameDivX, s_sOnGameModX, s_sOnGameDivY, s_sOnGameModY);
	FrameTiming::EndProfile(ProfileStage::DrawBackground);

	FrameTiming::BeginProfile(ProfileStage::DrawEffectLights);
	m_pEffectManager->DrawEffectLights();
	FrameTiming::EndProfile(ProfileStage::DrawEffectLights);

	FrameTiming::BeginProfile(ProfileStage::DrawObjects);
	DrawObjects(s_sOnGamePivotX, s_sOnGamePivotY, s_sOnGameDivX, s_sOnGameDivY, s_sOnGameModX, s_sOnGameModY, s_sOnGameMsX, s_sOnGameMsY);
	FrameTiming::EndProfile(ProfileStage::DrawObjects);

	FrameTiming::BeginProfile(ProfileStage::DrawEffects);
	m_pEffectManager->DrawEffects();
	FrameTiming::EndProfile(ProfileStage::DrawEffects);

	FrameTiming::BeginProfile(ProfileStage::DrawWeather);
	DrawWhetherEffects();
	FrameTiming::EndProfile(ProfileStage::DrawWeather);

	FrameTiming::BeginProfile(ProfileStage::DrawChat);
	DrawChatMsgs(-100, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
	FrameTiming::EndProfile(ProfileStage::DrawChat);

	WhetherObjectFrameCounter();

	// Apocalypse map effects
	if (m_cMapIndex == 26) {
		m_pEffectSpr[89]->Draw(1296 - m_sViewPointX, 1283 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[89]->Draw(1520 - m_sViewPointX, 1123 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[89]->Draw(1488 - m_sViewPointX, 3971 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[93]->Draw(2574 - m_sViewPointX, 3677 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[93]->Draw(3018 - m_sViewPointX, 3973 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
	}
	else if (m_cMapIndex == 27) {
		m_pEffectSpr[89]->Draw(1293 - m_sViewPointX, 3657 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[89]->Draw(944 - m_sViewPointX, 3881 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[89]->Draw(1325 - m_sViewPointX, 4137 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[89]->Draw(1648 - m_sViewPointX, 3913 - m_sViewPointY, _tmp_iEffectFrame % 12, SpriteLib::DrawParams::Alpha(0.5f));
	}

	// Apocalypse gate
	if ((m_iGatePositX >= m_sViewPointX / 32) && (m_iGatePositX <= m_sViewPointX / 32 + VIEW_TILE_WIDTH)
		&& (m_iGatePositY >= m_sViewPointY / 32) && (m_iGatePositY <= m_sViewPointY / 32 + VIEW_TILE_HEIGHT)) {
		m_pEffectSpr[101]->Draw(m_iGatePositX * 32 - m_sViewPointX - 96, m_iGatePositY * 32 - m_sViewPointY - 69, _tmp_iEffectFrame % 30, SpriteLib::DrawParams::Alpha(0.5f));
	}

	// UI rendering
	FrameTiming::BeginProfile(ProfileStage::DrawDialogs);
	m_dialogBoxManager.DrawDialogBoxs(s_sOnGameMsX, s_sOnGameMsY, s_sOnGameMsZ, s_cOnGameLB);
	FrameTiming::EndProfile(ProfileStage::DrawDialogs);

	FrameTiming::BeginProfile(ProfileStage::DrawMisc);
	if (m_bInputStatus) {
		if (((m_dialogBoxManager.IsEnabled(DialogBoxId::GuildMenu) == true) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1)) ||
			((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1))) {
		}
		else m_Renderer->DrawShadowBox(0, LOGICAL_HEIGHT - 69, LOGICAL_MAX_X, LOGICAL_HEIGHT - 51);
		ShowReceivedString();
	}

	ShowEventList(m_dwCurTime);

	// Item tooltip on cursor
	if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) &&
		(m_pItemList[m_stMCursor.sSelectedObjectID] != 0)) {
		cItemColor = m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemColor;
		if (cItemColor != 0) {
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->Draw(s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, SpriteLib::DrawParams::Tint(m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0]));
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->Draw(s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, SpriteLib::DrawParams::Tint(m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0]));
			}
		}
		else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->Draw(s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame);

		char cStr1[64], cStr2[64], cStr3[64];
		int iLoc;
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		iLoc = 0;
		if (strlen(cStr1) != 0) {
			if (m_bIsSpecial) PutString(s_sOnGameMsX, s_sOnGameMsY + 25, cStr1, RGB(0, 255, 50), false, 1);
			else PutString(s_sOnGameMsX, s_sOnGameMsY + 25, cStr1, RGB(255, 255, 255), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr2) != 0) { PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, cStr2, RGB(150, 150, 150), false, 1); iLoc += 15; }
		if (strlen(cStr3) != 0) { PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, cStr3, RGB(150, 150, 150), false, 1); iLoc += 15; }
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit != 0) && ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_dwAttribute & 0x00000001) == 0)) {
			wsprintf(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight >= 1100)) {
			int _wWeight = 0;
			if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight % 100) _wWeight = 1;
			wsprintf(G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight / 100 + _wWeight);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) {
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME10, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wCurLifeSpan, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wMaxLifeSpan);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if (iLoc == 15) {
			iLoc = 0;
			for (int iTmp = 0; iTmp < DEF_MAXITEMS; iTmp++) {
				if (m_pItemList[iTmp] != 0) {
					// Compare by item ID instead of name
					if (m_pItemList[iTmp]->m_sIDnum == m_pItemList[m_stMCursor.sSelectedObjectID]->m_sIDnum) iLoc++;
				}
			}
			if (iLoc > 1) {
				wsprintf(G_cTxt, DEF_MSG_TOTAL_NUMBER, iLoc);
				PutString(s_sOnGameMsX, s_sOnGameMsY + 40, G_cTxt, RGB(150, 150, 150), false, 1);
			}
		}
	}

	// Druncncity bubbles
	if (m_cMapIndex == 25)
		m_pEffectManager->AddEffect(13, m_sViewPointX + rand() % LOGICAL_MAX_X, m_sViewPointY + rand() % LOGICAL_MAX_Y, 0, 0, -1 * (rand() % 80), 1);

	// Heldenian tower count
	if ((m_iHeldenianAresdenLeftTower != -1) && (memcmp(m_cCurLocation, "BtField", 7) == 0)) {
		wsprintf(G_cTxt, "Aresden Flags : %d", m_iHeldenianAresdenFlags);
		PutString(10, 140, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Aresden Flags : %d", m_iHeldenianElvineFlags);
		PutString(10, 160, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Aresden's rest building number : %d", m_iHeldenianAresdenLeftTower);
		PutString(10, 180, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Elvine's rest building number : %d", m_iHeldenianElvineLeftTower);
		PutString(10, 200, G_cTxt, RGB(255, 255, 255));
	}

	DrawTopMsg();

	// Fade-in overlay
	if (m_cGameModeCount < 6) m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	if (m_cGameModeCount < 2) m_Renderer->DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	// Cursor
	if (m_bIsObserverMode == true) {
		m_Renderer->PutPixel(s_sOnGameMsX, s_sOnGameMsY, 255, 255, 255);
		m_Renderer->PutPixel(s_sOnGameMsX + 1, s_sOnGameMsY, 255, 255, 255);
		m_Renderer->PutPixel(s_sOnGameMsX - 1, s_sOnGameMsY, 255, 255, 255);
		m_Renderer->PutPixel(s_sOnGameMsX, s_sOnGameMsY + 1, 255, 255, 255);
		m_Renderer->PutPixel(s_sOnGameMsX, s_sOnGameMsY - 1, 255, 255, 255);
	}
	else m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(s_sOnGameMsX, s_sOnGameMsY, m_stMCursor.sCursorFrame);
	FrameTiming::EndProfile(ProfileStage::DrawMisc);

	// FPS and profiling display
	int iDisplayY = 100;
	if (ConfigManager::Get().IsShowFpsEnabled()) {
		wsprintf(G_cTxt, "fps : %u", FrameTiming::GetFPS());
		PutString(10, iDisplayY, G_cTxt, RGB(255, 255, 255));
		iDisplayY += 14;
	}

	if (ConfigManager::Get().IsShowLatencyEnabled()) {
		if (m_iLatencyMs >= 0)
			wsprintf(G_cTxt, "latency : %d ms", m_iLatencyMs);
		else
			wsprintf(G_cTxt, "latency : -- ms");
		PutString(10, iDisplayY, G_cTxt, RGB(255, 255, 255));
		iDisplayY += 14;
	}

	// Profiling display
	if (FrameTiming::IsProfilingEnabled()) {
		iDisplayY += 4; // Add spacing
		PutString(10, iDisplayY, "--- Profile (avg ms) ---", RGB(255, 255, 100));
		iDisplayY += 14;

		// Display each profile stage (wsprintf doesn't support %f, so use integer ms * 100 for .xx precision)
		for (int i = 0; i < static_cast<int>(ProfileStage::COUNT); i++) {
			ProfileStage stage = static_cast<ProfileStage>(i);
			double avgMs = FrameTiming::GetProfileAvgTimeMS(stage);
			int wholePart = static_cast<int>(avgMs);
			int fracPart = static_cast<int>((avgMs - wholePart) * 100);
			wsprintf(G_cTxt, "%-12s: %3d.%02d", FrameTiming::GetStageName(stage), wholePart, fracPart);
			PutString(10, iDisplayY, G_cTxt, RGB(200, 200, 200));
			iDisplayY += 12;
		}
	}
}

void CGame::StartBGM()
{
	// Determine track name based on current location
	const char* trackName = "MainTm";

	if ((m_bIsXmas == true) && (m_cWhetherEffectType >= 4))
	{
		trackName = "Carol";
	}
	else if (memcmp(m_cCurLocation, "aresden", 7) == 0)
	{
		trackName = "aresden";
	}
	else if (memcmp(m_cCurLocation, "elvine", 6) == 0)
	{
		trackName = "elvine";
	}
	else if (memcmp(m_cCurLocation, "dglv", 4) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "middled1", 8) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "middleland", 10) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "druncncity", 10) == 0)
	{
		trackName = "druncncity";
	}
	else if (memcmp(m_cCurLocation, "inferniaA", 9) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "inferniaB", 9) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "maze", 4) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "abaddon", 7) == 0)
	{
		trackName = "abaddon";
	}

	// Forward to AudioManager
	AudioManager::Get().PlayMusic(trackName);
}

void CGame::MotionResponseHandler(char* pData)
{
	WORD wResponse;
	short sX, sY;
	char cDir;
	int iPreHP;
	//						          0 3        4 5						 6 7		8 9		   10	    11
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_CONFIRM(2) | Loc-X(2) | Loc-Y(2) | Dir(1) | MapData ...
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_REJECT(2)  | Loc-X(2) | Loc-Y(2)
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResponse = header->msg_type;

	switch (wResponse) {
	case DEF_OBJECTMOTION_CONFIRM:
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_ATTACK_CONFIRM:
		m_cCommandCount--;
		if ((m_wLastAttackTargetID >= 10000) && (m_wLastAttackTargetID < 30000)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETNPCHP, 0, m_wLastAttackTargetID, 0, 0, 0);
		}
		break;

	case DEF_OBJECTMOTION_REJECT:
		if (m_iHP <= 0) return;
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionReject>(
				pData, sizeof(hb::net::PacketResponseMotionReject));
			if (!pkt) return;
			m_sPlayerX = pkt->x;
			m_sPlayerY = pkt->y;
		}

		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;

		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = false;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;

		m_bIsRedrawPDBGS = true;
		break;

	case DEF_OBJECTMOVE_CONFIRM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionMoveConfirm>(
			pData, sizeof(hb::net::PacketResponseMotionMoveConfirm));
		if (!pkt) return;
		sX = pkt->x;
		sY = pkt->y;
		cDir = static_cast<char>(pkt->dir);
		m_iSP = m_iSP - pkt->stamina_cost;
		if (m_iSP < 0) m_iSP = 0;
		// v1.3
		//m_iOccupyStatus = (int)*cp;
		iPreHP = m_iHP;
		m_iHP = pkt->hp;

		if (m_iHP != iPreHP)
		{
			if (m_iHP < iPreHP)
			{
				wsprintf(G_cTxt, NOTIFYMSG_HP_DOWN, iPreHP - m_iHP);
				AddEventList(G_cTxt, 10);
				m_dwDamagedTime = GameClock::GetTimeMS();
				if ((m_cLogOutCount > 0) && (m_bForceDisconn == false))
				{
					m_cLogOutCount = -1;
					AddEventList(MOTION_RESPONSE_HANDLER2, 10);
				}
			}
			else
			{
				wsprintf(G_cTxt, NOTIFYMSG_HP_UP, m_iHP - iPreHP);
				AddEventList(G_cTxt, 10);
			}
		}
		m_pMapData->ShiftMapData(cDir);
		const char* mapData = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseMotionMoveConfirm);
		_ReadMapData(sX, sY, mapData);
		m_bIsRedrawPDBGS = true;
		m_cCommandCount--;
	}
	break;

	case DEF_OBJECTMOVE_REJECT:
		if (m_iHP <= 0) return;
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionMoveReject>(
				pData, sizeof(hb::net::PacketResponseMotionMoveReject));
			if (!pkt) return;
			if (m_sPlayerObjectID != pkt->object_id) return;
			m_sPlayerX = pkt->x;
			m_sPlayerY = pkt->y;
			m_sPlayerType = pkt->type;
			m_cPlayerDir = static_cast<char>(pkt->dir);
			m_sPlayerAppr1 = pkt->appr1;
			m_sPlayerAppr2 = pkt->appr2;
			m_sPlayerAppr3 = pkt->appr3;
			m_sPlayerAppr4 = pkt->appr4;
			m_iPlayerApprColor = pkt->appr_color;
			m_iPlayerStatus = pkt->status;
		}
		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0,
			0, 7);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = false;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;
		m_bIsPrevMoveBlocked = true;
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 12, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 13, 0);
			break;
		}
		//m_bCommandAvailable = true;
		break;
	}
}


void CGame::CommandProcessor(short msX, short msY, short indexX, short indexY, char cLB, char cRB)
{
	char   cDir, absX, absY, cName[12];
	short  sX, sY, sObjectType, tX, tY;
	int iObjectStatus;
	int    iRet;
	uint32_t dwTime = GameClock::GetTimeMS();
	uint16_t wType = 0;
	int i;//, iFOE;
	char   cTxt[120];

	char  pDstName[21];
	short sDstOwnerType;
	int iDstOwnerStatus;

	bool  bGORet;
	// Fixed by Snoopy
	if ((m_bIsObserverCommanded == false) && (m_bIsObserverMode == true))
	{
		if ((msX == 0) && (msY == 0) && (m_sViewDstX > 32 * VIEW_TILE_WIDTH) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 8, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (msY == 0) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 2, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (msY == LOGICAL_MAX_Y) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 4, 0, 0, 0, 0);
		else if ((msX == 0) && (msY == LOGICAL_MAX_Y))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 6, 0, 0, 0, 0);
		else if ((msX == 0) && (m_sViewDstX > 32 * VIEW_TILE_WIDTH))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 7, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 3, 0, 0, 0, 0);
		else if ((msY == 0) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 1, 0, 0, 0, 0);
		else if ((msY == LOGICAL_MAX_Y) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 5, 0, 0, 0, 0);
		else return;

		m_bIsObserverCommanded = true;
		m_cArrowPressed = 0;
		return;
	}

	if (m_bIsObserverMode == true) return;

	if (InputManager::Get().IsAltDown()) // [ALT]
		m_bSuperAttackMode = true;
	else m_bSuperAttackMode = false;

	switch (m_stMCursor.cPrevStatus) {
	case DEF_CURSORSTATUS_NULL:
		if (cLB != 0)
		{
			iRet = _iCheckDlgBoxFocus(msX, msY, 1);
			if (iRet == 1)
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_SELECTED;
				return;
			}
			else if (iRet == 0)
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_PRESSED;
				// Snoopy: Added Golden LevelUp
				if ((msX > LEVELUP_TEXT_X) && (msX < (LEVELUP_TEXT_X)+75) && (msY > LEVELUP_TEXT_Y) && (msY < (LEVELUP_TEXT_Y)+21))
				{
					if (m_iHP > 0)
					{
						if ((m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) != true) && (m_iLU_Point > 0))
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::LevelUpSetting, 0, 0, 0);
							PlaySound('E', 14, 5);
						}
					}
					else // Centuu : restart
					{
						if (m_cRestartCount == -1)
						{
							m_cRestartCount = 5;
							m_dwRestartCountTime = GameClock::GetTimeMS();
							wsprintf(G_cTxt, DLGBOX_CLICK_SYSMENU1, m_cRestartCount); // "Restarting game....%d"
							AddEventList(G_cTxt, 10);
							PlaySound('E', 14, 5);

						}
					}
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
					return;
				}
			}
			else if (iRet == -1)
			{
				return;
			}
		}
		else if (cRB != 0)
		{
			iRet = _iCheckDlgBoxFocus(msX, msY, 2);
			if (iRet == 1) return;
		}
		break;
	case DEF_CURSORSTATUS_PRESSED:
		if (cLB == 0) // Normal Click
		{
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
		}
		break;
	case DEF_CURSORSTATUS_SELECTED:
		if (cLB == 0)
		{
			//ZeroEoyPnk - Bye delay...
			if (((m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) != true) || (m_stMCursor.sSelectedObjectID != 12))
				&& ((m_dialogBoxManager.IsEnabled(DialogBoxId::ChangeStatsMajestic) != true) || (m_stMCursor.sSelectedObjectID != 42)))
			{
				if (((dwTime - m_stMCursor.dwSelectClickTime) < DEF_DOUBLECLICKTIME) 	// Double Click
					&& (abs(msX - m_stMCursor.sClickX) <= DEF_DOUBLECLICKTOLERANCE)
					&& (abs(msY - m_stMCursor.sClickY) <= DEF_DOUBLECLICKTOLERANCE))
				{
					m_stMCursor.dwSelectClickTime = 0; // Reset to prevent triple-click
					m_dialogBoxManager._bCheckDlgBoxDoubleClick(msX, msY);
				}
				else // Click
				{
					m_dialogBoxManager._bCheckDlgBoxClick(msX, msY);
					m_stMCursor.sClickX = msX;
					m_stMCursor.sClickY = msY;
				}
			}
			else
			{
				m_dialogBoxManager._bCheckDlgBoxClick(msX, msY);
				m_stMCursor.sClickX = msX;
				m_stMCursor.sClickY = msY;
			}
			m_stMCursor.dwSelectClickTime = dwTime;
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM)
			{
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
			}
			return;
		}
		else 			// v2.05 01-11-30
		{
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;

			if ((m_stMCursor.sPrevX != msX) || (m_stMCursor.sPrevY != msY))
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_DRAGGING;
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 30))
				{
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1))
				{
					EndInputString();
					m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 20;
				}
				// Query Drop Item Amount
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1))
					// Guild Menu
				{
					EndInputString();
					m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode = 20;
				}
				return;
			}
			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		break;
	case DEF_CURSORSTATUS_DRAGGING:
		if (cLB != 0)
		{
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX)
			{
				// HudPanel is fixed and cannot be moved
				if (m_stMCursor.sSelectedObjectID != DialogBoxId::HudPanel)
				{
					m_dialogBoxManager.Info(m_stMCursor.sSelectedObjectID).sX = msX - m_stMCursor.sDistX;
					m_dialogBoxManager.Info(m_stMCursor.sSelectedObjectID).sY = msY - m_stMCursor.sDistY;
				}
			}
			m_stMCursor.sPrevX = msX;
			m_stMCursor.sPrevY = msY;

			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		if (cLB == 0) {
			switch (m_stMCursor.cSelectedObjectType) {
			case DEF_SELECTEDOBJTYPE_DLGBOX:
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 20))
				{
					sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
					sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;
					StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
					m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 1;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 20))
				{	// Query Drop Item Amount
					sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
					sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
					StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
					m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode = 1;
				}

				if (m_stMCursor.sSelectedObjectID == 9)
				{
					{
						if (msX < 400) //LifeX Fix Map
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX = 0;
						}
						else
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX = LOGICAL_MAX_X - m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX;
						}

						if (msY < 273)
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY = 0;
						}
						else
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY = 547 - m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY;
						}
					}
				}

				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;

			case DEF_SELECTEDOBJTYPE_ITEM:
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;

			default:
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;
			}
			return;
		}
		break;
	}

CP_SKIPMOUSEBUTTONSTATUS:;
	if (m_bCommandAvailable == false) return;
	if ((dwTime - m_dwCommandTime) < 300)
	{
		delete m_pGSock;
		m_pGSock = 0;
		InputManager::Get().ClearEscPressed();
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}
	if (m_iHP <= 0) return;

	if (m_sDamageMove != 0)
	{
		m_cCommand = DEF_OBJECTDAMAGEMOVE;
		goto MOTION_COMMAND_PROCESS;
	}

	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0))
		RequestTeleportAndWaitData();

	// indexX, indexY
	if (cLB != 0) // Mouse Left button
	{
		if (m_bIsGetPointingMode == true)
		{
			if ((m_sMCX != 0) || (m_sMCY != 0))
				PointCommandHandler(m_sMCX, m_sMCY);
			else PointCommandHandler(indexX, indexY);

			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			m_bIsGetPointingMode = false;
			return;
		}

		m_pMapData->bGetOwner(m_sMCX, m_sMCY - 1, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID); // v1.4
		//m_pMapData->m_pData[dX][dY].m_sItemSprite
		if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && (sObjectType <= 6 || (m_pMapData->m_pData[m_sPlayerX - m_pMapData->m_sPivotX][m_sPlayerY - m_pMapData->m_sPivotY].m_sItemID != 0 && m_pItemConfigList[m_pMapData->m_pData[m_sPlayerX - m_pMapData->m_sPivotX][m_sPlayerY - m_pMapData->m_sPivotY].m_sItemID]->m_sSprite != 0)))
		{//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[15][15].m_sItemSprite != 0 )) {
		 //if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && sObjectType <= 6){
			if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/)
			{
				m_cCommand = DEF_OBJECTGETITEM;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;
			}
		}
		else
		{
			if (memcmp(m_cMCName, m_cPlayerName, 10) == 0) m_sMCY -= 1;
			if ((m_sMCX != 0) && (m_sMCY != 0)) // m_sMCX, m_sMCY
			{
				if (InputManager::Get().IsCtrlDown() == true)
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if ((iObjectStatus & 0x10) != 0) return;
					if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;
					m_stMCursor.sCursorFrame = 3;
					absX = abs(m_sPlayerX - m_sMCX);
					absY = abs(m_sPlayerY - m_sMCY);
					if ((absX <= 1) && (absY <= 1))
					{
						wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
						&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
					{
						wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else // Pas au corp � corp
					{
						switch (_iGetWeaponSkillType()) {
						case 6: // Bow
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
							break;

						case 5: // OpenHand
						case 7: // SS
							if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
							{
								if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
								{
									if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
									{
										m_cCommand = DEF_OBJECTATTACKMOVE;
										wType = _iGetAttackType();
									}
									else
									{
										m_cCommand = DEF_OBJECTRUN;
										GetPlayerTurn();
									}
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else
								{
									m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							else
							{
								if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)
									&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
									m_cCommand = DEF_OBJECTRUN;	// Staminar
								else m_cCommand = DEF_OBJECTMOVE;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								GetPlayerTurn();
							}
							break;

						case 8: // LS
							if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() != 30)) // Crit without StormBlade
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() == 30))  // Crit with StormBlade (by Snoopy)
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 3) && (absY <= 3)
								&& (_iGetAttackType() == 5))  // Normal hit with StormBlade (by Snoopy)
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else // Swing
							{
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))
									&& (_iGetAttackType() != 5)) // no Dash possible with StormBlade
								{
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
									{
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else
										{
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else
									{
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else
								{
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;

						case 9: // Fencing
							if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;

						case 10: // Axe
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else
							{
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
								{
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
									{
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else
										{
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else
									{
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else
								{
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						case 14: // Hammer
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						case 21: // Wand
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						}
					}
				}
				else // CTRL not pressed
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6)))
					{
						switch (sObjectType) { 	// CLEROTH - NPC TALK
						case 15: // ShopKeeper-W�
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 5, 11, 1);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 15;
							/*	break;
							}*/
							break;

						case 19: // Gandlf
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 16, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 19;
							/*	break;
							}*/
							break;

						case 20: // Howard
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 14, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 20;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 20;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = m_wCommObjectID;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = m_sMCX;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = m_sMCY;
							/*	break;
							}*/
							break;

						case 24: // Tom
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 5, 11, 2);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 24;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 24;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = m_wCommObjectID;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = m_sMCX;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = m_sMCY;
							/*	break;
							}*/
							break;

						case 25: // William
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 13, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 25;
							/*	break;
							}*/
							break;

						case 26: // Kennedy
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 7, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 26;
							/*	break;
							}*/
							break;

						case 21: // Guard
							if ((_iGetFOE(iObjectStatus) >= 0) && (!m_bIsCombatMode))
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 21;
							}
							break;
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							if (!m_bIsCombatMode)
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = sObjectType;
							}
							break;

						case 32: // Unicorn
							if (!m_bIsCombatMode)
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 32;
							}
							break;

						case 90: // Snoopy: Gail
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 6, 0, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 90;
							/*break;
						}*/
							break;

						default: // Other mobs
							if (_iGetFOE(iObjectStatus) >= 0) break;
							if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
							absX = abs(m_sPlayerX - m_sMCX);
							absY = abs(m_sPlayerY - m_sMCY);
							if ((absX <= 1) && (absY <= 1))
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
								&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else // Normal hit from a range.
							{
								switch (_iGetWeaponSkillType()) {
								case 6: // Bow
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
									break;

								case 5: // Boxe
								case 7: // SS
									if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
									break;

								case 8: // LS
									if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
										&& (_iGetAttackType() != 30)) // Crit without StormBlade by Snoopy
									{
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
										&& (_iGetAttackType() == 30)) // Crit with StormBlade by Snoopy
									{
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else if ((absX <= 3) && (absY <= 3)
										&& (_iGetAttackType() == 5)) // Normal hit with StormBlade by Snoopy
									{
										m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else
									{
										if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 9: // Fencing
									if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
									{
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else
									{
										if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 10: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 14: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 21: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								}
							}
							break;
						}
					}
					else {
						if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
							(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
							m_cCommand = DEF_OBJECTRUN;
						else m_cCommand = DEF_OBJECTMOVE;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						GetPlayerTurn();
					}
				}
			}
			else
			{
				if ((InputManager::Get().IsShiftDown() || ConfigManager::Get().IsRunningModeEnabled()) && (m_iSP > 0) &&
					(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
					m_cCommand = DEF_OBJECTRUN;
				else m_cCommand = DEF_OBJECTMOVE;
				m_sCommX = indexX;
				m_sCommY = indexY;
				GetPlayerTurn();
			}
		}
	}
	else if (cRB != 0) // Mouse Right button
	{
		m_cCommand = DEF_OBJECTSTOP;
		if (m_bIsGetPointingMode == true)
		{
			m_bIsGetPointingMode = false;
			AddEventList(COMMAND_PROCESSOR1, 10);
		}
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sMCX != 0) && (m_sMCY != 0))
		{
			absX = abs(m_sPlayerX - m_sMCX);
			absY = abs(m_sPlayerY - m_sMCY);
			if (absX == 0 && absY == 0) return;

			if (InputManager::Get().IsCtrlDown() == true)
			{
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if ((iObjectStatus & 0x10) != 0) return;
				if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;

				if ((absX <= 1) && (absY <= 1))
				{
					wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
					&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
				{
					wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else
				{
					switch (_iGetWeaponSkillType()) {
					case 6: // Bow
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						wType = _iGetAttackType();
						break;

					case 5: // Boxe
					case 7: // SS
						break;

					case 8: // LS
						if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
							&& (_iGetAttackType() != 30)) // without StormBlade by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
							&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 3) && (absY <= 3)
							&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						break;

					case 9: // Fencing
						if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 10: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 14: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					case 21: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					}
				}
			}
			else // CTRL not pressed
			{
				absX = abs(m_sPlayerX - m_sMCX);
				absY = abs(m_sPlayerY - m_sMCY);
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6))) {
					switch (sObjectType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26: // npcs
						break;

					default: // All "normal mobs"
						if (_iGetFOE(iObjectStatus) >= 0) break;
						if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
						if ((absX <= 1) && (absY <= 1))
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else //
						{
							switch (_iGetWeaponSkillType()) {
							case 6: // Bow
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
								break;

							case 5: // Boxe
							case 7: // SS
								break;

							case 8: // LS
								if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() != 30)) // crit without StormBlade by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 3) && (absY <= 3)
									&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								break;

							case 9: // fencing
								if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;

							case 10: //
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 14: // hammer
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 21: // wand
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							}
						}
						break;
					}
				}
			}
		}
		else
		{
			cDir = CMisc::cGetNextMoveDir(m_sPlayerX, m_sPlayerY, indexX, indexY);
			if (m_iHP <= 0) return;
			if (cDir == 0) return;
			if (m_cPlayerDir == cDir) return;
			ClearSkillUsingStatus();
			m_cPlayerDir = cDir;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTSTOP, m_cPlayerDir, 0, 0, 0, 0);

			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				m_cCommand, 0, 0, 0, 0,
				10);
			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			return;
		}
	}

MOTION_COMMAND_PROCESS:;

	if (m_cCommand != DEF_OBJECTSTOP)
	{
		if (m_iHP <= 0) return;
		if (m_cCommandCount == 5) AddEventList(COMMAND_PROCESSOR2, 10, false);
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sPlayerType >= 0) && (m_sPlayerType > 6))
		{
			switch (m_cCommand) {
			case DEF_OBJECTRUN:
			case DEF_OBJECTMAGIC:
			case DEF_OBJECTGETITEM:
				m_cCommand = DEF_OBJECTSTOP;
				break;
			}
		}

		ClearSkillUsingStatus();

		if ((m_sDamageMove != 0) || (m_sDamageMoveAmount != 0))
		{
			if (m_sDamageMove != 0)
			{
				m_cCommand = DEF_OBJECTDAMAGEMOVE;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;

				// mim crit fixed by kaozures tocado para ande bien by cloud :P
				if (m_bIllusionMVT == true) {
					switch (m_sDamageMove) {
					case 1: m_sCommY++; break;
					case 2: m_sCommX--; m_sCommY++; break;
					case 3: m_sCommX--; break;
					case 4: m_sCommX--; m_sCommY--; break;
					case 5: m_sCommY--; break;
					case 6: m_sCommX++; m_sCommY--; break;
					case 7: m_sCommX++; break;
					case 8: m_sCommX++; m_sCommY++; break;
					}
				}
				else {
					switch (m_sDamageMove) {
					case 1: m_sCommY--; break;
					case 2: m_sCommX++; m_sCommY--; break;
					case 3: m_sCommX++; break;
					case 4: m_sCommX++; m_sCommY++; break;
					case 5: m_sCommY++; break;
					case 6: m_sCommX--; m_sCommY++; break;
					case 7: m_sCommX--; break;
					case 8: m_sCommX--; m_sCommY--; break;
					}
				}
			}

			for (i = 1; i < DEF_MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					std::memset(cTxt, 0, sizeof(cTxt));
					if (m_sDamageMoveAmount > 0)
						wsprintf(cTxt, "-%dPts", m_sDamageMoveAmount); //pts
					else strcpy(cTxt, "Critical!");

					int iFontType;
					if ((m_sDamageMoveAmount >= 0) && (m_sDamageMoveAmount < 12))		iFontType = 21;
					else if ((m_sDamageMoveAmount >= 12) && (m_sDamageMoveAmount < 40)) iFontType = 22;
					else if ((m_sDamageMoveAmount >= 40) || (m_sDamageMoveAmount < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

					if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					break;
				}
			m_sDamageMove = 0;
			m_sDamageMoveAmount = 0;
		}

		switch (m_cCommand) {
		case DEF_OBJECTRUN:
		case DEF_OBJECTMOVE:
		case DEF_OBJECTDAMAGEMOVE: // v1.43

			if (m_bParalyze) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID); // v1.4

			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				(bGORet == true) && (sDstOwnerType != 0))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 2) && (abs(m_sPlayerY - m_sCommY) <= 2) &&
				(m_pMapData->m_tile[m_sCommX][m_sCommY].m_bIsMoveAllowed == false))
				m_cCommand = DEF_OBJECTSTOP;
			else
			{
				if (m_cCommand == DEF_OBJECTMOVE)
				{
					if (ConfigManager::Get().IsRunningModeEnabled() || InputManager::Get().IsShiftDown()) m_cCommand = DEF_OBJECTRUN;
				}
				if (m_cCommand == DEF_OBJECTRUN)
				{
					if ((ConfigManager::Get().IsRunningModeEnabled() == false) && (InputManager::Get().IsShiftDown() == false)) m_cCommand = DEF_OBJECTMOVE;
					if (m_iSP < 1) m_cCommand = DEF_OBJECTMOVE;
				}

				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true);
				// Snoopy: Illusion Movement
				if ((m_bIllusionMVT == true) && (m_cCommand != DEF_OBJECTDAMAGEMOVE))
				{
					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, true);
				}
				if (cDir != 0)
				{
					m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, m_cCommand, cDir, 0, 0, 0, 0);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}
					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
						m_iPlayerStatus, m_cPlayerName,
						m_cCommand, 0, 0, 0);
					m_bCommandAvailable = false;
					m_dwCommandTime = GameClock::GetTimeMS();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}

			if (m_cCommand == DEF_OBJECTDAMAGEMOVE)
			{
				m_bIsGetPointingMode = false;
				m_iPointCommandType = -1;
				m_stMCursor.sCursorFrame = 0;
				ClearSkillUsingStatus();
				m_cCommand = DEF_OBJECTSTOP;
			}
			break;

		case DEF_OBJECTATTACK:
			cDir = CMisc::cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY);
			// Snoopy: Illusion movement
			if (m_bIllusionMVT == true)
			{
				cDir += 4;
				if (cDir > 8) cDir -= 8;
			}
			if (cDir != 0)
			{
				if ((wType == 2) || (wType == 25))
				{
					if (_bCheckItemByType(DEF_ITEMTYPE_ARROW) == false)
						wType = 0;
				}
				if (wType >= 20)
				{
					m_iSuperAttackLeft--;
					if (m_iSuperAttackLeft < 0) m_iSuperAttackLeft = 0;
				}
				m_cPlayerDir = cDir;
				m_wLastAttackTargetID = m_wCommObjectID;
				bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACK, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
					m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
					m_iPlayerStatus, m_cPlayerName,
					DEF_OBJECTATTACK,
					m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
				m_bCommandAvailable = false;
				m_dwCommandTime = GameClock::GetTimeMS();
			}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTATTACKMOVE:
			if (m_bParalyze) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID);
			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				(bGORet == true) && (sDstOwnerType != 0))
				m_cCommand = DEF_OBJECTSTOP;
			else
			{
				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true);
				// Snoopy: Illusion mvt
				if (m_bIllusionMVT == true)
				{
					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, true);
				}
				if (cDir != 0)
				{
					m_cPlayerDir = cDir;
					m_wLastAttackTargetID = m_wCommObjectID;
					bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACKMOVE, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}

					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
						m_iPlayerStatus, m_cPlayerName,
						m_cCommand, m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
					m_bCommandAvailable = false;
					m_dwCommandTime = GameClock::GetTimeMS();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTGETITEM:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTGETITEM, m_cPlayerDir, 0, 0, 0, 0);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				DEF_OBJECTGETITEM, 0, 0, 0);
			m_bCommandAvailable = false;
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTMAGIC:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTMAGIC, m_cPlayerDir, m_iCastingMagicType, 0, 0, 0);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				DEF_OBJECTMAGIC, m_iCastingMagicType, 0, 0);
			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			m_bIsGetPointingMode = true;
			m_cCommand = DEF_OBJECTSTOP;
			_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
			for (i = 1; i < DEF_MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, "%s!", m_pMagicCfgList[m_iCastingMagicType]->m_cName);
					m_pChatMsgList[i] = new class CMsg(41, cTxt, GameClock::GetTimeMS());
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
					m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i);
					return;
				}
			break;

		default:
			break;
		}
	}
}

void CGame::bItemDrop_Character()
{
	ItemEquipHandler((char)m_stMCursor.sSelectedObjectID);
}

void CGame::bItemDrop_Inventory(short msX, short msY)
{
	short sX, sY, dX, dY;
	char  cTxt[120];
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stMCursor.sSelectedObjectID] == 0) return;
	if ((m_bSkillUsingStatus == true) && (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true))
	{
		AddEventList(BITEMDROP_INVENTORY1, 10);
		return;
	}
	if (m_bIsItemDisabled[m_stMCursor.sSelectedObjectID] == true) return;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;
	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	dX = msX - sX - 32 - m_stMCursor.sDistX;
	dY = msY - sY - 44 - m_stMCursor.sDistY;
	if (dY < -10) dY = -10;
	if (dX < 0)   dX = 0;
	if (dX > 170) dX = 170;
	if (dY > 95) dY = 95;

	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sX = dX;
	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sY = dY;

	short sTmpSpr, sTmpSprFrm;
	sTmpSpr = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite;
	sTmpSprFrm = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame;

	char cItemID;
	if (InputManager::Get().IsShiftDown())
	{
		for (int i = 0; i < DEF_MAXITEMS; i++)
		{
			if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1)
			{
				cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
				if (m_pItemList[cItemID] != 0 && memcmp(m_pItemList[cItemID]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, 20) == 0)
				{
					m_pItemList[cItemID]->m_sX = dX;
					m_pItemList[cItemID]->m_sY = dY;
					bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemID, dX, dY, 0, 0);
				}
			}
		}
	}
	else bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, (char)(m_stMCursor.sSelectedObjectID), dX, dY, 0, 0);

	if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
	{
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
		else PlaySound('E', 29, 0);

		// Remove Angelic Stats
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
			&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
		{
			char cItemID = m_stMCursor.sSelectedObjectID;
			if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{
				m_iAngelicStr = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{
				m_iAngelicDex = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{
				m_iAngelicInt = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{
				m_iAngelicMag = 0;
			}
		}
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
		m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
		m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
	}
}

void CGame::bItemDrop_SellList(short msX, short msY)
{
	int i;
	char cItemID;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	for (i = 0; i < DEF_MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex == cItemID)
		{
			AddEventList(BITEMDROP_SELLLIST1, 10);
			return;
		}
	if (m_pItemList[cItemID]->m_sIDnum == hb::item::ItemId::Gold) {
		AddEventList(BITEMDROP_SELLLIST2, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		std::memset(G_cTxt, 0, sizeof(G_cTxt));
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
		wsprintf(G_cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);
		AddEventList(G_cTxt, 10);
		return;
	}

	if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1001;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = cItemID;
		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		m_bIsItemDisabled[cItemID] = true;
	}
	else
	{
		for (i = 0; i < DEF_MAXSELLLIST; i++)
			if (m_stSellItemList[i].iIndex == -1)
			{
				m_stSellItemList[i].iIndex = cItemID;
				m_stSellItemList[i].iAmount = 1;
				m_bIsItemDisabled[cItemID] = true;
				return;
			}
		AddEventList(BITEMDROP_SELLLIST3, 10);
	}
}

void CGame::bItemDrop_ItemUpgrade()
{
	char cItemID;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE) return;

	switch (m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode) {
	case 1:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = true;
		PlaySound('E', 29, 0);
		break;

	case 6:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = true;
		PlaySound('E', 29, 0);
		break;
	}
}

void CGame::bItemDrop_Bank(short msX, short msY)
{
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1 = m_stMCursor.sSelectedObjectID;
	if (m_cCommand < 0) return;
	if (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1] == 0) return;
	if (m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1] == true) return;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) && ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cItemType == DEF_ITEMTYPE_ARROW)) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;

		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1002;// NPC
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1;

		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_dwCount, 0);
	}
	else
	{
		if (_iGetBankItemCount() >= (iMaxBankItems - 1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
		else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, 1, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); //v1.4
	}
}

void CGame::bItemDrop_SkillDialog()
{
	int iConsumeNum;
	char cItemID;

	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true)
		&& ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{
			iConsumeNum = 0;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE))
		{
		}
		else return;

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10);
		break;

	case 4:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{
			iConsumeNum = 0;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

		// Crafting
	case 7:
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE)			// Merien Stone
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)		// Necks XXXMagins
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)		// stones
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_MATERIAL))	// XXXwares
		{
		}
		else return;

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

	default:
		break;
	}
}

// Slates Item Drag&Drop - Diuuude
void CGame::bItemDrop_Slates()
{
	char cItemID;
	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) &&
		((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2))) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::Slates).cMode) {
	case 1:
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && (m_pItemList[cItemID]->m_sSpriteFrame >= 151) && (m_pItemList[cItemID]->m_sSpriteFrame <= 154)) {
			char cItemIDText[20];
			switch (m_pItemList[cItemID]->m_sSpriteFrame) {
			case 151:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 152:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 153:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 154:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			}
		}
		break;

	default:
		break;
	}
}

void CGame::ResponseTeleportList(char* pData)
{
	int i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	const auto* header = hb::net::PacketCast<hb::net::PacketResponseTeleportListHeader>(
		pData, sizeof(hb::net::PacketResponseTeleportListHeader));
	if (!header) return;
	const auto* entries = reinterpret_cast<const hb::net::PacketResponseTeleportListEntry*>(
		pData + sizeof(hb::net::PacketResponseTeleportListHeader));
	m_iTeleportMapCount = header->count;
	for (i = 0; i < m_iTeleportMapCount; i++)
	{
		m_stTeleportList[i].iIndex = entries[i].index;
		std::memset(m_stTeleportList[i].mapname, 0, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, entries[i].map_name, 10);
		m_stTeleportList[i].iX = entries[i].x;
		m_stTeleportList[i].iY = entries[i].y;
		m_stTeleportList[i].iCost = entries[i].cost;
	}
}

void CGame::ResponseChargedTeleport(char* pData)
{
	short sRejectReason = 0;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseChargedTeleport>(
		pData, sizeof(hb::net::PacketResponseChargedTeleport));
	if (!pkt) return;
	sRejectReason = pkt->reason;

#ifdef _DEBUG
	AddEventList("charged teleport ?", 10);
#endif

	switch (sRejectReason) {
	case 1:
		AddEventList(RESPONSE_CHARGED_TELEPORT1, 10);
		break;
	case 2:
		AddEventList(RESPONSE_CHARGED_TELEPORT2, 10);
		break;
	case 3:
		AddEventList(RESPONSE_CHARGED_TELEPORT3, 10);
		break;
	case 4:
		AddEventList(RESPONSE_CHARGED_TELEPORT4, 10);
		break;
	case 5:
		AddEventList(RESPONSE_CHARGED_TELEPORT5, 10);
		break;
	case 6:
		AddEventList(RESPONSE_CHARGED_TELEPORT6, 10);
		break;
	default:
		AddEventList(RESPONSE_CHARGED_TELEPORT7, 10);
	}
}

void CGame::_Draw_OnLogin(char* pAccount, char* pPassword, int msX, int msY, int iFrame)
{
	bool bFlag = true;
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawVersion();

	if ((iFrame >= 15) && (iFrame <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->Draw(39 + SCREENX, 121 + SCREENY, 2, SpriteLib::DrawParams::Alpha(0.25f));
	else if (iFrame > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 39 + SCREENX, 121 + SCREENY, 2, true);

	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidName(pAccount) != false)
			PutString2(180 + SCREENX, 162 + SCREENY, pAccount, 200, 200, 200);
		else PutString2(180 + SCREENX, 162 + SCREENY, pAccount, 200, 100, 100);
	}
	if ((CMisc::bCheckValidName(pAccount) == false) || (strlen(pAccount) == 0)) bFlag = false;

	if (m_cCurFocus != 2) {
		if ((CMisc::bCheckValidString(pPassword) != false))
			PutString(180 + SCREENX, 185 + SCREENY, pPassword, RGB(200, 200, 200), true, 1);
		else PutString(180 + SCREENX, 185 + SCREENY, pPassword, RGB(200, 100, 100), true, 1);
	}
	if ((CMisc::bCheckValidString(pPassword) == false) || (strlen(pPassword) == 0)) bFlag = false;

	if (m_cCurFocus == 1)
		ShowReceivedString();
	else
		if (m_cCurFocus == 2)
			ShowReceivedString(true);

	if (bFlag == true)
	{
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 80 + SCREENX, 282 + SCREENY, 3, true);
	}
	if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256 + SCREENX, 282 + SCREENY, 4, true);
	if ((m_bIsHideLocalCursor != true) && (msX != 0) && (msY != 0)) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->Draw(msX, msY, 0);
	}
}

void CGame::ShowEventList(uint32_t dwTime)
{
	int i;
	int baseY = EVENTLIST2_BASE_Y;
	m_Renderer->BeginTextBatch();
	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory[i].dwTime) < 5000)
		{
			switch (m_stEventHistory[i].cColor) {
			case 0:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(225, 225, 225), false, 1, true);
				break;
			case 1:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(130, 255, 130), false, 1, true);
				break;
			case 2:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(255, 130, 130), false, 1, true);
				break;
			case 3:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(130, 130, 255), false, 1, true);
				break;
			case 4:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(230, 230, 130), false, 1, true);
				break;
			case 10:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(180, 255, 180), false, 1, true);
				break;
			case 20:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(150, 150, 170), false, 1, true);
				break;
			}
		}

	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory2[i].dwTime) < 5000)
		{
			switch (m_stEventHistory2[i].cColor) {
			case 0:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(225, 225, 225), false, 1, true);
				break;
			case 1:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(130, 255, 130), false, 1, true);
				break;
			case 2:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(255, 130, 130), false, 1, true);
				break;
			case 3:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(130, 130, 255), false, 1, true);
				break;
			case 4:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(230, 230, 130), false, 1, true);
				break;
			case 10:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(180, 255, 180), false, 1, true);
				break;
			case 20:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(150, 150, 170), false, 1, true);
				break;
			}
		}
	if (m_bSkillUsingStatus == true)
	{
		PutString(440 - 29, 440 - 52, SHOW_EVENT_LIST1, RGB(235, 235, 235), false, 1, true);
	}
	m_Renderer->EndTextBatch();
}

void CGame::RequestTeleportAndWaitData()
{	// Snoopy: removed that, Noob Dungeon is now at farm...
	/*if (strcmp(m_cMapName, "aresden") == 0)
	{	if ( ((m_sPlayerX == 188) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 107))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}
	if (strcmp(m_cMapName, "elvine") == 0)
	{	if ( ((m_sPlayerX == 218) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 111))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}*/
	bSendCommand(MSGID_REQUEST_TELEPORT, 0, 0, 0, 0, 0, 0);
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
}

void CGame::InitDataResponseHandler(char* pData)
{
	int i;
	short sX, sY;
	const char* cp;
	char cMapFileName[32], cTxt[120], cPreCurLocation[12];
	bool  bIsObserverMode;
	HANDLE hFile;
	uint32_t dwFileSize;

	std::memset(cPreCurLocation, 0, sizeof(cPreCurLocation));
	m_bParalyze = false;
	m_pMapData->Init();

	m_sMonsterID = 0;
	m_dwMonsterEventTime = 0;

	m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::SaleMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CityHallMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Bank);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::MagicShop);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Map);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcTalk);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildHallMenu); // Gail's diag

	m_cCommand = DEF_OBJECTSTOP;
	//m_bCommandAvailable = true;
	m_cCommandCount = 0;
	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1;
	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;
	m_bIsTeleportRequested = false;
	m_bIsConfusion = false;
	m_bSkillUsingStatus = false;

	m_bItemUsingStatus = false;

	m_cRestartCount = -1;
	m_dwRestartCountTime = 0;

	if (m_pEffectManager) m_pEffectManager->ClearAllEffects();

	for (i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
	{
		m_stWhetherObject[i].sX = 0;
		m_stWhetherObject[i].sBX = 0;
		m_stWhetherObject[i].sY = 0;
		m_stWhetherObject[i].cStep = 0;
	}

	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = 0;
	}

	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseInitDataHeader>(
		pData, sizeof(hb::net::PacketResponseInitDataHeader));
	if (!pkt) return;
	m_sPlayerObjectID = pkt->player_object_id;
	sX = pkt->pivot_x;
	sY = pkt->pivot_y;
	m_sPlayerType = pkt->player_type;
	m_sPlayerAppr1 = pkt->appr1;
	m_sPlayerAppr2 = pkt->appr2;
	m_sPlayerAppr3 = pkt->appr3;
	m_sPlayerAppr4 = pkt->appr4;
	m_iPlayerApprColor = pkt->appr_color;
	m_iPlayerStatus = pkt->status;

	//Snoopy MIM fix
	if ((m_iPlayerStatus & 0x00200000) == 0x00200000)
	{
		m_bIllusionMVT = true;
	}
	else
	{
		m_bIllusionMVT = false;
	}
	std::memset(m_cMapName, 0, sizeof(m_cMapName));
	std::memset(m_cMapMessage, 0, sizeof(m_cMapMessage));
	memcpy(m_cMapName, pkt->map_name, sizeof(pkt->map_name));
	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	if (m_cMapIndex < 0)
	{
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY = -1;
	}
	else
	{
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX = 128;
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY = 128;
	}

	strcpy(cPreCurLocation, m_cCurLocation);
	std::memset(m_cCurLocation, 0, sizeof(m_cCurLocation));
	memcpy(m_cCurLocation, pkt->cur_location, sizeof(pkt->cur_location));

	G_cSpriteAlphaDegree = static_cast<char>(pkt->sprite_alpha);

	m_cWhetherStatus = static_cast<char>(pkt->weather_status);
	switch (G_cSpriteAlphaDegree) { //Snoopy:  Xmas bulbs
		// Will be sent by server if DayTime is 3 (and a snowy weather)
	case 1:	m_bIsXmas = false; break;
	case 2: m_bIsXmas = false; break;
	case 3: // Snoopy Special night with chrismas bulbs
		if (m_cWhetherStatus > 3) m_bIsXmas = true;
		else m_bIsXmas = false;
		G_cSpriteAlphaDegree = 2;
		break;
	}
	m_iContribution = pkt->contribution;
	//	m_iContributionPrice = 0;
	bIsObserverMode = pkt->observer_mode != 0;
	//	m_iRating = pkt->rating;
	m_iHP = pkt->hp;
	m_cDiscount = static_cast<char>(pkt->discount);

	cp = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseInitDataHeader);

	if (m_cWhetherStatus != 0)
		SetWhetherStatus(true, m_cWhetherStatus);
	else SetWhetherStatus(false, m_cWhetherStatus);

	std::memset(cMapFileName, 0, sizeof(cMapFileName));
	strcat(cMapFileName, "mapdata\\");
	// CLEROTH - MW MAPS
	if (memcmp(m_cMapName, "defaultmw", 9) == 0)
	{
		strcat(cMapFileName, "mw\\defaultmw");
	}
	else
	{
		strcat(cMapFileName, m_cMapName);
	}

	strcat(cMapFileName, ".amd");
	m_pMapData->OpenMapDataFile(cMapFileName);

	m_pMapData->m_sPivotX = sX;
	m_pMapData->m_sPivotY = sY;

	m_sPlayerX = sX + 19;
	m_sPlayerY = sY + 17;

	m_cPlayerDir = 5;

	if (bIsObserverMode == false)
	{
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0);
	}

	//m_sViewDstX = m_sViewPointX = (sX + VIEW_CENTER_TILE_X) * 32 - 16;
	//m_sViewDstY = m_sViewPointY = (sY + VIEW_CENTER_TILE_Y + 1) * 32 - 16;
	m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
	m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;
	_ReadMapData(sX + 7, sY + 8, cp);
	m_bIsRedrawPDBGS = true;
	// ------------------------------------------------------------------------+
	wsprintf(cTxt, INITDATA_RESPONSE_HANDLER1, m_cMapMessage);
	AddEventList(cTxt, 10);

	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sX = 150;
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sY = 130;

	if ((memcmp(m_cCurLocation, "middleland", 10) == 0)
		|| (memcmp(m_cCurLocation, "dglv2", 5) == 0)
		|| (memcmp(m_cCurLocation, "middled1n", 9) == 0))
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::WarningBattleArea, 0, 0, 0);

	// Snoopy: removed for v351 compatibility. Maybe usefull later...
	/*	bool bPrevSafe, bNowSafe;
		if( memcmp( cPreCurLocation, m_cLocation, 3 ) == 0 )
			bPrevSafe = true;
		else bPrevSafe = false;

		if( memcmp( m_cCurLocation, m_cLocation, 3 ) == 0 )
			bNowSafe = true;
		else bNowSafe = false;

		if( memcmp( m_cCurLocation, "2nd", 3 ) == 0 ) bNowSafe = true;
		if( m_iPKCount != 0 ) bNowSafe = false;

		if( bPrevSafe )
		{	if( bNowSafe == false ) SetTopMsg(DEF_MSG_DANGERZONE, 5);
		}else
		{	if( bNowSafe ) SetTopMsg(DEF_MSG_SAFEZONE, 5);
		}*/

		// ------------------------------------------------------------------------+

	ChangeGameMode(DEF_GAMEMODE_ONMAINGAME);

	//v1.41
	if ((m_sPlayerAppr2 & 0xF000) != 0)
		m_bIsCombatMode = true;
	else m_bIsCombatMode = false;

	//v1.42
	if (m_bIsFirstConn == true)
	{
		m_bIsFirstConn = false;
		hFile = CreateFile("contents\\contents1000.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (hFile == INVALID_HANDLE_VALUE)
			dwFileSize = 0;
		else
		{
			dwFileSize = GetFileSize(hFile, 0);
			CloseHandle(hFile);
		}
		bSendCommand(MSGID_REQUEST_NOTICEMENT, 0, 0, (int)dwFileSize, 0, 0, 0);
	}
	//cp += 2;
}

void CGame::MotionEventHandler(char* pData)
{
	WORD wEventType, wObjectID;
	short sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sV1, sV2, sV3, sPrevAppr2;
	int iStatus;
	char cDir, cName[12];
	int iApprColor, iLoc;
	char    cTxt[120];
	int i;
	std::memset(cName, 0, sizeof(cName));
	sX = -1;
	sY = -1;
	sV1 = sV2 = sV3 = 0;
	iApprColor = 0;
	iStatus = 0;
	iLoc = 0;
	cDir = 0;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wEventType = header->msg_type;

	const auto* baseId = hb::net::PacketCast<hb::net::PacketEventMotionBaseId>(pData, sizeof(hb::net::PacketEventMotionBaseId));
	if (!baseId) return;
	wObjectID = baseId->object_id;

	if (wObjectID >= 10000 && wObjectID < 30000) {
		m_dwLastNpcEventTime = GameClock::GetTimeMS();
	}

	if (wObjectID < 30000)
	{
		if (wObjectID < 10000) 	// Player
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionPlayer>(pData, sizeof(hb::net::PacketEventMotionPlayer));
			if (!pkt) return;
			sX = pkt->x;
			sY = pkt->y;
			sType = pkt->type;
			cDir = static_cast<char>(pkt->dir);
			memcpy(cName, pkt->name, sizeof(pkt->name));
			sAppr1 = pkt->appr1;
			sAppr2 = pkt->appr2;
			sAppr3 = pkt->appr3;
			sAppr4 = pkt->appr4;
			iApprColor = pkt->appr_color;
			iStatus = pkt->status;
			iLoc = pkt->loc;
		}
		else 	// Npc or mob
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionNpc>(pData, sizeof(hb::net::PacketEventMotionNpc));
			if (!pkt) return;
			sX = pkt->x;
			sY = pkt->y;
			sType = pkt->type;
			cDir = static_cast<char>(pkt->dir);
			memcpy(cName, pkt->name, sizeof(pkt->name));
			sAppr1 = sAppr3 = sAppr4 = 0;
			sAppr2 = pkt->appr2;
			iStatus = pkt->status;
			iLoc = pkt->loc;
		}
	}
	else
	{
		switch (wEventType) {
		case DEF_OBJECTMOVE:
		case DEF_OBJECTRUN:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionDirOnly>(pData, sizeof(hb::net::PacketEventMotionDirOnly));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sX = -1;
			sY = -1;
		}
		break;

		case DEF_OBJECTMAGIC:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDAMAGEMOVE:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionShort>(pData, sizeof(hb::net::PacketEventMotionShort));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1; // Damage or 0
			sV2 = pkt->v2;
			sX = -1;
			sY = -1;
		}
		break;

		case DEF_OBJECTDYING:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionMove>(pData, sizeof(hb::net::PacketEventMotionMove));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1;
			sV2 = pkt->v2;
			sX = pkt->x;
			sY = pkt->y;
		}
		break;

		case DEF_OBJECTATTACK:
		case DEF_OBJECTATTACKMOVE:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionAttack>(pData, sizeof(hb::net::PacketEventMotionAttack));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1;
			sV2 = pkt->v2;
			sV3 = pkt->v3;
		}
		break;

		default:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionDirOnly>(pData, sizeof(hb::net::PacketEventMotionDirOnly));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
		}
		break;
		}
	}

	if ((wEventType == DEF_OBJECTNULLACTION) && (memcmp(cName, m_cPlayerName, 10) == 0))
	{
		m_sPlayerType = sType;
		m_sPlayerAppr1 = sAppr1;
		sPrevAppr2 = m_sPlayerAppr2;
		m_sPlayerAppr2 = sAppr2;
		m_sPlayerAppr3 = sAppr3;
		m_sPlayerAppr4 = sAppr4;
		m_iPlayerApprColor = iApprColor;
		m_iPlayerStatus = iStatus;
		if ((sPrevAppr2 & 0xF000) == 0)
		{
			if ((sAppr2 & 0xF000) != 0)
			{
				AddEventList(MOTION_EVENT_HANDLER1, 10);
				m_bIsCombatMode = true;
			}
		}
		else
		{
			if ((sAppr2 & 0xF000) == 0)
			{
				AddEventList(MOTION_EVENT_HANDLER2, 10);
				m_bIsCombatMode = false;
			}
		}
		if (m_cCommand != DEF_OBJECTRUN) m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);
	}
	else m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);

	switch (wEventType) {
	case DEF_OBJECTMAGIC: // Casting
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s!", m_pMagicCfgList[sV1]->m_cName);
				m_pChatMsgList[i] = new class CMsg(41, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTDYING:
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				if (sV1 > 0)
					wsprintf(cTxt, "-%dPts!", sV1);
				else strcpy(cTxt, "Critical!");
				int iFontType;
				if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
				else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
				else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;
				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTDAMAGE:
	case DEF_OBJECTDAMAGEMOVE:
		if (memcmp(cName, m_cPlayerName, 10) == 0)
		{
			m_bIsGetPointingMode = false;
			m_iPointCommandType = -1;
			m_stMCursor.sCursorFrame = 0;
			ClearSkillUsingStatus();
		}
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				if (sV1 != 0)
				{
					if (sV1 > 0)
						wsprintf(cTxt, "-%dPts", sV1);
					else strcpy(cTxt, "Critical!");
					int iFontType;
					if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
					else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
					else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				}
				else
				{
					strcpy(cTxt, " * Failed! *");
					m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
					PlaySound('C', 17, 0);
				}
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTATTACK:
	case DEF_OBJECTATTACKMOVE:
		if (wObjectID == m_sPlayerObjectID + 30000)
		{
			if (m_pMagicCfgList[sV3] != 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s", m_pMagicCfgList[sV3]->m_cName);
				AddEventList(cTxt, 10);
			}
		}
		break;
	}
}

void CGame::GrandMagicResult(char* pMapName, int iV1, int iV2, int iV3, int iV4, int iHP1, int iHP2, int iHP3, int iHP4)
{
	int i, iTxtIdx = 0;
	char cTemp[120];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	for (i = 0; i < 92; i++)
		if (m_pGameMsgList[i] == 0) return;

	if (strcmp(pMapName, "aresden") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[2]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[3]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0) {
			if ((m_bCitizen == true) && (m_bAresden == false))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[59]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[60]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[61]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[62]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if ((m_bCitizen == true) && (m_bAresden == true))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[69]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[70]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[71]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[72]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[73]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[74]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else PlaySound('E', 25, 0, 0);
		}
		else
		{
			if (iV1 != 0)
			{
				if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[63]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[64]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[65]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[75]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[76]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[77]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[78]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[79]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[80]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[81]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[82]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[66]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[67]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[68]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[83]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[84]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[85]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[86]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[87]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[88]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[89]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[90]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[7]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[8]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0) {
			if ((m_bCitizen == true) && (m_bAresden == true))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[59]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[60]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[61]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[62]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if ((m_bCitizen == true) && (m_bAresden == false))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[69]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[70]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[71]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[72]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[73]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[74]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else PlaySound('E', 25, 0, 0);
		}
		else
		{
			if (iV1 != 0) {
				if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[63]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[64]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[65]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[75]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[76]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[77]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[78]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[79]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[80]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[81]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[82]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[66]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[67]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[68]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[83]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[84]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[85]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[86]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[87]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[88]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[89]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[90]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
}

// num : 1 - F2, 2 - F3
void CGame::UseShortCut(int num)
{
	int index;
	if (num < 4) index = num;
	else index = num + 7;
	if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
	if (InputManager::Get().IsCtrlDown() == true)
	{
		if (m_sRecentShortCut == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else
		{
			m_sShortCut[num] = m_sRecentShortCut;
			if (m_sShortCut[num] < 100)
			{
				if (m_pItemList[m_sShortCut[num]] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				char cStr1[64], cStr2[64], cStr3[64];
				std::memset(cStr1, 0, sizeof(cStr1));
				std::memset(cStr2, 0, sizeof(cStr2));
				std::memset(cStr3, 0, sizeof(cStr3));

				GetItemName(m_pItemList[m_sShortCut[num]], cStr1, cStr2, cStr3);
				wsprintf(G_cTxt, MSG_SHORTCUT4, cStr1, cStr2, cStr3, index);// (%s %s %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
			else if (m_sShortCut[num] >= 100)
			{
				if (m_pMagicCfgList[m_sShortCut[num] - 100] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				wsprintf(G_cTxt, MSG_SHORTCUT5, m_pMagicCfgList[m_sShortCut[num] - 100]->m_cName, index);// %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
		}
	}
	else
	{
		if (m_sShortCut[num] == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else if (m_sShortCut[num] < 100)
		{
			ItemEquipHandler((char)m_sShortCut[num]);
		}
		else if (m_sShortCut[num] >= 100) UseMagic(m_sShortCut[num] - 100);
	}
}

int CGame::iGetManaCost(int iMagicNo)
{
	int i, iManaSave, iManaCost;
	iManaSave = 0;
	if (iMagicNo < 0 || iMagicNo >= 100) return 1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_pItemList[i] == 0) continue;
		if (m_bIsItemEquipped[i] == true)
		{
			// Data-driven mana save calculation using ItemEffectType
			auto effectType = m_pItemList[i]->GetItemEffectType();
			switch (effectType)
			{
			case hb::item::ItemEffectType::AttackManaSave:
				// Weapons with mana save: value stored in m_sItemEffectValue4
				iManaSave += m_pItemList[i]->m_sItemEffectValue4;
				break;

			case hb::item::ItemEffectType::AddEffect:
				// AddEffect with sub-type ManaSave (necklaces, etc.)
				if (m_pItemList[i]->m_sItemEffectValue1 == hb::item::ToInt(hb::item::AddEffectType::ManaSave))
				{
					iManaSave += m_pItemList[i]->m_sItemEffectValue2;
				}
				break;

			default:
				break;
			}
		}
	}
	// Mana save max = 80%
	if (iManaSave > 80) iManaSave = 80;
	iManaCost = m_pMagicCfgList[iMagicNo]->m_sValue1;
	if (m_bIsSafeAttackMode) iManaCost += (iManaCost / 2) - (iManaCost / 10);
	if (iManaSave > 0)
	{
		double dV1 = (double)iManaSave;
		double dV2 = (double)(dV1 / 100.0f);
		double dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;
	}
	if (iManaCost < 1) iManaCost = 1;
	return iManaCost;
}

void CGame::UseMagic(int iMagicNo)
{
	if (iMagicNo < 0 || iMagicNo >= 100) return;
	if ((m_cMagicMastery[iMagicNo] == 0) || (m_pMagicCfgList[iMagicNo] == 0)) return;

	// Casting
	if (m_iHP <= 0) return;
	if (m_bIsGetPointingMode == true) return;
	if (iGetManaCost(iMagicNo) > m_iMP) return;
	if (_bIsItemOnHand() == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC1, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC2, 10);
		return;
	}
	if ((m_sPlayerAppr2 & 0xF000) == 0) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, 0, 0, 0, 0, 0);
	m_cCommand = DEF_OBJECTMAGIC;
	m_iCastingMagicType = iMagicNo;
	m_sMagicShortCut = iMagicNo;
	m_sRecentShortCut = iMagicNo + 100;
	m_iPointCommandType = iMagicNo + 100;
	//m_bIsGetPointingMode = true;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Magic);
}


void CGame::ReleaseEquipHandler(char cEquipPos)
{
	char cStr1[64], cStr2[64], cStr3[64];
	if (m_sItemEquipmentStatus[cEquipPos] < 0) return;
	// Remove Angelic Stats
	if ((cEquipPos >= 11)
		&& (m_pItemList[m_sItemEquipmentStatus[cEquipPos]]->m_cItemType == 1))
	{
		char cItemID = m_sItemEquipmentStatus[cEquipPos];
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{
			m_iAngelicStr = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{
			m_iAngelicDex = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{
			m_iAngelicInt = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{
			m_iAngelicMag = 0;
		}
	}

	GetItemName(m_pItemList[m_sItemEquipmentStatus[cEquipPos]], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(G_cTxt, 10);
	m_bIsItemEquipped[m_sItemEquipmentStatus[cEquipPos]] = false;
	m_sItemEquipmentStatus[cEquipPos] = -1;
}

void CGame::ItemEquipHandler(char cItemID)
{
	if (bCheckItemOperationEnabled(cItemID) == false) return;
	if (m_bIsItemEquipped[cItemID] == true) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE)
	{
		AddEventList(BITEMDROP_CHARACTER3, 10);//"The item is not available."
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		AddEventList(BITEMDROP_CHARACTER1, 10); //"The item is exhausted. Fix it to use it."
		return;
	}
	if (m_pItemList[cItemID]->m_wWeight / 100 > m_iStr + m_iAngelicStr)
	{
		AddEventList(BITEMDROP_CHARACTER2, 10);
		return;
	}
	if (((m_pItemList[cItemID]->m_dwAttribute & 0x00000001) == 0) && (m_pItemList[cItemID]->m_sLevelLimit > m_iLevel))
	{
		AddEventList(BITEMDROP_CHARACTER4, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(BITEMDROP_CHARACTER5, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_cGenderLimit != 0)
	{
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			if (m_pItemList[cItemID]->m_cGenderLimit != 1)
			{
				AddEventList(BITEMDROP_CHARACTER6, 10);
				return;
			}
			break;
		case 4:
		case 5:
		case 6:
			if (m_pItemList[cItemID]->m_cGenderLimit != 2)
			{
				AddEventList(BITEMDROP_CHARACTER7, 10);
				return;
			}
			break;
		}
	}

	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EQUIPITEM, 0, cItemID, 0, 0, 0);
	m_sRecentShortCut = cItemID;
	ReleaseEquipHandler(m_pItemList[cItemID]->m_cEquipPos);
	switch (m_pItemList[cItemID]->m_cEquipPos) {
	case DEF_EQUIPPOS_HEAD:
	case DEF_EQUIPPOS_BODY:
	case DEF_EQUIPPOS_ARMS:
	case DEF_EQUIPPOS_PANTS:
	case DEF_EQUIPPOS_BOOTS:
	case DEF_EQUIPPOS_BACK:
		ReleaseEquipHandler(DEF_EQUIPPOS_FULLBODY);
		break;
	case DEF_EQUIPPOS_FULLBODY:
		ReleaseEquipHandler(DEF_EQUIPPOS_HEAD);
		ReleaseEquipHandler(DEF_EQUIPPOS_BODY);
		ReleaseEquipHandler(DEF_EQUIPPOS_ARMS);
		ReleaseEquipHandler(DEF_EQUIPPOS_PANTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BOOTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BACK);
		break;
	case DEF_EQUIPPOS_LHAND:
	case DEF_EQUIPPOS_RHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_TWOHAND);
		break;
	case DEF_EQUIPPOS_TWOHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_RHAND);
		ReleaseEquipHandler(DEF_EQUIPPOS_LHAND);
		break;
	}

	m_sItemEquipmentStatus[m_pItemList[cItemID]->m_cEquipPos] = cItemID;
	m_bIsItemEquipped[cItemID] = true;

	// Add Angelic Stats
	if ((m_pItemList[cItemID]->m_cItemType == 1)
		&& (m_pItemList[cItemID]->m_cEquipPos >= 11))
	{
		int iAngelValue = 0;
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicStr = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicDex = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicInt = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicMag = 1 + iAngelValue;
		}
	}

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, BITEMDROP_CHARACTER9, cStr1);
	AddEventList(G_cTxt, 10);
	PlaySound('E', 28, 0);
}

/*********************************************************************************************************************
**  void CheckActiveAura(short sX, short sY, DWORD dwTime, short sOwnerType)( initially Cleroth fixed by Snoopy )	**
**  description			: Generates special auras around players													**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura(short sX, short sY, uint32_t dwTime, short sOwnerType)
{	// Used at the beginning of character drawing
	// DefenseShield
	if ((_tmp_iStatus & 0x02000000) != 0)
		//m_pEffectSpr[80]->Draw(sX+75, sY+107, _tmp_iEffectFrame%17, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[80]->Draw(sX + 75, sY + 107, _tmp_iEffectFrame % 17, SpriteLib::DrawParams::Alpha(0.5f));

	// Protection From Magic
	if ((_tmp_iStatus & 0x04000000) != 0)
		//m_pEffectSpr[79]->Draw(sX+101, sY+135, _tmp_iEffectFrame%15, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[79]->Draw(sX + 101, sY + 135, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));

	// Protection From Arrow
	if ((_tmp_iStatus & 0x08000000) != 0)
		//m_pEffectSpr[72]->Draw(sX, sY+35, _tmp_iEffectFrame%30, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[72]->Draw(sX, sY + 35, _tmp_iEffectFrame % 30, SpriteLib::DrawParams::Alpha(0.7f));

	// Illusion
	if ((_tmp_iStatus & 0x01000000) != 0)
		//m_pEffectSpr[73]->Draw(sX+125, sY+95, _tmp_iEffectFrame%24, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[73]->Draw(sX + 125, sY + 130 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, SpriteLib::DrawParams::Alpha(0.7f));

	// Illusion movement
	if ((_tmp_iStatus & 0x00200000) != 0)
		//m_pEffectSpr[151]->Draw(sX+90, sY+55, _tmp_iEffectFrame%24, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[151]->Draw(sX + 90, sY + 90 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, SpriteLib::DrawParams::Alpha(0.7f));

	// Slate red  (HP)  Flame au sol
	if ((_tmp_iStatus & 0x00400000) != 0)
		//m_pEffectSpr[149]->Draw(sX+90, sY+120, _tmp_iEffectFrame%15, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[149]->Draw(sX + 90, sY + 120, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));

	// Slate Blue (Mana) Bleu au sol
	if ((_tmp_iStatus & 0x00800000) != 0)
		//m_pEffectSpr[150]->Draw(sX+1, sY+26, _tmp_iEffectFrame%15, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[150]->Draw(sX + 1, sY + 26, _tmp_iEffectFrame % 15, SpriteLib::DrawParams::Alpha(0.7f));

	// Slate Green (XP) Mauve au sol
	if ((_tmp_iStatus & 0x00010000) != 0)
		//m_pEffectSpr[148]->Draw(sX, sY+32, _tmp_iEffectFrame%23, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[148]->Draw(sX, sY + 32, _tmp_iEffectFrame % 23, SpriteLib::DrawParams::Alpha(0.7f));

	// Hero Flag (Heldenian)  Flameches d'entangle
	if ((_tmp_iStatus & 0x00020000) != 0)
		//m_pEffectSpr[87]->Draw(sX+53, sY+54, _tmp_iEffectFrame%29, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[87]->Draw(sX + 53, sY + 54, _tmp_iEffectFrame % 29, SpriteLib::DrawParams::Alpha(0.7f));
}

/*********************************************************************************************************************
**  void CheckActiveAura2(short sX, short sY, DWORD dwTime,  _tmp_sOwnerType) ( initially Cleroth fixed by Snoopy )	**
**  description			: Generates poison aura around players. This one should be use later...						**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura2(short sX, short sY, uint32_t dwTime, short sOwnerType)
{	// Poison
	if ((_tmp_iStatus & 0x80) != 0)
		//m_pEffectSpr[81]->Draw(sX+115, sY+85, _tmp_iEffectFrame%21, SpriteLib::DrawParams::Alpha(0.5f));
		m_pEffectSpr[81]->Draw(sX + 115, sY + 120 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 21, SpriteLib::DrawParams::Alpha(0.7f));
	//	_iAttackerHeight[]
}

void CGame::DrawAngel(int iSprite, short sX, short sY, char cFrame, uint32_t dwTime)
{
	switch (_tmp_cDir)
	{
	case 1:
	case 2:
	case 7:
	case 8:
		sX -= 30;
		break;
	}
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if ((_tmp_iStatus & 0x1000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + iSprite]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f));  //AngelicPendant(STR)
		else if ((_tmp_iStatus & 0x2000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 1) + iSprite]->Draw(sX, sY, cFrame, SpriteLib::DrawParams::Alpha(0.5f)); //AngelicPendant(DEX)
		else if ((_tmp_iStatus & 0x4000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 2) + iSprite]->Draw(sX, sY - 15, cFrame, SpriteLib::DrawParams::Alpha(0.5f));//AngelicPendant(INT)
		else if ((_tmp_iStatus & 0x8000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 3) + iSprite]->Draw(sX, sY - 15, cFrame, SpriteLib::DrawParams::Alpha(0.5f));//AngelicPendant(MAG)
	}
	else
	{
		if ((_tmp_iStatus & 0x1000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + iSprite]->Draw(sX, sY, cFrame);  //AngelicPendant(STR)
		else if ((_tmp_iStatus & 0x2000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 1) + iSprite]->Draw(sX, sY, cFrame); //AngelicPendant(DEX)
		else if ((_tmp_iStatus & 0x4000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 2) + iSprite]->Draw(sX, sY - 15, cFrame);//AngelicPendant(INT)
		else if ((_tmp_iStatus & 0x8000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 3) + iSprite]->Draw(sX, sY - 15, cFrame);//AngelicPendant(MAG)
	}

}
/*********************************************************************************************************************
**  int CGame::bHasHeroSet( short m_sAppr3, short m_sAppr3, char OwnerType)		( Snoopy )							**
**  description			:: check weather the object (is character) is using a hero set (1:war, 2:mage)				**
**********************************************************************************************************************/
int CGame::bHasHeroSet(short Appr3, short Appr4, char OwnerType)
{
	char cArmor, cLeg, cBerk, cHat;
	cArmor = (Appr3 & 0xF000) >> 12;
	cLeg = (Appr3 & 0x0F00) >> 8;
	cHat = (Appr3 & 0x00F0) >> 4;
	cBerk = Appr3 & 0x000F;
	switch (OwnerType) {
	case 1:
	case 2:
	case 3:
		if ((cArmor == 8) && (cLeg == 5) && (cHat == 9) && (cBerk == 3)) return (1); // Warr elv M
		if ((cArmor == 9) && (cLeg == 6) && (cHat == 10) && (cBerk == 4)) return (1); // Warr ares M
		if ((cArmor == 10) && (cLeg == 5) && (cHat == 11) && (cBerk == 3)) return (2); // Mage elv M
		if ((cArmor == 11) && (cLeg == 6) && (cHat == 12) && (cBerk == 4)) return (2); // Mage ares M
		break;
	case 4:
	case 5:
	case 6: // fixed
		if ((cArmor == 9) && (cLeg == 6) && (cHat == 9) && (cBerk == 4)) return (1); //warr elv W
		if ((cArmor == 10) && (cLeg == 7) && (cHat == 10) && (cBerk == 5)) return (1); //warr ares W
		if ((cArmor == 11) && (cLeg == 6) && (cHat == 11) && (cBerk == 4)) return (2); //mage elv W
		if ((cArmor == 12) && (cLeg == 7) && (cHat == 12) && (cBerk == 5)) return (2); //mage ares W
		break;
	}
	return 0;
}
/*********************************************************************************************************************
**  void ShowHeldenianVictory( short sSide)				( Snoopy )													**
**  description			: Shows the Heldenian's End window															**
**********************************************************************************************************************/
void CGame::ShowHeldenianVictory(short sSide)
{
	int i, iPlayerSide;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (m_bCitizen == false) iPlayerSide = 0;
	else if (m_bAresden == true) iPlayerSide = 1;
	else if (m_bAresden == false) iPlayerSide = 2;
	switch (sSide) {
	case 0:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in a tie.", 0);
		break;
	case 1:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in favor of Aresden.", 0);
		break;
	case 2:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in favor of Elvine.", 0);
		break;
	}
	m_pMsgTextList[4] = new class CMsg(0, " ", 0);

	if (((iPlayerSide != 1) && (iPlayerSide != 2))   // Player not a normal citizen
		|| (sSide == 0))								// or no winner
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[5] = new class CMsg(0, " ", 0);
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, " ", 0);
		m_pMsgTextList[8] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (sSide == iPlayerSide)
		{
			PlaySound('E', 23, 0, 0);
			PlaySound('C', 21, 0, 0);
			PlaySound('C', 22, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "Congratulation.", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As cityzen of victory,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You will recieve a reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "      ", 0);
		}
		else
		{
			PlaySound('E', 24, 0, 0);
			PlaySound('C', 12, 0, 0);
			PlaySound('C', 13, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "To our regret", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As cityzen of defeat,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You cannot recieve any reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "     ", 0);
		}
	}
	for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeSoldier);
}

/*********************************************************************************************************************
**  void 	ResponseHeldenianTeleportList(char *pData)									(  Snoopy )					**
**  description			: Gail's TP																					**
**********************************************************************************************************************/
void CGame::ResponseHeldenianTeleportList(char* pData)
{
	int i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	const auto* header = hb::net::PacketCast<hb::net::PacketResponseTeleportListHeader>(
		pData, sizeof(hb::net::PacketResponseTeleportListHeader));
	if (!header) return;
	const auto* entries = reinterpret_cast<const hb::net::PacketResponseTeleportListEntry*>(
		pData + sizeof(hb::net::PacketResponseTeleportListHeader));
	m_iTeleportMapCount = header->count;
	for (i = 0; i < m_iTeleportMapCount; i++)
	{
		m_stTeleportList[i].iIndex = entries[i].index;
		std::memset(m_stTeleportList[i].mapname, 0, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, entries[i].map_name, 10);
		m_stTeleportList[i].iX = entries[i].x;
		m_stTeleportList[i].iY = entries[i].y;
		m_stTeleportList[i].iCost = entries[i].cost;
	}
}
/*********************************************************************************************************************
**  bool DKGlare(int iWeaponIndex, int iWeaponIndex, int *iWeaponGlare)	( Snoopy )									**
**  description			: test glowing condition for DK set															**
**********************************************************************************************************************/
void CGame::DKGlare(int iWeaponColor, int iWeaponIndex, int* iWeaponGlare)
{
	if (iWeaponColor != 9) return;
	if (((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64 * 14) && (iWeaponIndex < DEF_SPRID_WEAPON_M + 64 * 14 + 56)) //msw3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64 * 14) && (iWeaponIndex < DEF_SPRID_WEAPON_W + 64 * 14 + 56))) //wsw3
	{
		*iWeaponGlare = 3;
	}
	else if (((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64 * 37) && (iWeaponIndex < DEF_SPRID_WEAPON_M + 64 * 37 + 56)) //MStaff3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64 * 37) && (iWeaponIndex < DEF_SPRID_WEAPON_W + 64 * 37 + 56)))//WStaff3
	{
		*iWeaponGlare = 2;
	}
}
/*********************************************************************************************************************
**  void DrawDruncncity()	( Snoopy )																				**
**  description			: 	Placeholder for Druncncity effects (nota: bubbles already coded)						**
**********************************************************************************************************************/
void CGame::DrawDruncncity()
{
}

/*********************************************************************************************************************
**  void CGame::Abaddon_corpse(int sX, int sY);		( Snoopy )														**
**  description			: Placeholder for abaddon's death lightnings												**
**********************************************************************************************************************/
void CGame::Abaddon_corpse(int sX, int sY)
{
	int ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir, ir, 1);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir + 2, ir, 2);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir, ir, 1);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir + 2, ir, 2);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir, ir, 1);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir, ir, 1);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir, ir, 1);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir, ir, 1);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir - 2, ir + 2, 2);

	for (int x = sX - 50; x <= sX + 100; x += rand() % 35)
		for (int y = sY - 30; y <= sY + 50; y += rand() % 45)
		{
			ir = (rand() % 20) - 10;
			_DrawThunderEffect(x, 0, x, y, ir, ir, 2);
		}
}



