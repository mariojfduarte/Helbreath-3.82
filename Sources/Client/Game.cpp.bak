// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////


#include "Game.h"
#include "CommonTypes.h"
#include "Benchmark.h"
#include "FrameTiming.h"
#include "lan_eng.h"
#include "Packet/SharedPackets.h"
#include <cstdio>
#include <windows.h>

// Manager singletons
#include "ConfigManager.h"
#include "Camera.h"
#include "AudioManager.h"
#include "WeatherManager.h"
#include "ChatCommandManager.h"

// DialogBox system
#include "IDialogBox.h"

extern char G_cSpriteAlphaDegree;

extern char G_cCmdLine[256], G_cCmdLineTokenA[120], G_cCmdLineTokenA_Lowercase[120], G_cCmdLineTokenB[120], G_cCmdLineTokenC[120], G_cCmdLineTokenD[120], G_cCmdLineTokenE[120];
extern class XSocket* G_pCalcSocket;
extern bool G_bIsCalcSocketConnected;
extern uint32_t G_dwCalcSocketTime, G_dwCalcSocketSendTime;
extern HWND	G_hWnd, G_hEditWnd;
extern HINSTANCE G_hInstance;

char _cDrawingOrder[] = { 0, 1, 0, 0, 0, 0, 0, 1, 1 };
char _cMantleDrawingOrder[] = { 0, 1, 1, 1, 0, 0, 0, 2, 2 };
char _cMantleDrawingOrderOnRun[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1 };


short _tmp_sOwnerType, _tmp_sAppr1, _tmp_sAppr2, _tmp_sAppr3, _tmp_sAppr4;//, _tmp_iStatus;
//CInt _tmp_iStatus;
int _tmp_iStatus;
char  _tmp_cAction, _tmp_cDir, _tmp_cFrame, _tmp_cName[12];
int   _tmp_iChatIndex, _tmp_dx, _tmp_dy, _tmp_iApprColor, _tmp_iEffectType, _tmp_iEffectFrame, _tmp_dX, _tmp_dY; // 21.171 2002-6-14
uint16_t _tmp_wObjectID;
char cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData3, cDynamicObjectData4;
uint16_t wFocusObjectID;
short sFocus_dX, sFocus_dY;
char  cFocusAction, cFocusFrame, cFocusDir, cFocusName[12];
short sFocusX, sFocusY, sFocusOwnerType, sFocusAppr1, sFocusAppr2, sFocusAppr3, sFocusAppr4;
int iFocuiStatus;
int   iFocusApprColor;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void CGame::ReadSettings()
{
	// Initialize and load settings from JSON file via ConfigManager
	ConfigManager::Get().Initialize();
	ConfigManager::Get().Load();

	// Copy values to CGame member variables
	m_sMagicShortCut = ConfigManager::Get().GetMagicShortcut();
	m_sRecentShortCut = ConfigManager::Get().GetRecentShortcut();
	for (int i = 0; i < 5; i++)
	{
		m_sShortCut[i] = ConfigManager::Get().GetShortcut(i);
	}
	m_sShortCut[5] = -1; // 6th slot unused

	// Audio settings loaded into AudioManager
	AudioManager::Get().SetSoundVolume(ConfigManager::Get().GetSoundVolume());
	AudioManager::Get().SetMusicVolume(ConfigManager::Get().GetMusicVolume());
	AudioManager::Get().SetSoundEnabled(ConfigManager::Get().IsSoundEnabled());
	AudioManager::Get().SetMusicEnabled(ConfigManager::Get().IsMusicEnabled());
}

void CGame::WriteSettings()
{
	// Copy CGame member variables to ConfigManager
	ConfigManager::Get().SetMagicShortcut(m_sMagicShortCut);
	for (int i = 0; i < 5; i++)
	{
		ConfigManager::Get().SetShortcut(i, m_sShortCut[i]);
	}

	// Audio settings from AudioManager
	ConfigManager::Get().SetSoundVolume(AudioManager::Get().GetSoundVolume());
	ConfigManager::Get().SetMusicVolume(AudioManager::Get().GetMusicVolume());
	ConfigManager::Get().SetSoundEnabled(AudioManager::Get().IsSoundEnabled());
	ConfigManager::Get().SetMusicEnabled(AudioManager::Get().IsMusicEnabled());

	// Save to JSON file
	ConfigManager::Get().Save();
}

CGame::CGame()
{
	int i;

	// Initialize critical pointers first to avoid 0xCDCDCDCD debug heap issues
	m_pInputBuffer = nullptr;
	m_dialogBoxManager.Initialize(this);
	m_dialogBoxManager.InitializeDialogBoxes();

	srand((unsigned)time(0));
	ReadSettings();

#ifdef _DEBUG
	m_bToggleScreen = true;
#else
	m_bToggleScreen = false;
#endif
	iMaxStats = 0;
	iMaxLevel = 0;
	m_bShowFPS = false;
	m_cDetailLevel = 2;
	m_cLoading = 0;
	m_bZoomMap = true;
	m_bIsFirstConn = true;
	m_iItemDropCnt = 0;
	m_bItemDrop = false;
	m_bIsSpecial = false;
	m_cGameMode = DEF_GAMEMODE_ONLOADING;
	m_cWhisperIndex = DEF_MAXWHISPERMSG;
	m_cGameModeCount = 0;
	std::memset(m_cMapName, 0, sizeof(m_cMapName));
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	m_pGSock = 0;
	m_pLSock = 0;
	m_pMapData = 0;
	m_cCommandCount = 0;
	m_dwCommandTime = 0; //v2.15 SpeedHack
	m_sPlayerX = 0;
	m_sPlayerY = 0;
	m_sViewDX = 0;
	m_sViewDY = 0;
	m_sViewDstX = 0;
	m_sViewDstY = 0;
	m_sViewPointX = 0;
	m_sViewPointY = 0;
	m_sVDL_X = 0;
	m_sVDL_Y = 0;
	m_wCommObjectID = 0;
	m_wLastAttackTargetID = 0;
	m_wEnterGameType = 0;
	m_cCommand = DEF_OBJECTSTOP;
	m_bIsObserverMode = false;
	for (i = 0; i < DEF_MAXSPRITES; i++) m_pSprite[i] = 0;
	for (i = 0; i < DEF_MAXTILES; i++) m_pTileSpr[i] = 0;
	for (i = 0; i < DEF_MAXEFFECTSPR; i++) m_pEffectSpr[i] = 0;

	for (i = 0; i < 5000; i++) m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXCHATMSGS; i++) m_pChatMsgList[i] = 0;

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) m_pChatScrollList[i] = 0;

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) m_pWhisperMsg[i] = 0;

	for (i = 0; i < DEF_MAXEFFECTS; i++) m_pEffectList[i] = 0;

	for (i = 0; i < DEF_MAXITEMS; i++) m_pItemList[i] = 0;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) m_pBankList[i] = 0;

	for (i = 0; i < 4; i++) m_pCharList[i] = 0;
	// Snoopy: Fixed here
	for (i = 0; i < 61; i++) m_dialogBoxManager.SetOrderAt(i, 0);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicCfgList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillCfgList[i] = 0;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		m_pMsgTextList[i] = 0;
		m_pMsgTextList2[i] = 0;
		m_pAgreeMsgTextList[i] = 0;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = 0;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispBuildItemList[i] = 0;

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pCraftItemList[i] = 0;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispCraftItemList[i] = 0;



	for (i = 0; i < DEF_MAXGAMEMSGS; i++) m_pGameMsgList[i] = 0;

	m_pExID = 0;

	for (i = 0; i < DEF_MAXITEMNAMES; i++) m_pItemNameList[i] = 0;

	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	std::memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
	m_iGameServerMode = 2; // Snoopy: Default is INTERNET

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		m_pItemForSaleList[i] = 0;

	// CLEROTh - INIT DIALOG BOXES

	//Character-Info Dialog(F5)
	m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX = 30 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY = 30 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sSizeX = 270;
	m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sSizeY = 376;

	//Inventory Dialog(F6)
	m_dialogBoxManager.Info(DialogBoxId::Inventory).sX = 380 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Inventory).sY = 210 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Inventory).sSizeX = 225;
	m_dialogBoxManager.Info(DialogBoxId::Inventory).sSizeY = 185;

	//Magic Circle Dialog(F7)
	m_dialogBoxManager.Info(DialogBoxId::Magic).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Magic).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Magic).sSizeX = 258;//280;
	m_dialogBoxManager.Info(DialogBoxId::Magic).sSizeY = 328;//346;

	// Item drop confirmation
	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sSizeX = 270;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sSizeY = 105;

	// ** This is a battle area **
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sSizeY = 170;

	//Guild Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sSizeY = 339;

	//Guild Operation Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sSizeX = 295;
	m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sSizeY = 346;

	//Guide Map Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX = LOGICAL_MAX_X - 128;
	m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY = 0;
	m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX = 128;
	m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY = 128;

	//Chatting History Dialog(F9)
	m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sX = 135 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sY = 273 + SCREENY + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sSizeX = 364;
	m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sSizeY = 162;

	//Sale Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sX = 70 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sY = 50 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sSizeY = 339;

	//Level-Up Setting Dialog
	m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sSizeY = 339;

	//City Hall Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).sSizeY = 339;

	//Bank Dialog
	m_dialogBoxManager.Info(DialogBoxId::Bank).sX = 60 + SCREENX; //337
	m_dialogBoxManager.Info(DialogBoxId::Bank).sY = 50 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sSizeY = 339;
	m_dialogBoxManager.Info(DialogBoxId::Bank).sV1 = 13;

	//Skill Menu(F8)
	m_dialogBoxManager.Info(DialogBoxId::Skill).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Skill).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Skill).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Skill).sSizeY = 339;

	//Magic Shop Menu
	m_dialogBoxManager.Info(DialogBoxId::MagicShop).sX = 30 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::MagicShop).sY = 30 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::MagicShop).sSizeX = 304;
	m_dialogBoxManager.Info(DialogBoxId::MagicShop).sSizeY = 328;

	//Dialog items drop external screen
	m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sSizeX = 215;
	m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sSizeY = 87;

	//Text Dialog
	m_dialogBoxManager.Info(DialogBoxId::Text).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Text).sY = 65 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Text).sSizeX = 258; // 238
	m_dialogBoxManager.Info(DialogBoxId::Text).sSizeY = 339; // 274

	//System Menu Dialog(F12)
	m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sY = 107 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sSizeX = 258;//270; //v2.18
	m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sSizeY = 268;//346;

	//NpcActionQuery Dialog
	m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = 237 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sSizeX = 252;
	m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sSizeY = 87;

	//NpcTalk Dialog
	m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sSizeY = 339;

	//Map
	m_dialogBoxManager.Info(DialogBoxId::Map).sX = 336 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Map).sY = 88 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Map).sSizeX = 270;
	m_dialogBoxManager.Info(DialogBoxId::Map).sSizeY = 346;

	//ItemSellorRepair Dialog
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sSizeY = 339;

	//Fishing Dialog
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sX = 193 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sY = 241 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sSizeX = 263;
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sSizeY = 100;

	//Noticement Dialog
	m_dialogBoxManager.Info(DialogBoxId::Noticement).sX = 162 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Noticement).sY = 40 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Noticement).sSizeX = 315;
	m_dialogBoxManager.Info(DialogBoxId::Noticement).sSizeY = 171;

	//Manufacture Dialog
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY = 60 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 339;

	//Exchange Dialog
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sY = 30 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sSizeX = 520;
	m_dialogBoxManager.Info(DialogBoxId::Exchange).sSizeY = 357;

	//Quest Dialog
	m_dialogBoxManager.Info(DialogBoxId::Quest).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Quest).sSizeY = 339;

	//Gauge Pannel
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX = 0;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY = LOGICAL_HEIGHT - 53;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sSizeX = 157;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sSizeY = 53;

	//Icon Pannel
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX = 0;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY = LOGICAL_HEIGHT - ICON_PANEL_HEIGHT;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sSizeX = ICON_PANEL_WIDTH;
	m_dialogBoxManager.Info(DialogBoxId::HudPanel).sSizeY = ICON_PANEL_HEIGHT;//47;

	//Sell List Dialog
	m_dialogBoxManager.Info(DialogBoxId::SellList).sX = 170 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::SellList).sY = 70 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::SellList).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::SellList).sSizeY = 339;

	//Party Dialog
	m_dialogBoxManager.Info(DialogBoxId::Party).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Party).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Party).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Party).sSizeY = 339;

	//Crusade Job Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sX = 360 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sY = 65 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sSizeY = 339;

	//Item Upgrade Dialog
	m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sX = 60 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sY = 50 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sSizeY = 339;

	//Help Menu Dialog(F1)
	m_dialogBoxManager.Info(DialogBoxId::Help).sX = 358 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Help).sY = 65 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Help).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Help).sSizeY = 339;

	//Crusade Commander Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sSizeY = 386;

	//Crusade Constructor Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sSizeY = 386;

	//Crusade Soldier Dialog
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sX = 20 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sY = 20 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sSizeX = 310;
	m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sSizeY = 386;

	// Give item ???
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sSizeX = 291;
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sSizeY = 413;

	// 3.51 Slates Dialog - Diuuude
	m_dialogBoxManager.Info(DialogBoxId::Slates).sX = 100 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sY = 60 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeY = 339;

	// Snoopy: Item exchange confirmation
	m_dialogBoxManager.Info(DialogBoxId::ConfirmExchange).sX = 285 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ConfirmExchange).sY = 200 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ConfirmExchange).sSizeX = 270;
	m_dialogBoxManager.Info(DialogBoxId::ConfirmExchange).sSizeY = 105;

	// MJ Stats Change DialogBox - Diuuude
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX = 0 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY = 0 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sSizeY = 339;

	// Upgrade Window
	m_dialogBoxManager.Info(DialogBoxId::UpgradeWindow).sX = 380;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeWindow).sY = 180;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeWindow).sSizeX = 160;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeWindow).sSizeY = 85;

	// Upgrade all
	m_dialogBoxManager.Info(DialogBoxId::UpgradeAll).sX = 185;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeAll).sY = 100;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeAll).sSizeX = 350;
	m_dialogBoxManager.Info(DialogBoxId::UpgradeAll).sSizeY = 105;

	// Snoopy: Resurection
	m_dialogBoxManager.Info(DialogBoxId::Resurrect).sX = 185 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::Resurrect).sY = 100 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::Resurrect).sSizeX = 270;
	m_dialogBoxManager.Info(DialogBoxId::Resurrect).sSizeY = 105;

	//Guild Hall Menu Dialog
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sSizeY = 339;

	//50Cent - Repair All
	m_dialogBoxManager.Info(DialogBoxId::RepairAll).sX = 337 + SCREENX;
	m_dialogBoxManager.Info(DialogBoxId::RepairAll).sY = 57 + SCREENY;
	m_dialogBoxManager.Info(DialogBoxId::RepairAll).sSizeX = 258;
	m_dialogBoxManager.Info(DialogBoxId::RepairAll).sSizeY = 339;



	m_bCtrlPressed = false;
	m_bShiftPressed = false;
	m_bEnterPressed = false;
	m_bEscPressed = false;
	m_dwDialogCloseTime = 0;
	m_iTimeLeftSecAccount = 0;
	m_iTimeLeftSecIP = 0;
	m_bWhisper = true;
	m_bShout = true;

	// Initialize char arrays that were previously zero-initialized by HEAP_ZERO_MEMORY
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
	std::memset(m_cMsg, 0, sizeof(m_cMsg));
	std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
	std::memset(m_cBackupChatMsg, 0, sizeof(m_cBackupChatMsg));
	std::memset(m_cAmountString, 0, sizeof(m_cAmountString));
	std::memset(m_cCurLocation, 0, sizeof(m_cCurLocation));
	std::memset(m_cMapMessage, 0, sizeof(m_cMapMessage));
	std::memset(m_cGameServerName, 0, sizeof(m_cGameServerName));
	std::memset(m_cAccountAge, 0, sizeof(m_cAccountAge));
	std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
	std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
	std::memset(m_cAccountCountry, 0, sizeof(m_cAccountCountry));
	std::memset(m_cAccountSSN, 0, sizeof(m_cAccountSSN));
	std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
	std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
	std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
	std::memset(m_cName_IE, 0, sizeof(m_cName_IE));
	std::memset(m_cTakeHeroItemName, 0, sizeof(m_cTakeHeroItemName));
}

CGame::~CGame()
{
}

bool CGame::bInit(HWND hWnd, HINSTANCE hInst, char* pCmdLine)
{
	int iIndex;
	int i;
	char seps[] = "&= ,\t\n";
	char* token;
	// CLEROTH - BUG
	for (i = 0; i < DEF_MAXSPRITES; i++)
		m_pSprite[i] = 0;
	if (pCmdLine != 0)
	{
		std::memset(G_cCmdLine, 0, sizeof(G_cCmdLine));
		std::memset(G_cCmdLineTokenA, 0, sizeof(G_cCmdLineTokenA));
		std::memset(G_cCmdLineTokenB, 0, sizeof(G_cCmdLineTokenB));
		std::memset(G_cCmdLineTokenC, 0, sizeof(G_cCmdLineTokenC));
		std::memset(G_cCmdLineTokenD, 0, sizeof(G_cCmdLineTokenD));
		std::memset(G_cCmdLineTokenE, 0, sizeof(G_cCmdLineTokenE));

		strcpy(G_cCmdLine, pCmdLine);

		iIndex = 0;
		token = strtok(pCmdLine, seps);
		while (token != 0)
		{
			switch (iIndex) {
			case 0:	strcpy(G_cCmdLineTokenA, token); break;
			case 1: strcpy(G_cCmdLineTokenB, token); break;
			case 2: strcpy(G_cCmdLineTokenC, token); break;
			case 3: strcpy(G_cCmdLineTokenD, token); break;
			case 4: strcpy(G_cCmdLineTokenE, token); break;
			}
			token = strtok(0, seps);
			iIndex++;
		}
	}

	std::memset(G_cCmdLineTokenA_Lowercase, 0, sizeof(G_cCmdLineTokenA_Lowercase));
	strcpy(G_cCmdLineTokenA_Lowercase, G_cCmdLineTokenA);
	_strlwr(G_cCmdLineTokenA_Lowercase);

	if (memcmp(G_cCmdLineTokenA_Lowercase, "/egparam", 8) == 0)
	{
		std::memset(G_cCmdLineTokenA, 0, sizeof(G_cCmdLineTokenA));
		memcpy(G_cCmdLineTokenA, "dataq", 5);
	}
	m_hWnd = hWnd;
	m_bCommandAvailable = true;
	m_pCGameMonitor = 0;
	m_dwTime = G_dwGlobalTime;

	// Initialize AudioManager (sounds loaded later during loading screen)
	AudioManager::Get().Initialize(m_hWnd);

	// Initialize ChatCommandManager
	ChatCommandManager::Get().Initialize(this);

	m_bIsHideLocalCursor = false;
	m_cEnterCheck = m_cTabCheck = m_cLeftArrowCheck = 0;

	if (bCheckImportantFile() == false)
	{
		MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR1", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	if (_bDecodeBuildItemContents() == false)
	{
		MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR2", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	bReadIp();

	if (bReadItemNameConfigFile() == false)
	{
		MessageBox(m_hWnd, "ItemName.cfg file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	if (bInitMagicCfgList() == false) {
		MessageBox(m_hWnd, "MAGICCFG.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	// Skill
	if (bInitSkillCfgList() == false)
	{
		MessageBox(m_hWnd, "SKILLCFG.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	if (m_DDraw.bInit(m_hWnd) == false)
	{
		MessageBox(m_hWnd, "This program requires DirectX7.0a!", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	if (m_DInput.bInit(hWnd, hInst) == false) {
		MessageBox(m_hWnd, "This program requires DirectX7.0a!", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}

	m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 0, false);
	CloseHandle(m_hPakFile);

	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 0, false);
	m_pSprite[DEF_SPRID_INTERFACE_CRAFTING] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 3, false);
	CloseHandle(m_hPakFile);

	// CLEROTH - LOAD FONTS BEFORE MAIN LOADING
	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile != INVALID_HANDLE_VALUE)
	{
		m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 1, false);
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 2, false);
		CloseHandle(m_hPakFile);
	}

	m_hPakFile = CreateFile("sprites\\sprfonts.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile != INVALID_HANDLE_VALUE)
	{
		m_pSprite[DEF_SPRID_INTERFACE_FONT1] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 0, false);
		m_pSprite[DEF_SPRID_INTERFACE_FONT2] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 1, false);
		CloseHandle(m_hPakFile);
	}

	m_stMCursor.sX = 0;
	m_stMCursor.sY = 0;
	m_pMapData = new class CMapData(this);
	std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
	std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
	std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));

	m_sPlayerType = 2;
	m_cPlayerTurn = 0;
	// Snoopy: fixed here
	m_dialogBoxManager.SetOrderAt(60, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetOrderAt(59, DialogBoxId::HudPanel); // 29�� GaugePannel

	m_cMenuDir = 4;
	m_cMenuDirCnt = 0;
	m_cMenuFrame = 0;

	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(70, 70, 80), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(70, 70, 80), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(70, 70, 80), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(70, 100, 70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(130, 90, 10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(42, 53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Violet
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(75, 10, 10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(135, 104, 30), &m_wR[10], &m_wG[10], &m_wB[10]);	// Gold, buggy

	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(200 / 2, 200 / 2, 200 / 2), &m_wR[0], &m_wG[0], &m_wB[0]);
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50 / 2, 0x50 / 2, 0xC0 / 2), &m_wR[1], &m_wG[1], &m_wB[1]); // Indigo Blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(79, 79, 62), &m_wR[2], &m_wG[2], &m_wB[2]); // Custom-Weapon Color
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(135, 104, 30), &m_wR[3], &m_wG[3], &m_wB[3]); // Gold
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(255 / 2, 36 / 2, 0), &m_wR[4], &m_wG[4], &m_wB[4]); // Crimson
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(10, 60, 10), &m_wR[5], &m_wG[5], &m_wB[5]); // Green
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50 / 2, 0x50 / 2, 0x50 / 2), &m_wR[6], &m_wG[6], &m_wB[6]); // Gray
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x5F / 2, 0x9E / 2, 0xA0 / 2), &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xFF / 2, 0x69 / 2, 0xB4 / 2), &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(90, 60, 90), &m_wR[9], &m_wG[9], &m_wB[9]); // Violet

	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0, 35, 60), &m_wR[10], &m_wG[10], &m_wB[10]); // Blue
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xD2 / 2, 0xB4 / 2, 0x8C / 2), &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xBD / 2, 0xB7 / 2, 0x6B / 2), &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(85, 85, 8), &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(75, 10, 10), &m_wR[14], &m_wG[14], &m_wB[14]); // Red
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x30, 0x30, 0x30), &m_wR[15], &m_wG[15], &m_wB[15]); // Black



#ifndef _DEBUG
	m_pCGameMonitor = new class CGameMonitor;
	//===============================================
	// badword.txt
	if (!CMisc::_iConvertFileXor("contents\\badword.txt", "contents\\badword.tmp", 35))
	{
		MessageBox(m_hWnd, "BADWORD.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	m_pCGameMonitor->iReadBadWordFileList("contents\\badword.tmp");
	DeleteFile("contents\\badword.tmp");

	if (!CMisc::_iConvertFileXor("contents\\Curse.txt", "contents\\Curse.tmp", 35))
	{
		MessageBox(m_hWnd, "CURSE.TXT file contains wrong infomation.", "ERROR", MB_ICONEXCLAMATION | MB_OK);
		return false;
	}
	m_curse.LoadCurse("contents\\Curse.tmp");
	DeleteFile("contents\\Curse.tmp");
	//==============================================
#endif

	_LoadGameMsgTextContents();
	std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));

	// Initialize manager singletons (ConfigManager already initialized in ReadSettings)
	Camera::Get().Initialize();
	// AudioManager initialized in bInit() with HWND
	WeatherManager::Get().Initialize();

	// Set Camera viewport to match screen dimensions
	Camera::Get().SetViewportSize(SCREENX * 2 + 640, SCREENY * 2 + 480);
	Camera::Get().SetTileSize(32, 32);

	return true;
}

void CGame::Quit()
{
	int i;
	WriteSettings();
	ChangeGameMode(DEF_GAMEMODE_NULL);

	// Shutdown manager singletons
	WeatherManager::Get().Shutdown();
	AudioManager::Get().Shutdown();
	Camera::Get().Shutdown();
	ConfigManager::Get().Shutdown();

	for (i = 0; i < 5000; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXSPRITES; i++)
		if (m_pSprite[i] != 0) delete m_pSprite[i];
	for (i = 0; i < DEF_MAXTILES; i++)
		if (m_pTileSpr[i] != 0) delete m_pTileSpr[i];
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
		if (m_pEffectSpr[i] != 0) delete m_pEffectSpr[i];

	// Sound cleanup handled by AudioManager::Shutdown()

	for (i = 0; i < 4; i++)
		if (m_pCharList[i] != 0) delete m_pCharList[i];

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)	delete m_pItemList[i];

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)	delete m_pBankList[i];

	for (i = 0; i < DEF_MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++)
		if (m_pChatScrollList[i] != 0) delete m_pChatScrollList[i];

	for (i = 0; i < DEF_MAXWHISPERMSG; i++)
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicCfgList[i] != 0) delete m_pMagicCfgList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != 0) delete m_pSkillCfgList[i];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != 0)  delete m_pMsgTextList[i];
		if (m_pMsgTextList2[i] != 0) delete m_pMsgTextList2[i];
		if (m_pAgreeMsgTextList[i] != 0) delete m_pAgreeMsgTextList[i];
	}

	if (m_pExID != 0) delete m_pExID;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0) delete m_pDispBuildItemList[i];

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pCraftItemList[i] != 0) delete m_pCraftItemList[i];
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispCraftItemList[i] != 0) delete m_pDispCraftItemList[i];


	for (i = 0; i < DEF_MAXGAMEMSGS; i++)
		if (m_pGameMsgList[i] != 0) delete m_pGameMsgList[i];

	for (i = 0; i < DEF_MAXITEMNAMES; i++)
		if (m_pItemNameList[i] != 0) delete m_pItemNameList[i];

	delete m_pMapData;

	if (m_pGSock != 0) delete m_pGSock;
	if (m_pLSock != 0) delete m_pLSock;
	if (G_pCalcSocket != 0) delete G_pCalcSocket;
	if (m_pCGameMonitor != 0) delete m_pCGameMonitor;
}


void CGame::UpdateScreen()
{
	G_dwGlobalTime = GameClock::GetTimeMS();
	OnGameSocketEvent();
	OnLogSocketEvent();
	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		// UpdateScreen_OnAgreement(); //unused by HBx server..
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		UpdateScreen_CreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		UpdateScreen_VersionNotMatch();
		break;

	case DEF_GAMEMODE_ONCONNECTING:
		UpdateScreen_Connecting();
		break;

	case DEF_GAMEMODE_ONMAINMENU:
		UpdateScreen_MainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		UpdateScreen_Loading();
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		UpdateScreen_OnGame();
		break;

	case DEF_GAMEMODE_ONWAITINGINITDATA:
		UpdateScreen_WaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		UpdateScreen_ConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		UpdateScreen_Msg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		UpdateScreen_Login();
		break;

	case DEF_GAMEMODE_ONSELECTSERVER:
		UpdateScreen_SelectServer();
		break;

	case DEF_GAMEMODE_ONQUIT:
		UpdateScreen_Quit();
		break;

	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		UpdateScreen_QueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		UpdateScreen_SelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		UpdateScreen_CreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		UpdateScreen_WaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		UpdateScreen_QueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		UpdateScreen_LogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		UpdateScreen_ChangePassword();
		break;
	}
}


// DrawScreen: Dispatches to DrawScreen_* methods based on current game mode
// Separated from UpdateScreen to allow: Update -> ClearBackB4 -> Draw -> iFlip
// NOTE: Unsplit screens temporarily call the old combined UpdateScreen_On* method here
void CGame::DrawScreen()
{
	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		DrawScreen_CreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		DrawScreen_VersionNotMatch();
		break;

	case DEF_GAMEMODE_ONCONNECTING:
		DrawScreen_Connecting();
		break;

	case DEF_GAMEMODE_ONMAINMENU:
		DrawScreen_MainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		DrawScreen_Loading();
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		DrawScreen_OnGame();
		break;

	case DEF_GAMEMODE_ONWAITINGINITDATA:
		DrawScreen_WaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		DrawScreen_ConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		DrawScreen_Msg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		DrawScreen_Login();
		break;

	case DEF_GAMEMODE_ONSELECTSERVER:
		DrawScreen_SelectServer();
		break;

	case DEF_GAMEMODE_ONQUIT:
		DrawScreen_Quit();
		break;

	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		DrawScreen_QueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		DrawScreen_SelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		DrawScreen_CreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		DrawScreen_WaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		DrawScreen_QueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		DrawScreen_LogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		DrawScreen_ChangePassword();
		break;
	}
}


// RenderFrame: Centralized rendering frame wrapper
// Handles: Update -> (skip check) -> Clear backbuffer -> Draw -> Flip
// This centralizes surface operations that were previously scattered across all screen methods
void CGame::RenderFrame()
{
	// Reset skip flag - screens can set this to skip rendering (e.g., UpdateScreen_OnGame when iUpdateRet == 0)
	m_bSkipFrame = false;

	// Update manager singletons with frame delta time
	double deltaTime = FrameTiming::GetDeltaTime();
	Camera::Get().Update(deltaTime);
	AudioManager::Get().Update(deltaTime);

	// Update phase: Logic, input handling, state changes
	// May set m_bSkipFrame = true to skip rendering entirely
	UpdateScreen();

	// Skip rendering if update phase indicated nothing needs to be drawn
	// This saves ClearBackB4 and iFlip operations when frame is skipped
	if (m_bSkipFrame)
		return;

	// Clear backbuffer before drawing
	m_DDraw.ClearBackB4();

	// Draw phase: Pure rendering based on current state
	DrawScreen();

	// Flip to show the drawn content
	if (m_DDraw.iFlip() == DDERR_SURFACELOST)
		RestoreSprites();

	// Count this as a displayed frame for FPS calculation
	FrameTiming::CountDisplayedFrame();
}


void CGame::CalcViewPoint()
{
	short dX, dY;
	dX = m_sViewPointX - m_sViewDstX;
	dY = m_sViewPointY - m_sViewDstY;
	if (abs(dX) < abs(m_sViewDX))
	{
		m_sViewPointX = m_sViewDstX;
		m_sViewDX = 0;
	}
	else
	{
		if (dX > 0) m_sViewDX--;
		if (dX < 0) m_sViewDX++;
		if (dX == 0) m_sViewDX = 0;
		if (abs(dX) < 40) {
			if (m_sViewDX > 2)  m_sViewDX = 2;
			else if (m_sViewDX < -2) m_sViewDX = -2;
		}
		m_sViewPointX += m_sViewDX;
	}

	if (abs(dY) < abs(m_sViewDY))
	{
		m_sViewPointY = m_sViewDstY;
		m_sViewDY = 0;
	}
	else
	{
		if (dY > 0) m_sViewDY--;
		if (dY < 0) m_sViewDY++;
		if (dY == 0) m_sViewDY = 0;
		if (abs(dY) < 40) {
			if (m_sViewDY > 2)  m_sViewDY = 2;
			else if (m_sViewDY < -2) m_sViewDY = -2;
		}
		m_sViewPointY += m_sViewDY;
	}
}

// MODERNIZED: No longer a window message handler - polls socket directly
void CGame::OnGameSocketEvent()
{
	int iRet;
	char* pData;
	uint32_t dwMsgSize;

	if (m_pGSock == 0) return;

	// MODERNIZED: Poll() instead of iOnSocketEvent()
	iRet = m_pGSock->Poll();
	switch (iRet) {
	case 0:
		// No events
		return;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_GAME);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		pData = m_pGSock->pGetRcvDataPointer(&dwMsgSize);
		GameRecvMsgHandler(dwMsgSize, pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = 0;
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		break;
	}
}

void CGame::RestoreSprites()
{
	for (int i = 0; i < DEF_MAXSPRITES; i++)
		if (m_pSprite[i] != 0) m_pSprite[i]->iRestore();
}

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };
char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, bool bMoveCheck, bool bMIM)
{
	char  cDir, cTmpDir;
	//int   aX, aY, aX2, aY2, dX, dY;
	int   aX, aY, dX, dY;
	int   i;
	if ((sX == dstX) && (sY == dstY)) return 0;
	dX = sX;
	dY = sY;

	if (bMIM == false) // MIM Fix
		cDir = CMisc::cGetNextMoveDir(dX, dY, dstX, dstY);
	else cDir = CMisc::cGetNextMoveDir(dstX, dstY, dX, dY);

	if (m_cPlayerTurn == 0)
		for (i = cDir; i <= cDir + 2; i++)
		{
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(DEF_MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}

	if (m_cPlayerTurn == 1)
		for (i = cDir; i >= cDir - 2; i--)
		{
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(DEF_MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}
	return 0;
}

bool CGame::_bCheckMoveable(short sx, short sy)
{	// Snoopy: This function prevents the client from asking at TP from some maps to
	// ML or PL if not citizen
	// Incomplete function and useless (the server will handle such cases)
/*	if( m_bIsCrusadeMode ) return true;
	if( m_bHunter == false ) return true;
	if( m_bCitizen == false ) return true;
	if( m_bAresden == true && m_cMapIndex == 11 )
	{	if( sy == 20 )
		{	if( (sx>=39) && (sx<=47) ) return false;
			if( (sx>=360) && (sx<=368) ) return false;
		}
	}
	if( m_bAresden == false && m_cMapIndex == 3 )
	{
		if( sy == 373 )
		{	if( (sx>=27) && (sx<=32) ) return false;
		}
		if( sy == 374 )
		{	if( (sx>=298) && (sx<=305) ) return false;
		}
	}*/
	return true;
}

bool CGame::bSendCommand(uint32_t dwMsgID, uint16_t wCommand, char cDir, int iV1, int iV2, int iV3, char* pString, int iV4)
{
	char cMsg[300], cKey;
	DWORD dwTime;
	int iRet, i;

	if ((m_pGSock == 0) && (m_pLSock == 0)) return false;
	dwTime = GameClock::GetTimeMS();
	std::memset(cMsg, 0, sizeof(cMsg));
	cKey = (char)(rand() % 255) + 1;

	switch (dwMsgID) {

	case DEF_REQUEST_ANGEL:	// to Game Server
	{
		hb::net::PacketRequestAngel req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		if (pString != nullptr) {
			std::size_t name_len = std::strlen(pString);
			if (name_len >= sizeof(req.name)) name_len = sizeof(req.name) - 1;
			std::memcpy(req.name, pString, name_len);
		}
		req.angel_id = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case DEF_REQUEST_RESURRECTPLAYER_YES: // By snoopy
	case DEF_REQUEST_RESURRECTPLAYER_NO:  // By snoopy
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_SCROLL:// By snoopy
	{
		hb::net::PacketRequestHeldenianScroll req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		if (pString != nullptr) {
			std::size_t name_len = std::strlen(pString);
			if (name_len >= sizeof(req.name)) name_len = sizeof(req.name) - 1;
			std::memcpy(req.name, pString, name_len);
		}
		req.item_id = wCommand;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_TELEPORT_LIST:
	{
		hb::net::PacketRequestName20 req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		std::memcpy(req.name, "William", sizeof(req.name));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_TP_LIST: // Snoopy: Heldenian TP
	{
		hb::net::PacketRequestName20 req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.name, 0, sizeof(req.name));
		std::memcpy(req.name, "Gail", sizeof(req.name));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_HELDENIAN_TP: // Snoopy: Heldenian TP
	case MSGID_REQUEST_CHARGED_TELEPORT:
	{
		hb::net::PacketRequestTeleportId req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.teleport_id = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_SELLITEMLIST:
	{
		hb::net::PacketRequestSellItemList req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		for (i = 0; i < DEF_MAXSELLLIST; i++) {
			req.entries[i].index = static_cast<uint8_t>(m_stSellItemList[i].iIndex);
			req.entries[i].amount = m_stSellItemList[i].iAmount;
		}
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_RESTART:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_PANNING:
	{
		hb::net::PacketRequestPanning req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.dir = static_cast<uint8_t>(cDir);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_CHANGEPASSWORD:
	{
		hb::net::ChangePasswordRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.new_password, 0, sizeof(req.new_password));
		std::memcpy(req.new_password, m_cNewPassword, sizeof(req.new_password));
		std::memset(req.new_password_confirm, 0, sizeof(req.new_password_confirm));
		std::memcpy(req.new_password_confirm, m_cNewPassConfirm, sizeof(req.new_password_confirm));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_CREATENEWACCOUNT:
		// to Log Server
	{
		hb::net::CreateAccountRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.email, 0, sizeof(req.email));
		std::memcpy(req.email, m_cEmailAddr, sizeof(req.email));
		std::memset(req.quiz, 0, sizeof(req.quiz));
		std::memcpy(req.quiz, m_cAccountQuiz, sizeof(req.quiz));
		std::memset(req.answer, 0, sizeof(req.answer));
		std::memcpy(req.answer, m_cAccountAnswer, sizeof(req.answer));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_GETMINIMUMLOADGATEWAY:
	case MSGID_REQUEST_LOGIN:
		// to Log Server
	{
		hb::net::LoginRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	break;

	case MSGID_REQUEST_CREATENEWCHARACTER:
		// to Log Server
	{
		hb::net::CreateCharacterRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_cPlayerName, sizeof(req.character_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		req.gender = static_cast<uint8_t>(m_cGender);
		req.skin = static_cast<uint8_t>(m_cSkinCol);
		req.hairstyle = static_cast<uint8_t>(m_cHairStyle);
		req.haircolor = static_cast<uint8_t>(m_cHairCol);
		req.underware = static_cast<uint8_t>(m_cUnderCol);
		req.str = static_cast<uint8_t>(m_ccStr);
		req.vit = static_cast<uint8_t>(m_ccVit);
		req.dex = static_cast<uint8_t>(m_ccDex);
		req.intl = static_cast<uint8_t>(m_ccInt);
		req.mag = static_cast<uint8_t>(m_ccMag);
		req.chr = static_cast<uint8_t>(m_ccChr);
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_ENTERGAME:
		// to Log Server
	{
		hb::net::EnterGameRequestFull req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = static_cast<uint16_t>(m_wEnterGameType);
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_cPlayerName, sizeof(req.character_name));
		std::memset(req.map_name, 0, sizeof(req.map_name));
		std::memcpy(req.map_name, m_cMapName, sizeof(req.map_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		req.level = m_iLevel;
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		std::memset(req.cmd_line, 0, sizeof(req.cmd_line));
		std::memcpy(req.cmd_line, G_cCmdLineTokenA, sizeof(req.cmd_line));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_DELETECHARACTER:
		// to Log Server
	{
		hb::net::DeleteCharacterRequest req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = static_cast<uint16_t>(m_wEnterGameType);
		std::memset(req.character_name, 0, sizeof(req.character_name));
		std::memcpy(req.character_name, m_pCharList[m_wEnterGameType - 1]->m_cName, sizeof(req.character_name));
		std::memset(req.account_name, 0, sizeof(req.account_name));
		std::memcpy(req.account_name, m_cAccountName, sizeof(req.account_name));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.world_name, 0, sizeof(req.world_name));
		std::memcpy(req.world_name, m_cWorldServerName, sizeof(req.world_name));
		iRet = m_pLSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_SETITEMPOS:
		// to Game Server
	{
		hb::net::PacketRequestSetItemPos req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.dir = static_cast<uint8_t>(cDir);
		req.x = static_cast<int16_t>(iV1);
		req.y = static_cast<int16_t>(iV2);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_COMMAND_CHECKCONNECTION:
	{
		hb::net::PacketCommandCheckConnection req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.time_ms = dwTime;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	break;

	case MSGID_REQUEST_INITDATA:
	case MSGID_REQUEST_INITPLAYER:
		// to Game Server
	{
		hb::net::PacketRequestInitPlayer req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		std::memset(req.player, 0, sizeof(req.player));
		std::memcpy(req.player, m_cPlayerName, sizeof(req.player));
		std::memset(req.account, 0, sizeof(req.account));
		std::memcpy(req.account, m_cAccountName, sizeof(req.account));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		req.is_observer = static_cast<uint8_t>(m_bIsObserverMode);
		std::memset(req.server, 0, sizeof(req.server));
		std::memcpy(req.server, m_cGameServerName, sizeof(req.server));
		req.padding = 0;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}

	//m_bIsObserverMode = false;
	break;
	case MSGID_LEVELUPSETTINGS:
		// CLEROTH
		//if ((m_cLU_Str + m_cLU_Vit + m_cLU_Dex + m_cLU_Int + m_cLU_Mag + m_cLU_Char) > 3) return false;
	{
		hb::net::PacketRequestLevelUpSettings req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.str = static_cast<int16_t>(m_cLU_Str);
		req.vit = static_cast<int16_t>(m_cLU_Vit);
		req.dex = static_cast<int16_t>(m_cLU_Dex);
		req.intel = static_cast<int16_t>(m_cLU_Int);
		req.mag = static_cast<int16_t>(m_cLU_Mag);
		req.chr = static_cast<int16_t>(m_cLU_Char);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_COMMAND_CHATMSG:
		if (m_bIsTeleportRequested == true) return false;
		if (pString == 0) return false;

		// to Game Server
		{
			hb::net::PacketCommandChatMsgHeader req{};
			req.header.msg_id = dwMsgID;
			req.header.msg_type = 0;
			req.x = m_sPlayerX;
			req.y = m_sPlayerY;
			std::memset(req.name, 0, sizeof(req.name));
			std::memcpy(req.name, m_cPlayerName, sizeof(req.name));
			req.chat_type = static_cast<uint8_t>(iV1);
			if (bCheckLocalChatCommand(pString) == true) return false;
			std::size_t text_len = std::strlen(pString);
			std::memset(cMsg, 0, sizeof(cMsg));
			std::memcpy(cMsg, &req, sizeof(req));
			std::memcpy(cMsg + sizeof(req), pString, text_len + 1);
			iRet = m_pGSock->iSendMsg(cMsg, static_cast<int>(sizeof(req) + text_len + 1));
		}
		break;

	case MSGID_COMMAND_COMMON:
		if (m_bIsTeleportRequested == true) return false;
		switch (wCommand) {
		case DEF_COMMONTYPE_BUILDITEM:
		{
			hb::net::PacketCommandCommonBuild req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			std::memset(req.name, 0, sizeof(req.name));
			if (pString != 0) {
				std::size_t name_len = std::strlen(pString);
				if (name_len > sizeof(req.name)) name_len = sizeof(req.name);
				std::memcpy(req.name, pString, name_len);
			}
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		case DEF_COMMONTYPE_REQ_CREATEPORTION:
		{
			hb::net::PacketCommandCommonItems req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			req.padding = 0;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		//Crafting
		case DEF_COMMONTYPE_CRAFTITEM:
		{
			hb::net::PacketCommandCommonBuild req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			std::memset(req.name, ' ', sizeof(req.name));
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6);
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		// Create Slate Request - Diuuude
		case DEF_COMMONTYPE_REQ_CREATESLATE:
		{
			hb::net::PacketCommandCommonItems req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.item_ids[0] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV1);
			req.item_ids[1] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV2);
			req.item_ids[2] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV3);
			req.item_ids[3] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV4);
			req.item_ids[4] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV5);
			req.item_ids[5] = static_cast<uint8_t>(m_dialogBoxManager.Info(DialogBoxId::Slates).sV6);
			req.padding = 0;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		break;

		default:
			if (pString == 0)
			{
				hb::net::PacketCommandCommonWithTime req{};
				req.base.header.msg_id = dwMsgID;
				req.base.header.msg_type = wCommand;
				req.base.x = m_sPlayerX;
				req.base.y = m_sPlayerY;
				req.base.dir = static_cast<uint8_t>(cDir);
				req.v1 = iV1;
				req.v2 = iV2;
				req.v3 = iV3;
				req.time_ms = dwTime;
				iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
			}
			else
			{
				hb::net::PacketCommandCommonWithString req{};
				req.base.header.msg_id = dwMsgID;
				req.base.header.msg_type = wCommand;
				req.base.x = m_sPlayerX;
				req.base.y = m_sPlayerY;
				req.base.dir = static_cast<uint8_t>(cDir);
				req.v1 = iV1;
				req.v2 = iV2;
				req.v3 = iV3;
				std::memset(req.text, 0, sizeof(req.text));
				std::size_t text_len = std::strlen(pString);
				if (text_len > sizeof(req.text)) text_len = sizeof(req.text);
				std::memcpy(req.text, pString, text_len);
				req.v4 = iV4;
				iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
			}
			break;
		}

		break;

	case MSGID_REQUEST_CREATENEWGUILD:
	case MSGID_REQUEST_DISBANDGUILD:
		// to Game Server
	{
		hb::net::PacketRequestGuildAction req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		std::memset(req.player, 0, sizeof(req.player));
		std::memcpy(req.player, m_cPlayerName, sizeof(req.player));
		std::memset(req.account, 0, sizeof(req.account));
		std::memcpy(req.account, m_cAccountName, sizeof(req.account));
		std::memset(req.password, 0, sizeof(req.password));
		std::memcpy(req.password, m_cAccountPassword, sizeof(req.password));
		std::memset(req.guild, 0, sizeof(req.guild));
		char cTemp[21];
		std::memset(cTemp, 0, sizeof(cTemp));
		std::memcpy(cTemp, m_cGuildName, 20);
		CMisc::ReplaceString(cTemp, ' ', '_');
		std::memcpy(req.guild, cTemp, sizeof(req.guild));
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case MSGID_REQUEST_TELEPORT:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}

	m_bIsTeleportRequested = true;
	break;

	case MSGID_REQUEST_CIVILRIGHT:
	{
		hb::net::PacketRequestHeaderOnly req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_REQUEST_RETRIEVEITEM:
	{
		hb::net::PacketRequestRetrieveItem req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = DEF_MSGTYPE_CONFIRM;
		req.item_slot = static_cast<uint8_t>(iV1);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_REQUEST_NOTICEMENT:
	{
		hb::net::PacketRequestNoticement req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.value = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req), cKey);
	}
	break;

	case  MSGID_REQUEST_FIGHTZONE_RESERVE:
	{
		hb::net::PacketRequestFightzoneReserve req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.fightzone = iV1;
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	case MSGID_STATECHANGEPOINT:
		// Diuuude
	{
		hb::net::PacketRequestStateChange req{};
		req.header.msg_id = dwMsgID;
		req.header.msg_type = 0;
		req.change1 = static_cast<uint8_t>(cStateChange1);
		req.change2 = static_cast<uint8_t>(cStateChange2);
		req.change3 = static_cast<uint8_t>(cStateChange3);
		iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
	}
	break;

	default:
		if (m_bIsTeleportRequested == true) return false;
		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE))
		{
			hb::net::PacketCommandMotionAttack req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.base.dx = static_cast<int16_t>(iV1);
			req.base.dy = static_cast<int16_t>(iV2);
			req.base.type = static_cast<int16_t>(iV3);
			req.target_id = static_cast<uint16_t>(iV4);
			req.time_ms = dwTime;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req));
		}
		else
		{
			hb::net::PacketCommandMotionSimple req{};
			req.base.header.msg_id = dwMsgID;
			req.base.header.msg_type = wCommand;
			req.base.x = m_sPlayerX;
			req.base.y = m_sPlayerY;
			req.base.dir = static_cast<uint8_t>(cDir);
			req.base.dx = static_cast<int16_t>(iV1);
			req.base.dy = static_cast<int16_t>(iV2);
			req.base.type = static_cast<int16_t>(iV3);
			req.time_ms = dwTime;
			iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&req), sizeof(req)); //v2.171
		}
		m_cCommandCount++;
		break;
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
	{
		char cDbg[160];
		wsprintf(cDbg, "[NETWARN] bSendCommand: ret=%d msgid=0x%X cmd=0x%X\n", iRet, dwMsgID, wCommand);
		OutputDebugStringA(cDbg);
	}
	ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
	delete m_pGSock;
	m_pGSock = 0;
	break;

	case DEF_XSOCKEVENT_CRITICALERROR:
	{
		char cDbg[160];
		wsprintf(cDbg, "[NETWARN] bSendCommand: CRITICAL ret=%d msgid=0x%X cmd=0x%X\n", iRet, dwMsgID, wCommand);
		OutputDebugStringA(cDbg);
	}
	delete m_pGSock;
	m_pGSock = 0;
	if (G_pCalcSocket != 0) {
		delete G_pCalcSocket;
		G_pCalcSocket = 0;
	}
	SendMessage(m_hWnd, WM_DESTROY, 0, 0);
	break;
	}
	return true;
}


void CGame::DrawObjects(short sPivotX, short sPivotY, short sDivX, short sDivY, short sModX, short sModY, short msX, short msY)
{
	int ix, iy, indexX, indexY, dX, dY, iDvalue;
	char cItemColor;
	bool bIsPlayerDrawed = false;
	bool bContact = false;
	bool bRet = false;
	short sItemSprite, sItemSpriteFrame, sObjSpr, sObjSprFrame, sDynamicObject, sDynamicObjectFrame;
	static DWORD dwMCAnimTime = G_dwGlobalTime;
	static short sMCAnimFrame = 1;
	// Xmas
	static int ix1[100];
	static int iy2[100];
	static int iXmasTreeBulbDelay = 76;
	int idelay = 75;
	bool frame_omit = false;

	// Item's desc on floor
	uint32_t dwItemAttr, dwItemSelectedAttr;
	int iItemSelectedx, iItemSelectedy;
	short sItemID, sItemSelectedID = -1;

	int res_x = LOGICAL_MAX_X;
	int res_y = LOGICAL_MAX_Y;
	int res_msy = LOGICAL_HEIGHT - 49;

	if (sDivY < 0 || sDivX < 0) return;
	m_sMCX = 0;
	m_sMCY = 0;
	std::memset(m_cMCName, 0, sizeof(m_cMCName));

	//dwTime = G_dwGlobalTime;
	uint32_t dwTime = m_dwCurTime;
	m_stMCursor.sCursorFrame = 0;

	indexY = sDivY + sPivotY - 7;
	for (iy = -sModY - 224; iy <= res_y + 352; iy += 32)
	{
		indexX = sDivX + sPivotX - 4;
		for (ix = -sModX - 128; ix <= res_x + 128; ix += 32)
		{
			sDynamicObject = 0;
			bRet = false;
			if ((ix >= -sModX) && (ix <= res_x + 16) && (iy >= -sModY) && (iy <= res_y + 32 + 16))
			{
				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = 0;
				_tmp_cDir = _tmp_cFrame = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iChatIndex = 0;
				std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{
					sItemID = 0;
					bRet = false;
					cItemColor = 0;
					dwItemAttr = 0;
				}
				else
				{
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX;
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY;
					_tmp_wObjectID = m_pMapData->m_pData[dX][dY].m_wDeadObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sDeadOwnerType;
					_tmp_cDir = m_pMapData->m_pData[dX][dY].m_cDeadDir;
					_tmp_sAppr1 = m_pMapData->m_pData[dX][dY].m_sDeadAppr1;
					_tmp_sAppr2 = m_pMapData->m_pData[dX][dY].m_sDeadAppr2;
					_tmp_sAppr3 = m_pMapData->m_pData[dX][dY].m_sDeadAppr3;
					_tmp_sAppr4 = m_pMapData->m_pData[dX][dY].m_sDeadAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iDeadApprColor;
					_tmp_cFrame = m_pMapData->m_pData[dX][dY].m_cDeadOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iDeadChatMsg;
					_tmp_iStatus = m_pMapData->m_pData[dX][dY].m_iDeadStatus;
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cDeadOwnerName);
					sItemID = m_pMapData->m_pData[dX][dY].m_sItemID;
					dwItemAttr = m_pMapData->m_pData[dX][dY].m_dwItemAttr;
					cItemColor = m_pMapData->m_pData[dX][dY].m_cItemColor;
					sDynamicObject = m_pMapData->m_pData[dX][dY].m_sDynamicObjectType;
					sDynamicObjectFrame = (short)m_pMapData->m_pData[dX][dY].m_cDynamicObjectFrame;
					cDynamicObjectData1 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData1;
					cDynamicObjectData2 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData2;
					cDynamicObjectData3 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData3;
					cDynamicObjectData4 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData4;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					bRet = true;
				}

				if ((bRet == true) && (sItemID != 0) && m_pItemConfigList[sItemID] != 0)
				{
					if (cItemColor == 0)
						m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->PutSpriteFast(ix, iy, m_pItemConfigList[sItemID]->m_sSpriteFrame, dwTime);
					else
					{
						switch (m_pItemConfigList[sItemID]->m_sSprite) {
						case 1: // Swds
						case 2: // Bows
						case 3: // Shields
						case 15: // Axes hammers
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->PutSpriteRGB(ix, iy
								, m_pItemConfigList[sItemID]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
							break;
						default:
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pItemConfigList[sItemID]->m_sSprite]->PutSpriteRGB(ix, iy
								, m_pItemConfigList[sItemID]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
							break;
						}
					}

					if (m_bShiftPressed && msX >= ix - 16 && msY >= iy - 16 && msX <= ix + 16 && msY <= iy + 16) {
						sItemSelectedID = sItemID;
						dwItemSelectedAttr = dwItemAttr;
						iItemSelectedx = ix;
						iItemSelectedy = iy;
					}

					if ((ix - 13 < msX) && (ix + 13 > msX) && (iy - 13 < msY) && (iy + 13 > msY))
					{
						if ((dwTime - dwMCAnimTime) > 200)
						{
							dwMCAnimTime = dwTime;
							if (sMCAnimFrame == 1)
								sMCAnimFrame = 2;
							else sMCAnimFrame = 1;
						}
						m_stMCursor.sCursorFrame = sMCAnimFrame;
					}
				}

				if ((bRet == true) && (_tmp_wObjectID != 0))
				{
					bContact = DrawObject_OnDead(indexX, indexY, ix, iy, false, dwTime, msX, msY);
				}

				if ((bContact == true) && (msY <= res_msy))
				{
					m_sMCX = indexX;
					m_sMCY = indexY;
					sFocusX = ix;
					sFocusY = iy;
					sFocusOwnerType = _tmp_sOwnerType;
					cFocusAction = DEF_OBJECTDEAD;
					wFocusObjectID = _tmp_wObjectID;
					cFocusFrame = _tmp_cFrame;
					cFocusDir = _tmp_cDir;
					sFocusAppr1 = _tmp_sAppr1;
					sFocusAppr2 = _tmp_sAppr2;
					sFocusAppr3 = _tmp_sAppr3;
					sFocusAppr4 = _tmp_sAppr4;
					iFocusApprColor = _tmp_iApprColor;
					iFocuiStatus = _tmp_iStatus;
					std::memset(cFocusName, 0, sizeof(cFocusName));
					strcpy(cFocusName, _tmp_cName);
					std::memset(m_cMCName, 0, sizeof(m_cMCName));
					strcpy(m_cMCName, _tmp_cName);
					sFocus_dX = _tmp_dX;
					sFocus_dY = _tmp_dY;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					bContact = false;
				}

				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = 0;
				_tmp_cFrame = _tmp_cDir = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iApprColor = _tmp_iChatIndex = 0;
				std::memset(_tmp_cName, 0, sizeof(_tmp_cName));

				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{
					sItemID = 0;
					bRet = false;
				}
				else
				{
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX; // v2.171 2002-6-14
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY; // v2.171 2002-6-14
					_tmp_wObjectID = m_pMapData->m_pData[dX][dY].m_wObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sOwnerType;
					_tmp_cAction = m_pMapData->m_pData[dX][dY].m_cOwnerAction;
					_tmp_iStatus = m_pMapData->m_pData[dX][dY].m_iStatus;
					_tmp_cDir = m_pMapData->m_pData[dX][dY].m_cDir;
					_tmp_sAppr1 = m_pMapData->m_pData[dX][dY].m_sAppr1;
					_tmp_sAppr2 = m_pMapData->m_pData[dX][dY].m_sAppr2;
					_tmp_sAppr3 = m_pMapData->m_pData[dX][dY].m_sAppr3;
					_tmp_sAppr4 = m_pMapData->m_pData[dX][dY].m_sAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iApprColor; // v1.4
					_tmp_cFrame = m_pMapData->m_pData[dX][dY].m_cOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iChatMsg;
					_tmp_iEffectType = m_pMapData->m_pData[dX][dY].m_iEffectType;
					_tmp_iEffectFrame = m_pMapData->m_pData[dX][dY].m_iEffectFrame;
					_tmp_bSpriteOmit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cOwnerName);
					bRet = true;

					if (m_iIlusionOwnerH != 0)
					{
						if ((strcmp(_tmp_cName, m_cPlayerName) != 0) && (_tmp_sOwnerType < 10))
						{
							_tmp_sOwnerType = m_cIlusionOwnerType;
							_tmp_iStatus = m_iStatus_IE;
							_tmp_sAppr1 = m_sAppr1_IE;
							_tmp_sAppr2 = m_sAppr2_IE;
							_tmp_sAppr3 = m_sAppr3_IE;
							_tmp_sAppr4 = m_sAppr4_IE;
							_tmp_iApprColor = m_iApprColor_IE;
						}
					}
				}

				if ((bRet == true) && (strlen(_tmp_cName) > 0))
				{
					_tmp_dx = 0;
					_tmp_dy = 0;
					switch (_tmp_cAction) {
					case DEF_OBJECTSTOP:
						bContact = DrawObject_OnStop(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTMOVE:
						bContact = DrawObject_OnMove(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTDAMAGEMOVE:
						bContact = DrawObject_OnDamageMove(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTRUN:
						bContact = DrawObject_OnRun(indexX, indexY, ix, iy, false, dwTime, msX, msY, _tmp_bSpriteOmit);
						break;

					case DEF_OBJECTATTACK:
						bContact = DrawObject_OnAttack(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACKMOVE:
						bContact = DrawObject_OnAttackMove(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTMAGIC:
						bContact = DrawObject_OnMagic(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTGETITEM:
						bContact = DrawObject_OnGetItem(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGE:
						bContact = DrawObject_OnDamage(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;

					case DEF_OBJECTDYING:
						bContact = DrawObject_OnDying(indexX, indexY, ix, iy, false, dwTime, msX, msY);
						break;
					}

					if ((bContact == true) && (msY <= res_msy))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusX = ix;
						sFocusY = iy;
						wFocusObjectID = _tmp_wObjectID;
						sFocusOwnerType = _tmp_sOwnerType;
						cFocusAction = _tmp_cAction;
						cFocusFrame = _tmp_cFrame;
						cFocusDir = _tmp_cDir;
						sFocusAppr1 = _tmp_sAppr1;
						sFocusAppr2 = _tmp_sAppr2;
						sFocusAppr3 = _tmp_sAppr3;
						sFocusAppr4 = _tmp_sAppr4;
						iFocusApprColor = _tmp_iApprColor; // v1.4
						iFocuiStatus = _tmp_iStatus;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						strcpy(cFocusName, _tmp_cName);
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
						strcpy(m_cMCName, _tmp_cName);
						sFocus_dX = _tmp_dX; // v2.171
						sFocus_dY = _tmp_dY; // v2.171
						bContact = false;
						frame_omit = m_pMapData->m_pData[dX][dY].m_bSpriteOmit;
					}

					if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
					{
						if (m_bIsObserverMode == false)
						{
							m_sViewDstX = (indexX - VIEW_CENTER_TILE_X) * 32;
							m_sViewDstY = (indexY - (VIEW_CENTER_TILE_Y + 1)) * 32;
						}
						SetRect(&m_rcPlayerRect, m_rcBodyRect.left, m_rcBodyRect.top, m_rcBodyRect.right, m_rcBodyRect.bottom);
						bIsPlayerDrawed = true;
					}
				}
			}

			// CLEROTH
			sObjSpr = m_pMapData->m_tile[indexX][indexY].m_sObjectSprite;
			sObjSprFrame = m_pMapData->m_tile[indexX][indexY].m_sObjectSpriteFrame;

			if (sObjSpr != 0)
			{
				if ((sObjSpr < 100) || (sObjSpr >= 200))
				{
					switch (sObjSpr) {
					case 200:
					case 223:
						m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
						break;

					case 224:
						switch (sObjSprFrame) {
						case 24:
						case 34:
						case 35:
						case 36:
						case 37:
						case 38:
							break;
						default:
							m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
							break;
						}
					}
					if (m_cDetailLevel == 0) // Special Grass & Flowers
					{
						if ((sObjSpr != 6) && (sObjSpr != 9))
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}
					else
					{
						m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}

					switch (sObjSpr) {
					case 223:
						if (sObjSprFrame == 4)
						{
							if (G_cSpriteAlphaDegree == 2) //nuit
							{
								int iDvalue1 = -1 * (rand() % 5);
								int iDvalue2 = -1 * (rand() % 5);
								int iDvalue3 = -1 * (rand() % 5);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix + 2 - 17, iy - 147 - 15, 1, iDvalue1, iDvalue1, iDvalue1, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix + 16 - 17, iy - 96 - 15, 1, iDvalue2, iDvalue2, iDvalue2, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix - 19 - 17, iy - 126 - 15, 1, iDvalue3, iDvalue3, iDvalue3, dwTime);
							}
						}
						break;

					case 370: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix - 16 + 30, m_sViewPointY + iy - 16 - 334, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix - 16 + 17, m_sViewPointY + iy - 16 - 300, 0, 0, 0, 0);
						break;

					case 374: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix - 7, m_sViewPointY + iy - 122, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 6) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix - 14, m_sViewPointY + iy - 321, 0, 0, 0, 0);
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 7) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix + 7, m_sViewPointY + iy - 356, 0, 0, 0, 0);
						break;

					case 376: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 12) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix - 16, m_sViewPointY + iy - 346, 0, 0, 0, 0);
							bAddNewEffect(65, m_sViewPointX + ix + 11, m_sViewPointY + iy - 308, 0, 0, 0, 0);
						}
						break;

					case 378: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix, m_sViewPointY + iy - 91, 0, 0, 0, 0);
						break;

					case 382: // nuit
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix + 73, m_sViewPointY + iy - 264, 0, 0, 0, 0);
							bAddNewEffect(65, m_sViewPointX + ix + 23, m_sViewPointY + iy - 228, 0, 0, 0, 0);
						}
						break;

					case 429:
						if (((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2)) bAddNewEffect(65, m_sViewPointX + ix - 15, m_sViewPointY + iy - 224, 0, 0, 0, 0);
						break;
					}
				}
				else // sprites 100..199: Trees and tree shadows
				{
					m_pTileSpr[sObjSpr]->_GetSpriteRect(ix - 16, iy - 16, sObjSprFrame);
					if (m_cDetailLevel == 0)
					{
						if (sObjSpr < 100 + 11) m_pTileSpr[100 + 4]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if (sObjSpr < 100 + 23) m_pTileSpr[100 + 9]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if (sObjSpr < 100 + 32) m_pTileSpr[100 + 23]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else m_pTileSpr[100 + 32]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}
					else
					{
						if ((bIsPlayerDrawed == true) && (m_pTileSpr[sObjSpr]->m_rcBound.top <= m_rcPlayerRect.top) && (m_pTileSpr[sObjSpr]->m_rcBound.bottom >= m_rcPlayerRect.bottom) &&
							(m_cDetailLevel >= 2) && (m_pTileSpr[sObjSpr]->m_rcBound.left <= m_rcPlayerRect.left) && (m_pTileSpr[sObjSpr]->m_rcBound.right >= m_rcPlayerRect.right))
						{
							m_pTileSpr[sObjSpr + 50]->PutFadeSprite(ix, iy, sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutTransSprite2(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}
						else
						{
							m_pTileSpr[sObjSpr + 50]->PutSpriteFast(ix, iy, sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}
						if (m_bIsXmas == true)
						{
							if (G_cSpriteAlphaDegree == 2) // nuit
							{
								if (iXmasTreeBulbDelay < 0 || iXmasTreeBulbDelay > idelay + 1) iXmasTreeBulbDelay = 0;
								if (iXmasTreeBulbDelay > idelay)
								{
									for (int i = 0; i < 100; i++) {
										ix1[i] = 1 * (rand() % 400) - 200;
										iy2[i] = -1 * (rand() % 300);
									}
									iXmasTreeBulbDelay = 0;
								}
								else iXmasTreeBulbDelay++;

								for (int j = 0; j < 100; j++)
								{
									if (m_pTileSpr[sObjSpr]->_bCheckCollison(ix - 16, iy - 16, sObjSprFrame, ix + ix1[j], iy + iy2[j]))
									{
										m_pEffectSpr[66 + (j % 6)]->PutTransSprite(ix + ix1[j], iy + iy2[j], (iXmasTreeBulbDelay >> 2), dwTime);
									}
								}
							}
						}
					}
				}
			}

			// Dynamic Object
			if ((bRet == true) && (sDynamicObject != 0))
			{
				switch (sDynamicObject) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:	// 10
					if (sDynamicObjectFrame >= 0)
						m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_LOOP:		// 11
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame + 8, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_END:		// 12
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix + (rand() % 2), iy + (rand() % 2), sDynamicObjectFrame + 16, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:		// 8
					iDvalue = (rand() % 5) * (-1);
					m_pEffectSpr[0]->PutTransSpriteRGB(ix, iy, 1, iDvalue, iDvalue, iDvalue, dwTime);
					m_pEffectSpr[13]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_FIRE:			// 1
				case DEF_DYNAMICOBJECT_FIRE3:			// 14
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					m_pEffectSpr[9]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame / 3, dwTime);
					break;

				case DEF_DYNAMICOBJECT_FIRE2:			// 13
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					break;

				case DEF_DYNAMICOBJECT_FISH:			// 2
				{
					char cTmpDOdir, cTmpDOframe;
					cTmpDOdir = CMisc::cCalcDirection(cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData1 + cDynamicObjectData3, cDynamicObjectData2 + cDynamicObjectData4);
					cTmpDOframe = ((cTmpDOdir - 1) * 4) + (rand() % 4);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 0]->PutTransSprite2(ix + cDynamicObjectData1, iy + cDynamicObjectData2, cTmpDOframe, dwTime);
				}
				break;

				case DEF_DYNAMICOBJECT_MINERAL1:		// 4
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->PutShadowSprite(ix, iy, 0, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->PutSpriteFast(ix, iy, 0, dwTime);
					if ((m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top != -1)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top < msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.bottom > msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.left < msX)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.right > msX))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = 0;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL2:		// 5
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->PutShadowSprite(ix, iy, 1, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->PutSpriteFast(ix, iy, 1, dwTime);
					if ((m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top != -1)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.top < msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.bottom > msY)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.left < msX)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 1]->m_rcBound.right > msX))
					{
						m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = 0;
						std::memset(cFocusName, 0, sizeof(cFocusName));
						std::memset(m_cMCName, 0, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_SPIKE:			// 9
					m_pEffectSpr[17]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ARESDENFLAG1:  // 6
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 2]->PutSpriteFast(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ELVINEFLAG1: // 7
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT + 2]->PutSpriteFast(ix, iy, sDynamicObjectFrame, dwTime);
					break;
				}
			}
			indexX++;
		}
		indexY++;
	}

	if ((dwTime - m_dwEnvEffectTime) > 400) m_dwEnvEffectTime = dwTime;

	if (m_sMCX != 0)	// CLEROTH - STATUS
	{
		if (_iGetFOE(iFocuiStatus) < 0) m_stMCursor.sCursorFrame = 3;
		else m_stMCursor.sCursorFrame = 6;

		_tmp_wObjectID = wFocusObjectID;
		_tmp_sOwnerType = sFocusOwnerType;
		_tmp_cAction = cFocusAction;
		_tmp_cFrame = cFocusFrame;
		_tmp_cDir = cFocusDir;
		_tmp_sAppr1 = sFocusAppr1;
		_tmp_sAppr2 = sFocusAppr2;
		_tmp_sAppr3 = sFocusAppr3;
		_tmp_sAppr4 = sFocusAppr4;
		_tmp_iApprColor = iFocusApprColor; // v1.4
		_tmp_iStatus = iFocuiStatus;
		strcpy(_tmp_cName, cFocusName);
		_tmp_dX = sFocus_dX; // v2.171
		_tmp_dY = sFocus_dY; // v2.171

		if ((_tmp_cAction != DEF_OBJECTDEAD) && (_tmp_cFrame < 0)) return;
		switch (_tmp_cAction) {
		case DEF_OBJECTSTOP:
			DrawObject_OnStop(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;
		case DEF_OBJECTMOVE:
			switch (_tmp_sOwnerType) {
			case 1:
			case 2:
			case 3: // Human M
			case 4:
			case 5:
			case 6: // Human F

			case 28: // Troll.
			case 29: // Ogre
			case 30: // Liche
			case 31: // DD
			case 32: // Uni
			case 33: // WW
			case 43: // LWB
			case 44: // GHK
			case 45: // GHKABS
			case 46: // TK
			case 47: // BG
			case 48: // SK
			case 49: // HC
			case 50: // TW
			case 51: // CP
			case 52: // GG
			case 53: // BB
			case 54: // DE
			case 55: // Rabbit
			case 56: // Cat
			case 57: // Frog
			case 58: // MG
			case 59: // Ettin
			case 60: // Plant
			case 61: // Rudolph
			case 62: // DireBoar
			case 63: // Frost
			case 65: // Ice-Golem
			case 66: // Wyvern
			case 70: // Dragon..........Ajouts par Snoopy
			case 71: // Centaur
			case 72: // ClawTurtle
			case 73: // FireWyvern
			case 74: // GiantCrayfish
			case 75: // Gi Lizard
			case 76: // Gi Tree
			case 77: // Master Orc
			case 78: // Minaus
			case 79: // Nizie
			case 80: // Tentocle
			case 81: // Abaddon
			case 82: // Sorceress
			case 83: // ATK
			case 84: // MasterElf
			case 85: // DSK
			case 86: // HBT
			case 87: // CT
			case 88: // Barbarian
			case 89: // AGC
			case 91: // Gate

				/*	case 15: // ShopKeeper // Ils ont 8 sprites Stop
					case 19: // Gandalf
					case 20: // Howard
					case 24: // Tom
					case 25: // William
					case 26: // Kenedy
					case 90: // Gail*/
				break;

			default: // 10..27
				_tmp_cFrame = _tmp_cFrame * 2; //
				break;
			}

			DrawObject_OnMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTDAMAGEMOVE:
			DrawObject_OnDamageMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTRUN:
			DrawObject_OnRun(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY, frame_omit);
			break;

		case DEF_OBJECTATTACK:
			DrawObject_OnAttack(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTATTACKMOVE:
			DrawObject_OnAttackMove(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTMAGIC:
			DrawObject_OnMagic(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDAMAGE:
			DrawObject_OnDamage(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDYING: //10
			DrawObject_OnDying(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;

		case DEF_OBJECTDEAD: //101
			DrawObject_OnDead(m_sMCX, m_sMCY, sFocusX, sFocusY, true, dwTime, msX, msY);
			break;
		}
	}

	if (sItemSelectedID != -1) {
		char cStr1[64], cStr2[64], cStr3[64];
		int  iLoc;
		GetItemName(m_pItemConfigList[sItemSelectedID]->m_cName, dwItemSelectedAttr, cStr1, cStr2, cStr3);

		iLoc = 0;
		if (strlen(cStr1) != 0)
		{
			if (m_bIsSpecial)
				PutString(msX, msY + 25, cStr1, RGB(0, 255, 50), false, 1);
			else
				PutString(msX, msY + 25, cStr1, RGB(255, 255, 255), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr2) != 0)
		{
			PutString(msX, msY + 25 + iLoc, cStr2, RGB(150, 150, 150), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr3) != 0)
		{
			PutString(msX, msY + 25 + iLoc, cStr3, RGB(150, 150, 150), false, 1);
			iLoc += 15;
		}
	}

	if (m_bIsGetPointingMode == true)
	{
		if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200)) // spell
		{
			if (m_bCommandAvailable == true)
			{
				if (m_sMCX != 0)
				{
					if (_iGetFOE(iFocuiStatus) < 0)
						m_stMCursor.sCursorFrame = 5;   // Red enemi for spell
					else m_stMCursor.sCursorFrame = 4;  // Blue friend for spell
				}
				else m_stMCursor.sCursorFrame = 4;     // Blue friend for spell
			}
			else m_stMCursor.sCursorFrame = 8;
		}
		else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50)) // item
		{
			m_stMCursor.sCursorFrame = 10;				// hand to grap item
		}
	}
}

bool CGame::_bDecodeItemConfigFileContents(char* pData, uint32_t dwMsgSize)
{
	char* pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemConfigListIndex, iTemp;

	pContents = new char[dwMsgSize + 1];
	std::memset(pContents, 0, dwMsgSize + 1);
	memcpy(pContents, pData, dwMsgSize);

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete[] pContents;
						return false;
					}
					iItemConfigListIndex = atoi(token);

					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);

					if (m_pItemConfigList[iItemConfigListIndex] != 0) {
						//wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						//PutLogList(cTxt);
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					std::memset(m_pItemConfigList[iItemConfigListIndex]->m_cName, 0, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete[] pContents;
						return false;
					}
					iTemp = atoi(token);
					if (iTemp < 0)
						m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = false;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = true;

					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == false) {
						//PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = strtok(NULL, seps);
	}

DICFC_STOPDECODING:;

	delete[] pContents;

	return true;
}

void CGame::GameRecvMsgHandler(uint32_t dwMsgSize, char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_id) {
	case MSGID_ITEMCONFIGURATIONCONTENTS:
		_bDecodeItemConfigFileContents(reinterpret_cast<char*>(pData + sizeof(hb::net::PacketHeader)), dwMsgSize);
		break;
	case MSGID_RESPONSE_CHARGED_TELEPORT:
		ResponseChargedTeleport(pData);
		break;

	case MSGID_RESPONSE_TELEPORT_LIST:
		ResponseTeleportList(pData);
		break;

	case MSGID_RESPONSE_HELDENIAN_TP_LIST: // Snoopy Heldenian TP
		ResponseHeldenianTeleportList(pData);
		break;

	case MSGID_RESPONSE_NOTICEMENT:
		NoticementHandler(pData);
		break;

	case MSGID_DYNAMICOBJECT:
		DynamicObjectHandler(pData);
		break;

	case MSGID_RESPONSE_INITPLAYER:
		InitPlayerResponseHandler(pData);
		break;

	case MSGID_RESPONSE_INITDATA:
		InitDataResponseHandler(pData);
		break;

	case MSGID_RESPONSE_MOTION:
		MotionResponseHandler(pData);
		break;

	case MSGID_EVENT_COMMON:
		CommonEventHandler(pData);
		break;

	case MSGID_EVENT_MOTION:
		MotionEventHandler(pData);
		break;

	case MSGID_EVENT_LOG:
		LogEventHandler(pData);
		break;

	case MSGID_COMMAND_CHATMSG:
		ChatMsgHandler(pData);
		break;

	case MSGID_PLAYERITEMLISTCONTENTS:
		InitItemList(pData);
		break;

	case MSGID_NOTIFY:
		NotifyMsgHandler(pData);
		break;

	case MSGID_RESPONSE_CREATENEWGUILD:
		CreateNewGuildResponseHandler(pData);
		break;

	case MSGID_RESPONSE_DISBANDGUILD:
		DisbandGuildResponseHandler(pData);
		break;

	case MSGID_PLAYERCHARACTERCONTENTS:
		InitPlayerCharacteristics(pData);
		break;

	case MSGID_RESPONSE_CIVILRIGHT:
		CivilRightAdmissionHandler(pData);
		break;

	case MSGID_RESPONSE_RETRIEVEITEM:
		RetrieveItemHandler(pData);
		break;

	case MSGID_RESPONSE_PANNING:
		ResponsePanningHandler(pData);
		break;

	case MSGID_RESPONSE_FIGHTZONE_RESERVE:
		ReserveFightzoneResponseHandler(pData);
		break;
	}
}


void CGame::ConnectionEstablishHandler(char cWhere)
{
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGRESPONSE);

	switch (cWhere) {
	case DEF_SERVERTYPE_GAME:
		bSendCommand(MSGID_REQUEST_INITPLAYER, 0, 0, 0, 0, 0, 0);
		break;

	case DEF_SERVERTYPE_LOG:
		switch (m_dwConnectMode) {
		case MSGID_REQUEST_LOGIN:
			bSendCommand(MSGID_REQUEST_LOGIN, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CREATENEWACCOUNT:
			bSendCommand(MSGID_REQUEST_CREATENEWACCOUNT, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CREATENEWCHARACTER:
			bSendCommand(MSGID_REQUEST_CREATENEWCHARACTER, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_ENTERGAME:
			bSendCommand(MSGID_REQUEST_ENTERGAME, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_DELETECHARACTER:
			bSendCommand(MSGID_REQUEST_DELETECHARACTER, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_CHANGEPASSWORD:
			bSendCommand(MSGID_REQUEST_CHANGEPASSWORD, 0, 0, 0, 0, 0, 0);
			break;
		case MSGID_REQUEST_INPUTKEYCODE:
			bSendCommand(MSGID_REQUEST_INPUTKEYCODE, 0, 0, 0, 0, 0, 0);
			break;
		}
		break;
	}
}

void CGame::InitPlayerResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		bSendCommand(MSGID_REQUEST_INITDATA, 0, 0, 0, 0, 0, 0);
		ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
		break;

	case DEF_MSGTYPE_REJECT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3J");
		break;
	}
}


void CGame::MakeSprite(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pSprite[i + sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeTileSpr(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pTileSpr[i + sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeEffectSpr(char* FileName, short sStart, short sCount, bool bAlphaEffect)
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf(PathName, "sprites\\%s.pak", FileName);
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (m_hPakFile == INVALID_HANDLE_VALUE) return;
	SetFilePointer(m_hPakFile, 20, 0, FILE_BEGIN);
	ReadFile(m_hPakFile, (char*)&iTotalimage, 4, &nCount, 0);
	for (short i = 0; i < sCount; i++)
	{
		if (i < iTotalimage) m_pEffectSpr[i + sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::UpdateScreen_OnLoading(bool bActive)
{
	int i;
	if (bActive) UpdateScreen_OnLoading_Progress();

	switch (m_cLoading) {
	case 0:
	{
		m_hPakFile = CreateFile("sprites\\interface.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_MOUSECURSOR] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 1, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\Newmaps.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 2, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 3, false);
			m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 4, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\LoginDialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 0, false);
#ifdef DEF_MAKE_ACCOUNT
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_AGREEMENT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 2, false);
#endif
			CloseHandle(m_hPakFile);
		}
#ifdef DEF_MAKE_ACCOUNT			// CLEROTH - ACC - Snoopy: fixed to use without special pak
		m_hPakFile = CreateFile("sprites\\CreateNewAcc.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "CreateNewAcc", 0, false);
			CloseHandle(m_hPakFile);
		}
		else
		{
			m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 2, false);
			CloseHandle(m_hPakFile);
		}
#endif
		m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 2, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\GameDialog.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME1] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 1, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME3] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 2, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 3, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 4, false);
			//m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 5, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 6, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 7, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_SELECTCHAR] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 8, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWCHAR] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 9, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_NEWEXCHANGE] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 10, false);
			CloseHandle(m_hPakFile);
		}

		//m_hPakFile = CreateFile("sprites\\GameDialog2.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		//if (m_hPakFile != INVALID_HANDLE_VALUE) {
		//	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL2] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog2", 6, false);
		//	CloseHandle(m_hPakFile);
		//}

		m_hPakFile = CreateFile("sprites\\PartySprite.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS] = new class CSprite(m_hPakFile, &m_DDraw, "PartySprite", 0, false);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\DialogText.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_TEXT] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 0, false);
			m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 1, false);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Telescope", DEF_SPRID_INTERFACE_GUIDEMAP, 32, false);	  // Snoopy: 20->32
		MakeSprite("Telescope2", DEF_SPRID_INTERFACE_GUIDEMAP + 35, 4, false); // Snoopy: Ajout.351 (heldenian maps)
		MakeSprite("monster", DEF_SPRID_INTERFACE_MONSTER, 1, false);
		m_cLoading = 4;
	}
	break;
	case 4:
	{
		MakeTileSpr("maptiles1", 0, 32, true);
		m_hPakFile = CreateFile("sprites\\structures1.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); //�Ⱦ��� Ÿ�� �ε� ���Ѵ�.2002.09.06����
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pTileSpr[1 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1", 1, true);
			m_pTileSpr[5 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1", 5, true);
			CloseHandle(m_hPakFile);
		}
		MakeTileSpr("Sinside1", 70, 27, false);
		MakeTileSpr("Trees1", 100, 46, true);
		MakeTileSpr("TreeShadows", 150, 46, true);
		MakeTileSpr("objects1", 200, 10, true); // snoopy: 8->10
		MakeTileSpr("objects2", 211, 5, true);
		MakeTileSpr("objects3", 216, 4, true);
		MakeTileSpr("objects4", 220, 2, true); //snoopy: 1->2
		m_cLoading = 8;
	}
	break;
	case 8:
	{
		MakeTileSpr("Tile223-225", 223, 3, true);
		MakeTileSpr("Tile226-229", 226, 4, true);
		MakeTileSpr("objects5", 230, 9, true);	// Snoopy
		MakeTileSpr("objects6", 238, 4, true);	// Snoopy
		MakeTileSpr("objects7", 242, 7, true);	// Snoopy
		MakeTileSpr("maptiles2", 300, 15, true);//- Index 300
		MakeTileSpr("maptiles4", 320, 10, true);
		MakeTileSpr("maptiles5", 330, 19, true);
		MakeTileSpr("maptiles6", 349, 4, true);
		MakeTileSpr("maptiles353-361", 353, 9, true);
		MakeTileSpr("Tile363-366", 363, 4, true);
		MakeTileSpr("Tile367-367", 367, 1, true); // Add by Snoopy (fountains)
		MakeTileSpr("Tile370-381", 370, 12, true);// Tile370~381
		MakeTileSpr("Tile382-387", 382, 6, true);
		MakeTileSpr("Tile388-402", 388, 15, true);
		m_cLoading = 12;
	}
	break;
	case 12:
	{
		MakeTileSpr("Tile403-405", 403, 3, true);
		MakeTileSpr("Tile406-421", 406, 16, true);
		MakeTileSpr("Tile422-429", 422, 8, true);
		MakeTileSpr("Tile430-443", 430, 14, true);
		MakeTileSpr("Tile444-444", 444, 1, true);
		MakeTileSpr("Tile445-461", 445, 17, true);
		MakeTileSpr("Tile462-473", 462, 12, true);	// Diuuude
		MakeTileSpr("Tile474-478", 474, 5, true);	// Diuuude
		MakeTileSpr("Tile479-488", 479, 10, true);	// Diuuude
		MakeTileSpr("Tile489-522", 489, 34, true);	// Diuuude Drunken City
		MakeTileSpr("Tile523-530", 523, 8, true);	// Diuuude Rampart
		MakeTileSpr("Tile531-540", 531, 10, true);	// Diuuude GodH + Pont
		MakeTileSpr("Tile541-545", 541, 5, true);	// Diuuude GodH

		// DEF_SPRID_ITEMPACK_PIVOTPOINT+0
		MakeSprite("item-pack", DEF_SPRID_ITEMPACK_PIVOTPOINT + 1, 27, false);
		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 17, false); //
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 18, false); //
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19, false); // Angels
			CloseHandle(m_hPakFile);
		}

		// DEF_SPRID_ITEMGROUND_PIVOTPOINT+1
		MakeSprite("item-ground", DEF_SPRID_ITEMGROUND_PIVOTPOINT + 1, 19, false);
		m_hPakFile = CreateFile("sprites\\item-ground.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 17, false);
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 18, false);
			m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 19, false);//Angels
			CloseHandle(m_hPakFile);
		}
		MakeSprite("item-dynamic", DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT, 3, false);// Snoopy 2-> 3 (flags)
		m_cLoading = 16;
	}
	break;
	case 16:
	{
		m_hPakFile = CreateFile("sprites\\item-equipM.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 0, false);	// body
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 1] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 1, false);	// 1-swords
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 2] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 2, false);	// 2-bows
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 3] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 3, false);	// 3-shields
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 4] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 4, false);	// 4-tunics
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 5] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 5, false);	// 5-shoes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 7] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 6, false);	// 6-berk
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 8] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 7, false);	// 7-hoses
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 9] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 8, false);	// 8-bodyarmor
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 15] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 11, false); // Axe hammer
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 17] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 12, false); // Wands
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 9, false);  // hair
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 10, false); // undies
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 13, false); // capes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 14, false); // helm
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 16] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15); // Necks
			//Snoopy: Angels pandents
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19); // Angels
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-equipW.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 0, false); // body
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 41] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 1, false); // 1-swords
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 42] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 2, false); // 2-bows
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 43] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 3, false); // 3-shields
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 45] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 4, false); // 4-shoes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 50] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 5, false); // 5-Soustif
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 51] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 6, false); // 6 berk
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 52] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 7, false); // 7 hose
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 53] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 8, false); // 8-hoses
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 55] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 11, false); // Axe hammer
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 57] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 12, false); // Wands
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 58] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 9, false); // hair
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 59] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 10, false);// undies
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 60] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 13, false);// capes
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 61] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 14, false);// helm
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 56] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15);// necks
			//Snoopy: Angels pandents
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 62] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19); // Angels
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Bm", 500 + 15 * 8 * 0, 96, true);// Black Man (Type: 1)
		MakeSprite("Wm", 500 + 15 * 8 * 1, 96, true);// White Man (Type: 2)
		MakeSprite("Ym", 500 + 15 * 8 * 2, 96, true);// Yellow Man (Type: 3)
		m_cLoading = 20;
	}
	break;
	case 20:
	{
		MakeSprite("TutelarAngel1", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 0, 48, false);//(STR)
		MakeSprite("TutelarAngel2", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 1, 48, false);//(DEX)
		MakeSprite("TutelarAngel3", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 2, 48, false);//(INT)
		MakeSprite("TutelarAngel4", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50 * 3, 48, false);//(MAG)
		MakeSprite("Bw", 500 + 15 * 8 * 3, 96, true);// Black Woman (Type: 4)
		MakeSprite("Ww", 500 + 15 * 8 * 4, 96, true);// White Woman (Type: 5)
		MakeSprite("Yw", 500 + 15 * 8 * 5, 96, true);// Yellow Woman (Type: 6)
		m_cLoading = 24;
	}
	break;
	case 24:
	{
		MakeSprite("slm", DEF_SPRID_MOB + 7 * 8 * 0, 40, true);// Slime (Type: 10)
		MakeSprite("ske", DEF_SPRID_MOB + 7 * 8 * 1, 40, true);// Skeleton (Type: 11)
		MakeSprite("Gol", DEF_SPRID_MOB + 7 * 8 * 2, 40, true);// Stone-Golem (Type: 12)
		MakeSprite("Cyc", DEF_SPRID_MOB + 7 * 8 * 3, 40, true);// Cyclops (Type: 13)
		MakeSprite("Orc", DEF_SPRID_MOB + 7 * 8 * 4, 40, true);// Orc (Type: 14)
		MakeSprite("Shopkpr", DEF_SPRID_MOB + 7 * 8 * 5, 8);		// ShopKeeper-Woman (Type: 15)
		MakeSprite("Ant", DEF_SPRID_MOB + 7 * 8 * 6, 40, true);//  Giant-Ant (Type: 16)
		MakeSprite("Scp", DEF_SPRID_MOB + 7 * 8 * 7, 40, true);//  Scorpion (Type: 17)
		MakeSprite("Zom", DEF_SPRID_MOB + 7 * 8 * 8, 40, true);//  Zombie (Type: 18)
		MakeSprite("Gandlf", DEF_SPRID_MOB + 7 * 8 * 9, 8, true);// Gandalf � (Type: 19)
		MakeSprite("Howard", DEF_SPRID_MOB + 7 * 8 * 10, 8, true);// Howard ������ ���� (Type: 20)
		MakeSprite("Guard", DEF_SPRID_MOB + 7 * 8 * 11, 40, true);// Guard (Type: 21)
		MakeSprite("Amp", DEF_SPRID_MOB + 7 * 8 * 12, 40, true);// Amphis (Type: 22)
		MakeSprite("Cla", DEF_SPRID_MOB + 7 * 8 * 13, 40, true);// Clay-Golem (Type: 23)
		MakeSprite("tom", DEF_SPRID_MOB + 7 * 8 * 14, 8, true);// Tom (Type: 24)
		MakeSprite("William", DEF_SPRID_MOB + 7 * 8 * 15, 8, true);// William (Type: 25)
		m_cLoading = 28;
	}
	break;
	case 28:
	{
		MakeSprite("Kennedy", DEF_SPRID_MOB + 7 * 8 * 16, 8, true);// Kennedy (Type: 26)
		MakeSprite("Helb", DEF_SPRID_MOB + 7 * 8 * 17, 40, true);// Hellbound (Type: 27)
		MakeSprite("Troll", DEF_SPRID_MOB + 7 * 8 * 18, 40, true);// Troll (Type: 28)
		MakeSprite("Orge", DEF_SPRID_MOB + 7 * 8 * 19, 40, true);// Orge (Type: 29)
		MakeSprite("Liche", DEF_SPRID_MOB + 7 * 8 * 20, 40, true);// Liche (Type: 30)
		MakeSprite("Demon", DEF_SPRID_MOB + 7 * 8 * 21, 40, true);// Demon (Type: 31)
		MakeSprite("Unicorn", DEF_SPRID_MOB + 7 * 8 * 22, 40, true);// Unicorn (Type: 32)
		MakeSprite("WereWolf", DEF_SPRID_MOB + 7 * 8 * 23, 40, true);// WereWolf (Type: 33)
		MakeSprite("Dummy", DEF_SPRID_MOB + 7 * 8 * 24, 40, true);// Dummy (Type: 34)
		m_hPakFile = CreateFile("sprites\\Effect5.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); // Energy-Ball (Type: 35)
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 40; i++)
				m_pSprite[DEF_SPRID_MOB + i + 7 * 8 * 25] = new class CSprite(m_hPakFile, &m_DDraw, "Effect5", 0, true);

			CloseHandle(m_hPakFile);
		}
		m_cLoading = 32;
	}
	break;
	case 32:
	{
		MakeSprite("GT-Arrow", DEF_SPRID_MOB + 7 * 8 * 26, 40, true);// Arrow-GuardTower (Type: 36)
		MakeSprite("GT-Cannon", DEF_SPRID_MOB + 7 * 8 * 27, 40, true);// Cannon-GuardTower (Type: 37)
		MakeSprite("ManaCollector", DEF_SPRID_MOB + 7 * 8 * 28, 40, true);// Mana Collector (Type: 38)
		MakeSprite("Detector", DEF_SPRID_MOB + 7 * 8 * 29, 40, true);// Detector (Type: 39)
		MakeSprite("ESG", DEF_SPRID_MOB + 7 * 8 * 30, 40, true);// ESG (Type: 40)
		MakeSprite("GMG", DEF_SPRID_MOB + 7 * 8 * 31, 40, true);// GMG (Type: 41)
		MakeSprite("ManaStone", DEF_SPRID_MOB + 7 * 8 * 32, 40, true);// ManaStone (Type: 42)
		MakeSprite("LWB", DEF_SPRID_MOB + 7 * 8 * 33, 40, true);// Light War Beetle (Type: 43)
		MakeSprite("GHK", DEF_SPRID_MOB + 7 * 8 * 34, 40, true);// God's Hand Knight (Type: 44)
		MakeSprite("GHKABS", DEF_SPRID_MOB + 7 * 8 * 35, 40, true);// God's Hand Knight with Armored Battle Steed (Type: 45)
		MakeSprite("TK", DEF_SPRID_MOB + 7 * 8 * 36, 40, true);// Temple Knight (Type: 46)
		MakeSprite("BG", DEF_SPRID_MOB + 7 * 8 * 37, 40, true);// Battle Golem (Type: 47)
		m_cLoading = 36;
	}
	break;
	case 36:
	{
		MakeSprite("Stalker", DEF_SPRID_MOB + 7 * 8 * 38, 40, true);// Stalker (Type: 48)
		MakeSprite("Hellclaw", DEF_SPRID_MOB + 7 * 8 * 39, 40, true);// Hellclaw (Type: 49)
		MakeSprite("Tigerworm", DEF_SPRID_MOB + 7 * 8 * 40, 40, true);// Tigerworm (Type: 50)
		MakeSprite("Catapult", DEF_SPRID_MOB + 7 * 8 * 41, 40, true);// Catapult (Type: 51)
		MakeSprite("Gagoyle", DEF_SPRID_MOB + 7 * 8 * 42, 40, true);// Gargoyle (Type: 52)
		MakeSprite("Beholder", DEF_SPRID_MOB + 7 * 8 * 43, 40, true);// Beholder (Type: 53)
		MakeSprite("DarkElf", DEF_SPRID_MOB + 7 * 8 * 44, 40, true);// Dark-Elf (Type: 54)
		MakeSprite("Bunny", DEF_SPRID_MOB + 7 * 8 * 45, 40, true);// Bunny (Type: 55)
		MakeSprite("Cat", DEF_SPRID_MOB + 7 * 8 * 46, 40, true);// Cat (Type: 56)
		MakeSprite("GiantFrog", DEF_SPRID_MOB + 7 * 8 * 47, 40, true);// GiantFrog (Type: 57)
		MakeSprite("MTGiant", DEF_SPRID_MOB + 7 * 8 * 48, 40, true);// Mountain Giant (Type: 58)
		m_cLoading = 40;
	}
	break;
	case 40:
	{
		MakeSprite("Ettin", DEF_SPRID_MOB + 7 * 8 * 49, 40, true);// Ettin (Type: 59)
		MakeSprite("CanPlant", DEF_SPRID_MOB + 7 * 8 * 50, 40, true);// Cannibal Plant (Type: 60)
		MakeSprite("Rudolph", DEF_SPRID_MOB + 7 * 8 * 51, 40, true);// Rudolph (Type: 61)
		MakeSprite("DireBoar", DEF_SPRID_MOB + 7 * 8 * 52, 40, true);// Boar (Type: 62)
		MakeSprite("frost", DEF_SPRID_MOB + 7 * 8 * 53, 40, true);// Frost (Type: 63)
		MakeSprite("Crop", DEF_SPRID_MOB + 7 * 8 * 54, 40, true);// Crop(Type: 64)
		MakeSprite("IceGolem", DEF_SPRID_MOB + 7 * 8 * 55, 40, true);// IceGolem (Type: 65)
		MakeSprite("Wyvern", DEF_SPRID_MOB + 7 * 8 * 56, 24, true);// Wyvern (Type: 66)
		MakeSprite("McGaffin", DEF_SPRID_MOB + 7 * 8 * 57, 16, true);// McGaffin (Type: 67)
		MakeSprite("Perry", DEF_SPRID_MOB + 7 * 8 * 58, 16, true);// Perry (Type: 68)
		MakeSprite("Devlin", DEF_SPRID_MOB + 7 * 8 * 59, 16, true);// Devlin (Type: 69)
		MakeSprite("Barlog", DEF_SPRID_MOB + 7 * 8 * 60, 40, true);// Barlog (Type: 70)
		MakeSprite("Centaurus", DEF_SPRID_MOB + 7 * 8 * 61, 40, true);// Centaurus (Type: 71)
		MakeSprite("ClawTurtle", DEF_SPRID_MOB + 7 * 8 * 62, 40, true);// Claw-Turtle (Type: 72)
		MakeSprite("FireWyvern", DEF_SPRID_MOB + 7 * 8 * 63, 24, true);// Fire-Wyvern (Type: 73)
		MakeSprite("GiantCrayfish", DEF_SPRID_MOB + 7 * 8 * 64, 40, true);// Giant-Crayfish (Type: 74)
		MakeSprite("GiantLizard", DEF_SPRID_MOB + 7 * 8 * 65, 40, true);// Giant-Lizard (Type: 75)
		m_cLoading = 44;
	}
	break;
	case 44:
	{	// New NPCs - Diuuude - fixed by Snoopy
		MakeSprite("GiantPlant", DEF_SPRID_MOB + 7 * 8 * 66, 40, true);// Giant-Plant (Type: 76)
		MakeSprite("MasterMageOrc", DEF_SPRID_MOB + 7 * 8 * 67, 40, true);// MasterMage-Orc (Type: 77)
		MakeSprite("Minotaurs", DEF_SPRID_MOB + 7 * 8 * 68, 40, true);// Minotaurs (Type: 78)
		MakeSprite("Nizie", DEF_SPRID_MOB + 7 * 8 * 69, 40, true);// Nizie (Type: 79)
		MakeSprite("Tentocle", DEF_SPRID_MOB + 7 * 8 * 70, 40, true);// Tentocle (Type: 80)
		MakeSprite("yspro", DEF_SPRID_MOB + 7 * 8 * 71, 32, true);// Abaddon (Type: 81)
		MakeSprite("Sorceress", DEF_SPRID_MOB + 7 * 8 * 72, 40, true);// Sorceress (Type: 82)
		MakeSprite("TPKnight", DEF_SPRID_MOB + 7 * 8 * 73, 40, true);// TPKnight (Type: 83)
		MakeSprite("ElfMaster", DEF_SPRID_MOB + 7 * 8 * 74, 40, true);// ElfMaster (Type: 84)
		MakeSprite("DarkKnight", DEF_SPRID_MOB + 7 * 8 * 75, 40, true);// DarkKnight (Type: 85)
		MakeSprite("HBTank", DEF_SPRID_MOB + 7 * 8 * 76, 32, true);// HeavyBattleTank (Type: 86)
		MakeSprite("CBTurret", DEF_SPRID_MOB + 7 * 8 * 77, 32, true);// CBTurret (Type: 87)
		MakeSprite("Babarian", DEF_SPRID_MOB + 7 * 8 * 78, 40, true);// Babarian (Type: 88)
		MakeSprite("ACannon", DEF_SPRID_MOB + 7 * 8 * 79, 32, true);// ACannon (Type: 89)
		m_cLoading = 48;
	}
	break;
	case 48:
	{
		MakeSprite("Gail", DEF_SPRID_MOB + 7 * 8 * 80, 8, true); // Gail (Type: 90)
		MakeSprite("Gate", DEF_SPRID_MOB + 7 * 8 * 81, 24, true);// Heldenian Gate (Type: 91)/**/
		m_hPakFile = CreateFile("sprites\\Mpt.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 0] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 1, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 52;
	}
	break;

	case 52:
	{
		m_hPakFile = CreateFile("sprites\\Mhr.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 0] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 1, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("MLArmor", DEF_SPRID_BODYARMOR_M + 15 * 1, 12, true);
		MakeSprite("MCMail", DEF_SPRID_BODYARMOR_M + 15 * 2, 12, true);
		MakeSprite("MSMail", DEF_SPRID_BODYARMOR_M + 15 * 3, 12, true);
		MakeSprite("MPMail", DEF_SPRID_BODYARMOR_M + 15 * 4, 12, true);
		MakeSprite("Mtunic", DEF_SPRID_BODYARMOR_M + 15 * 5, 12, true);
		MakeSprite("MRobe1", DEF_SPRID_BODYARMOR_M + 15 * 6, 12, true);
		MakeSprite("MSanta", DEF_SPRID_BODYARMOR_M + 15 * 7, 12, true);
		MakeSprite("MHRobe1", DEF_SPRID_BODYARMOR_M + 15 * 10, 12, true); //hero
		MakeSprite("MHRobe2", DEF_SPRID_BODYARMOR_M + 15 * 11, 12, true); //hero
		MakeSprite("MHPMail1", DEF_SPRID_BODYARMOR_M + 15 * 8, 12, true); //hero
		MakeSprite("MHPMail2", DEF_SPRID_BODYARMOR_M + 15 * 9, 12, true); //hero
		MakeSprite("MShirt", DEF_SPRID_BERK_M + 15 * 1, 12, true);
		MakeSprite("MHauberk", DEF_SPRID_BERK_M + 15 * 2, 12, true);
		MakeSprite("MHHauberk1", DEF_SPRID_BERK_M + 15 * 3, 12, true);
		MakeSprite("MHHauberk2", DEF_SPRID_BERK_M + 15 * 4, 12, true);
		m_cLoading = 56;
	}
	break;
	case 56:
	{
		MakeSprite("MTrouser", DEF_SPRID_LEGG_M + 15 * 1, 12, true);
		MakeSprite("MHTrouser", DEF_SPRID_LEGG_M + 15 * 2, 12, true);
		MakeSprite("MCHoses", DEF_SPRID_LEGG_M + 15 * 3, 12, true);
		MakeSprite("MLeggings", DEF_SPRID_LEGG_M + 15 * 4, 12, true);
		MakeSprite("MHLeggings1", DEF_SPRID_LEGG_M + 15 * 5, 12, true); // hero
		MakeSprite("MHLeggings2", DEF_SPRID_LEGG_M + 15 * 6, 12, true); // hero
		MakeSprite("MShoes", DEF_SPRID_BOOT_M + 15 * 1, 12, true);
		MakeSprite("MLBoots", DEF_SPRID_BOOT_M + 15 * 2, 12, true);
		m_hPakFile = CreateFile("sprites\\Msw.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 0, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 1, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 2, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 3, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 5, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 6, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 8] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 7, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 9] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 8, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 10] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 9, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 11] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 10, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 12] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56 * 11, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 60;
	}
	break;
	case 60:
	{
		MakeSprite("Mswx", DEF_SPRID_WEAPON_M + 64 * 5, 56, true);
		MakeSprite("Msw2", DEF_SPRID_WEAPON_M + 64 * 13, 56, true);
		MakeSprite("Msw3", DEF_SPRID_WEAPON_M + 64 * 14, 56, true);
		MakeSprite("MStormBringer", DEF_SPRID_WEAPON_M + 64 * 15, 56, true);
		MakeSprite("MDarkExec", DEF_SPRID_WEAPON_M + 64 * 16, 56, true);
		MakeSprite("MKlonessBlade", DEF_SPRID_WEAPON_M + 64 * 17, 56, true);
		MakeSprite("MKlonessAstock", DEF_SPRID_WEAPON_M + 64 * 18, 56, true);
		MakeSprite("MDebastator", DEF_SPRID_WEAPON_M + 64 * 19, 56, true);
		MakeSprite("MAxe1", DEF_SPRID_WEAPON_M + 64 * 20, 56, true);// Axe
		MakeSprite("MAxe2", DEF_SPRID_WEAPON_M + 64 * 21, 56, true);
		MakeSprite("MAxe3", DEF_SPRID_WEAPON_M + 64 * 22, 56, true);
		MakeSprite("MAxe4", DEF_SPRID_WEAPON_M + 64 * 23, 56, true);
		MakeSprite("MAxe5", DEF_SPRID_WEAPON_M + 64 * 24, 56, true);
		MakeSprite("MPickAxe1", DEF_SPRID_WEAPON_M + 64 * 25, 56, true);
		MakeSprite("MAxe6", DEF_SPRID_WEAPON_M + 64 * 26, 56, true);
		MakeSprite("Mhoe", DEF_SPRID_WEAPON_M + 64 * 27, 56, true);
		MakeSprite("MKlonessAxe", DEF_SPRID_WEAPON_M + 64 * 28, 56, true);
		MakeSprite("MLightBlade", DEF_SPRID_WEAPON_M + 64 * 29, 56, true);
		m_cLoading = 64;
	}
	break;
	case 64:
	{
		MakeSprite("MHammer", DEF_SPRID_WEAPON_M + 64 * 30, 56, true);
		MakeSprite("MBHammer", DEF_SPRID_WEAPON_M + 64 * 31, 56, true);
		MakeSprite("MBabHammer", DEF_SPRID_WEAPON_M + 64 * 32, 56, true);
		MakeSprite("MBShadowSword", DEF_SPRID_WEAPON_M + 64 * 33, 56, true);
		MakeSprite("MBerserkWand", DEF_SPRID_WEAPON_M + 64 * 34, 56, true);
		MakeSprite("Mstaff1", DEF_SPRID_WEAPON_M + 64 * 35, 56, true);// Staff
		MakeSprite("Mstaff2", DEF_SPRID_WEAPON_M + 64 * 36, 56, true);
		MakeSprite("MStaff3", DEF_SPRID_WEAPON_M + 64 * 37, 56, true);
		MakeSprite("MReMagicWand", DEF_SPRID_WEAPON_M + 64 * 38, 56, true);
		MakeSprite("MKlonessWand", DEF_SPRID_WEAPON_M + 64 * 39, 56, true);
		// Bows 40 41 below
		MakeSprite("MDirectBow", DEF_SPRID_WEAPON_M + 64 * 42, 56, true);
		MakeSprite("MFireBow", DEF_SPRID_WEAPON_M + 64 * 43, 56, true);
		m_cLoading = 68;
	}
	break;
	case 68:
	{
		MakeSprite("Mbo", DEF_SPRID_WEAPON_M + 64 * 40, 56, true);
		m_hPakFile = CreateFile("sprites\\Mbo.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64 * 41] = new class CSprite(m_hPakFile, &m_DDraw, "Mbo", i + 56 * 1, true);
			CloseHandle(m_hPakFile);
		}
		m_hPakFile = CreateFile("sprites\\Msh.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 0, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 1, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 2, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 3, true);
			for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 4, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 5, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 6, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 8] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 7, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8 * 9] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7 * 8, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 72;
	}
	break;
	case 72:
	{
		MakeSprite("Mmantle01", DEF_SPRID_MANTLE_M + 15 * 1, 12, true);
		MakeSprite("Mmantle02", DEF_SPRID_MANTLE_M + 15 * 2, 12, true);
		MakeSprite("Mmantle03", DEF_SPRID_MANTLE_M + 15 * 3, 12, true);
		MakeSprite("Mmantle04", DEF_SPRID_MANTLE_M + 15 * 4, 12, true);
		MakeSprite("Mmantle05", DEF_SPRID_MANTLE_M + 15 * 5, 12, true);
		MakeSprite("Mmantle06", DEF_SPRID_MANTLE_M + 15 * 6, 12, true);
		MakeSprite("MHelm1", DEF_SPRID_HEAD_M + 15 * 1, 12, true);
		MakeSprite("MHelm2", DEF_SPRID_HEAD_M + 15 * 2, 12, true);
		MakeSprite("MHelm3", DEF_SPRID_HEAD_M + 15 * 3, 12, true);
		MakeSprite("MHelm4", DEF_SPRID_HEAD_M + 15 * 4, 12, true);
		MakeSprite("MHCap1", DEF_SPRID_HEAD_M + 15 * 11, 12, true);
		MakeSprite("MHCap2", DEF_SPRID_HEAD_M + 15 * 12, 12, true);
		MakeSprite("MHHelm1", DEF_SPRID_HEAD_M + 15 * 9, 12, true);
		MakeSprite("MHHelm2", DEF_SPRID_HEAD_M + 15 * 10, 12, true);
		MakeSprite("NMHelm1", DEF_SPRID_HEAD_M + 15 * 5, 12, true);
		MakeSprite("NMHelm2", DEF_SPRID_HEAD_M + 15 * 6, 12, true);
		MakeSprite("NMHelm3", DEF_SPRID_HEAD_M + 15 * 7, 12, true);
		MakeSprite("NMHelm4", DEF_SPRID_HEAD_M + 15 * 8, 12, true);
		m_cLoading = 76;
	}
	break;
	case 76:
	{
		m_hPakFile = CreateFile("sprites\\Wpt.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 0] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}

		m_hPakFile = CreateFile("sprites\\Whr.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 0] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 0, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 2, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 3, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 4, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 5, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 6, true);
			for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12 * 7, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 80;
	}
	break;
	case 80:
	{
		MakeSprite("WBodice1", DEF_SPRID_BODYARMOR_W + 15 * 1, 12, true);
		MakeSprite("WBodice2", DEF_SPRID_BODYARMOR_W + 15 * 2, 12, true);
		MakeSprite("WLArmor", DEF_SPRID_BODYARMOR_W + 15 * 3, 12, true);
		MakeSprite("WCMail", DEF_SPRID_BODYARMOR_W + 15 * 4, 12, true);
		MakeSprite("WSMail", DEF_SPRID_BODYARMOR_W + 15 * 5, 12, true);
		MakeSprite("WPMail", DEF_SPRID_BODYARMOR_W + 15 * 6, 12, true);
		MakeSprite("WRobe1", DEF_SPRID_BODYARMOR_W + 15 * 7, 12, true);
		MakeSprite("WSanta", DEF_SPRID_BODYARMOR_W + 15 * 8, 12, true);
		MakeSprite("WHRobe1", DEF_SPRID_BODYARMOR_W + 15 * 11, 12, true); // hero
		MakeSprite("WHRobe2", DEF_SPRID_BODYARMOR_W + 15 * 12, 12, true); // hero
		MakeSprite("WHPMail1", DEF_SPRID_BODYARMOR_W + 15 * 9, 12, true); //hero
		MakeSprite("WHPMail2", DEF_SPRID_BODYARMOR_W + 15 * 10, 12, true); //hero
		MakeSprite("WChemiss", DEF_SPRID_BERK_W + 15 * 1, 12, true);
		MakeSprite("WShirt", DEF_SPRID_BERK_W + 15 * 2, 12, true);
		MakeSprite("WHauberk", DEF_SPRID_BERK_W + 15 * 3, 12, true);
		MakeSprite("WHHauberk1", DEF_SPRID_BERK_W + 15 * 4, 12, true);
		MakeSprite("WHHauberk2", DEF_SPRID_BERK_W + 15 * 5, 12, true);
		MakeSprite("WSkirt", DEF_SPRID_LEGG_W + 15 * 1, 12, true);
		MakeSprite("WTrouser", DEF_SPRID_LEGG_W + 15 * 2, 12, true);
		MakeSprite("WHTrouser", DEF_SPRID_LEGG_W + 15 * 3, 12, true);
		MakeSprite("WHLeggings1", DEF_SPRID_LEGG_W + 15 * 6, 12, true);
		MakeSprite("WHLeggings2", DEF_SPRID_LEGG_W + 15 * 7, 12, true);
		MakeSprite("WCHoses", DEF_SPRID_LEGG_W + 15 * 4, 12, true);
		MakeSprite("WLeggings", DEF_SPRID_LEGG_W + 15 * 5, 12, true);
		MakeSprite("WShoes", DEF_SPRID_BOOT_W + 15 * 1, 12, true);
		MakeSprite("WLBoots", DEF_SPRID_BOOT_W + 15 * 2, 12, true);
		m_cLoading = 84;
	}
	break;
	case 84:
	{
		m_hPakFile = CreateFile("sprites\\Wsw.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 0, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 1, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 2, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 3, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 5, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 6, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 8] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 7, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 9] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 8, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 10] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 9, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 11] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 10, true);
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 12] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56 * 11, true);
			CloseHandle(m_hPakFile);
		}
		MakeSprite("Wswx", DEF_SPRID_WEAPON_W + 64 * 5, 56, true);
		MakeSprite("Wsw2", DEF_SPRID_WEAPON_W + 64 * 13, 56, true);
		MakeSprite("Wsw3", DEF_SPRID_WEAPON_W + 64 * 14, 56, true); // TheVampire
		MakeSprite("WStormBringer", DEF_SPRID_WEAPON_W + 64 * 15, 56, true);
		MakeSprite("WDarkExec", DEF_SPRID_WEAPON_W + 64 * 16, 56, true);
		MakeSprite("WKlonessBlade", DEF_SPRID_WEAPON_W + 64 * 17, 56, true);
		MakeSprite("WKlonessAstock", DEF_SPRID_WEAPON_W + 64 * 18, 56, true);
		MakeSprite("WDebastator", DEF_SPRID_WEAPON_W + 64 * 19, 56, true);
		m_cLoading = 88;
	}
	break;
	case 88:
	{
		MakeSprite("WAxe1", DEF_SPRID_WEAPON_W + 64 * 20, 56, true);// Axe
		MakeSprite("WAxe2", DEF_SPRID_WEAPON_W + 64 * 21, 56, true);
		MakeSprite("WAxe3", DEF_SPRID_WEAPON_W + 64 * 22, 56, true);
		MakeSprite("WAxe4", DEF_SPRID_WEAPON_W + 64 * 23, 56, true);
		MakeSprite("WAxe5", DEF_SPRID_WEAPON_W + 64 * 24, 56, true);
		MakeSprite("WpickAxe1", DEF_SPRID_WEAPON_W + 64 * 25, 56, true);
		MakeSprite("WAxe6", DEF_SPRID_WEAPON_W + 64 * 26, 56, true);
		MakeSprite("Whoe", DEF_SPRID_WEAPON_W + 64 * 27, 56, true);
		MakeSprite("WKlonessAxe", DEF_SPRID_WEAPON_W + 64 * 28, 56, true);
		MakeSprite("WLightBlade", DEF_SPRID_WEAPON_W + 64 * 29, 56, true);
		MakeSprite("WHammer", DEF_SPRID_WEAPON_W + 64 * 30, 56, true);
		MakeSprite("WBHammer", DEF_SPRID_WEAPON_W + 64 * 31, 56, true);
		MakeSprite("WBabHammer", DEF_SPRID_WEAPON_W + 64 * 32, 56, true);
		MakeSprite("WBShadowSword", DEF_SPRID_WEAPON_W + 64 * 33, 56, true);
		MakeSprite("WBerserkWand", DEF_SPRID_WEAPON_W + 64 * 34, 56, true);
		MakeSprite("Wstaff1", DEF_SPRID_WEAPON_W + 64 * 35, 56, true);// Staff
		MakeSprite("Wstaff2", DEF_SPRID_WEAPON_W + 64 * 36, 56, true);
		MakeSprite("WStaff3", DEF_SPRID_WEAPON_W + 64 * 37, 56, true);
		MakeSprite("WKlonessWand", DEF_SPRID_WEAPON_W + 64 * 39, 56, true);
		MakeSprite("WReMagicWand", DEF_SPRID_WEAPON_W + 64 * 38, 56, true);
		// bows 40 41 below
		MakeSprite("WDirectBow", DEF_SPRID_WEAPON_W + 64 * 42, 56, true);
		MakeSprite("WFireBow", DEF_SPRID_WEAPON_W + 64 * 43, 56, true);
		m_cLoading = 92;
	}
	break;
	case 92:
	{
		MakeSprite("Wmantle01", DEF_SPRID_MANTLE_W + 15 * 1, 12, true);
		MakeSprite("Wmantle02", DEF_SPRID_MANTLE_W + 15 * 2, 12, true);
		MakeSprite("Wmantle03", DEF_SPRID_MANTLE_W + 15 * 3, 12, true);
		MakeSprite("Wmantle04", DEF_SPRID_MANTLE_W + 15 * 4, 12, true);
		MakeSprite("Wmantle05", DEF_SPRID_MANTLE_W + 15 * 5, 12, true);
		MakeSprite("Wmantle06", DEF_SPRID_MANTLE_W + 15 * 6, 12, true);
		MakeSprite("WHelm1", DEF_SPRID_HEAD_W + 15 * 1, 12, true);
		MakeSprite("WHelm4", DEF_SPRID_HEAD_W + 15 * 4, 12, true);
		MakeSprite("WHHelm1", DEF_SPRID_HEAD_W + 15 * 9, 12, true);
		MakeSprite("WHHelm2", DEF_SPRID_HEAD_W + 15 * 10, 12, true);
		MakeSprite("WHCap1", DEF_SPRID_HEAD_W + 15 * 11, 12, true);
		MakeSprite("WHCap2", DEF_SPRID_HEAD_W + 15 * 12, 12, true);
		MakeSprite("NWHelm1", DEF_SPRID_HEAD_W + 15 * 5, 12, true);
		MakeSprite("NWHelm2", DEF_SPRID_HEAD_W + 15 * 6, 12, true);
		MakeSprite("NWHelm3", DEF_SPRID_HEAD_W + 15 * 7, 12, true);
		MakeSprite("NWHelm4", DEF_SPRID_HEAD_W + 15 * 8, 12, true);
		m_cLoading = 96;
	}
	break;
	case 96:
	{
		MakeSprite("Wbo", DEF_SPRID_WEAPON_W + 64 * 40, 56, true);// Bow
		m_hPakFile = CreateFile("sprites\\Wbo.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64 * 41] = new class CSprite(m_hPakFile, &m_DDraw, "Wbo", i + 56 * 1, true);
			CloseHandle(m_hPakFile);
		}
		m_hPakFile = CreateFile("sprites\\Wsh.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE) {
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 0, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 1, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 2, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 3, true);
			for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 5] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 4, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 5, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 7] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 6, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 8] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 7, true);
			for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8 * 9] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7 * 8, true);
			CloseHandle(m_hPakFile);
		}
		m_cLoading = 100;
	}
	break;
	case 100:
	{
		MakeEffectSpr("effect", 0, 10, false);
		MakeEffectSpr("effect2", 10, 3, false);
		MakeEffectSpr("effect3", 13, 6, false);
		MakeEffectSpr("effect4", 19, 5, false);
		m_hPakFile = CreateFile("sprites\\effect5.pak", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (m_hPakFile != INVALID_HANDLE_VALUE)
		{
			for (i = 0; i <= 6; i++) // Because effectn�0 is EnergySphere
				m_pEffectSpr[i + 24] = new class CSprite(m_hPakFile, &m_DDraw, "effect5", i + 1, false);
			CloseHandle(m_hPakFile);
		}
		MakeEffectSpr("CruEffect1", 31, 9, false);
		MakeEffectSpr("effect6", 40, 5, false);
		MakeEffectSpr("effect7", 45, 12, false);
		MakeEffectSpr("effect8", 57, 9, false);
		MakeEffectSpr("effect9", 66, 21, false);

		MakeEffectSpr("effect10", 87, 2, false); // Effets Hero items
		MakeEffectSpr("effect11", 89, 14, false); // Cancel, stormBlade, resu, GateHeldenian....etc
		//NB: Charge 15 du client 3.51, mais il n'y a que 14 ds le PAK
		MakeEffectSpr("effect11s", 104, 1, false); // effet sort mais je ne sais pas lequel
		// Manque des effets ici .....
		// MakeEffectSpr( "effect13", 108, 2, false); // not loaded by client 351 (Heldenian gates death)
		//MakeEffectSpr( "yseffect2", 141, 8, false); // Wrong in 351 client...
		MakeEffectSpr("yseffect2", 140, 8, false); // Abaddon's death
		MakeEffectSpr("effect12", 148, 4, false); // Slates auras
		MakeEffectSpr("yseffect3", 152, 16, false); // Fumerolles ou ame qui s'envole
		//MakeEffectSpr( "yseffect4", 167, 7, false); // Wrong in 351 client
		MakeEffectSpr("yseffect4", 133, 7, false); // Abaddon's map thunder.

		// Pre-load all sound effects into memory
		AudioManager::Get().LoadSounds();

		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
	break;
	}
}
/*********************************************************************************************************************
** 	void CGame::UpdateScreen_OnLoading_Progress()																	**
**  description			:: loading becomes progressbar																**
**********************************************************************************************************************/
void CGame::UpdateScreen_OnLoading_Progress()
{
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOADING, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawVersion(true);
	int iBarWidth;
	iBarWidth = (int)m_cLoading;
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING]->PutSpriteFastWidth(472 + SCREENX, 442 + SCREENY, 1, iBarWidth, G_dwGlobalTime);
}

void CGame::OnTimer()
{
	if (m_cGameMode < 0) return;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameMode != DEF_GAMEMODE_ONLOADING) {
		if ((dwTime - m_dwCheckSprTime) > 8000)
		{
			m_dwCheckSprTime = dwTime;
			if (m_bIsProgramActive) ReleaseUnusedSprites();
			if ((m_pGSock != 0) && (m_pGSock->m_bIsAvailable == true))
				bSendCommand(MSGID_COMMAND_CHECKCONNECTION, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
		}
	}

	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{
		if ((dwTime - m_dwCheckConnTime) > 5000)
		{
			m_dwCheckConnTime = dwTime;
			if ((m_bIsCrusadeMode) && (m_iCrusadeDuty == 0)) m_dialogBoxManager.EnableDialogBox(DialogBoxId::CrusadeJob, 1, 0, 0);
		}

		if ((dwTime - m_dwCheckChatTime) > 2000)
		{
			m_dwCheckChatTime = m_dwTime;
			ReleaseTimeoverChatMsg();
			if (m_cCommandCount >= 6)
			{
				m_iNetLagCount++;
				if (m_iNetLagCount >= 7)
				{
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
					delete m_pGSock;
					m_pGSock = 0;
					return;
				}
			}
			else m_iNetLagCount = 0;
		}

		if ((G_bIsCalcSocketConnected == false) && ((dwTime - G_dwCalcSocketTime) > 5000))
		{
			delete m_pGSock;
			m_pGSock = 0;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			m_bEscPressed = false;
			PlaySound('E', 14, 5);
			AudioManager::Get().StopSound(SoundType::Effect, 38);
			AudioManager::Get().StopMusic();
			return;
		}

		if ((G_pCalcSocket != 0) && (G_bIsCalcSocketConnected == true)) {
			if ((dwTime - G_dwCalcSocketSendTime) > 1000 * 5) {
				if (memcmp(G_cCmdLineTokenA_Lowercase, "wisetop", 7) == 0)
				{
				}
				else
				{
					hb::net::PacketCalcSocketPing ping{};
					ping.key = 0;
					ping.length = static_cast<std::uint16_t>(sizeof(ping));
					ping.reserved = 0;
					G_pCalcSocket->iSendMsgBlockingMode(reinterpret_cast<char*>(&ping), sizeof(ping));
				}
				G_dwCalcSocketSendTime = dwTime;
			}
		}
	}
}


bool CGame::_bCheckDlgBoxClick(short msX, short msY)
{
	int i;
	char         cDlgID;
	m_DInput.m_sZ = 0;
	// Snoopy: 41->61
	for (i = 0; i < 61; i++)
		// Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			// Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
				(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
			{
				switch (cDlgID) {
				case 1: // DialogBoxId::CharacterInfo
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CharacterInfo))
						pDlg->OnClick(msX, msY);
					break;
				case 2: // DialogBoxId::Inventory
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Inventory))
						pDlg->OnClick(msX, msY);
					break;
				case 3: // DialogBoxId::Magic
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Magic))
						pDlg->OnClick(msX, msY);
					break;
				case 4: // DialogBoxId::ItemDropConfirm
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropConfirm))
						pDlg->OnClick(msX, msY);
					break;
				case 6: // DialogBoxId::WarningBattleArea
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::WarningBattleArea))
						pDlg->OnClick(msX, msY);
					break;
				case 7:
					DlgBoxClick_GuildMenu(msX, msY);
					break;
				case 8:
					DlgBoxClick_GuildOp(msX, msY);
					break;
				case 9: // DialogBoxId::GuideMap
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuideMap))
						pDlg->OnClick(msX, msY);
					break;
				case 11: // DialogBoxId::SaleMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SaleMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 12: // DialogBoxId::LevelUpSetting
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::LevelUpSetting))
						pDlg->OnClick(msX, msY);
					break;
				case 13:
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CityHallMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 14:
					DlgBoxClick_Bank(msX, msY);
					break;
				case 15: // DialogBoxId::Skill
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Skill))
						pDlg->OnClick(msX, msY);
					break;
				case 16: // DialogBoxId::MagicShop
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::MagicShop))
						pDlg->OnClick(msX, msY);
					break;
				case 18: // DialogBoxId::Text
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Text))
						pDlg->OnClick(msX, msY);
					break;
				case 19: // DialogBoxId::SystemMenu
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SystemMenu))
						pDlg->OnClick(msX, msY);
					break;
				case 20: // DialogBoxId::NpcActionQuery
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcActionQuery))
						pDlg->OnClick(msX, msY);
					break;
				case 21: // DialogBoxId::NpcTalk
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcTalk))
						pDlg->OnClick(msX, msY);
					break;
				case 23:
					DlgBoxClick_ItemSellorRepair(msX, msY);
					break;
				case 24: // DialogBoxId::Fishing
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Fishing))
						pDlg->OnClick(msX, msY);
					break;
				case 25: // DialogBoxId::Noticement
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Noticement))
						pDlg->OnClick(msX, msY);
					break;
				case 26:
					DlgBoxClick_SkillDlg(msX, msY);
					break;
				case 27:
					DlgBoxClick_Exchange(msX, msY);
					break;
				case 28:
					DlgBoxClick_Quest(msX, msY);
					break;
				case 29: // DialogBoxId::HudPanel
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
						pDlg->OnClick(msX, msY);
					break;
				case 31: // DialogBoxId::SellList
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellList))
						pDlg->OnClick(msX, msY);
					break;
				case 32:
					DlgBoxClick_Party(msX, msY);
					break;
				case 33: // DialogBoxId::CrusadeJob
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeJob))
						pDlg->OnClick(msX, msY);
					break;
				case 34: // DialogBoxId::ItemUpgrade
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemUpgrade))
						pDlg->OnClick(msX, msY);
					break;
				case 35: // DialogBoxId::Help
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Help))
						pDlg->OnClick(msX, msY);
					break;

				case 36:
					DlgBoxClick_Commander(msX, msY);
					break;

				case 37:
					DlgBoxClick_Constructor(msX, msY);
					break;

				case 38:
					DlgBoxClick_Soldier(msX, msY);
					break;

				case 40:
					DlgBoxClick_Slates(msX, msY);
					break;
					// Snoopy: Boite de dialogue de confirmation d'�change
				case 41: // DialogBoxId::ConfirmExchange
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ConfirmExchange))
						pDlg->OnClick(msX, msY);
					break;
				case 42:
					DlgBoxClick_ChangeStatsMajestic(msX, msY);
					break;
				case 50: // DialogBoxId::Resurrect
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Resurrect))
						pDlg->OnClick(msX, msY);
					break;
				case 51:
					DlgBoxClick_CMDHallMenu(msX, msY);
					break;
				case 52: // DialogBoxId::RepairAll
					if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::RepairAll))
						pDlg->OnClick(msX, msY);
					break;
				}

				return true;
			}
		}

	return false;
}

bool CGame::_bCheckDlgBoxDoubleClick(short msX, short msY)
{
	int i;
	char cDlgID;
	//	if (m_iHP <= 0) return false;
		//Snoopy: 41->61
	for (i = 0; i < 61; i++)
		//Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			//Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
				(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY)) {
				switch (cDlgID) {
				case 1:
					DlbBoxDoubleClick_Character(msX, msY);
					break;
				case 2:
					DlbBoxDoubleClick_Inventory(msX, msY);
					break;
				case 9:
					DlbBoxDoubleClick_GuideMap(msX, msY);
					break;
				}
				return true;
			}
		}
	return false;
}


bool CGame::bDlgBoxPress_Inventory(short msX, short msY)
{
	int i;
	char  cItemID;
	short sX, sY, x1, x2, y1, y2;

#ifdef _DEBUG
	AddEventList("Press Inventory", 10);
#endif

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Inventory) == false) return false;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return false;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true) return false;

	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1) {
			cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];

			if (m_pItemList[cItemID] != 0)
			{
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX,
					sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((m_bIsItemDisabled[cItemID] == false) && (m_bIsItemEquipped[cItemID] == false) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {

					if (m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_bCheckCollison(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame, msX, msY) == true)
					{
						_SetItemOrder(0, cItemID);
						if ((m_bIsGetPointingMode == true) && (m_iPointCommandType < 100) && (m_iPointCommandType >= 0)
							&& (m_pItemList[m_iPointCommandType] != 0)
							&& (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)
							&& (m_iPointCommandType != cItemID))
						{
							PointCommandHandler(0, 0, cItemID);
							//m_bCommandAvailable  = false;
							m_bIsGetPointingMode = false;
						}
						else
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
							m_stMCursor.sSelectedObjectID = cItemID;
							m_stMCursor.sDistX = msX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
							m_stMCursor.sDistY = msY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
						}
						return true;
					}
				}
			}
		}
	return false;
}

void CGame::_SetItemOrder(char cWhere, char cItemID)
{
	int i;

	switch (cWhere) {
	case 0:
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_cItemOrder[i] == cItemID)
				m_cItemOrder[i] = -1;

		for (i = 1; i < DEF_MAXITEMS; i++)
			if ((m_cItemOrder[i - 1] == -1) && (m_cItemOrder[i] != -1)) {
				m_cItemOrder[i - 1] = m_cItemOrder[i];
				m_cItemOrder[i] = -1;
			}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_cItemOrder[i] == -1) {
				m_cItemOrder[i] = cItemID;
				return;
			}
		break;
	}
}

bool CGame::_bCheckDraggingItemRelease(short msX, short msY)
{
	int i;
	char         cDlgID;
	//Snoopy: 41->61
	for (i = 0; i < 61; i++)
		//Snoopy: 40->60
		if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
			//Snoopy: 40->60
			cDlgID = m_dialogBoxManager.OrderAt(60 - i);
			if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX)
				&& (m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
			{
				m_dialogBoxManager.EnableDialogBox(cDlgID, 0, 0, 0);
				switch (cDlgID) {
				case 1:
					bItemDrop_Character();
					break;

				case 2:
					bItemDrop_Inventory(msX, msY);
					break;

				case 14:
					bItemDrop_Bank(msX, msY);
					break;

				case 26: // Alchim / Manuf
					bItemDrop_SkillDialog();
					break;

				case 27:
					bItemDrop_ExchangeDialog(msX, msY);
					break;

				case 30:
					bItemDrop_IconPannel(msX, msY);
					break;

				case 31:
					bItemDrop_SellList(msX, msY);
					break;

				case 34:
					bItemDrop_ItemUpgrade();
					break;

				case 40:
					bItemDrop_Slates();
					break;
				}
				return true;
			}
		}
	bItemDrop_ExternalScreen((char)m_stMCursor.sSelectedObjectID, msX, msY);
	return false;
}

void CGame::bItemDrop_ExternalScreen(char cItemID, short msX, short msY)
{
	char  cName[21];
	short sType, tX, tY;
	int iStatus;

	if (bCheckItemOperationEnabled(cItemID) == false) return;

	if ((m_sMCX != 0) && (m_sMCY != 0) && (abs(m_sPlayerX - m_sMCX) <= 8) && (abs(m_sPlayerY - m_sMCY) <= 8))
	{
		std::memset(cName, 0, sizeof(cName));
		m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sType, &iStatus, &m_wCommObjectID);
		if (memcmp(m_cPlayerName, cName, 10) == 0)
		{
		}
		else
		{
			if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))
				&& (m_pItemList[cItemID]->m_dwCount > 1))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
				if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sMCX;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sMCY;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = sType;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = m_wCommObjectID;
				std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
				if (sType < 10)
					memcpy(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, cName, 10);
				else
				{
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr);
				}
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
			}
			else
			{
				switch (sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 1, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					strcpy(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, cName);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); //v1.4
					break;

				case 20: // Howard
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 3, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID; // v1.4
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;

				case 15: // ShopKeeper-W
				case 24: // Tom
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 2, cItemID, sType);
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 1;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID; // v1.4
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_sMCX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
					m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;

					std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
					GetNpcName(sType, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
					break;

				default:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;
				}
				//m_bIsItemDisabled[cItemID] = true;
			}
			m_bIsItemDisabled[cItemID] = true;
		}
	}
	else
	{
		if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))
			&& (m_pItemList[cItemID]->m_dwCount > 1))
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
			if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0)		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 0;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = 0;
			std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		}
		else
		{
			if (_ItemDropHistory(m_pItemList[cItemID]->m_cName))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sX = msX - 140;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY = msY - 70;
				if (m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY < 0)	m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV1 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV2 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV3 = 1;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV4 = 0;
				m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sV5 = cItemID;
				std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).cStr));
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropConfirm, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
			}
			else
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, 0, cItemID, 1, 0, m_pItemList[cItemID]->m_cName);
			}
		}
		m_bIsItemDisabled[cItemID] = true;
	}
}


void CGame::CommonEventHandler(char* pData)
{
	WORD wEventType;
	short sX, sY, sV1, sV2, sV3, sV4;
	uint32_t dwV4;

	const auto* base = hb::net::PacketCast<hb::net::PacketEventCommonBase>(pData, sizeof(hb::net::PacketEventCommonBase));
	if (!base) return;
	wEventType = base->header.msg_type;
	sX = base->x;
	sY = base->y;
	sV1 = base->v1;
	sV2 = base->v2;
	sV3 = base->v3;

	switch (wEventType) {
	case DEF_COMMONTYPE_ITEMDROP:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonItem>(pData, sizeof(hb::net::PacketEventCommonItem));
		if (!pkt) return;
		dwV4 = pkt->v4;
	}
	if ((sV1 == 6) && (sV2 == 0)) {
		bAddNewEffect(4, sX, sY, 0, 0, 0);
	}
	m_pMapData->bSetItem(sX, sY, sV1, (char)sV3, dwV4);
	break;

	case DEF_COMMONTYPE_SETITEM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonItem>(pData, sizeof(hb::net::PacketEventCommonItem));
		if (!pkt) return;
		dwV4 = pkt->v4;
	}
	m_pMapData->bSetItem(sX, sY, sV1, (char)sV3, dwV4, false); // v1.4 color
	break;

	case DEF_COMMONTYPE_MAGIC:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventCommonMagic>(pData, sizeof(hb::net::PacketEventCommonMagic));
		if (!pkt) return;
		sV4 = pkt->v4;
	}
	bAddNewEffect(sV3, sX, sY, sV1, sV2, 0, sV4);
	break;

	case DEF_COMMONTYPE_CLEARGUILDNAME:
		ClearGuildNameList();
		break;
	}
}

void CGame::ClearGuildNameList()
{
	for (int i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}
}

void CGame::InitGameSettings()
{
	int i;

	m_bForceAttack = false;
	m_dwCommandTime = 0;

	m_bInputStatus = false;
	m_pInputBuffer = 0;

	m_iPDBGSdivX = 0;
	m_iPDBGSdivY = 0;
	m_bIsRedrawPDBGS = true;

	m_iCameraShakingDegree = 0;

	m_cCommand = DEF_OBJECTSTOP;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1; //v2.15 0 -> -1

	m_bIsCombatMode = false;
	m_bRunningMode = false;

	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	m_bSkillUsingStatus = false;
	m_bItemUsingStatus = false;
	m_bUsingSlate = false;

	m_bIsWhetherEffect = false;
	m_cWhetherEffectType = 0;

	m_iDownSkillIndex = -1;
	m_dialogBoxManager.Info(DialogBoxId::Skill).bFlag = false;

	m_bIsConfusion = false;

	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;

	m_iDrawFlag = 0;
	m_bSkipFrame = false;
	m_bDrawFlagDir = false;
	m_bIsCrusadeMode = false;
	m_iCrusadeDuty = 0;
	m_bIsAvatarMode = false;
	m_bIsAvatarMessenger = false;

	m_iNetLagCount = 0;

	m_dwEnvEffectTime = GameClock::GetTimeMS();

	for (i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}
	//Snoopy: 61
	for (i = 0; i < 61; i++)
		m_dialogBoxManager.SetEnabled(i, false);

	//Snoopy: 58 because 2 last ones alreaddy defined
	for (i = 0; i < 58; i++)
		m_dialogBoxManager.SetOrderAt(i, 0);
	m_dialogBoxManager.SetOrderAt(60, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetOrderAt(59, DialogBoxId::HudPanel);
	m_dialogBoxManager.SetEnabled(DialogBoxId::HudPanel, true);
	m_dialogBoxManager.SetEnabled(DialogBoxId::HudPanel, true);

	for (i = 0; i < DEF_MAXEFFECTS; i++) {
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];
		m_pEffectList[i] = 0;
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = 0;
	}

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) {
		if (m_pChatScrollList[i] != 0) delete m_pChatScrollList[i];
		m_pChatScrollList[i] = 0;
	}

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) {
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];
		m_pWhisperMsg[i] = 0;
	}

	std::memset(m_cLocation, 0, sizeof(m_cLocation));

	std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	m_iTotalGuildsMan = 0;

	for (i = 0; i < 100; i++) {
		m_stGuildOpList[i].cOpMode = 0;
		std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
	}

	for (i = 0; i < 6; i++) {
		std::memset(m_stEventHistory[i].cTxt, 0, sizeof(m_stEventHistory[i].cTxt));
		m_stEventHistory[i].dwTime = G_dwGlobalTime;

		std::memset(m_stEventHistory2[i].cTxt, 0, sizeof(m_stEventHistory2[i].cTxt));
		m_stEventHistory2[i].dwTime = G_dwGlobalTime;
	}

	for (i = 0; i < DEF_MAXMENUITEMS; i++) {
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];
		m_pItemForSaleList[i] = 0;
	}

	for (i = 0; i < 41; i++) {
		m_dialogBoxManager.Info(i).bFlag = false;
		m_dialogBoxManager.Info(i).sView = 0;
		m_dialogBoxManager.Info(i).bIsScrollSelected = false;
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0) {
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < DEF_MAXSELLLIST; i++) {
		m_stSellItemList[i].iIndex = -1;
		m_stSellItemList[i].iAmount = 0;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0) {
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_cMagicMastery[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_cSkillMastery[i] = 0;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;

		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;

		if (m_pAgreeMsgTextList[i] != 0)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = 0;
	}

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
		m_stPartyMember[i].cStatus = 0;
		std::memset(m_stPartyMember[i].cName, 0, sizeof(m_stPartyMember[i].cName));
	}

	m_iLU_Point = 0;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
	m_bDialogTrans = false;
	m_cWhetherStatus = 0;
	m_cLogOutCount = -1;
	m_dwLogOutCountTime = 0;
	m_iSuperAttackLeft = 0;
	m_bSuperAttackMode = false;
	m_iFightzoneNumber = 0;
	std::memset(m_cBGMmapName, 0, sizeof(m_cBGMmapName));
	m_dwWOFtime = 0;
	m_stQuest.sWho = 0;
	m_stQuest.sQuestType = 0;
	m_stQuest.sContribution = 0;
	m_stQuest.sTargetType = 0;
	m_stQuest.sTargetCount = 0;
	m_stQuest.sCurrentCount = 0;
	m_stQuest.sX = 0;
	m_stQuest.sY = 0;
	m_stQuest.sRange = 0;
	m_stQuest.bIsQuestCompleted = false;
	std::memset(m_stQuest.cTargetName, 0, sizeof(m_stQuest.cTargetName));
	m_bIsObserverMode = false;
	m_bIsObserverCommanded = false;
	m_bIsPoisoned = false;
	m_bIsPrevMoveBlocked = false;
	m_iPrevMoveX = m_iPrevMoveY = -1;
	m_sDamageMove = 0;
	m_sDamageMoveAmount = 0;
	m_bForceDisconn = false;
	m_bIsSpecialAbilityEnabled = false;
	m_iSpecialAbilityType = 0;
	m_dwSpecialAbilitySettingTime = 0;
	m_iSpecialAbilityTimeLeftSec = 0;
	m_stMCursor.cSelectedObjectType = 0;
	m_bIsF1HelpWindowEnabled = false;
	m_bIsTeleportRequested = false;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
	{
		m_stCrusadeStructureInfo[i].cType = 0;
		m_stCrusadeStructureInfo[i].cSide = 0;
		m_stCrusadeStructureInfo[i].sX = 0;
		m_stCrusadeStructureInfo[i].sY = 0;
	}
	std::memset(m_cStatusMapName, 0, sizeof(m_cStatusMapName));
	m_dwCommanderCommandRequestedTime = 0;
	std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	m_iTopMsgLastSec = 0;
	m_dwTopMsgTime = 0;
	m_iConstructionPoint = 0;
	m_iWarContribution = 0;
	std::memset(m_cTeleportMapName, 0, sizeof(m_cTeleportMapName));
	m_iTeleportLocX = m_iTeleportLocY = -1;
	std::memset(m_cConstructMapName, 0, sizeof(m_cConstructMapName));
	m_iConstructLocX = m_iConstructLocY = -1;

	//Snoopy: Apocalypse Gate
	std::memset(m_cGateMapName, 0, sizeof(m_cGateMapName));
	m_iGatePositX = m_iGatePositY = -1;
	m_iHeldenianAresdenLeftTower = -1;
	m_iHeldenianElvineLeftTower = -1;
	m_iHeldenianAresdenFlags = -1;
	m_iHeldenianElvineFlags = -1;
	m_bIsXmas = false;
	m_iTotalPartyMember = 0;
	m_iPartyStatus = 0;
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
	m_iGizonItemUpgradeLeft = 0;
	cStateChange1 = 0;
	cStateChange2 = 0;
	cStateChange3 = 0;
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuideMap, 0, 0, 0);
}

void CGame::_GetHairColorRGB(int iColorType, int* pR, int* pG, int* pB)
{
	switch (iColorType) {
	case 0: // rouge fonc�
		*pR = 14; *pG = -5; *pB = -5; break;
	case 1: // Orange
		*pR = 20; *pG = 0; *pB = 0; break;
	case 2: // marron tres clair
		*pR = 22; *pG = 13; *pB = -10; break;
	case 3: // vert
		*pR = 0; *pG = 10; *pB = 0; break;
	case 4: // Bleu flashy
		*pR = 0; *pG = 0; *pB = 22; break;
	case 5: // Bleu fonc�
		*pR = -5; *pG = -5; *pB = 15; break;
	case 6: //Mauve
		*pR = 15; *pG = -5; *pB = 16; break;
	case 7: // Noir
		*pR = -6; *pG = -6; *pB = -6; break;
	case 8:
		*pR = 10; *pG = 3; *pB = 10; break;
	case 9:
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10:
		*pR = -10; *pG = 3; *pB = 10; break;
	case 11:
		*pR = 10; *pG = 3; *pB = 20; break;
	case 12:
		*pR = 21; *pG = 3; *pB = 3; break;
	case 13:
		*pR = 3; *pG = 3; *pB = 25; break;
	case 14:
		*pR = 3; *pG = 11; *pB = 3; break;
	case 15:
		*pR = 6; *pG = 8; *pB = 0; break;
	}
}

void CGame::DlgBoxClick_GuildMenu(short msX, short msY)
{
	short sX, sY;
	char cTemp[21];
	int iAdjX, iAdjY;
	sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;

	iAdjX = -13;
	iAdjY = 30;

	switch (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode) {
	case 0:
		if ((msX > sX + iAdjX + 80) && (msX < sX + iAdjX + 210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78))
		{
			if (m_iGuildRank != -1) return;
			if (m_iCharisma < 20) return;
			if (m_iLevel < 20) return;
			if (m_bIsCrusadeMode) return;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99))
		{
			if (m_iGuildRank != 0) return;
			if (m_bIsCrusadeMode) return;
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 5;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 61) && (msX < sX + iAdjX + 226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120))
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 9;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 60) && (msX < sX + iAdjX + 227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139))
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 11;
			PlaySound('E', 14, 5);
		}
		if (m_iFightzoneNumber < 0) break;
		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
		{
			if (m_iGuildRank != 0) return;
			if (m_iFightzoneNumber == 0)	m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 13;
			else  m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 19;
			PlaySound('E', 14, 5);
		}
		break;
	case 1:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Submit
			if (strcmp(m_cGuildName, "NONE") == 0) return;
			if (strlen(m_cGuildName) == 0) return;
			bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 2;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		break;

	case 3:
	case 4:
	case 7:
	case 8:
	case 10:
	case 12:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 9:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Purchase�
			std::memset(cTemp, 0, sizeof(cTemp));
			strcpy(cTemp, "GuildAdmissionTicket");
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, 0, 1, 0, 0, cTemp);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 11:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Purchase
			std::memset(cTemp, 0, sizeof(cTemp));
			strcpy(cTemp, "GuildSecessionTicket");
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, 0, 1, 0, 0, cTemp);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 5:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Confirm
			bSendCommand(MSGID_REQUEST_DISBANDGUILD, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 6;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 13:
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 1, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 2, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 2;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 3, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 3;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 4, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 4;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 5, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 5;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 6, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 6;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 7, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 7;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
		{
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 8, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 18;
			m_iFightzoneNumberTemp = 8;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 14://
	case 15://
	case 16://
	case 17://
	case 21://
	case 22://
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// OK
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::CreateNewGuildResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		m_iGuildRank = 0;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 3;
		break;
	case DEF_MSGTYPE_REJECT:
		m_iGuildRank = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 4;
		break;
	}
}

void CGame::InitPlayerCharacteristics(char* pData)
{
	// Snoopy: Angels
	m_iAngelicStr = 0;
	m_iAngelicDex = 0;
	m_iAngelicInt = 0;
	m_iAngelicMag = 0;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponsePlayerCharacterContents>(
		pData, sizeof(hb::net::PacketResponsePlayerCharacterContents));
	if (!pkt) return;

	m_iHP = pkt->hp;
	m_iMP = pkt->mp;
	m_iSP = pkt->sp;
	m_iAC = pkt->ac;		//? m_iDefenseRatio
	m_iTHAC0 = pkt->thac0;    //? m_iHitRatio
	m_iLevel = pkt->level;
	m_iStr = pkt->str;
	m_iInt = pkt->intel;
	m_iVit = pkt->vit;
	m_iDex = pkt->dex;
	m_iMag = pkt->mag;
	m_iCharisma = pkt->chr;

	// CLEROTH - LU
	m_iLU_Point = pkt->lu_point - 3;

	m_iExp = pkt->exp;
	m_iEnemyKillCount = pkt->enemy_kills;
	m_iPKCount = pkt->pk_count;
	m_iRewardGold = pkt->reward_gold;

	memcpy(m_cLocation, pkt->location, sizeof(pkt->location));
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else
	{
		m_bAresden = true;
		m_bCitizen = false;
		m_bHunter = true;
	}

	memcpy(m_cGuildName, pkt->guild_name, sizeof(pkt->guild_name));

	if (strcmp(m_cGuildName, "NONE") == 0)
		std::memset(m_cGuildName, 0, sizeof(m_cGuildName));

	CMisc::ReplaceString(m_cGuildName, '_', ' ');
	m_iGuildRank = pkt->guild_rank;
	m_iSuperAttackLeft = pkt->super_attack_left;
	m_iFightzoneNumber = pkt->fightzone_number;
	iMaxStats = pkt->max_stats;
	iMaxLevel = pkt->max_level;
}



void CGame::DisbandGuildResponseHandler(char* pData)
{
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
		m_iGuildRank = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 7;
		break;
	case DEF_MSGTYPE_REJECT:
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 8;
		break;
	}
}


void CGame::_PutGuildOperationList(char* pName, char cOpMode)
{
	int i;
	for (i = 0; i < 100; i++)
		if (m_stGuildOpList[i].cOpMode == 0)
		{
			m_stGuildOpList[i].cOpMode = cOpMode;
			std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
			memcpy(m_stGuildOpList[i].cName, pName, 20);
			return;
		}
}

void CGame::_ShiftGuildOperationList()
{
	int i;
	std::memset(m_stGuildOpList[0].cName, 0, sizeof(m_stGuildOpList[0].cName));
	m_stGuildOpList[0].cOpMode = 0;

	for (i = 1; i < 100; i++)
		if ((m_stGuildOpList[i - 1].cOpMode == 0) && (m_stGuildOpList[i].cOpMode != 0)) {
			m_stGuildOpList[i - 1].cOpMode = m_stGuildOpList[i].cOpMode;
			std::memset(m_stGuildOpList[i - 1].cName, 0, sizeof(m_stGuildOpList[i - 1].cName));
			memcpy(m_stGuildOpList[i - 1].cName, m_stGuildOpList[i].cName, 20);

			std::memset(m_stGuildOpList[i].cName, 0, sizeof(m_stGuildOpList[i].cName));
			m_stGuildOpList[i].cOpMode = 0;
		}
}



void CGame::DlgBoxClick_GuildOp(short msX, short msY)
{
	short sX, sY;
	char cName[12], cName20[24];

	std::memset(cName, 0, sizeof(cName));
	std::memset(cName20, 0, sizeof(cName20));
	sX = m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sY;

	switch (m_stGuildOpList[0].cOpMode) {
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			_ShiftGuildOperationList();
			if (m_stGuildOpList[0].cOpMode == 0) m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildOperation);
		}
		return;
	}

	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Approve
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDAPPROVE, 0, 0, 0, 0, cName20);
			break;

		case 2:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0, cName20);
			break;
		}
		_ShiftGuildOperationList();
		if (m_stGuildOpList[0].cOpMode == 0) m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildOperation);
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Reject
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDREJECT, 0, 0, 0, 0, cName20);
			break;

		case 2:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDREJECT, 0, 0, 0, 0, cName20);
			break;
		}

		_ShiftGuildOperationList();
		if (m_stGuildOpList[0].cOpMode == 0) m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildOperation);
	}
}



void CGame::AddEventList(char* pTxt, char cColor, bool bDupAllow)
{
	int i;
	if ((bDupAllow == false) && (strcmp(m_stEventHistory[5].cTxt, pTxt) == 0)) return;
	if (cColor == 10)
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory2[i - 1].cTxt, m_stEventHistory2[i].cTxt);
			m_stEventHistory2[i - 1].cColor = m_stEventHistory2[i].cColor;
			m_stEventHistory2[i - 1].dwTime = m_stEventHistory2[i].dwTime;
		}
		std::memset(m_stEventHistory2[5].cTxt, 0, sizeof(m_stEventHistory2[5].cTxt));
		strcpy(m_stEventHistory2[5].cTxt, pTxt);
		m_stEventHistory2[5].cColor = cColor;
		m_stEventHistory2[5].dwTime = m_dwCurTime;
	}
	else
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory[i - 1].cTxt, m_stEventHistory[i].cTxt);
			m_stEventHistory[i - 1].cColor = m_stEventHistory[i].cColor;
			m_stEventHistory[i - 1].dwTime = m_stEventHistory[i].dwTime;
		}
		std::memset(m_stEventHistory[5].cTxt, 0, sizeof(m_stEventHistory[5].cTxt));
		strcpy(m_stEventHistory[5].cTxt, pTxt);
		m_stEventHistory[5].cColor = cColor;
		m_stEventHistory[5].dwTime = m_dwCurTime;
	}
}

int _iAttackerHeight[] = { 0, 35, 35,35,35,35,35, 0,0,0,
5,  // Slime
35, // Skeleton
40, // Stone-Golem
45, // Cyclops
35,// OrcMage
35,// ShopKeeper
5, // GiantAnt
8, // Scorpion
35,// Zombie
35,// Gandalf
35,// Howard
35,// Guard
10,// Amphis
38,// Clay-Golem
35,// Tom
35,// William
35,// Kennedy
35,// Hellhound
50,// Troll
45,// Orge
55,// Liche
65,// Demon
46,// Unicorn
49,// WereWolf
55,// Dummy
35,// Energysphere
75,// Arrow Guard Tower
75,// Cannon Guard Tower
50,// Mana Collector
50,// Detector
50,// Energy Shield Generator
50,// Grand Magic Generator
50,// ManaStone 42
40,// Light War Beetle
35,// GHK
40,// GHKABS
35,// TK
60,// BG
40,// Stalker
70,// HellClaw
85,// Tigerworm
50,// Catapult
85,// Gargoyle
70,// Beholder
40,// Dark-Elf
20,// Bunny
20,// Cat
40,// Giant-Frog
80,// Mountain-Giant
85,// Ettin
50,// Cannibal-Plant
50, // Rudolph 61 //Snoopy....
80, // Direboar 62
90, // Frost 63
40, // Crops 64
80, // IceGolem 65
190, // Wyvern 66
35, // npc 67
35, // npc 68
35, // npc 69
100, // Dragon 70
90, // Centaur 71
75, // ClawTurtle 72
200, // FireWyvern 73
80, // GiantCrayfish 74
120, // Gi Lizard 75
100, // Gi Tree 76
100, // Master Orc 77
80, // Minaus 78
100, // Nizie 79
25,  // Tentocle 80
200, // Abaddon	 81
60, // Sorceress 82
60, // ATK 83
70, // MasterElf 84
60, // DSK 85
50, // HBT 86
60, // CT 87
60, // Barbarian 88
60, // AGC 89
35, // ncp 90 Gail
35  // Gate 91
};

void CGame::bAddNewEffect(short sType, int sX, int sY, int dX, int dY, char cStartFrame, int iV1)
{
	int i;
	short sAbsX, sAbsY, sDist;
	long lPan;
	int  iV2 = 0;
	if (m_cDetailLevel == 0) // Detail Level Low
	{
		switch (sType) {
		case 8:
		case 9:
		case 11:
		case 12:
		case 14:
		case 15:
			return;
		}
	}
	if (m_bIsProgramActive == false) return;
	int x = LOGICAL_WIDTH / 2;
	int y = LOGICAL_HEIGHT / 2;
	int fixx = VIEW_CENTER_TILE_X;
	int fixy = VIEW_CENTER_TILE_Y;
	sAbsX = abs(((m_sViewPointX / 32) + fixx) - dX);
	sAbsY = abs(((m_sViewPointY / 32) + fixy) - dY);
	if (sAbsX > sAbsY) sDist = sAbsX; else sDist = sAbsY;
	short fixdist = sDist;
	int fixpan = LOGICAL_WIDTH;

	for (i = 0; i < DEF_MAXEFFECTS; i++)
		if (m_pEffectList[i] == 0)
		{
			m_pEffectList[i] = new class CEffect;
			m_pEffectList[i]->m_sType = sType;
			m_pEffectList[i]->m_sX = sX;
			m_pEffectList[i]->m_sY = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_iV1 = iV1;
			m_pEffectList[i]->m_cFrame = cStartFrame;
			m_pEffectList[i]->m_dwTime = m_dwCurTime;

			switch (sType) {
			case 1: // coup normal
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - _iAttackerHeight[iV1];
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 2:	// Fl�che qui vole
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - _iAttackerHeight[iV1];
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 10;
				m_pEffectList[i]->m_cDir = CMisc::cCalcDirection(sX, sY, dX, dY);
				PlaySound('C', 4, sDist);
				break;

			case 4: // Gold
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32;
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 100;
				sAbsX = abs(((m_sViewPointX / 32) + fixx) - sX);
				sAbsY = abs(((m_sViewPointY / 32) + fixy) - sY);
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 12, sDist, lPan);
				break;

			case 5: // FireBall Fire Explosion
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 11;
				m_pEffectList[i]->m_dwFrameTime = 10;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist);
				break;

			case 6:	 // Energy Bolt
			case 10: // Lightning Arrow
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 10;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 2, sDist, lPan);
				SetCameraShakingEffect(sDist);
				break;

			case 7: // Magic Missile Explosion
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 5;
				m_pEffectList[i]->m_dwFrameTime = 50;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 3, sDist, lPan);
				break;

			case 8: // Burst
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 4;
				m_pEffectList[i]->m_dwFrameTime = 30;
				break;

			case 9: // Burst
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_rX = 6 - (rand() % 12);
				m_pEffectList[i]->m_rY = -8 - (rand() % 6);
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 30;
				break;

			case 11:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_rX = 6 - (rand() % 12);
				if (iV2 == 0)
					m_pEffectList[i]->m_rY = -2 - (rand() % 4);
				else m_pEffectList[i]->m_rY = -2 - (rand() % 10);
				m_pEffectList[i]->m_cMaxFrame = 8;
				m_pEffectList[i]->m_dwFrameTime = 30;
				break;

			case 12: // Burst
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_rX = 8 - (rand() % 16);
				m_pEffectList[i]->m_rY = 4 - (rand() % 12);
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 30;
				break;

			case 13: // Bulles druncncity
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 18;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 14: // Traces de pas ou Tremor (pas en low detail)
				m_pEffectList[i]->m_mX = sX;
				if (m_pEffectList[i]->m_iV1 > 0) // Case if hit by an arrow
				{
					m_pEffectList[i]->m_mY = sY - (_iAttackerHeight[m_pEffectList[i]->m_iV1] / 4 + rand() % (_iAttackerHeight[m_pEffectList[i]->m_iV1] / 2));
					m_pEffectList[i]->m_mX = sX + (rand() % 5) - 2;
				}
				else m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 4;
				m_pEffectList[i]->m_dwFrameTime = 100;
				m_pEffectList[i]->m_iV1 = iV1;
				break;

			case 15: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 16: //
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 17:
				m_pEffectList[i]->m_mX = sX + (rand() % 20) - 40;
				m_pEffectList[i]->m_mY = sY + (rand() % 20) - 40;
				m_pEffectList[i]->m_rX = 8 - (rand() % 16);
				m_pEffectList[i]->m_rY = 4 - (rand() % 12);
				m_pEffectList[i]->m_mX3 = sX;
				m_pEffectList[i]->m_mY3 = sY;
				m_pEffectList[i]->m_iV1 = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 18:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 50;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				SetCameraShakingEffect(sDist);
				break;

			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27: // Critical strike with a weapon
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 10;
				m_pEffectList[i]->m_cDir = CMisc::cCalcDirection(sX, sY, dX, dY);
				break;

			case 30: // Mass-Fire-Strike (called 1 time)
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 9;
				m_pEffectList[i]->m_dwFrameTime = 40;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist * 2);
				break;

			case 31: // Mass-Fire-Strike (called 3 times)
			case 252: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 8;
				m_pEffectList[i]->m_dwFrameTime = 40;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist);
				break;

			case 32: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 4;
				m_pEffectList[i]->m_dwFrameTime = 100;
				break;

			case 33: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 34: //
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				SetCameraShakingEffect(sDist);
				break;

			case 35: // Snoopy: rajout (pour Mass Magic-Missile)
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 18;
				m_pEffectList[i]->m_dwFrameTime = 40;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist * 2);
				break;

			case 36: // Snoopy: Rajout (pour Mass Magic-Missile)
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 40;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist);
				break;

			case 40: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 45, sDist, lPan);
				break;

			case 41: // Large Type 1, 2, 3, 4
			case 42:
			case 43:
			case 44:
			case 45: // Small Type 1, 2
			case 46:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY - 220;
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_iV1 = 20;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 46, sDist, lPan);
				break;

			case 47: // Blizzard
			case 48: // Blizzard
			case 49: // Blizzard
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY - 220;
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_iV1 = 20;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 46, sDist, lPan);
				break;

			case 50: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 50;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				if ((rand() % 4) == 1) SetCameraShakingEffect(sDist);
				PlaySound('E', 47, sDist, lPan);
				break;

			case 51:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 9; //15;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 52: // Protect ring
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 80;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 53: // Hold twist
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 80;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 54: // star twingkling (effect armes brillantes)
			case 55: // Unused
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 15;
				break;

			case 56: //  Mass-Chill-Wind
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				PlaySound('E', 45, sDist, lPan);
				break;

			case 57: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 60: //
				m_pEffectList[i]->m_mX = sX + 300;
				m_pEffectList[i]->m_mY = sY - 460;
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 50;
				break;

			case 61: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 10;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist, 2);
				break;

			case 62: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 6;
				m_pEffectList[i]->m_dwFrameTime = 100;
				break;

			case 63: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 64: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 65: // Crusade's MS
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 66: // Crusade MS explosion
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist, 2);
				break;

			case 67: // Crusade's MS fire + smoke ?
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 27;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 68: // worm-bite
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 17;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				m_pEffectList[i]->m_iV1 = sDist;
				//SetCameraShakingEffect(sDist, 2);
				break;

			case 69: // identique au cas 70
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 11;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 42, sDist, lPan);
				break;

			case 70: // identtique au cas 69
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 11;
				m_pEffectList[i]->m_dwFrameTime = 30;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 42, sDist, lPan);
				break;

			case 71: //
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				SetCameraShakingEffect(sDist);
				break;

			case 72: // Blizzard
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 20;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				lPan = ((sX - m_sViewPointX) - x) * 30;
				if ((rand() % 4) == 1) SetCameraShakingEffect(sDist);
				PlaySound('E', 47, sDist, lPan);
				break;

			case 73:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 60;
				break;

			case 74:
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 19;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 75: //ice golem
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_dX = dX;
				m_pEffectList[i]->m_dY = dY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 76: //ice golem
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_dX = dX;
				m_pEffectList[i]->m_dY = dY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 77: //ice golem
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_dX = dX;
				m_pEffectList[i]->m_dY = dY;
				m_pEffectList[i]->m_cMaxFrame = 16;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 80: // Snoopy: rajou�, impl�ment� en dernier ds la v351
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_iV1 = 20;
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 25;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				SetCameraShakingEffect(sDist);
				break;

			case 81: //  Snoopy: Rajout (StormBlade)
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 27;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 82: //  Snoopy: Rajout (Gate Apocalypse)
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 100: // MagicMissile is Flying
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 101: // Heal
			case 111: // Staminar-Drain
			case 121: // Great Heal
			case 123: // Staminar-Recovery
			case 128: // Great-Staminar-Recovery
				m_pEffectList[i]->m_cMaxFrame = 14;
				m_pEffectList[i]->m_dwFrameTime = 80;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 102: // CreateFood
			case 122: // Recall
			case 126: // Possession
			case 127: // Poison
			case 134: // DetectInvi
			case 136: // Cure
			case 142: // Confuse language
			case 152: // Polymorph
			case 153: // Mass-Poison
			case 162: // Confusion
			case 171: // Mass-Confusion
				m_pEffectList[i]->m_cMaxFrame = 13;
				m_pEffectList[i]->m_dwFrameTime = 120;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 110: // Energy-Bolt
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 112: // Recall
			case 131: // Summon
			case 132: // Invi
			case 178: // Haste
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 80;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 113: // Defense-Shield
			case 144: // Great-Defense-Shield
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 120;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 114: // Celebrating Light
				bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -12);
				bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -9);
				bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -6);
				bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -3);
				bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, 0);
				delete m_pEffectList[i];
				m_pEffectList[i] = 0;
				break;

			case 120: // Fire Ball
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_cDir = CMisc::cCalcDirection(sX, sY, dX, dY);
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 124: // Protect form N.M
			case 133: // Protection from Magic
				bAddNewEffect(52, dX * 32, dY * 32, 0, 0, 0, 0);
				delete m_pEffectList[i];
				m_pEffectList[i] = 0;
				break;

			case 125: // Hold Person
			case 135: // Paralyze
				bAddNewEffect(53, dX * 32, dY * 32, 0, 0, 0, 0);
				delete m_pEffectList[i];
				m_pEffectList[i] = 0;
				break;

			case 130: // Fire Strike
			case 137: // Lightning Arrow
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_cDir = CMisc::cCalcDirection(sX, sY, dX, dY);
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 138: // Tremor.
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				SetCameraShakingEffect(sDist, 2);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);

				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 143: // Lightning
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 50;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_rX = 5 - (rand() % 10);
				m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				m_pEffectList[i]->m_cMaxFrame = 7;
				m_pEffectList[i]->m_dwFrameTime = 10;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 40, sDist, lPan);
				break;

			case 145: // ChillWind
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 147: // Triple-Energy-Bolt
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				break;

			case 150: // Berserk : Cirlcle 6 magic
			case 177: // Illusion-Movement
			case 180: // Illusion
			case 183: // Inhibition-Casting
			case 190: // Mass-Illusion
			case 195: // Mass-Illusion-Movement
				m_pEffectList[i]->m_cMaxFrame = 11;
				m_pEffectList[i]->m_dwFrameTime = 100;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 151: // LightningBolt
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 50;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_rX = 5 - (rand() % 10);
				m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 10;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 40, sDist, lPan);
				break;

			case 156: // Mass-Ligtning-Arrow
				m_pEffectList[i]->m_cMaxFrame = 3;
				m_pEffectList[i]->m_dwFrameTime = 130;
				break;

			case 157: // Ice-Strike
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 160: // Energy-Strike
				m_pEffectList[i]->m_cMaxFrame = 7;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 161: // Mass-Fire-Strike
			case 251: //
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_cDir = CMisc::cCalcDirection(sX, sY, dX, dY);
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 163: // Mass-Chill-Wind
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 164: // worm-bite
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 4, sDist, lPan);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);

				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
				m_pEffectList[i]->m_cMaxFrame = 1;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 165: // Absolute-Magic-Protection
				m_pEffectList[i]->m_cMaxFrame = 21;
				m_pEffectList[i]->m_dwFrameTime = 70;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 166: // Armor Break
				m_pEffectList[i]->m_cMaxFrame = 13;
				m_pEffectList[i]->m_dwFrameTime = 80;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 170: // Bloody-Shock-Wave
				m_pEffectList[i]->m_cMaxFrame = 7;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

			case 172: // Mass-Ice-Strike
				m_pEffectList[i]->m_cMaxFrame = 2;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			case 174: // Lightning-Strike
				m_pEffectList[i]->m_cMaxFrame = 5;
				m_pEffectList[i]->m_dwFrameTime = 120;
				break;

			case 176: // Snoopy: Ajout Cancellation
				m_pEffectList[i]->m_cMaxFrame = 23;
				m_pEffectList[i]->m_dwFrameTime = 60;
				sDist = sDist / 32;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 5, sDist, lPan);
				break;

			case 181: // MS
				m_pEffectList[i]->m_mX = dX * 32 + 300;
				m_pEffectList[i]->m_mY = dY * 32 - 460;
				m_pEffectList[i]->m_cMaxFrame = 10;
				m_pEffectList[i]->m_dwFrameTime = 25;
				break;

			case 182: // Snoopy: Ajout Mass-Magic-Missile
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 20;
				lPan = -(((m_sViewPointX / 32) + fixx) - sX) * fixpan;
				PlaySound('E', 1, sDist, lPan);
				break;

			case 244: // Snoopy: d�plac� pour nvx sorts: Aura du casteur de Mass MagicMissile
				//case 184: // effet sur le caster pour MassMM
				m_pEffectList[i]->m_cMaxFrame = 29;
				m_pEffectList[i]->m_dwFrameTime = 80;
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				break;

			case 191: // Blizzard
				m_pEffectList[i]->m_cMaxFrame = 7;
				m_pEffectList[i]->m_dwFrameTime = 80;
				break;

				//case 192: // Hero set Effect
			case 242: // Hero set Effect
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

				//case 193: // Hero set Effect
			case 243: // Hero set Effect
				m_pEffectList[i]->m_cMaxFrame = 19;
				m_pEffectList[i]->m_dwFrameTime = 18;
				break;

			case 194: // Resurrection
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 40;
				break;

			case 196: // Snoopy: Ajout de Earth-Shock-Wave
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 30;
				m_pEffectList[i]->m_dwFrameTime = 25;
				sAbsX = abs(x - (sX - m_sViewPointX));
				sAbsY = abs(y - (sY - m_sViewPointY));
				if (sAbsX > sAbsY) sDist = sAbsX;
				else sDist = sAbsY;
				sDist = sDist / 32;
				SetCameraShakingEffect(sDist);
				break;
			case 200: //
			case 201: //
			case 202: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 15;
				m_pEffectList[i]->m_dwFrameTime = 25;
				break;

			case 203: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 18;
				m_pEffectList[i]->m_dwFrameTime = 70;
				break;

			case 204: //
			case 205: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 12;
				m_pEffectList[i]->m_dwFrameTime = 70;
				break;

			case 206: //
				m_pEffectList[i]->m_mX = sX;
				m_pEffectList[i]->m_mY = sY;
				m_pEffectList[i]->m_cMaxFrame = 3;
				m_pEffectList[i]->m_dwFrameTime = 70;
				break;

			case 250: //
				m_pEffectList[i]->m_mX = sX * 32;
				m_pEffectList[i]->m_mY = sY * 32 - 40;
				m_pEffectList[i]->m_iErr = 0;
				m_pEffectList[i]->m_cMaxFrame = 0;
				m_pEffectList[i]->m_dwFrameTime = 10;
				break;

			default:
				delete m_pEffectList[i];
				m_pEffectList[i] = 0;
				break;
			}
			if (m_pEffectList[i] != 0)
			{
				m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
				m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
			}
			return;
		}
}

void CGame::DrawEffects()
{
	int i, dX, dY, iDvalue, tX, tY, rX, rY, rX2, rY2, rX3, rY3, rX4, rY4, rX5, rY5, iErr;
	char  cTempFrame;
	uint32_t dwTime = m_dwCurTime;
	short sObjectType;
	char  cName[21];
	int iStatus;

	for (i = 0; i < DEF_MAXEFFECTS; i++)
		if ((m_pEffectList[i] != 0) && (m_pEffectList[i]->m_cFrame >= 0))
		{
			switch (m_pEffectList[i]->m_sType) {
			case 1: // Normal hit
				if (m_pEffectList[i]->m_cFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 2: // Arrow flying
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 2;
				if (cTempFrame < 0) break;
				m_pEffectSpr[7]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
				break;

			case 4: // gold
				/// 1.5
				if (m_pEffectList[i]->m_cFrame < 9) break;
				cTempFrame = m_pEffectList[i]->m_cFrame - 9;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[1]->PutSpriteFast(dX, dY - 40, cTempFrame, dwTime);

				break;

			case 5: // FireBall Fire Explosion
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				iDvalue = (cTempFrame - 8) * (-5);
				if (cTempFrame < 7)
					m_pEffectSpr[3]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				else m_pEffectSpr[3]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
				break;

			case 6:	 // Energy Bolt
			case 10: // Lightning Arrow
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				iDvalue = (cTempFrame - 7) * (-6);
				if (cTempFrame < 6)
					m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 7: // Magic Missile Explosion
				cTempFrame = m_pEffectList[i]->m_cFrame;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				iDvalue = (cTempFrame - 4) * (-3);
				if (cTempFrame < 4)
					m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 8: // Burst
				cTempFrame = m_pEffectList[i]->m_cFrame;
				cTempFrame = 4 - cTempFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 9: // Burst
				cTempFrame = (rand() % 5);
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 11: // pt grenat
				cTempFrame = (rand() % 5) + 5;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite2(dX, dY, cTempFrame, dwTime);
				break;

			case 12: // Burst
				cTempFrame = (rand() % 6) + 10;
				if (cTempFrame < 0) break;
				iDvalue = (m_pEffectList[i]->m_cFrame - 4) * (-3);
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				if (cTempFrame < 4)
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				else //m_pEffectSpr[11]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				//
					m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				break;

			case 13:
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				if (cTempFrame < 13)
				{
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, 25 + (cTempFrame / 5), dwTime);
				}
				else
				{
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, (8 + cTempFrame), dwTime);
				}
				break;

			case 14: // Traces de pas (terrain sec)
				if (m_pEffectList[i]->m_cFrame < 0) break;
				dX = m_pEffectList[i]->m_mX - m_sViewPointX;
				dY = m_pEffectList[i]->m_mY - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (28 + m_pEffectList[i]->m_cFrame), dwTime);
				break;

			case 15: // petits nuages rouges
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = m_pEffectList[i]->m_mX - m_sViewPointX;
				dY = m_pEffectList[i]->m_mY - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (33 + cTempFrame), dwTime);
				break;

			case 16: //
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
				break;

			case 17: //test
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = 39 + (rand() % 3) * 3 + (rand() % 3);
				if (cTempFrame < 0) break;
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				dX = (m_pEffectList[i]->m_mX2) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY2) - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 18: //
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				m_pEffectSpr[18]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 20: // critical hit
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27: // Critical strike with a weapon
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, 1, dwTime);
				break;

			case 30: // Mass-Fire-Strike
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				m_pEffectSpr[14]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 31: // Mass-Fire-Strike
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				m_pEffectSpr[15]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 32: // Trace de pas  (raining weather)
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame + 20;
				if (cTempFrame < 0) break;
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 33: //
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				iDvalue = 0;
				m_pEffectSpr[19]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 34: // absent (220 et 351)
				break;

			case 35: // Snoopy: Ajout
				if (m_pEffectList[i]->m_cFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX - 30, dY - 18, cTempFrame, dwTime);
				break;

			case 36: // Snoopy: Ajout
				if (m_pEffectList[i]->m_cFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				m_pEffectSpr[97]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 40:
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[20]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); // 20
				break;

			case 41: // Large Type 1, 2, 3, 4
			case 42:
			case 43:
			case 44:
			case 45: // Small Type 1, 2
			case 46:
				dX = (m_pEffectList[i]->m_sX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_sY) - m_sViewPointY;
				m_pEffectSpr[21]->PutFadeSprite(dX, dY, 48, dwTime);
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				if ((8 * (m_pEffectList[i]->m_sType - 41) + cTempFrame) < (8 * (m_pEffectList[i]->m_sType - 41) + 7))
				{
					iDvalue = -8 * (6 - cTempFrame);
					m_pEffectSpr[21]->PutTransSpriteRGB(dX, dY, 8 * (m_pEffectList[i]->m_sType - 41) + cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				}
				else
				{
					if ((cTempFrame - 5) >= 8) cTempFrame = ((cTempFrame - 5) - 8) + 5;
					m_pEffectSpr[21]->PutSpriteFast(dX, dY, 8 * (m_pEffectList[i]->m_sType - 41) + (cTempFrame - 5), dwTime);
				}
				break;

			case 47:
			case 48:
			case 49: // Blizzard
				dX = (m_pEffectList[i]->m_sX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_sY) - m_sViewPointY;
				m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutRevTransSprite(dX, dY, 0, dwTime);
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				//PutString(dX, dY, "*", RGB(255,255,255);
				if (cTempFrame < 7) {
					iDvalue = -8 * (6 - cTempFrame);
					m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutTransSpriteRGB(dX, dY, cTempFrame + 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				else {
					if (cTempFrame >= 8) cTempFrame = cTempFrame % 8;
					m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutSpriteFast(dX, dY, cTempFrame + 1, dwTime);
				}
				break;

			case 50:
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;

				if (cTempFrame <= 6) {
					iDvalue = 0;
					m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
				}
				else {
					iDvalue = -5 * (cTempFrame - 6);
					m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, 6, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				}
				break;

			case 51: //
				cTempFrame = m_pEffectList[i]->m_cFrame + 11; //15
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[28]->PutTransSprite25(dX, dY, cTempFrame, dwTime); //20
				break;


			case 52: // Protection Ring commente par siementec, a voir
				/*			cTempFrame = m_pEffectList[i]->m_cFrame;
					dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					m_pEffectSpr[24]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				*/
				break;


			case 53: // Hold Twist
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				if (cTempFrame < 0) cTempFrame = 0;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[25]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); //25
				break;

			case 54: //  star twingkling (effect armes brillantes)
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) cTempFrame = 0;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[28]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				break;

			case 55: //
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) cTempFrame = 0;
				dX = (m_pEffectList[i]->m_mX);
				dY = (m_pEffectList[i]->m_mY);
				m_pEffectSpr[28]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 56: // Mass-Chill-Wind
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) cTempFrame = 0;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[29]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 57:  // absent (220 et 351)
				break;

			case 60:  //
			case 181: // MS
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				if (cTempFrame > 4)
				{
					cTempFrame = cTempFrame / 4;
				}
				if (cTempFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[31]->PutSpriteFast(dX, dY, 15 + cTempFrame, dwTime);
					m_pEffectSpr[31]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				}
				break;

			case 61: // Fire aura on ground (crueffect1, 1)
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[32]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 62: // MS strike
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				if (cTempFrame > 0)
				{
					cTempFrame = cTempFrame - 1;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame / 3);
				}
				break;

			case 63: // Fire explosion (crueffect1, 2)
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[33]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 64: // effet halo blancchatre
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[34]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 65: // MS from crusade striking
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				cTempFrame = cTempFrame / 6;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame >> 2);
				break;

			case 66: // MS explodes on the ground
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[39]->PutRevTransSprite(dX, dY, cTempFrame, dwTime);
				m_pEffectSpr[39]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 67: // MS fire with smoke
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				switch (rand() % 3) {
				case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(dX, dY + 20, 1, dwTime); break;
				case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(dX, dY + 20, 1, dwTime); break;
				case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(dX, dY + 20, 1, dwTime); break;
				}
				m_pEffectSpr[35]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame / 3, dwTime);
				break;

			case 68: // worm-bite
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				if (cTempFrame <= 11)
				{
					m_pEffectSpr[40]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
					m_pEffectSpr[41]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
					m_pEffectSpr[44]->PutRevTransSprite(dX - 2, dY - 3, cTempFrame, dwTime);
					m_pEffectSpr[44]->PutTransSprite_NoColorKey(dX - 4, dY - 3, cTempFrame, dwTime);
				}
				else
				{
					switch (cTempFrame) {
					case 12:
					case 13:
					case 14: m_pEffectSpr[40]->PutSpriteFast(dX, dY, 11, dwTime); break;
					case 15: m_pEffectSpr[40]->PutTransSprite70_NoColorKey(dX, dY, 11, dwTime); break;
					case 16: m_pEffectSpr[40]->PutTransSprite50_NoColorKey(dX, dY, 11, dwTime); break;
					case 17: m_pEffectSpr[40]->PutTransSprite25_NoColorKey(dX, dY, 11, dwTime); break;
					}
				}
				break;

			case 69: // identique au cas 70
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[42]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 70: // identique au cas 69
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[43]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 71: // absent v220 et v351
				break;

			case 72: // Blizzard
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				if (cTempFrame <= 8)
				{
					iDvalue = 0;
					m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
				}
				else
				{
					iDvalue = -1 * (cTempFrame - 8);
					m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, 8, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
				}
				break;

			case 73: // absent v220 et v351
			case 74: // absent v220 et v351
			case 75: // absent v220 et v351
			case 76: // absent v220 et v351
			case 77: // absent v220 et v351
				break;

			case 80:
			case 196: // Earth-Shock-Wave
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[91]->PutSpriteFast(dX, dY, cTempFrame, dwTime); //Nbe d'arguments modifi�s ds la 351....
				m_pEffectSpr[92]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				break;

			case 81: // Snoopy: Ajout StormBlade
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = m_pEffectList[i]->m_cFrame;
				m_pEffectSpr[100]->PutTransSprite_NoColorKey(dX + 70, dY + 70, cTempFrame, dwTime);
				break;

			case 82: // Gate (apocalypse)
				cTempFrame = m_pEffectList[i]->m_cFrame;
				m_pEffectSpr[101]->PutTransSprite_NoColorKey(320, 480, cTempFrame, dwTime);
				break;

			case 100: // Magic Missile
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
				break;

			case 101: // Heal
			case 121: // Great-Heal
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				m_pEffectSpr[50]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 102: // Create Food
			case 124: // Protection from N.M
			case 125: // Hold-Person
			case 126: // Possession
			case 127: // Poison
			case 133: // Protect-From-Magic
			case 134: // Detect-Invisibility
			case 135: // Paralyze
			case 136: // Cure
			case 142: // Confuse Language
			case 152: // Polymorph
			case 153: // Mass-Poison
			case 162: // Confusion
			case 171: // Mass-Confusion
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				if (cTempFrame < 5)
					m_pEffectSpr[4]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[4]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 110: // Energy-Bolt
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 2 + (rand() % 4), dwTime);
				break;

			case 111: // Staminar Drain
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				m_pEffectSpr[49]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 112: // Recall
			case 131: // Summon-Creature
			case 132: // Invisibility
			case 178: // Haste
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				m_pEffectSpr[52]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 113: // Defense Shield
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				if (cTempFrame < 6)
					m_pEffectSpr[62]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[62]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 120: // Fire Ball
			case 130: // Fire Strike
			case 161: // Mass-Fire-Strike
			case 251: //
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				break;

			case 122: // Absent v220 et 351
				break;

			case 123: // Staminar-Recovery
			case 128: // Great-Staminar-Recovery
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				m_pEffectSpr[56]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 137: // Lightning Arrow
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				tX = (m_pEffectList[i]->m_mX2) - m_sViewPointX;
				tY = (m_pEffectList[i]->m_mY2) - m_sViewPointY;
				iErr = 0;
				CMisc::GetPoint(dX, dY, tX, tY, &rX, &rY, &iErr, 15);
				CMisc::GetPoint(dX, dY, tX, tY, &rX2, &rY2, &iErr, 30);
				CMisc::GetPoint(dX, dY, tX, tY, &rX3, &rY3, &iErr, 45);
				CMisc::GetPoint(dX, dY, tX, tY, &rX4, &rY4, &iErr, 60);
				CMisc::GetPoint(dX, dY, tX, tY, &rX5, &rY5, &iErr, 75);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX5, rY5, cTempFrame, dwTime);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX4, rY4, cTempFrame, dwTime);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX3, rY3, cTempFrame, dwTime);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX2, rY2, cTempFrame, dwTime);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite70_NoColorKey(rX, rY, cTempFrame, dwTime);
				cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
				if (cTempFrame < 0) break;
				m_pEffectSpr[10]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				break;

			case 143: // Lightning
				_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - LOGICAL_WIDTH,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);
				_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - LOGICAL_WIDTH,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX + 4, m_pEffectList[i]->m_rY + 2, 2);
				_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - LOGICAL_WIDTH,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX - 2, m_pEffectList[i]->m_rY - 2, 2);
				break;

			case 144: // Great-Defense-Shield
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-5);
				if (cTempFrame < 9)
					m_pEffectSpr[63]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[63]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 151: // Lightning Bolt
				_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);

				_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX + 2, m_pEffectList[i]->m_rY - 2, 2);

				_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
					m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
					m_pEffectList[i]->m_rX - 2, m_pEffectList[i]->m_rY - 2, 2);
				break;

			case 165: // Absolute-Magic-Protect
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY; // 53 = APFM buble
				m_pEffectSpr[53]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 166: // Armor-Break
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[55]->PutRevTransSprite(dX, dY + 35, m_pEffectList[i]->m_cFrame, dwTime);
				m_pEffectSpr[54]->PutTransSprite50(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 176: // Cancellation
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[90]->PutTransSprite_NoColorKey(dX + 50, dY + 85, cTempFrame, dwTime);
				break;

			case 177: // Illusion-Movement
			case 180: // Illusion
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-3);
				if (cTempFrame < 9)	m_pEffectSpr[60]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[60]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

			case 182: //Mass-Magic-Missile
				cTempFrame = m_pEffectList[i]->m_cFrame;
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[98]->PutTransSprite(dX, dY, cTempFrame, dwTime, 0);
				break;

			case 183: // Inhibition-Casting
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-3);
				if (cTempFrame < 9) m_pEffectSpr[94]->PutTransSprite_NoColorKey(dX, dY + 40, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[94]->PutTransSpriteRGB(dX, dY + 40, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime);
				break;

			case 244: // Snoopy: d�plac� pour nvx sorts: Aura du casteur de Mass MagicMissile
				//case 184: // Aura du casteur de Mass MagicMissile
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = m_pEffectList[i]->m_mX - m_sViewPointX;
				dY = m_pEffectList[i]->m_mY - m_sViewPointY;
				m_pEffectSpr[96]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
				break;

			case 190: // Mass-Illusion
			case 195: // Mass-Illusion-Movement
				cTempFrame = m_pEffectList[i]->m_cFrame;
				if (cTempFrame < 0) break;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				iDvalue = (cTempFrame - 5) * (-3);
				if (cTempFrame < 9) m_pEffectSpr[61]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				else m_pEffectSpr[61]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
				break;

				//case 192: // Mage Hero set effect
			case 242:
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[87]->PutTransSprite_NoColorKey(dX + 50, dY + 57, m_pEffectList[i]->m_cFrame, dwTime);
				break;

				//case 193: // War Hero set effect
			case 243:
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[88]->PutTransSprite_NoColorKey(dX + 65, dY + 80, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 194: // Resurrection
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[99]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
				break;

			case 200: // shotstar fall on ground
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[133]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
				break;

			case 201: // shotstar fall on ground
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[134]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
				break;

			case 202: // shotstar fall on ground
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[135]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
				break;

			case 203: // explosion feu apoc
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[136]->PutTransSprite_NoColorKey(dX, dY, (rand() % 18), dwTime);
				break;

			case 204: // Faille oblique
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[137]->PutTransSprite_NoColorKey(dX, dY, (rand() % 12), dwTime);
				break;

			case 205: // Faille horizontale
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[138]->PutTransSprite_NoColorKey(dX, dY, (rand() % 12), dwTime);
				break;

			case 206: // steams
				dX = m_pEffectList[i]->m_mX;
				dY = m_pEffectList[i]->m_mY;
				m_pEffectSpr[139]->PutTransSprite_NoColorKey(dX, dY, (rand() % 20), dwTime);
				break;

			case 250: // Gate (round one)
				dX = m_pEffectList[i]->m_mX - m_sViewPointX;
				dY = m_pEffectList[i]->m_mY - m_sViewPointY;
				m_pEffectSpr[103]->PutTransSprite_NoColorKey(dX, dY, (rand() % 3), dwTime);
				break;

			case 252: // burst (lisgt salmon color)
				dX = m_pEffectList[i]->m_mX - m_sViewPointX;
				dY = m_pEffectList[i]->m_mY - m_sViewPointY;
				m_pEffectSpr[104]->PutTransSprite_NoColorKey(dX, dY, (rand() % 3), dwTime);
				break;
			}
		}
}

void CGame::bItemDrop_IconPannel(short msX, short msY)
{
	short sX, sY, sItemIndex;
	sX = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX;	sY = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY;

	sItemIndex = m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[sItemIndex] == true) return;
	if (m_cCommand < 0) return;
	if ((453 < msX) && (486 > msX) && (440 < msY) && (475 > msY))
	{
		bItemDrop_Inventory(m_dialogBoxManager.Info(DialogBoxId::Inventory).sX + (rand() % 148), m_dialogBoxManager.Info(DialogBoxId::Inventory).sY + (rand() % 55));
		return;
	}
	if ((425 < msX) && (448 > msX) && (440 < msY) && (475 > msY))
	{
		bItemDrop_Character();
		return;
	}
}



void CGame::DrawEffectLights()
{
	int i, dX, dY, iDvalue;
	uint32_t dwTime = m_dwCurTime;
	char  cTempFrame;
	for (i = 0; i < DEF_MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0) {
			switch (m_pEffectList[i]->m_sType) {
			case 1:
				break;

			case 2:
				break;

			case 4:
				break;

			case 5:	// Fire Explosion
				if (m_pEffectList[i]->m_cFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (m_pEffectList[i]->m_cFrame - 7) * (-1);
					if (m_pEffectList[i]->m_cFrame < 6)
						m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
					else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				break;

			case 6:	 // Energy Bolt
			case 10: // Lightning Arrow
				if (m_pEffectList[i]->m_cFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (m_pEffectList[i]->m_cFrame - 9) * (-1);
					if (m_pEffectList[i]->m_cFrame < 8)
						m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
					else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				break;
			case 7: // Magic Missile Explosion
				if (m_pEffectList[i]->m_cFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (m_pEffectList[i]->m_cFrame - 2) * (-1);
					if (m_pEffectList[i]->m_cFrame < 2)
						m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
					else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				break;

			case 16:
			case 61:
			case 66:
			case 100:
			case 110:
			case 120:
			case 130:
			case 137: // Lightning arrow
				//case 165: // APFM fixed green light
					// Light on ground below the flying effect
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				iDvalue = -5;
				m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
				break;

			case 69:
			case 70:
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[0]->PutTransSprite25(dX, dY + 30, 1, dwTime);
				break;

			case 33: //
				/*
				if (m_pEffectList[i]->m_cFrame >= 0) {
					dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
					if (m_pEffectList[i]->m_cFrame < 8)
						 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
					else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				*/
				break;

			case 40: //
			case 56:
				if (m_pEffectList[i]->m_cFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (m_pEffectList[i]->m_cFrame - 7) * (-1);
					if (m_pEffectList[i]->m_cFrame < 6)
						m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
					else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
				}
				break;

			case 52: // Protection Ring
				if (m_pEffectList[i]->m_cFrame >= 0)
				{
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[24]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				}
				break;

			case 57:
				if (m_pEffectList[i]->m_cFrame >= 0) {
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[30]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				}
				break;

			case 73:
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[74]->PutTransSprite(dX, dY - 34, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 74:
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[75]->PutTransSprite(dX, dY + 35, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 75: // Icegolem
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[76]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 76:// Icegolem
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[77]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 77:// Icegolem
				dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
				m_pEffectSpr[78]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 150: // Berserk : Cirlcle 6 magic
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[58]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
				break;

			case 180: // Ilusion
			case 190: // Mass Illusion
				cTempFrame = m_pEffectList[i]->m_cFrame;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[59]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
				//if( cTempFrame < 9 ) m_pEffectSpr[59]->PutTransSprite_NoColorKey( dX, dY, cTempFrame, dwTime );
				//else m_pEffectSpr[59]->PutSpriteFast( dX, dY, cTempFrame, dwTime );
				break;

			case 177: // Illusion mvt
			case 195: // Mass Illusion mvt
				cTempFrame = m_pEffectList[i]->m_cFrame;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[102]->PutTransSprite_NoColorKey(dX, dY + 30, cTempFrame, dwTime);
				break;

			case 183: // Inhibition casting
				cTempFrame = m_pEffectList[i]->m_cFrame;
				dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
				dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
				m_pEffectSpr[95]->PutTransSprite_NoColorKey(dX, dY + 40, cTempFrame, dwTime);
				break;
			}
		}
}

void CGame::_LoadShopMenuContents(char cType)
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;
	char* pBuffer;

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));
	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else {
		pBuffer = new char[dwFileSize + 1];
		std::memset(pBuffer, 0, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);

		__bDecodeContentsAndBuildItemForSaleList(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
}

bool CGame::__bDecodeContentsAndBuildItemForSaleList(char* pBuffer)
{
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemForSaleListIndex = 0;

	pContents = pBuffer;

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			//
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					std::memset(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, 0, sizeof(m_pItemForSaleList[iItemForSaleListIndex]->m_cName));
					memcpy(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:	// m_cItemType
					m_pItemForSaleList[iItemForSaleListIndex]->m_cItemType = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // m_cEquipPos
					m_pItemForSaleList[iItemForSaleListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // m_sItemEffectType
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 5;
					break;
				case 5:	// m_sItemEffectValue1
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 6;
					break;
				case 6: // m_sItemEffectValue2
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_sItemEffectValue3
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 8;
					break;
				case 8: // m_sItemEffectValue4
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_sItemEffectValue5
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 10;
					break;
				case 10: // m_sItemEffectValue6
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_wMaxLifeSpan
					m_pItemForSaleList[iItemForSaleListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 12;
					break;
				case 12: // m_sMaxFixCount
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sMaxFixCount = atoi(token);
					cReadModeB = 13;
					break;
				case 13: // m_sSprite
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSprite = atoi(token);
					cReadModeB = 14;
					break;
				case 14: // m_sSpriteFrame
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 15;
					break;
				case 15: // m_wPrice
					m_pItemForSaleList[iItemForSaleListIndex]->m_wPrice = atoi(token);
					cReadModeB = 16;
					break;
				case 16: // m_wWeight
					m_pItemForSaleList[iItemForSaleListIndex]->m_wWeight = atoi(token);
					cReadModeB = 17;
					break;
				case 17: // Appr Value
					//m_pItemForSaleList[iItemForSaleListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 18;
					break;
				case 18: // m_cSpeed
					m_pItemForSaleList[iItemForSaleListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 19;
					break;
				case 19: // Level Limit
					m_pItemForSaleList[iItemForSaleListIndex]->m_sLevelLimit = atoi(token);
					m_pItemForSaleList[iItemForSaleListIndex]->m_dwCount = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					iItemForSaleListIndex++;
					break;
				}
				break;

			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "ItemForSale", 4) == 0)
			{
				if (iItemForSaleListIndex >= DEF_MAXMENUITEMS)
				{
					return false;
				}
				cReadModeA = 1;
				cReadModeB = 1;
				m_pItemForSaleList[iItemForSaleListIndex] = new class CItem;
			}
		}
		token = strtok(NULL, seps);
	}
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}


static char __cSpace[] = { 8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8, 8,6,8,7,8,8,9,10,9,7, 8,8,8,8,8, 8,8,
						  15,16,12,17,14,15,14,16,10,13, 19,10,17,17,15,14,15,16,13,17, 16,16,20,17,16,14,
						  8,8,8,8,8,8,	8,6,7,8,7,7,7,7,4,7,7,  4,11,7,8,8,7,8,6,5,8,9,14,8,9,8, 8,8,8,8,
						  8,8,8,8,8,8,8 };
void CGame::PutString_SprFont(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[100];

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos + 1, iY, cTmpStr[iCnt] - 33, sR + 11, sG + 7, sB + 6, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, sR, sG, sB, dwTime);
			iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont2(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos, iR, iG, iB;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[200];

	m_DDraw.ColorTransferRGB(RGB(sR, sG, sB), &iR, &iG, &iB);

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos + 1, iY, cTmpStr[iCnt] - 33, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos + 1, iY + 1, cTmpStr[iCnt] - 33, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, iR, iG, iB, dwTime);
			iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont3(int iX, int iY, char* pStr, short sR, short sG, short sB, bool bTrans, int iType)
{
	int iXpos, iAdd;
	uint32_t iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[128];

	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	if (iType != -1) {
		iAdd = 95 * iType;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == false) {
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY + 1, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos + 1, iY + 1, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, sR, sG, sB, dwTime);

				}
				else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, sR, sG, sB, dwTime);

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->m_stBrush[cTmpStr[iCnt] - 32 + iAdd].szx);
			}
			else iXpos += 5;
		}
	}
	else {
		iAdd = 0;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == false) {
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY + 1, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos + 1, iY + 1, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, dwTime);
					else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, sR, sG, sB, dwTime);

				}
				else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 + iAdd, sR, sG, sB, dwTime);

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_FONT2]->m_stBrush[cTmpStr[iCnt] - 32 + iAdd].szx);
			}
			else iXpos += 5;
		}
	}
}

static char __cSpace2[] = { 6,4,6,6,6,6,6,6,6,6,6 }; //{8,6,9,8,8,9,8,8,8,8};
void CGame::PutString_SprNum(int iX, int iY, char* pStr, short sR, short sG, short sB)
{
	int iXpos;
	unsigned char iCnt;
	uint32_t dwTime = G_dwGlobalTime;
	char  cTmpStr[200];
	uint16_t wR, wG, wB;
	std::memset(cTmpStr, 0, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(sR, sG, sB), &wR, &wG, &wB);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++)
	{
		if ((cTmpStr[iCnt] >= 0x30) && (cTmpStr[iCnt] <= 0x39))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos + 2, iY, cTmpStr[iCnt] - 0x30 + 6, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos + 1, iY + 1, cTmpStr[iCnt] - 0x30 + 6, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos, iY, cTmpStr[iCnt] - 0x30 + 6, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 0x30 + 6, wR, wG, wB, dwTime);
			iXpos += __cSpace2[cTmpStr[iCnt] - 0x30];
		}
	}
}

void CGame::PutString(int iX, int iY, char* pString, COLORREF color, bool bHide, char cBGtype, bool bIsPreDC)
{
	char* pTmp;
	int i;
	if (strlen(pString) == 0) return;
	if (bIsPreDC == false) m_DDraw._GetBackBufferDC();
	if (bHide == false)
	{
		switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX + 1, iY, pString, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY + 1, pString, RGB(5, 5, 5));
			m_DDraw.TextOut(iX + 1, iY + 1, pString, RGB(5, 5, 5));
			m_DDraw.TextOut(iX + 1, iY, pString, RGB(5, 5, 5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pString, color);
	}
	else
	{
		pTmp = new char[strlen(pString) + 2];
		std::memset(pTmp, 0, strlen(pString) + 2);
		strcpy(pTmp, pString);
		for (i = 0; i < (int)strlen(pString); i++)
			if (pTmp[i] != 0) pTmp[i] = '*';

		switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX + 1, iY, pTmp, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY + 1, pTmp, RGB(5, 5, 5));
			m_DDraw.TextOut(iX + 1, iY + 1, pTmp, RGB(5, 5, 5));
			m_DDraw.TextOut(iX + 1, iY, pTmp, RGB(5, 5, 5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pTmp, color);
		delete[] pTmp;
	}
	if (bIsPreDC == false) m_DDraw._ReleaseBackBufferDC();
}


void CGame::PutString(int iX, int iY, char* pString, COLORREF color)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX, iY, pString, color);
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutString2(int iX, int iY, char* pString, short sR, short sG, short sB)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX + 1, iY, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY + 1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX + 1, iY + 1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutAlignedString(int iX1, int iX2, int iY, char* pString, short sR, short sG, short sB)
{
	RECT rt;
	m_DDraw._GetBackBufferDC();
	SetRect(&rt, iX1, iY, iX2, iY + 15);
	m_DDraw.DrawText(&rt, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

bool CGame::bInitMagicCfgList()
{
	char cFn[255], cTemp[255];
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicCfgListIndex = 0;
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFn, 0, sizeof(cFn));

	// CLEROTH - MAGIC CFG
	strcpy(cTemp, "magiccfg.txt");

	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (m_pMagicCfgList[atoi(token)] != 0)
					{
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[atoi(token)] = new class CMagic;
					iMagicCfgListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					std::memset(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, 0, sizeof(m_pMagicCfgList[iMagicCfgListIndex]->m_cName));
					memcpy(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_sValue1
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_sValue2	// INT
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // m_sValue3	// COST
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 6;
					break;

					// CLEROTH MAGIC CFG
				case 6: // m_sValue4	// STR
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // m_sValue5
					cReadModeB = 8;
					break;

				case 8: // m_sValue6
					cReadModeB = 9;
					break;

				case 9: // m_bIsVisible
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (atoi(token) == 0) m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = false;
					else m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = true;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return false;
	}

	return true;
}

bool CGame::bCheckImportantFile()
{
	HANDLE hFile;

#ifndef _DEBUG
	hFile = CreateFile("CONTENTS\\badword.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	CloseHandle(hFile);
#endif

	hFile = CreateFile("SPRITES\\TREES1.PAK", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	//	// FileSize : 1846406.... Anti Tree1.pak hack....inutile ca peut se modifier sans changer la taille!
	//	if( GetFileSize( hFile, 0 ) != 2945524 )
	//	{	CloseHandle( hFile );
	//		return false;
	//	}

	CloseHandle(hFile);
	return true;
}

bool CGame::bInitSkillCfgList()
{
	char cFn[255], cTemp[255];
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillCfgListIndex = 0;
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFn, 0, sizeof(cFn));

	strcpy(cTemp, "Skillcfg.txt");
	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false)
					{
						delete[] pContents;
						return false;
					}
					if (m_pSkillCfgList[atoi(token)] != 0)
					{
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[atoi(token)] = new class CSkill;
					iSkillCfgListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					std::memset(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, 0, sizeof(m_pSkillCfgList[iSkillCfgListIndex]->m_cName));
					memcpy(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_bIsUseable
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_bIsUseable = (bool)atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_cUseMethod
					if (_bGetIsStringIsNumber(token) == false) {
						delete[] pContents;
						return false;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_cUseMethod = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return false;
	}

	return true;
}


bool CGame::_bGetIsStringIsNumber(char* pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}


void CGame::RequestFullObjectData(uint16_t wObjectID)
{
	int     iRet;
	hb::net::PacketHeader header{};
	header.msg_id = MSGID_REQUEST_FULLOBJECTDATA;
	header.msg_type = wObjectID;

	iRet = m_pGSock->iSendMsg(reinterpret_cast<char*>(&header), sizeof(header));

	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);

		delete m_pGSock;
		m_pGSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = 0;

		if (G_pCalcSocket != 0) {
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		break;
	}
}


bool   CGame::DrawObject_OnAttack(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	default:
		if (_tmp_sAppr2 != 0)
		{
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			_tmp_cFrame = _tmp_sAppr2 - 1;
		}
		else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
				{
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				}
				else
				{
					m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame - 1, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // FireWyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))
			{
				m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
			}
			else
				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame - 1, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel((_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 8, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX - 50, sY - 50, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX - 20, sY - 80, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX + 70, sY - 50, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX - 30, sY, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX - 60, sY + 90, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX + 65, sY + 85, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 108, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 50, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 70, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 105, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 90, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX - 35, sY + 100, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 80, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 65, sY - 5, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX + 45, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 31, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX + 40, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 30, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX + 20, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 20, sY + 16, _tmp_iEffectFrame % 15, dwTime);
			break;
		}
	}

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}


bool   CGame::DrawObject_OnAttackMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex, dx, dy, dsx, dsy;
	int cFrameMoveDots;
	bool bInv = false, bDashDraw = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_cFrame) {
	case 4:  _tmp_cFrame = 4; break;
	case 5:  _tmp_cFrame = 4; break;
	case 6:  _tmp_cFrame = 4; break;
	case 7:  _tmp_cFrame = 4; break;
	case 8:  _tmp_cFrame = 4; break;
	case 9:  _tmp_cFrame = 4; break;
	case 10: _tmp_cFrame = 5; break;
	case 11: _tmp_cFrame = 6; break;
	case 12: _tmp_cFrame = 7; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1) && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 5;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;
	default:
		iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if ((_tmp_cFrame >= 1) && (_tmp_cFrame <= 3))
	{
		switch (_tmp_cFrame) {
		case 1: cFrameMoveDots = 26; break;
		case 2: cFrameMoveDots = 16; break;
		case 3: cFrameMoveDots = 0;  break;
		}
		switch (_tmp_cDir) {
		case 1: dy = cFrameMoveDots; break;
		case 2: dy = cFrameMoveDots; dx = -cFrameMoveDots; break;
		case 3: dx = -cFrameMoveDots; break;
		case 4: dx = -cFrameMoveDots; dy = -cFrameMoveDots; break;
		case 5: dy = -cFrameMoveDots; break;
		case 6: dy = -cFrameMoveDots; dx = cFrameMoveDots; break;
		case 7: dx = cFrameMoveDots; break;
		case 8: dx = cFrameMoveDots; dy = cFrameMoveDots; break;
		}
		switch (_tmp_cFrame) {
		case 1: dy++;    break;
		case 2: dy += 2; break;
		case 3: dy++;    break;
		}
		switch (_tmp_cFrame) {
		case 2: bDashDraw = true; cFrameMoveDots = 26; break;
		case 3: bDashDraw = true; cFrameMoveDots = 16; break;
		}
		dsx = 0;
		dsy = 0;
		switch (_tmp_cDir) {
		case 1: dsy = cFrameMoveDots; break;
		case 2: dsy = cFrameMoveDots; dsx = -cFrameMoveDots; break;
		case 3: dsx = -cFrameMoveDots; break;
		case 4: dsx = -cFrameMoveDots; dsy = -cFrameMoveDots; break;
		case 5: dsy = -cFrameMoveDots; break;
		case 6: dsy = -cFrameMoveDots; dsx = cFrameMoveDots; break;
		case 7: dsx = cFrameMoveDots; break;
		case 8: dsx = cFrameMoveDots; dsy = cFrameMoveDots; break;
		}
	}
	else if (_tmp_cFrame > 3)
	{
		dx = 0;
		dy = 0;
	}
	else
	{
		switch (_tmp_cDir) {
		case 1: dy = 32; break;
		case 2: dy = 32; dx = -32; break;
		case 3: dx = -32; break;
		case 4: dx = -32; dy = -32; break;
		case 5: dy = -32; break;
		case 6: dy = -32; dx = 32; break;
		case 7: dx = 32; break;
		case 8: dx = 32; dy = 32; break;
		}
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX + dx, sY + dy, _tmp_cFrame);

	if (_tmp_iEffectType != 0) {
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX + dx, sY + dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX + dx, sY + dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX + dx, sY + dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame - 1, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX + dx, sY + dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;

			default:
				if (m_cDetailLevel != 0 && !bInv) {
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX + dx, sY + dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}


			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13 + dx, sY - 34 + dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame - 1, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			}
		}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(8 + (_tmp_cDir - 1), sX + dx + 20, sY + dy - 20, _tmp_cFrame % 8, dwTime);
		CheckActiveAura2(sX + dx, sY + dy, dwTime, _tmp_sOwnerType);

		if (bDashDraw == true) {
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX + dsx, sY + dsy, _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			if (iWeaponIndex != -1) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX + dsx, sY + dsy, _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
			if (iShieldIndex != -1) m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX + dsx, sY + dsy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime);
		}
	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX + dx, sY + dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX + dx, sY + dy, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX + dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY + dy;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;

	return false;
}


bool   CGame::DrawObject_OnMagic(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
			bInv = true;
		else
		{
			if (_tmp_iChatIndex != 0)
			{
				if (m_pChatMsgList[_tmp_iChatIndex] != 0)
				{
					m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
					m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
				}
				else
				{
					m_pMapData->ClearChatMsg(indexX, indexY);
				}
			}
			return false;
		}
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 8;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 8;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 8;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 8;
		break;
	}

	/*
	switch (_tmp_cFrame) {
	case 15:
		_tmp_cFrame = 14;
		break;
	case 16:
		_tmp_cFrame = 14;
		break;
	case 17:
		_tmp_cFrame = 15;
		break;
	case 18:
		_tmp_cFrame = 15;
		break;
	case 19:
		_tmp_cFrame = 15;
		break;
	case 20:
		_tmp_cFrame = 15;
		break;
	case 21:
		_tmp_cFrame = 15;
		break;
	case 22:
		_tmp_cFrame = 15;
		break;
	case 23:
		_tmp_cFrame = 14;
		break;
	}
	*/
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (m_cDetailLevel != 0 && !bInv) {
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}

		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}

		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
		}

		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
		}

		if (iMantleIndex != -1)
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 16 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(32 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 16, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool   CGame::DrawObject_OnGetItem(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (9 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 9;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 9; 		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (9 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 9;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 9;
		break;
	default:
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (m_cDetailLevel != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1)
		{
			if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}
		}

		if (iPantsIndex != -1)
		{
			if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}
		}

		if (iArmArmorIndex != -1)
		{
			if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}
		}

		if (iBodyArmorIndex != -1)
		{
			if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}
		}

		if (iHelmIndex != -1)
		{
			if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}
		}

		if (iMantleIndex != -1)
		{
			if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnDamage(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB;
	int iAdd, iDrawMode, iMantleIndex;
	char cFrame;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	cFrame = _tmp_cFrame;
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 4)
		{
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
			iDrawMode = 0;
		}
		else
		{
			cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 10;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
			iDrawMode = 1;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if (cFrame < 4)
		{
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
			iDrawMode = 0;
		}
		else
		{
			cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 10;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
			iDrawMode = 1;
		}
		break;

	default:
		if (cFrame < 4)
		{
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		}
		else
		{
			cFrame -= 4;
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
		}
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		iDrawMode = 0;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (iDrawMode == 1) // Etrange, 1 semble impossible avec des mobs !
		{
			if (_cDrawingOrder[_tmp_cDir] == 1)
			{
				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (m_cDetailLevel != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else
				{
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}
			else
			{
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (m_cDetailLevel != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else
				{
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
			}

			if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			DrawAngel(16 + (_tmp_cDir - 1), sX + 20, sY - 20, cFrame % 4, dwTime);
			CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

		}
		else // DrawMode != 1
		{
			if (_cDrawingOrder[_tmp_cDir] == 1)
			{
				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (m_cDetailLevel != 0 && !bInv)
					{
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}
			else
			{
				switch (_tmp_sOwnerType) {
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
					//case 66: // Wyvern
					//case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
					break;
				default:
					if (m_cDetailLevel != 0 && !bInv) {
						if (sX < 50)
							m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

				if (_tmp_sOwnerType == 81) // Abaddon
				{
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}
				else if (bInv == true)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}

				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iShieldIndex != -1)
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
					switch (iShieldGlare) {
					case 0: break;
						//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}

				if (iWeaponIndex != -1)
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
			}

			if ((_tmp_iStatus & 0x20) != 0)	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			DrawAngel(16 + (_tmp_cDir - 1), sX + 20, sY - 20, cFrame % 4, dwTime);
			CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);
		}
	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX - 50, sY - 50, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX - 20, sY - 80, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX + 70, sY - 50, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX - 30, sY, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX - 60, sY + 90, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX + 65, sY + 85, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 108, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 50, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 70, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 105, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 90, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX - 35, sY + 100, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 80, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 65, sY - 5, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX + 45, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 31, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX + 40, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 30, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX + 20, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 20, sY + 16, _tmp_iEffectFrame % 15, dwTime);
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;

	return false;
}

bool CGame::DrawObject_OnDying(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;
	char cFrame;
	int randFrame;

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	cFrame = _tmp_cFrame;

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 6)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		else
		{
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 11;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if (cFrame < 6)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		else
		{
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 11;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		}
		break;

	default:
		if (cFrame < 4)
		{
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
			iUndiesIndex = -1;
			iHairIndex = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex = -1;
			switch (_tmp_sOwnerType) {
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT
			case 40: // ESG
			case 41: // GMG
			case 42: // ManaStone
				if (_tmp_sAppr2 == 0) cFrame = 0;
				break;
			case 51: cFrame = 0; break;
			}
		}
		else
		{
			switch (_tmp_sOwnerType) {
			case 51: cFrame = 0; break;
			default: cFrame -= 4; break;
			}
			if (_tmp_sAppr2 != 0)
			{
				iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
				cFrame = _tmp_sAppr2 - 1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			iUndiesIndex = -1;
			iHairIndex = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex = -1;
		}
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (m_cDetailLevel != 0)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
			}
			break;
		}
		if (_tmp_sOwnerType == 81)
		{
			m_pEffectSpr[152]->PutTransSprite70(sX - 80, sY - 15, _tmp_iEffectFrame % 27, dwTime); // Explosion Abaddon
			m_pEffectSpr[152]->PutTransSprite70(sX, sY - 15, _tmp_iEffectFrame % 27, dwTime);
			m_pEffectSpr[152]->PutTransSprite70(sX - 40, sY, _tmp_iEffectFrame % 27, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX - 90, sY - 80, _tmp_iEffectFrame % 12, dwTime); // Ames qui s'envolent
			m_pEffectSpr[160]->PutTransSprite70(sX - 60, sY - 50, _tmp_iEffectFrame % 12, dwTime);
			m_pEffectSpr[161]->PutTransSprite70(sX - 30, sY - 20, _tmp_iEffectFrame % 12, dwTime);
			m_pEffectSpr[162]->PutTransSprite70(sX, sY - 100, _tmp_iEffectFrame % 12, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX + 30, sY - 30, _tmp_iEffectFrame % 12, dwTime);
			m_pEffectSpr[162]->PutTransSprite70(sX + 60, sY - 90, _tmp_iEffectFrame % 12, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX + 90, sY - 50, _tmp_iEffectFrame % 12, dwTime);
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[140]->PutTransSprite70(sX, sY, cFrame, dwTime); break; // Abbadon dying
			case 2: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame, dwTime); break; // fixed sprit IDs
			case 3: m_pEffectSpr[142]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 4: m_pEffectSpr[143]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 5: m_pEffectSpr[144]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 6: m_pEffectSpr[145]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 7: m_pEffectSpr[146]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 8: m_pEffectSpr[147]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			}
		}
		else if (_tmp_sOwnerType == 66) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
		else if (_tmp_sOwnerType == 73)
		{	//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
			m_pSprite[33]->PutTransSprite(sX, sY, cFrame, dwTime);
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break; // Abbadon qui meurt
			case 2: m_pEffectSpr[142]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
			case 3: m_pEffectSpr[143]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
			case 4: m_pEffectSpr[144]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
			case 5: m_pEffectSpr[145]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
			case 6: m_pEffectSpr[146]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
			case 7: m_pEffectSpr[147]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break;
				//case 8: m_pEffectSpr[148]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 8: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame + 8, dwTime); break; //due to buggy Sprite nb
			}
		}
		else
		{
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
		}

		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}

		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}

		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
		}

		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
		}

		if (iMantleIndex != -1)
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
		DrawAngel(24 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool   CGame::DrawObject_OnDead(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iFrame, iMantleIndex, iHelmIndex;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 66) return false;

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 11;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 11;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 11;
		break;
	default:
		switch (_tmp_sOwnerType) {
		case 28: // Troll
		case 29: // Ogre
		case 30: // Liche
		case 31: // DD		// les 2 dernieres sont pas bonnes pour un mort !
		case 63: // Frost	// les 2 dernieres sont pas bonnes pour un mort !
			iFrame = 5;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 32: // Uni
		case 33: // WW
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
		case 48: // SK
		case 49: // HC
		case 50: // TW
		case 53: // BB
		case 54: // DE
		case 55: // Rabbit
		case 56: // Cat
		case 57: // Frog
		case 58: // MG
		case 59: // Ettin
		case 60: // Plant
		case 61: // Rudolph
		case 62: // Direboar
		case 64: // Crops  ----------- Crop ici! etonant, pourtant !
		case 65: // IceGolem
		case 70: // Dragon..........Ajouts par Snoopy
		case 71: // Centaur
		case 72: // ClawTurtle
		case 74: // GiantCrayfish
		case 75: // Gi Lizard
		case 76: // Gi Tree
		case 77: // Master Orc
		case 78: // Minaus
		case 79: // Nizie
		case 80: // Tentocle
		case 82: // Sorceress
		case 83: // ATK
		case 84: // MasterElf
		case 85: // DSK
		case 88: // Barbarian
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 86: // HBT
		case 87: // CT
		case 89: // AGC
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			break;

		case 66: // Wyvern
			iFrame = 15;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			break;

		case 73: // FireWyvern
			iFrame = 7;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			bTrans = true; // Prevents showing hugly corpse
			break;

		case 81: // Abaddon
			iFrame = 0;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
			bTrans = true; // Prevents showing hugly corpse
			break;

		case 51: // CP
			iFrame = 0;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 52: // GG
			iFrame = 11;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;

		case 91: // Gate
			iFrame = 5;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
			break;

		default: // 40*4 (10...27)
			iFrame = 3;
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			break;
		}
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (bTrans == false)
	{
		if (_tmp_cFrame == -1)
		{
			_tmp_cFrame = 7;
			if ((_tmp_iStatus & 0x40) != 0)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, iFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, iFrame, dwTime);

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if (iMantleIndex != -1)
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}
		}
		else if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, iFrame, -2 * _tmp_cFrame + 5, -2 * _tmp_cFrame - 5, -2 * _tmp_cFrame - 5, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, iFrame, -2 * _tmp_cFrame, -2 * _tmp_cFrame, -2 * _tmp_cFrame, dwTime);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearDeadChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		Abaddon_corpse(sX, sY); // By Snoopy....
	}
	else if (_tmp_sOwnerType == 73)
	{	//m_pEffectSpr[35]->PutTransSprite70(sX+120, sY+120, rand(), dwTime);
		m_pEffectSpr[35]->PutTransSprite70(sX + 20, sY - 15, rand() % 10, dwTime);
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}



bool   CGame::DrawObject_OnMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /* || _tmp_sOwnerType == 66 || _tmp_sOwnerType == 73*/)	bInv = true; //Energy-Ball, Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else  iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;

	default:
		if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;
	int value_2 = 30;
	switch (_tmp_cDir) {
	case 1: dy = value_2 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = value_2 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 3: dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 4: dx = (_tmp_cFrame << 2) + value - value_2; dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 5: dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 6: dy = (_tmp_cFrame << 2) + value - value_2; dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = value_2 - (_tmp_cFrame << 2) - value; dy = value_2 - (_tmp_cFrame << 2) - value; break;
	}

	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:

	case 28: // Troll.
	case 29: // Orge.
	case 30: // Liche
	case 31: // DD
	case 32: // Uni
	case 33: // ww

	case 43: // LWB
	case 44: // GHK
	case 45: // GHKABS
	case 46: // TK
	case 47: // BG
	case 48: // SK
	case 49: // HC
	case 50: // TW

	case 52: // GG
	case 53: // BB
	case 54: // DE
	case 55: // Rabbit
	case 56: // Cat
	case 57: // Frog
	case 58: // MG
	case 59: // Ettin
	case 60: // Plant
	case 61: // Rudolph
	case 62: // DireBoar
	case 63: // Frost

	case 65: // Ice-Golem
	case 66: // Wyvern

	case 70: // Dragon..........Ajouts par Snoopy
	case 71: // Centaur
	case 72: // ClawTurtle
	case 73: // FireWyvern
	case 74: // GiantCrayfish
	case 75: // Gi Lizard
	case 76: // Gi Tree
	case 77: // Master Orc
	case 78: // Minaus
	case 79: // Nizie
	case 80: // Tentocle
	case 81: // Abaddon
	case 82: // Sorceress
	case 83: // ATK
	case 84: // MasterElf
	case 85: // DSK
	case 86: // HBT
	case 87: // CT
	case 88: // Barbarian
	case 89: // AGC
	case 90: // Gail
		break;

	default:
		_tmp_cFrame = _tmp_cFrame / 2;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (_tmp_sOwnerType == 65) // IceGolem
	{	/*m_pEffectSpr[77]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);*/
		switch (rand() % 3) {
		case 0:	m_pEffectSpr[76]->PutTransSprite70(fix_x, fix_y, _tmp_cFrame, dwTime); break;
		case 1:	m_pEffectSpr[77]->PutTransSprite70(fix_x, fix_y, _tmp_cFrame, dwTime); break;
		case 2:	m_pEffectSpr[78]->PutTransSprite70(fix_x, fix_y, _tmp_cFrame, dwTime); break;
		}
	}
	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(fix_x, fix_y, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv) {
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(fix_x, fix_y, 1, dwTime);

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
			}
			else if (bInv == true)
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(fix_x, fix_y, 1, dwTime);

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite70(fix_x, fix_y, _tmp_cFrame, dwTime);
			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(fix_x, fix_y, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_iEffectFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX - 50, sY - 50, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX - 20, sY - 80, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX + 70, sY - 50, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX - 30, sY, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX - 60, sY + 90, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX + 65, sY + 85, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(fix_x, fix_y + 108, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 50, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(fix_x, fix_y + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 70, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(fix_x, fix_y + 105, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 90, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(fix_x - 35, fix_y + 100, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 80, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(fix_x, fix_y + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 65, fix_y - 5, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(fix_x + 45, fix_y + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 31, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(fix_x + 40, fix_y + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 30, fix_y + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(fix_x + 20, fix_y + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(fix_x - 20, fix_y + 16, _tmp_iEffectFrame % 15, dwTime);
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnDamageMove(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int cFrame, cDir;
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 67 || _tmp_sOwnerType == 68 || _tmp_sOwnerType == 69 || _tmp_sOwnerType == 81) return false;
	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}
	cDir = _tmp_cDir;
	switch (_tmp_cDir) {
	case 1: _tmp_cDir = 5; break;
	case 2: _tmp_cDir = 6; break;
	case 3: _tmp_cDir = 7; break;
	case 4: _tmp_cDir = 8; break;
	case 5: _tmp_cDir = 1; break;
	case 6: _tmp_cDir = 2; break;
	case 7: _tmp_cDir = 3; break;
	case 8: _tmp_cDir = 4; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 10;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (10 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 10;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 10;
		break;
	default:
		if (_tmp_sOwnerType == 66)      iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);// Ne devrait pas arriver!
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (2 * 8);// Ne devrait pas arriver!
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (3 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;

	switch (_tmp_cDir) {
	case 1: dy = 30 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = 30 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - 30; break;
	case 3: dx = (_tmp_cFrame << 2) + value - 30; break;
	case 4: dx = (_tmp_cFrame << 2) + value - 30; dy = (_tmp_cFrame << 2) + value - 30; break;
	case 5: dy = (_tmp_cFrame << 2) + value - 30; break;
	case 6: dy = (_tmp_cFrame << 2) + value - 30; dx = 30 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = 30 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = 30 - (_tmp_cFrame << 2) - value; dy = 30 - (_tmp_cFrame << 2) - value; break;
	}

	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}
	cFrame = _tmp_cFrame;
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, cFrame);
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, cFrame, dwTime);
				}
				break;
			}

			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{
				if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{
				if (iHelmColor == 0)
					m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iShieldIndex != -1)
			{
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 4 + cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x, fix_y, cFrame, 0, -5, -5, dwTime);
		DrawAngel(16 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

bool CGame::DrawObject_OnMove_ForMenu(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	short dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
	bool bInv = false;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
	iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
	iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
	iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
	iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
	iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
	iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
	iHelmColor = (_tmp_iApprColor & 0x0000000F);

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else
				{
					iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
				}
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iAdd = 3;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + iAdd;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + iAdd;
			}
			else  iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + iAdd;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 2;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 2;
			}
			else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 2;
		}
		break;
	default:
		iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (1 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if (_cDrawingOrder[_tmp_cDir] == 1)
	{
		if (iWeaponIndex != -1)
		{
			if (iWeaponColor == 0)
				m_pSprite[iWeaponIndex]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
		}
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (m_cDetailLevel != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			}
			break;
		}
		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);


		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}
		if (iUndiesIndex != -1)
		{
			if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}
		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
		}
		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}
		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
		}
		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}

		if (iShieldIndex != -1)
		{
			if (iShieldColor == 0)
				m_pSprite[iShieldIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}
	}
	else
	{
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
			//case 66: // Wyvern
			//case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
			break;
		default:
			if (m_cDetailLevel != 0 && !bInv)
			{
				if (sX < 50)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX + dx, sY + dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == true)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX + dx, sY + dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);

		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}
		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}
		if (iPantsIndex != -1)
		{
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
		}
		if (iArmArmorIndex != -1)
		{
			if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
		}
		if (iBodyArmorIndex != -1)
		{
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
		}
		if (iHelmIndex != -1)
		{
			if (iHelmColor == 0)
				m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}

		if (iShieldIndex != -1)
		{
			if (iShieldColor == 0)
				m_pSprite[iShieldIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX + dx, sY + dy, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
		}
		if (iWeaponIndex != -1)
		{
			if (iWeaponColor == 0)
				m_pSprite[iWeaponIndex]->PutSpriteFast(sX + dx, sY + dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX + dx, sY + dy, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
		}
	}

	if (_tmp_iChatIndex != 0)
	{
		if (m_pChatMsgList[_tmp_iChatIndex] != 0)
		{
			DrawChatMsgBox(sX + dx, sY + dy, _tmp_iChatIndex, false);
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}


bool   CGame::DrawObject_OnStop(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY)
{
	int iBodyIndex, iUndiesIndex, iHairIndex, iBodyArmorIndex, iArmArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
	int iWeaponIndex, iShieldIndex, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/ || _tmp_sOwnerType == 81) bInv = true; //Energy-Ball, Wyvern
	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	// CLEROTH - Single-direction monsters
	switch (_tmp_sOwnerType) {
	case 110: // Air Elemental
		_tmp_cDir = 1; // North
		break;
	case 91: // Snoopy: Gate
		if (_tmp_cDir <= 3) _tmp_cDir = 3;
		else  _tmp_cDir = 5;
		break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		_tmp_cFrame = _tmp_cFrame / 2;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 1;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 1;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		break;

	case 4:
	case 5:
	case 6:
		_tmp_cFrame = _tmp_cFrame / 2;
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 1;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 1;
		}
		else
		{
			iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15;
			iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 0;
		}
		break;
	default:
		if (_tmp_sAppr2 != 0)
		{
			iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (4 * 8);
			_tmp_cFrame = (_tmp_sAppr2 & 0x00FF) - 1;
		}
		/*	else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);*/
		else iBodyIndex = DEF_SPRID_MOB + (_tmp_sOwnerType - 10) * 8 * 7 + (0 * 8);
		iUndiesIndex = -1;
		iHairIndex = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex = -1;
		iBootsIndex = -1;
		iPantsIndex = -1;
		iWeaponIndex = -1;
		iShieldIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	switch (_tmp_sOwnerType) { // hum? la lumiere en dessous ?
	case 15: // ShopKeeper
	case 19: // Gandalf
	case 20: // Howard
	case 24: // Tom
	case 25: // William
	case 26: // Kenedy
	case 51: // CP
	case 86: // HBT
	case 90: // Gail
		m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
		break;
	}
	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}
	if (bTrans == false)
	{
		CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);

			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);

			}
			else if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			if (_tmp_sOwnerType == 81) // Abaddon
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			else if (bInv == true)
			{
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX - 13, sY - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}
		if (_tmp_sOwnerType == 64) // crop
		{
			switch (_tmp_cFrame) {
			case 0: // color effect for crop
				m_pEffectSpr[84]->PutTransSprite(sX + 52, sY + 54, (dwTime % 3000) / 120, dwTime);
				break;
			case 1: // color effect for crop
				m_pEffectSpr[83]->PutTransSprite(sX + 53, sY + 59, (dwTime % 3000) / 120, dwTime);
				break;
			case 2: // color effect for crop
				m_pEffectSpr[82]->PutTransSprite(sX + 53, sY + 65, (dwTime % 3000) / 120, dwTime);
				break;
			}
		}
		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40 + (_tmp_cDir - 1), sX + 20, sY - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(sX, sY, dwTime, _tmp_sOwnerType);

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{
		int randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX - 50, sY - 50, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX - 20, sY - 80, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX + 70, sY - 50, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX - 30, sY, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX - 60, sY + 90, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX + 65, sY + 85, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 108, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 50, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 70, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 105, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 90, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX - 35, sY + 100, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 80, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 65, sY - 5, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX + 45, sY + 95, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 31, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX + 40, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 30, sY + 10, _tmp_iEffectFrame % 15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX + 20, sY + 110, _tmp_iEffectFrame % 28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX - 20, sY + 16, _tmp_iEffectFrame % 15, dwTime);
			break;
		}
	}
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

void CGame::_ReadMapData(short sPivotX, short sPivotY, const char* pData)
{
	int i;
	const char* cp;
	char ucHeader, cDir, cName[12], cItemColor;
	short sTotal, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sDynamicObjectType;
	int iStatus;
	int iApprColor;
	uint16_t wObjectID;
	uint16_t wDynamicObjectID;
	short sItemID;
	uint32_t dwItemAttr;

	cp = pData;
	m_sVDL_X = sPivotX; // Valid Data Loc-X
	m_sVDL_Y = sPivotY;

	const auto* mapHeader = hb::net::PacketCast<hb::net::PacketMapDataHeader>(cp, sizeof(hb::net::PacketMapDataHeader));
	if (!mapHeader) return;
	sTotal = mapHeader->total;
	cp += sizeof(hb::net::PacketMapDataHeader);
	for (i = 1; i <= sTotal; i++)
	{
		const auto* entry = hb::net::PacketCast<hb::net::PacketMapDataEntryHeader>(cp, sizeof(hb::net::PacketMapDataEntryHeader));
		if (!entry) return;
		sX = entry->x;
		sY = entry->y;
		ucHeader = entry->flags;
		cp += sizeof(hb::net::PacketMapDataEntryHeader);
		if (ucHeader & 0x01) // object ID
		{
			const auto* objBase = hb::net::PacketCast<hb::net::PacketMapDataObjectBase>(cp, sizeof(hb::net::PacketMapDataObjectBase));
			if (!objBase) return;
			if (objBase->object_id < 10000)
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectPlayer>(cp, sizeof(hb::net::PacketMapDataObjectPlayer));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = obj->appr1;
				sAppr2 = obj->appr2;
				sAppr3 = obj->appr3;
				sAppr4 = obj->appr4;
				iApprColor = obj->appr_color;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectPlayer);
			}
			else // NPC
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectNpc>(cp, sizeof(hb::net::PacketMapDataObjectNpc));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = sAppr3 = sAppr4 = 0;
				sAppr2 = obj->appr2;
				iApprColor = 0;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectNpc);
			}
			m_pMapData->bSetOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		}
		if (ucHeader & 0x02) // object ID
		{
			const auto* objBase = hb::net::PacketCast<hb::net::PacketMapDataObjectBase>(cp, sizeof(hb::net::PacketMapDataObjectBase));
			if (!objBase) return;
			if (objBase->object_id < 10000)
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectPlayer>(cp, sizeof(hb::net::PacketMapDataObjectPlayer));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = obj->appr1;
				sAppr2 = obj->appr2;
				sAppr3 = obj->appr3;
				sAppr4 = obj->appr4;
				iApprColor = obj->appr_color;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectPlayer);
			}
			else // NPC
			{
				const auto* obj = hb::net::PacketCast<hb::net::PacketMapDataObjectNpc>(cp, sizeof(hb::net::PacketMapDataObjectNpc));
				if (!obj) return;
				wObjectID = obj->base.object_id;
				sType = obj->base.type;
				cDir = static_cast<char>(obj->base.dir);
				sAppr1 = sAppr3 = sAppr4 = 0;
				sAppr2 = obj->appr2;
				iApprColor = 0;
				iStatus = obj->status;
				std::memset(cName, 0, sizeof(cName));
				memcpy(cName, obj->name, sizeof(obj->name));
				cp += sizeof(hb::net::PacketMapDataObjectNpc);
			}
			m_pMapData->bSetDeadOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName);
		}
		if (ucHeader & 0x04)
		{
			const auto* item = hb::net::PacketCast<hb::net::PacketMapDataItem>(cp, sizeof(hb::net::PacketMapDataItem));
			if (!item) return;
			sItemID = item->item_id;
			cItemColor = static_cast<char>(item->color);
			dwItemAttr = item->attribute;
			cp += sizeof(hb::net::PacketMapDataItem);
			m_pMapData->bSetItem(sPivotX + sX, sPivotY + sY, sItemID, cItemColor, dwItemAttr, false);
		}
		if (ucHeader & 0x08) // Dynamic object
		{
			const auto* dyn = hb::net::PacketCast<hb::net::PacketMapDataDynamicObject>(cp, sizeof(hb::net::PacketMapDataDynamicObject));
			if (!dyn) return;
			wDynamicObjectID = dyn->object_id;
			sDynamicObjectType = dyn->type;
			cp += sizeof(hb::net::PacketMapDataDynamicObject);
			m_pMapData->bSetDynamicObject(sPivotX + sX, sPivotY + sY, wDynamicObjectID, sDynamicObjectType, false);
		}
	}
}


void CGame::LogEventHandler(char* pData)
{
	WORD wEventType, wObjectID;
	short sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4;
	int iStatus;
	char cDir, cName[12];
	int iApprColor = 0;

	const auto* base = hb::net::PacketCast<hb::net::PacketEventLogBase>(pData, sizeof(hb::net::PacketEventLogBase));
	if (!base) return;
	wEventType = base->header.msg_type;
	wObjectID = base->object_id;
	sX = base->x;
	sY = base->y;
	sType = base->type;
	cDir = static_cast<char>(base->dir);
	std::memset(cName, 0, sizeof(cName));
	if (wObjectID < 10000)
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventLogPlayer>(pData, sizeof(hb::net::PacketEventLogPlayer));
		if (!pkt) return;
		memcpy(cName, pkt->name, sizeof(pkt->name));
		sAppr1 = pkt->appr1;
		sAppr2 = pkt->appr2;
		sAppr3 = pkt->appr3;
		sAppr4 = pkt->appr4;
		iApprColor = pkt->appr_color;
		iStatus = pkt->status;
	}
	else 	// NPC
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketEventLogNpc>(pData, sizeof(hb::net::PacketEventLogNpc));
		if (!pkt) return;
		memcpy(cName, pkt->name, sizeof(pkt->name));
		sAppr1 = sAppr3 = sAppr4 = 0;
		sAppr2 = pkt->appr2;
		iStatus = pkt->status;
	}

	switch (wEventType) {
	case DEF_MSGTYPE_CONFIRM:
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		switch (sType) {
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
			bAddNewEffect(64, (sX) * 32, (sY) * 32, 0, 0, 0);
			break;
		}
		break;

	case DEF_MSGTYPE_REJECT:
		m_pMapData->bSetOwner(wObjectID, -1, -1, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, 0, 0, 0);
		break;
	}

	_RemoveChatMsgListByObjectID(wObjectID);
}

// MODERNIZED: No longer a window message handler - polls socket directly
void CGame::OnLogSocketEvent()
{
	int iRet;
	char* pData;
	uint32_t dwMsgSize;
	if (m_pLSock == 0) return;

	// MODERNIZED: Poll() instead of iOnSocketEvent()
	iRet = m_pLSock->Poll();
	switch (iRet) {
	case 0:
		// No events
		return;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_LOG);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		pData = m_pLSock->pGetRcvDataPointer(&dwMsgSize);
		LogRecvMsgHandler(pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = 0;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = 0;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pLSock;
		m_pLSock = 0;
		break;
	}
}

void CGame::LogResponseHandler(char* pData)
{
	WORD wResponse;
	char cCharName[12];
	int i;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResponse = header->msg_type;

	switch (wResponse) {
	case DEF_LOGRESMSGTYPE_CHARACTERDELETED:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogCharacterListHeader>(
			pData, sizeof(hb::net::PacketLogCharacterListHeader));
		if (!list) return;
		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0)
			{
				delete m_pCharList[i];
				m_pCharList[i] = 0;
			}

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogCharacterListHeader));
		for (i = 0; i < m_iTotalChar; i++) {
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3A");
	}
	break;

	case DEF_LOGRESMSGTYPE_CONFIRM:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogCharacterListHeader>(
			pData, sizeof(hb::net::PacketLogCharacterListHeader));
		if (!list) return;
		m_iAccntYear = 0;
		m_iAccntMonth = 0;
		m_iAccntDay = 0;
		m_iIpYear = 0;
		m_iIpMonth = 0;
		m_iIpDay = 0;
		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0)
			{
				delete m_pCharList[i];
				m_pCharList[i] = 0;
			}

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogCharacterListHeader));
		for (i = 0; i < m_iTotalChar; i++)
		{
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		ClearContents_OnSelectCharacter();
	}
	break;

	case DEF_LOGRESMSGTYPE_REJECT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseReject>(pData, sizeof(hb::net::PacketLogResponseReject));
		if (!pkt) return;
		m_iBlockYear = pkt->block_year;
		m_iBlockMonth = pkt->block_month;
		m_iBlockDay = pkt->block_day;

		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7H");
	}
	break;

	case DEF_LOGRESMSGTYPE_NOTENOUGHPOINT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7I");
		break;

	case DEF_LOGRESMSGTYPE_ACCOUNTLOCKED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7K");
		break;

	case DEF_LOGRESMSGTYPE_SERVICENOTAVAILABLE:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "7L");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGESUCCESS:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6B");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGEFAIL:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6C");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDMISMATCH:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "11");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "12");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTCREATED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "54");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "05");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "06");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "Not existing character!");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERCREATED:
	{
		const auto* list = hb::net::PacketCast<hb::net::PacketLogNewCharacterCreatedHeader>(
			pData, sizeof(hb::net::PacketLogNewCharacterCreatedHeader));
		if (!list) return;
		std::memset(cCharName, 0, sizeof(cCharName));
		memcpy(cCharName, list->character_name, sizeof(list->character_name));

		m_iTotalChar = list->total_chars;
		for (i = 0; i < 4; i++)
			if (m_pCharList[i] != 0) delete m_pCharList[i];

		const auto* entries = reinterpret_cast<const hb::net::PacketLogCharacterEntry*>(
			pData + sizeof(hb::net::PacketLogNewCharacterCreatedHeader));
		for (i = 0; i < m_iTotalChar; i++) {
			const auto& entry = entries[i];
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, entry.name, sizeof(entry.name));
			m_pCharList[i]->m_sAppr1 = entry.appr1;
			m_pCharList[i]->m_sAppr2 = entry.appr2;
			m_pCharList[i]->m_sAppr3 = entry.appr3;
			m_pCharList[i]->m_sAppr4 = entry.appr4;
			m_pCharList[i]->m_sSex = entry.sex;
			m_pCharList[i]->m_sSkinCol = entry.skin;
			m_pCharList[i]->m_sLevel = entry.level;
			m_pCharList[i]->m_iExp = entry.exp;
			m_pCharList[i]->m_iApprColor = entry.appr_color;
			std::memset(m_pCharList[i]->m_cMapName, 0, sizeof(m_pCharList[i]->m_cMapName));
			memcpy(m_pCharList[i]->m_cMapName, entry.map_name, sizeof(entry.map_name));
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "47");
	}
	break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "28");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "29");
		break;

	case DEF_ENTERGAMERESTYPE_PLAYING:
		ChangeGameMode(DEF_GAMEMODE_ONQUERYFORCELOGIN);
		break;

	case DEF_ENTERGAMERESTYPE_CONFIRM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogEnterGameConfirm>(
			pData, sizeof(hb::net::PacketLogEnterGameConfirm));
		if (!pkt) return;
		int iGameServerPort = pkt->game_server_port;
		char cGameServerAddr[16];
		std::memset(cGameServerAddr, 0, sizeof(cGameServerAddr));
		memcpy(cGameServerAddr, pkt->game_server_addr, sizeof(pkt->game_server_addr));
		std::memset(m_cGameServerName, 0, sizeof(m_cGameServerName));
		memcpy(m_cGameServerName, pkt->game_server_name, sizeof(pkt->game_server_name));
		(void)iGameServerPort;

		m_pGSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
		m_pGSock->bConnect(m_cLogServerAddr, m_iGameServerPort);
		m_pGSock->bInitBufferSize(30000);
	}
	break;

	case DEF_ENTERGAMERESTYPE_REJECT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseCode>(pData, sizeof(hb::net::PacketLogResponseCode));
		if (!pkt) return;
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		switch (pkt->code) {
		case 1:	strcpy(m_cMsg, "3E"); break;
		case 2:	strcpy(m_cMsg, "3F"); break;
		case 3:	strcpy(m_cMsg, "33"); break;
		case 4: strcpy(m_cMsg, "3D"); break;
		case 5: strcpy(m_cMsg, "3G"); break;
		case 6: strcpy(m_cMsg, "3Z"); break;
		case 7: strcpy(m_cMsg, "3J"); break;
		}
	}
	break;

	case DEF_ENTERGAMERESTYPE_FORCEDISCONN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "3X");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGWORLDSERVER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1Y");
		break;

	case DEF_LOGRESMSGTYPE_INPUTKEYCODE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketLogResponseCode>(pData, sizeof(hb::net::PacketLogResponseCode));
		if (!pkt) return;
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		switch (pkt->code) {
		case 1:	strcpy(m_cMsg, "8U"); break; //MainMenu, Keycode registration success
		case 2:	strcpy(m_cMsg, "82"); break; //MainMenu, Not existing Account
		case 3:	strcpy(m_cMsg, "81"); break; //MainMenu, Password wrong
		case 4: strcpy(m_cMsg, "8V"); break; //MainMenu, Invalid Keycode
		case 5: strcpy(m_cMsg, "8W"); break; //MainMenu, Already Used Keycode
		}
	}
	break;

	case DEF_LOGRESMSGTYPE_FORCECHANGEPASSWORD:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "6M");
		break;

	case DEF_LOGRESMSGTYPE_INVALIDKOREANSSN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1a");
		break;

	case DEF_LOGRESMSGTYPE_LESSTHENFIFTEEN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		std::memset(m_cMsg, 0, sizeof(m_cMsg));
		strcpy(m_cMsg, "1b");
		break;
	}
	delete m_pLSock;
	m_pLSock = 0;
}


void CGame::LogRecvMsgHandler(char* pData)
{
	LogResponseHandler(pData);
}


void CGame::_InitOnCreateNewCharacter()
{
	m_cGender = rand() % 2 + 1;
	m_cSkinCol = rand() % 3 + 1;
	m_cHairStyle = rand() % 8;
	m_cHairCol = rand() % 16;
	m_cUnderCol = rand() % 8;
	m_ccStr = 10;
	m_ccVit = 10;
	m_ccDex = 10;
	m_ccInt = 10;
	m_ccMag = 10;
	m_ccChr = 10;
}

void CGame::ClearContents_OnCreateNewAccount()
{
	std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
	std::memset(m_cAccountAge, 0, sizeof(m_cAccountAge));
	std::memset(m_cAccountCountry, 0, sizeof(m_cAccountCountry));
	std::memset(m_cAccountSSN, 0, sizeof(m_cAccountSSN));
	std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
	//v1.4334
	std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
	std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
}

void CGame::ChangeGameMode(char cMode)
{
	m_cGameMode = cMode;
	m_cGameModeCount = 0;
	m_dwTime = G_dwGlobalTime;

#ifndef DEF_SELECTSERVER
	if (cMode == DEF_GAMEMODE_ONSELECTSERVER)
	{
		std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
		strcpy(m_cWorldServerName, NAME_WORLDNAME1);
		m_cGameMode = DEF_GAMEMODE_ONLOGIN;
	}
#endif
}

// Overlay system methods
void CGame::ShowOverlay(OverlayType type, char context, char message)
{
	m_activeOverlay = type;
	m_cOverlayContext = context;
	m_cOverlayMessage = message;
	m_dwOverlayStartTime = G_dwGlobalTime;
}

void CGame::HideOverlay()
{
	m_activeOverlay = OverlayType::None;
	m_cOverlayContext = 0;
	m_cOverlayMessage = 0;
}

void CGame::UpdateOverlay()
{
	// Handle input for the active overlay
	// This will be filled in when we convert each overlay screen
	switch (m_activeOverlay)
	{
	case OverlayType::Connecting:
		// ESC to cancel connection
		if (m_bEscPressed)
		{
			m_bEscPressed = false;
			HideOverlay();
			if (m_pGSock) m_pGSock->_CloseConn();
			if (m_pLSock) m_pLSock->_CloseConn();
		}
		break;

	case OverlayType::WaitingResponse:
		// ESC to cancel waiting
		if (m_bEscPressed)
		{
			m_bEscPressed = false;
			HideOverlay();
			if (m_pGSock) m_pGSock->_CloseConn();
			if (m_pLSock) m_pLSock->_CloseConn();
		}
		break;

	case OverlayType::LogResMsg:
		// Click to dismiss
		// Will be handled in the Draw phase click detection
		break;

	case OverlayType::QueryForceLogin:
		// Yes/No button handling
		break;

	case OverlayType::QueryDeleteCharacter:
		// Yes/No button handling
		break;

	default:
		break;
	}
}

void CGame::DrawOverlay()
{
	// Draw the overlay on top of the base screen
	// This will be filled in when we convert each overlay screen
	switch (m_activeOverlay)
	{
	case OverlayType::Connecting:
		// Draw "Connecting..." message
		break;

	case OverlayType::WaitingResponse:
		// Draw "Waiting for response..." message
		break;

	case OverlayType::LogResMsg:
		// Draw login response message
		break;

	case OverlayType::QueryForceLogin:
		// Draw force login confirmation dialog
		break;

	case OverlayType::QueryDeleteCharacter:
		// Draw delete character confirmation dialog
		break;

	default:
		break;
	}
}

bool CGame::bReadIp()
{
	std::memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, DEF_SERVER_IP);
	m_iLogServerPort = DEF_SERVER_PORT;
	m_iGameServerPort = DEF_GSERVER_PORT;
	return true;
}


void CGame::ReleaseUnusedSprites()
{
	int i;
	for (i = 0; i < DEF_MAXSPRITES; i++)
		if ((m_pSprite[i] != 0))
		{
			if ((m_pSprite[i]->m_bIsSurfaceEmpty == false) && (m_pSprite[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pSprite[i]->m_dwRefTime) > 60000) m_pSprite[i]->_iCloseSprite();

			}
		}
	for (i = 0; i < DEF_MAXTILES; i++)
		if ((m_pTileSpr[i] != 0))
		{
			if ((m_pTileSpr[i]->m_bIsSurfaceEmpty == false) && (m_pTileSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pTileSpr[i]->m_dwRefTime) > 60000) m_pTileSpr[i]->_iCloseSprite();
			}
		}
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
		if ((m_pEffectSpr[i] != 0))
		{
			if ((m_pEffectSpr[i]->m_bIsSurfaceEmpty == false) && (m_pEffectSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pEffectSpr[i]->m_dwRefTime) > 60000) m_pEffectSpr[i]->_iCloseSprite();
			}
		}

	// Stale sound buffer release is now handled by AudioManager::Update()
	AudioManager::Get().Update(G_dwGlobalTime);
}

void CGame::PutChatScrollList(char* pMsg, char cType)
{
	int i;
	if (m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] != 0)
	{
		delete m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1];
		m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] = 0;
	}
	for (i = DEF_MAXCHATSCROLLMSGS - 2; i >= 0; i--)
	{
		m_pChatScrollList[i + 1] = m_pChatScrollList[i];
		m_pChatScrollList[i] = 0;
	}
	m_pChatScrollList[0] = new class CMsg(1, pMsg, cType);
}

void CGame::ChatMsgHandler(char* pData)
{
	int i, iObjectID, iLoc;
	short sX, sY;
	char cMsgType, cName[21], cTemp[100], cMsg[100], cTxt1[100], cTxt2[100];
	uint32_t dwTime;
	bool bFlag;

	char cHeadMsg[200];

	dwTime = m_dwCurTime;

	std::memset(cTxt1, 0, sizeof(cTxt1));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	std::memset(cMsg, 0, sizeof(cMsg));

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandChatMsgHeader>(
		pData, sizeof(hb::net::PacketCommandChatMsgHeader));
	if (!pkt) return;
	iObjectID = static_cast<int>(pkt->header.msg_type);
	sX = pkt->x;
	sY = pkt->y;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, sizeof(pkt->name));
	cMsgType = static_cast<char>(pkt->chat_type);

	if (bCheckExID(cName) == true) return;

	std::memset(cTemp, 0, sizeof(cTemp));
	strcpy(cTemp, pData + sizeof(hb::net::PacketCommandChatMsgHeader));

	if ((cMsgType == 0) || (cMsgType == 2) || (cMsgType == 3))
	{
		if (CMisc::bCheckIMEString(cTemp) == false) return;
	}
	if (!m_bWhisper)
	{
		if (cMsgType == 20) return;
	}
	if (!m_bShout)
	{
		if (cMsgType == 2 || cMsgType == 3) return;
	}

	std::memset(cMsg, 0, sizeof(cMsg));
	wsprintf(cMsg, "%s: %s", cName, cTemp);
	m_DDraw._GetBackBufferDC();
	bFlag = false;
	short sCheckByte = 0;
	while (bFlag == false)
	{
		iLoc = CMisc::iGetTextLengthLoc(m_DDraw.m_hDC, cMsg, 305);
		for (int i = 0; i < iLoc; i++) if (cMsg[i] < 0) sCheckByte++;
		if (iLoc == 0)
		{
			PutChatScrollList(cMsg, cMsgType);
			bFlag = true;
		}
		else
		{
			if ((sCheckByte % 2) == 0)
			{
				std::memset(cTemp, 0, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc);
				PutChatScrollList(cTemp, cMsgType);
				std::memset(cTemp, 0, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc);
				std::memset(cMsg, 0, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
			else
			{
				std::memset(cTemp, 0, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc + 1);
				PutChatScrollList(cTemp, cMsgType);
				std::memset(cTemp, 0, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc + 1);
				std::memset(cMsg, 0, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
		}
	}

	m_DDraw._ReleaseBackBufferDC();

	_RemoveChatMsgListByObjectID(iObjectID);

	const char* cp = pData + sizeof(hb::net::PacketCommandChatMsgHeader);
	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == 0) {
			m_pChatMsgList[i] = new class CMsg(1, (char*)(cp), dwTime);
			m_pChatMsgList[i]->m_iObjectID = iObjectID;

			if (m_pMapData->bSetChatMsgOwner(iObjectID, sX, sY, i) == false) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = 0;
			}

			if ((cMsgType != 0) && (m_dialogBoxManager.IsEnabled(DialogBoxId::ChatHistory) != true)) {
				std::memset(cHeadMsg, 0, sizeof(cHeadMsg));
				wsprintf(cHeadMsg, "%s:%s", cName, cp);
				AddEventList(cHeadMsg, cMsgType);
			}
			return;
		}
}

void CGame::ReleaseTimeoverChatMsg()
{
	int i;
	uint32_t dwTime;
	dwTime = G_dwGlobalTime;
	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0) {

			if ((m_pChatMsgList[i]->m_cType >= 1) && (m_pChatMsgList[i]->m_cType <= 20)) {
				if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
			}
			else
				if ((m_pChatMsgList[i]->m_cType >= 21) && (m_pChatMsgList[i]->m_cType <= 40)) {
					if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_B) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
				}
				else
					if ((m_pChatMsgList[i]->m_cType >= 41) && (m_pChatMsgList[i]->m_cType <= 60)) {
						if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_C) {
							delete m_pChatMsgList[i];
							m_pChatMsgList[i] = 0;
						}
					}
					else if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
		}
}

void CGame::DrawBackground(short sDivX, short sModX, short sDivY, short sModY)
{
	int indexX, indexY, ix, iy;
	short sSpr, sSprFrame;
	if (sDivX < 0 || sDivY < 0) return;
	if ((m_bIsRedrawPDBGS == true) || (m_iPDBGSdivX != sDivX) || (m_iPDBGSdivY != sDivY)) {
		// Pre-Draw Background Surface
		m_bIsRedrawPDBGS = false;
		m_iPDBGSdivX = sDivX;
		m_iPDBGSdivY = sDivY;
		SetRect(&m_DDraw.m_rcClipArea, 0, 0, LOGICAL_WIDTH + 32, LOGICAL_HEIGHT + 32);
		indexY = sDivY + m_pMapData->m_sPivotY;
		for (iy = -sModY; iy < LOGICAL_MAX_Y + 48; iy += 32) // LOGICAL_HEIGHT 
		{
			indexX = sDivX + m_pMapData->m_sPivotX;
			for (ix = -sModX; ix < LOGICAL_MAX_X + 48; ix += 32)
			{
				sSpr = m_pMapData->m_tile[indexX][indexY].m_sTileSprite;
				sSprFrame = m_pMapData->m_tile[indexX][indexY].m_sTileSpriteFrame;
				m_pTileSpr[sSpr]->PutSpriteFastNoColorKeyDst(m_DDraw.m_lpPDBGS, ix - 16 + sModX, iy - 16 + sModY, sSprFrame, m_dwCurTime);
				indexX++;
			}
			indexY++;
		}
		SetRect(&m_DDraw.m_rcClipArea, 0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
	}
	RECT rcRect;
	SetRect(&rcRect, sModX, sModY, LOGICAL_WIDTH + sModX, LOGICAL_HEIGHT + sModY); // our fictitious sprite bitmap is
	m_DDraw.m_lpBackB4->BltFast(0, 0, m_DDraw.m_lpPDBGS, &rcRect, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);

	// Grid overlay removed.

	if (m_bIsCrusadeMode)
	{
		if (m_iConstructLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iConstructLocX * 32 - m_sViewPointX, m_iConstructLocY * 32 - m_sViewPointY, 41);
		if (m_iTeleportLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iTeleportLocX * 32 - m_sViewPointX, m_iTeleportLocY * 32 - m_sViewPointY, 42);
	}
}


bool CGame::bEffectFrameCounter()
{
	int i, x;
	uint32_t dwTime;
	bool bRet = false;
	short sAbsX, sAbsY, sDist;
	char  cDir;
	long lPan;
	dwTime = m_dwCurTime;
	dwTime += m_pMapData->m_dwFrameAdjustTime;
	for (i = 0; i < DEF_MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0) {
			if ((dwTime - m_pEffectList[i]->m_dwTime) > m_pEffectList[i]->m_dwFrameTime)
			{
				m_pEffectList[i]->m_dwTime = dwTime;
				m_pEffectList[i]->m_cFrame++;
				bRet = true;
				m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
				m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
				switch (m_pEffectList[i]->m_sType) {
				case 1: // coup normal
					if (m_pEffectList[i]->m_cFrame == 1)
					{
						for (int j = 1; j <= m_pEffectList[i]->m_iV1; j++) bAddNewEffect(11, m_pEffectList[i]->m_mX + 15 - (rand() % 30), m_pEffectList[i]->m_mY + 15 - (rand() % 30), 0, 0, -1 * (rand() % 2));
					}
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 2:	// (Arrow missing target ?)
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32 - 40,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 70);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
					{	//bAddNewEffect(14, m_pEffectList[i]->m_mX +(rand() % 5) - 2, m_pEffectList[i]->m_mY +(rand() % 5) - 2, 0, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 4: // Gold Drop ,33,69,70
				case 33: //
				case 69:
				case 70:
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 5:
				case 30:
				case 31: // Fire Explosion
				case 252:
					if (m_pEffectList[i]->m_cFrame == 1)
					{
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
					}
					if (m_pEffectList[i]->m_cFrame == 7)
					{
						bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
						bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
						bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
					}
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 6: // Lightning Bolt Burst
					if (m_pEffectList[i]->m_cFrame == 1)
					{
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
					}
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 7: // Magic Missile Burst
					if (m_pEffectList[i]->m_cFrame == 1)
					{
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
					}
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 9:  // Burst Type 2
				case 11: // Burst Type 3
					m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
					m_pEffectList[i]->m_rY++;
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 10: // Lightning Arrow Burst
					if (m_pEffectList[i]->m_cFrame == 1)
					{
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
					}
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 12: // Burst Type 4
					m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 13: // Bulles druncncity
					if (m_pEffectList[i]->m_cFrame < 15)
					{
						if ((rand() % 2) == 0)
							m_pEffectList[i]->m_mX++;
						else m_pEffectList[i]->m_mX--;
						m_pEffectList[i]->m_mY--;
					}
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 16: //
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 40);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
					{
						bAddNewEffect(18, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0, 0, 0); // testcode 0111 18
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 17: // Ice-Storm
					cDir = CMisc::cGetNextMoveDir(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, m_pEffectList[i]->m_mX3, m_pEffectList[i]->m_mY3);
					switch (cDir) {
					case 1:
						m_pEffectList[i]->m_rY -= 2;
						break;
					case 2:
						m_pEffectList[i]->m_rY -= 2;
						m_pEffectList[i]->m_rX += 2;
						break;
					case 3:
						m_pEffectList[i]->m_rX += 2;
						break;
					case 4:
						m_pEffectList[i]->m_rX += 2;
						m_pEffectList[i]->m_rY += 2;
						break;
					case 5:
						m_pEffectList[i]->m_rY += 2;
						break;
					case 6:
						m_pEffectList[i]->m_rX -= 2;
						m_pEffectList[i]->m_rY += 2;
						break;
					case 7:
						m_pEffectList[i]->m_rX -= 2;
						break;
					case 8:
						m_pEffectList[i]->m_rX -= 2;
						m_pEffectList[i]->m_rY -= 2;
						break;
					}
					if (m_pEffectList[i]->m_rX < -10) m_pEffectList[i]->m_rX = -10;
					if (m_pEffectList[i]->m_rX > 10) m_pEffectList[i]->m_rX = 10;
					if (m_pEffectList[i]->m_rY < -10) m_pEffectList[i]->m_rY = -10;
					if (m_pEffectList[i]->m_rY > 10) m_pEffectList[i]->m_rY = 10;
					m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
					m_pEffectList[i]->m_mY3--;
					if (m_pEffectList[i]->m_cFrame > 10)
					{
						m_pEffectList[i]->m_cFrame = 0;
						if (abs(m_pEffectList[i]->m_sY - m_pEffectList[i]->m_mY3) > 100)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
					}
					break;

				case 20: // Critical strike with a weapon
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27: // Critical strike with a weapon
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32 - 40,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2) &&
						(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 34: //
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(33, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, -1 * (rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
						(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
					{
						bAddNewEffect(33, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0, 0, 0); //7
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;


				case 40:
				case 56:
					if (m_pEffectList[i]->m_cFrame == 9)
					{
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
					}
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 41: //Large Type 1, 2, 3, 4
				case 42:
				case 43:
				case 44:
				case 45: // Small Type 1, 2
				case 46:
					if (m_pEffectList[i]->m_cFrame >= 7)
					{
						m_pEffectList[i]->m_mX--;
						m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
						m_pEffectList[i]->m_iV1++;
					}

					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						if ((m_pEffectList[i]->m_sType != 45) && (m_pEffectList[i]->m_sType != 46))
						{
							bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						}
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 47: // Blizzard
				case 48:
				case 49:
					if (m_pEffectList[i]->m_cFrame >= 7)
					{
						m_pEffectList[i]->m_mX--;
						m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
						m_pEffectList[i]->m_iV1 += 4;
					}
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						if (m_pEffectList[i]->m_sType == 49)
							bAddNewEffect(72, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
						else bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);

						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 60: //
				case 181: // Meteor-Strike
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
						bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else if (m_pEffectList[i]->m_cFrame >= 0)
					{
						m_pEffectList[i]->m_mX -= 30;
						m_pEffectList[i]->m_mY += 46;
						bAddNewEffect(62, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
					}
					break;

				case 62:
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else if (m_pEffectList[i]->m_cFrame >= 0)
					{
						m_pEffectList[i]->m_mX += (rand() % 3) - 1;
						m_pEffectList[i]->m_mY += (rand() % 3) - 1;
					}
					break;

				case 65: // Building fire after MS (crusade) 65 & 67
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else if (m_pEffectList[i]->m_cFrame >= 0)
					{
						m_pEffectList[i]->m_mX += (rand() % 3) - 1;
						m_pEffectList[i]->m_mY -= 4 + (rand() % 2);
					}
					break;

				case 66:
				case 203:
				case 204:
				case 205:
				case 206:
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 68:
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else if (m_pEffectList[i]->m_cFrame == 11)
					{
						SetCameraShakingEffect(m_pEffectList[i]->m_iV1, 2);
					}
					break;

				case 71:
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(48, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
						(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
					{
						bAddNewEffect(49, m_pEffectList[i]->m_mX/* + (rand() % 30) - 15*/, m_pEffectList[i]->m_mY/* + (rand() % 30) - 15*/, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 81: // Snoopy: Ajout StromBlade
					CMisc::GetPoint(m_pEffectList[i]->m_mX
						, m_pEffectList[i]->m_mY
						, m_pEffectList[i]->m_dX * 32
						, m_pEffectList[i]->m_dY * 32
						, &m_pEffectList[i]->m_mX
						, &m_pEffectList[i]->m_mY
						, &m_pEffectList[i]->m_iErr
						, 10);
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 100: // Magic Missile
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));

					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2) &&
						(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32/* - 40*/)) <= 2))
					{
						bAddNewEffect(7, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 110: // Enegy-Bolt
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{
						bAddNewEffect(6, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0); // 6 testcode 0111
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 120: // Fire Ball
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{
						bAddNewEffect(5, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 130: // Fire Strike
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{
						bAddNewEffect(5, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7);
						bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5);
						bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 137: // Lightning Arrow
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{
						bAddNewEffect(10, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 143: // Lightning
				case 151: // Lightning-Bolt
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						bAddNewEffect(10, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						m_pEffectList[i]->m_rX = 5 - (rand() % 10);
						m_pEffectList[i]->m_rY = 5 - (rand() % 10);
					}
					break;

				case 145: // Chill-Wind
					bAddNewEffect(40, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
					bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -10);
					bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -6);
					bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 147:  // Triple-Energy-Bolt
					bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						m_pEffectList[i]->m_dX - 1, m_pEffectList[i]->m_dY - 1, 0);
					bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						m_pEffectList[i]->m_dX + 1, m_pEffectList[i]->m_dY - 1, 0);
					bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						m_pEffectList[i]->m_dX + 1, m_pEffectList[i]->m_dY + 1, 0);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX) * LOGICAL_WIDTH;
					PlaySound('E', 1, sDist, lPan);
					bAddNewEffect(7, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 156: // Mass-Lightning-Arrow
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(137, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0);
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX) * LOGICAL_WIDTH;
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 157: // Ice-Strike
					bAddNewEffect(41, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
					for (x = 0; x < 14; x++)
					{
						bAddNewEffect(41 + (rand() % 3), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1);
					}
					for (x = 0; x < 6; x++)
					{
						bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1 - 10);
					}
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 160: // Energy-Strike
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(16, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX * 32 + 50 - (rand() % 100), m_pEffectList[i]->m_dY * 32 + 50 - (rand() % 100), 0);
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 161: // Mass-Fire-Strike
					CMisc::GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{
						bAddNewEffect(30, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7);
						bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5);
						bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 163: // Mass-Chill-Wind Chill-Wind
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -10);
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -6);
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
					bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 164: // worm-bite
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						bAddNewEffect(68, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0); // testcode 0111 18
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 170: // Bloody-Shock-Wave
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else if ((m_pEffectList[i]->m_cFrame % 2) == 0)
					{
						bAddNewEffect(34, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX * 32 + 30 - (rand() % 60), m_pEffectList[i]->m_dY * 32 + 30 - (rand() % 60), 0);
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 172: // Mass-Ice-Strike
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
					for (x = 0; x < 16; x++)
					{
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * x - 1);
					}
					for (x = 0; x < 8; x++)
					{
						bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1 - 10);
					}
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 174: // Lightning-Strike
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 3) - 1, m_pEffectList[i]->m_dY + (rand() % 3) - 1, 0);
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 182: // Mass-Magic-Missile
					CMisc::GetPoint(m_pEffectList[i]->m_mX
						, m_pEffectList[i]->m_mY
						, m_pEffectList[i]->m_dX * 32
						, m_pEffectList[i]->m_dY * 32
						, &m_pEffectList[i]->m_mX
						, &m_pEffectList[i]->m_mY
						, &m_pEffectList[i]->m_iErr
						, 50);
					bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
					{	// JLE 0043132A
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(35, m_pEffectList[i]->m_dX * 32 + 22, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7, 1);
						bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 - 22, m_pEffectList[i]->m_dY * 32 - 7, 0, 0, -7, 1);
						bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 + 30, m_pEffectList[i]->m_dY * 32 - 22, 0, 0, -5, 1);
						bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 + 12, m_pEffectList[i]->m_dY * 32 + 22, 0, 0, -3, 1);
					}
					break;

				case 191: // Blizzard
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else /*if (m_pEffectList[i]->m_cFrame == 1)*/
					{
						bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX * 32 + (rand() % 120) - 60, m_pEffectList[i]->m_dY * 32 + (rand() % 120) - 60, 0);
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 196: // Earth-Shock-Wave
					CMisc::GetPoint(m_pEffectList[i]->m_mX
						, m_pEffectList[i]->m_mY
						, m_pEffectList[i]->m_dX * 32
						, m_pEffectList[i]->m_dY * 32
						, &m_pEffectList[i]->m_mX
						, &m_pEffectList[i]->m_mY
						, &m_pEffectList[i]->m_iErr
						, 40);
					bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0, 1);
					bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, 0, 0);
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						sAbsX = abs(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + VIEW_CENTER_TILE_Y) - m_pEffectList[i]->m_dY);
						if (sAbsX > sAbsY) sDist = sAbsX - 10;
						else sDist = sAbsY - 10;
						lPan = -(((m_sViewPointX / 32) + VIEW_CENTER_TILE_X) - m_pEffectList[i]->m_dX);
						PlaySound('E', 1, sDist, lPan);
					}
					break;

				case 200:
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(203, m_pEffectList[i]->m_sX + 40, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
						bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
						bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
						bAddNewEffect(206, m_pEffectList[i]->m_sX - 7, m_pEffectList[i]->m_sY + 27, 0, 0, 0, 0);
						bAddNewEffect(201, (rand() % 160) + 320, (rand() % 120) + 240, 0, 0, 0, 1);
						bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, 0, 0, 0, 1);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 201:
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(203, m_pEffectList[i]->m_sX + 110, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
						bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
						bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
						bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, 0, 0, 0, 1);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 202:
					if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(203, m_pEffectList[i]->m_sX + 65, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
						bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
						bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
						bAddNewEffect(206, m_pEffectList[i]->m_sX - 7, m_pEffectList[i]->m_sY + 27, 0, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 250: // Gate round
					CMisc::GetPoint(m_pEffectList[i]->m_mX
						, m_pEffectList[i]->m_mY
						, m_pEffectList[i]->m_dX * 32
						, m_pEffectList[i]->m_dY * 32 - 40
						, &m_pEffectList[i]->m_mX
						, &m_pEffectList[i]->m_mY
						, &m_pEffectList[i]->m_iErr
						, 10);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 251: // Salmon burst (effect11s)
					CMisc::GetPoint(m_pEffectList[i]->m_mX
						, m_pEffectList[i]->m_mY
						, m_pEffectList[i]->m_dX * 32
						, m_pEffectList[i]->m_dY * 32
						, &m_pEffectList[i]->m_mX
						, &m_pEffectList[i]->m_mY
						, &m_pEffectList[i]->m_iErr
						, 50);
					if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
						&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					else
					{
						bAddNewEffect(252, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0, 1);
						bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7, 1);
						bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 - 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5, 1);
						bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3, 1);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;

				case 8:
				case 14:
				case 15:
				case 18:
				case 32:
				case 35: //
				case 36: //
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 57:
				case 61:
				case 63:
				case 64:
				case 67:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 80: //
				case 82: //

				case 101:
				case 102:
				case 111:
				case 112:
				case 113:
				case 121:
				case 122:
				case 123: // Stamina Rec
				case 124:
				case 125:
				case 126:
				case 127:
				case 128: // Gr Stamina Rec
				case 131:
				case 132:
				case 133:
				case 134:
				case 135:
				case 136:
				case 142:
				case 144:
				case 150: // Berserk : Cirlcle 6 magic
				case 152: // Polymorph
				case 153:
				case 162:
				case 165:
				case 166:
				case 171:
				case 176: //
				case 177: //

				case 180:
				case 183: //
				case 184: // EP's Magic Drain
				case 190:
				case 192:
				case 193:
				case 194:
				case 195:
				case 242: // Mage hero effect
				case 243: // War hero effect
				case 244: // Snoopy: d�plac� pour nvx sorts: Aura du casteur de Mass MagicMissile
					if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
					{
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
					}
					break;
				}
			}
		}
	return bRet;
}


bool   CGame::DrawObject_OnRun(int indexX, int indexY, int sX, int sY, bool bTrans, uint32_t dwTime, int msX, int msY, bool frame_omision)
{
	int dx, dy;
	int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB, iMantleIndex;
	bool bInv = false;
	int iWeaponGlare, iShieldGlare;
	int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
	int iSkirtDraw = 0;

	if (_tmp_sOwnerType == 35 /*|| _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66*/) bInv = true; //Energy-Ball,Wyvern

	if (m_cDetailLevel == 0)
	{
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor = 0;
		iMantleColor = 0;
		iArmColor = 0;
		iPantsColor = 0;
		iBootsColor = 0;
		iHelmColor = 0;
	}
	else
	{
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = true;
		else if (_iGetFOE(_tmp_iStatus) == 1) bInv = true;
		else return false;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (4 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F) * 15 + 4;
		iHairIndex = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F) * 15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{
			iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F) * 8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 4;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1) * 8 * 15 + (4 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F) * 15 + 4;
		iHairIndex = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12) * 15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F) * 15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8) * 15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12) * 15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{
			iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4) * 64 + 8 * 6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F) * 8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8) * 15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4) * 15 + 4;
		break;

	default:
		iUndiesIndex = -1;
		iHairIndex = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex = -1;
		break;
	}
	dx = 0;
	dy = 0;
	bool value = frame_omision;
	int value_2 = 30;
	switch (_tmp_cDir) {
	case 1: dy = value_2 - (_tmp_cFrame << 2) - value; break;
	case 2: dy = value_2 - (_tmp_cFrame << 2) - value; dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 3: dx = (_tmp_cFrame << 2) + value - value_2; break;
	case 4: dx = (_tmp_cFrame << 2) + value - value_2; dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 5: dy = (_tmp_cFrame << 2) + value - value_2; break;
	case 6: dy = (_tmp_cFrame << 2) + value - value_2; dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 7: dx = value_2 - (_tmp_cFrame << 2) - value; break;
	case 8: dx = value_2 - (_tmp_cFrame << 2) - value; dy = value_2 - (_tmp_cFrame << 2) - value; break;
	}


	int fix_x = 0;
	int fix_y = 0;

	switch (_tmp_cDir) {
	case 1: fix_x = sX + dx;		 fix_y = sY + dy - value; break;//listo
	case 2: fix_x = sX + dx + value; fix_y = sY + dy - value; break;//listo
	case 3: fix_x = sX + dx + value; fix_y = sY + dy;		  break;//listo
	case 4: fix_x = sX + dx + value; fix_y = sY + dy + value; break;//listo
	case 5: fix_x = sX + dx;		 fix_y = sY + dy + value; break;//listo
	case 6: fix_x = sX + dx - value; fix_y = sY + dy + value; break;//listo
	case 7: fix_x = sX + dx - value; fix_y = sY + dy;		  break;//listo
	case 8: fix_x = sX + dx - value; fix_y = sY + dy - value; break;//listo
	}
	if (m_bIsCrusadeMode) DrawObjectFOE(fix_x, fix_y, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(fix_x, fix_y, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == false)
	{
		CheckActiveAura(fix_x, fix_y, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{
			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(fix_x, fix_y, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == true)
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime); // GM effect
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}
		}
		else
		{
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
				//case 66: // Wyvern
				//case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
				break;
			default:
				if (m_cDetailLevel != 0 && !bInv)
				{
					if (sX < 50)
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(fix_x, fix_y, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == true)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(fix_x, fix_y, _tmp_cFrame, dwTime);
			else
			{
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wR[10] - m_wR[0] / 2, m_wG[10] - m_wG[0] / 2, m_wB[10] - m_wB[0] / 2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if (bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				m_pSprite[iUndiesIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1)
			{
				if (bInv) m_pSprite[iPantsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iPantsColor] - m_wR[0], m_wG[iPantsColor] - m_wG[0], m_wB[iPantsColor] - m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1)
			{
				if (bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmColor] - m_wR[0], m_wG[iArmColor] - m_wG[0], m_wB[iArmColor] - m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{
				if (bInv) m_pSprite[iBootsIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iBootsColor] - m_wR[0], m_wG[iBootsColor] - m_wG[0], m_wB[iBootsColor] - m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1)
			{
				if (bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iArmorColor] - m_wR[0], m_wG[iArmorColor] - m_wG[0], m_wB[iArmorColor] - m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1)
			{
				if (bInv) m_pSprite[iHelmIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						m_pSprite[iHelmIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iHelmColor] - m_wR[0], m_wG[iHelmColor] - m_wG[0], m_wB[iHelmColor] - m_wB[0], dwTime);
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1)
			{
				if (bInv) m_pSprite[iShieldIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iShieldColor] - m_wR[0], m_wG[iShieldColor] - m_wG[0], m_wB[iShieldColor] - m_wB[0], dwTime);
				}
				switch (iShieldGlare) {
				case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(fix_x - 13, fix_y - 34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{
				if (bInv) m_pSprite[iMantleIndex]->PutTransSprite25(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(fix_x, fix_y, (_tmp_cDir - 1) * 8 + _tmp_cFrame, m_wR[iMantleColor] - m_wR[0], m_wG[iMantleColor] - m_wG[0], m_wB[iMantleColor] - m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1)
			{
				if (bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(fix_x, fix_y, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(fix_x, fix_y, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_wWR[iWeaponColor] - m_wR[0], m_wWG[iWeaponColor] - m_wG[0], m_wWB[iWeaponColor] - m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x, fix_y, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40 + (_tmp_cDir - 1), fix_x + 20, fix_y - 20, _tmp_cFrame % 4, dwTime);
		CheckActiveAura2(fix_x, fix_y, dwTime, _tmp_sOwnerType);

		// Centuu : Haste effect
		if ((_tmp_iStatus & 0x40000) != 0) {
			for (int i = 1; i <= 5; i++)
			{
				switch (_tmp_cDir) {
				case 1: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x, fix_y + (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 2: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x - (i * 5), fix_y + (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 3: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x - (i * 5), fix_y, _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 4: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x - (i * 5), fix_y - (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 5: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x, fix_y - (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 6: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x + (i * 5), fix_y - (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 7: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x + (i * 5), fix_y, _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				case 8: m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(fix_x + (i * 5), fix_y + (i * 5), _tmp_cFrame, m_wR[10] - (m_wR[0] / 3), m_wG[10] - (m_wG[0] / 3), m_wB[10] - (m_wB[0] / 3), dwTime); break;
				}
			}
		}

	}
	else if (strlen(_tmp_cName) > 0)
	{
		if ((_tmp_sOwnerType >= 1) && (_tmp_sOwnerType <= 6)) DrawObjectName(fix_x, fix_y, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(fix_x, fix_y, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != 0)
	{
		if ((m_pChatMsgList[_tmp_iChatIndex] != 0) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = fix_x;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = fix_y;
		}
		else
		{
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ((m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX)) return true;
	return false;
}

void CGame::GetPlayerTurn()
{
	char cDir;
	short sX, sY, sCnt1, sCnt2;
	int   iError;

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt1 = 0;
	m_cPlayerTurn = 0;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt1++;
		if (sCnt1 > 30) break;
	}

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt2 = 0;
	m_cPlayerTurn = 1;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt2++;
		if (sCnt2 > 30) break;
	}

	if (sCnt1 > sCnt2)
		m_cPlayerTurn = 0;
	else m_cPlayerTurn = 1;
}


int CGame::_iCheckDlgBoxFocus(short msX, short msY, char cButtonSide)
{
	int i;
	char         cDlgID;
	short        sX, sY;
	uint32_t dwTime = m_dwCurTime;
	if (cButtonSide == 1) {
		// Snoopy: 41->61
		for (i = 0; i < 61; i++)
			// Snoopy: 40->60
			if (m_dialogBoxManager.OrderAt(60 - i) != 0) 	// Snoopy: 40->60
			{
				cDlgID = m_dialogBoxManager.OrderAt(60 - i);
				if ((m_dialogBoxManager.Info(cDlgID).sX <= msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) >= msX) &&
					(m_dialogBoxManager.Info(cDlgID).sY <= msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) >= msY))
				{
					m_dialogBoxManager.EnableDialogBox(cDlgID, 0, 0, 0);

					m_stMCursor.sPrevX = msX;
					m_stMCursor.sPrevY = msY;
					m_stMCursor.sDistX = msX - m_dialogBoxManager.Info(cDlgID).sX;
					m_stMCursor.sDistY = msY - m_dialogBoxManager.Info(cDlgID).sY;

					switch (cDlgID) {
					case 1:
						if (bDlgBoxPress_Character(msX, msY) == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:

					case 12:
					case 13:
					case 16:
					case 17:
					case 20:
					case 22:
					case 23:
					case 24:
					case 25:
					case 28:
					case 29:
					case 30:
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
					case 36:
					case 37:
					case 38:
					case 40:
					case 50: // resur
						// NPC
					case 67:
					case 68:
					case 69:
					case 44:
					case 49:
					case 54:
					case 58:
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 2:	// (Sell Item)
						if (bDlgBoxPress_Inventory(msX, msY) == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 10:
						sX = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sY;
						if ((msX >= sX + 340) && (msX <= sX + 360) && (msY >= sY + 22) && (msY <= sY + 138)) {
							m_dialogBoxManager.Info(DialogBoxId::ChatHistory).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::ChatHistory).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 11:
						sX = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sY;
						if ((m_dialogBoxManager.Info(DialogBoxId::SaleMenu).cMode == 0) && (msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 20) && (msY <= sY + 330)) {
							m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bIsScrollSelected = true;
							return -1;
						}

						if ((m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bIsScrollSelected == false)) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 14:
						sX = m_dialogBoxManager.Info(DialogBoxId::Bank).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Bank).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::Bank).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::Bank).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 15:
						sX = m_dialogBoxManager.Info(DialogBoxId::Skill).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Skill).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320))
						{
							m_dialogBoxManager.Info(DialogBoxId::Skill).bIsScrollSelected = true;
							return -1;
						}
						if (m_dialogBoxManager.Info(DialogBoxId::Skill).bIsScrollSelected == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 18:
						sX = m_dialogBoxManager.Info(DialogBoxId::Text).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::Text).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::Text).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::Text).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 19:
						sX = m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::SystemMenu).sY;
						if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY + 122) && (msY <= sY + 138)) {
							m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected = true;
							return -1;
						}
						if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY + 139) && (msY <= sY + 155)) {
							m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::SystemMenu).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 21:
						sX = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sX;
						sY = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sY;
						if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
							m_dialogBoxManager.Info(DialogBoxId::NpcTalk).bIsScrollSelected = true;
							return -1;
						}

						if (m_dialogBoxManager.Info(DialogBoxId::NpcTalk).bIsScrollSelected == false) {
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						else return -1;
						break;

					case 26:
						if (bDlgBoxPress_SkillDlg(msX, msY) == false)
						{
							m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
							m_stMCursor.sSelectedObjectID = cDlgID;
						}
						break;

					case 27:
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 41: //Snoopy: Drag exchange confirmation dialog
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 42:  // Snoopy: Drag majestic stats
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;

					case 51:  // Snoopy: Drag Gail menu
						m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
						break;
					}
					return 1;
				}
			}
		return 0;
	}
	else if (cButtonSide == 2)
	{
		if ((dwTime - m_dwDialogCloseTime) < 300) return 0;
		// Snoopy: 40->60
		for (i = 0; i < 61; i++)
			// Snoopy: 40->60
			if (m_dialogBoxManager.OrderAt(60 - i) != 0) {
				// Snoopy: 40->60
				cDlgID = m_dialogBoxManager.OrderAt(60 - i);
				if ((m_dialogBoxManager.Info(cDlgID).sX < msX) && ((m_dialogBoxManager.Info(cDlgID).sX + m_dialogBoxManager.Info(cDlgID).sSizeX) > msX) &&
					(m_dialogBoxManager.Info(cDlgID).sY < msY) && ((m_dialogBoxManager.Info(cDlgID).sY + m_dialogBoxManager.Info(cDlgID).sSizeY) > msY))
				{
					if ((cDlgID != 5) && (cDlgID != 6) && (cDlgID != 8) && (cDlgID != 12) && ((cDlgID != 23) || (m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode < 3)) && (cDlgID != 24) && (cDlgID != 27) && (cDlgID != 34) &&
						(cDlgID != 33) && !((cDlgID == 32) && ((m_dialogBoxManager.Info(cDlgID).cMode == 1) || (m_dialogBoxManager.Info(cDlgID).cMode == 3))))
						m_dialogBoxManager.DisableDialogBox(cDlgID);
					m_dwDialogCloseTime = dwTime;
					return 1;
				}
			}
	}
	return 0;
}



void CGame::InitItemList(char* pData)
{
	int     i, iAngelValue;
	uint8_t cTotalItems;
	const char* cp;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_cItemOrder[i] = -1;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		m_sItemEquipmentStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_bIsItemDisabled[i] = false;

	const auto* header = hb::net::PacketCast<hb::net::PacketResponseItemListHeader>(
		pData, sizeof(hb::net::PacketResponseItemListHeader));
	if (!header) return;
	cTotalItems = header->item_count;
	cp = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseItemListHeader);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	const auto* itemEntries = reinterpret_cast<const hb::net::PacketResponseItemListEntry*>(cp);
	for (i = 0; i < cTotalItems; i++)
	{
		const auto& entry = itemEntries[i];
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, entry.name, 20);
		m_pItemList[i]->m_dwCount = entry.count;
		m_pItemList[i]->m_sX = 40;
		m_pItemList[i]->m_sY = 30;
		m_pItemList[i]->m_cItemType = entry.item_type;
		m_pItemList[i]->m_cEquipPos = entry.equip_pos;
		if (entry.is_equipped == 0) m_bIsItemEquipped[i] = false;
		else m_bIsItemEquipped[i] = true;
		if (m_bIsItemEquipped[i] == true)
		{
			m_sItemEquipmentStatus[m_pItemList[i]->m_cEquipPos] = i;
		}
		m_pItemList[i]->m_sLevelLimit = entry.level_limit;
		m_pItemList[i]->m_cGenderLimit = entry.gender_limit;
		m_pItemList[i]->m_wCurLifeSpan = entry.cur_lifespan;
		m_pItemList[i]->m_wWeight = entry.weight;
		m_pItemList[i]->m_sSprite = entry.sprite;
		m_pItemList[i]->m_sSpriteFrame = entry.sprite_frame;
		m_pItemList[i]->m_cItemColor = entry.item_color;
		m_pItemList[i]->m_sItemSpecEffectValue2 = static_cast<short>(entry.spec_value2); // v1.41
		m_pItemList[i]->m_dwAttribute = entry.attribute;
		/*
		m_pItemList[i]->m_bIsCustomMade = (bool)*cp;
		cp++;
		*/
		m_cItemOrder[i] = i;
		// Snoopy: Add Angelic Stats
		if ((m_pItemList[i]->m_cItemType == 1)
			&& (m_bIsItemEquipped[i] == true)
			&& (m_pItemList[i]->m_cEquipPos >= 11))
		{
			if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicStr = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicDex = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicInt = 1 + iAngelValue;
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicMag = 1 + iAngelValue;
			}
		}
	}

	cp = reinterpret_cast<const char*>(itemEntries + cTotalItems);
	cTotalItems = static_cast<uint8_t>(*cp);
	cp++;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	const auto* bankEntries = reinterpret_cast<const hb::net::PacketResponseBankItemEntry*>(cp);
	for (i = 0; i < cTotalItems; i++)
	{
		const auto& entry = bankEntries[i];
		m_pBankList[i] = new class CItem;
		memcpy(m_pBankList[i]->m_cName, entry.name, 20);
		m_pBankList[i]->m_dwCount = entry.count;

		m_pBankList[i]->m_sX = 40;
		m_pBankList[i]->m_sY = 30;

		m_pBankList[i]->m_cItemType = entry.item_type;
		m_pBankList[i]->m_cEquipPos = entry.equip_pos;
		m_pBankList[i]->m_sLevelLimit = entry.level_limit;
		m_pBankList[i]->m_cGenderLimit = entry.gender_limit;
		m_pBankList[i]->m_wCurLifeSpan = entry.cur_lifespan;
		m_pBankList[i]->m_wWeight = entry.weight;
		m_pBankList[i]->m_sSprite = entry.sprite;
		m_pBankList[i]->m_sSpriteFrame = entry.sprite_frame;
		m_pBankList[i]->m_cItemColor = entry.item_color;
		m_pBankList[i]->m_sItemSpecEffectValue2 = static_cast<short>(entry.spec_value2); // v1.41
		m_pBankList[i]->m_dwAttribute = entry.attribute;
		/*
		m_pBankList[i]->m_bIsCustomMade = (bool)*cp;
		cp++;
		*/
	}

	cp = reinterpret_cast<const char*>(bankEntries + cTotalItems);
	// Magic, Skill Mastery
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	{
		m_cMagicMastery[i] = *cp;
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	{
		m_cSkillMastery[i] = (unsigned char)*cp;
		if (m_pSkillCfgList[i] != 0)
			m_pSkillCfgList[i]->m_iLevel = (int)*cp;
		cp++;
	}
}

void CGame::DrawDialogBoxs(short msX, short msY, short msZ, char cLB)
{
	int i;
	if (m_bIsObserverMode == true) return;
	// Note: Dialogs that handle scroll should read m_DInput.m_sZ directly and reset it after processing
	//Snoopy: 41->61
	bool bIconPanelDrawn = false;
	for (i = 0; i < 61; i++)
		if (m_dialogBoxManager.OrderAt(i) != 0)
		{
			switch (m_dialogBoxManager.OrderAt(i)) {
			case DialogBoxId::CharacterInfo:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CharacterInfo))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Inventory:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Inventory))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Magic:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Magic))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemDropConfirm:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropConfirm))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::WarningBattleArea:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::WarningBattleArea))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuildMenu:
				DrawDialogBox_GuildMenu(msX, msY);
				break;
			case DialogBoxId::GuildOperation:
				DrawDialogBox_GuildOperation(msX, msY);
				break;
			case DialogBoxId::GuideMap:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::GuideMap))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ChatHistory:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ChatHistory))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SaleMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SaleMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::LevelUpSetting:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::LevelUpSetting))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CityHallMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CityHallMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Bank:
				DrawDialogBox_Bank(msX, msY, msZ, cLB); //@@@
				break;
			case DialogBoxId::Skill:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Skill))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::MagicShop:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::MagicShop))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemDropExternal:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemDropExternal))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Text:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Text))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SystemMenu:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SystemMenu))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::NpcActionQuery:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcActionQuery))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::NpcTalk:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::NpcTalk))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Map:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Map))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::SellOrRepair:
				DrawDialogBox_SellorRepairItem(msX, msY); //@@@
				break;
			case DialogBoxId::Fishing:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Fishing))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Noticement:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Noticement))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Manufacture: // Manuf
				DrawDialogBox_SkillDlg(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Exchange:
				DrawDialogBox_Exchange(msX, msY); //@@@
				break;
			case DialogBoxId::Quest:
				DrawDialogBox_Quest(msX, msY); //@@@
				break;
			case DialogBoxId::HudPanel:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				bIconPanelDrawn = true;
				break;
			case DialogBoxId::SellList:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::SellList))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Party:
				DrawDialogBox_Party(msX, msY); //@@@
				break;
			case DialogBoxId::CrusadeJob:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::CrusadeJob))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ItemUpgrade:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ItemUpgrade))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::Help:
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Help))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::CrusadeCommander:
				DrawDialogBox_Commander(msX, msY); //@@@
				break;
			case DialogBoxId::CrusadeConstructor:
				DrawDialogBox_Constructor(msX, msY); //@@@
				break;
			case DialogBoxId::CrusadeSoldier:
				DrawDialogBox_Soldier(msX, msY); //@@@
				break;
			case DialogBoxId::Slates:
				DrawDialogBox_Slates(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ConfirmExchange:	//Snoopy: Confirmation Exchange
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::ConfirmExchange))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::ChangeStatsMajestic:
				DrawDialogBox_ChangeStatsMajestic(msX, msY);
				break;
			case DialogBoxId::Resurrect: // Snoopy: Resurection?
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::Resurrect))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			case DialogBoxId::GuildHallMenu: // Gail
				DrawDialogBox_CMDHallMenu(msX, msY);
				break;
			case DialogBoxId::RepairAll: //50Cent - Repair All
				if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::RepairAll))
					pDlg->OnDraw(msX, msY, msZ, cLB);
				break;
			}
		}
	if (bIconPanelDrawn == false)
	{
		if (auto* pDlg = m_dialogBoxManager.GetDialogBox(DialogBoxId::HudPanel))
			pDlg->OnDraw(msX, msY, msZ, cLB);
	}
	int resy = 0;
	int resx = 0;
	short iconX = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sX;
	short iconY = m_dialogBoxManager.Info(DialogBoxId::HudPanel).sY;
	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
	{
		if (m_iSuperAttackLeft > 0)
		{
			if (GetAsyncKeyState(VK_MENU) >> 15)
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutTransSprite(iconX + 368 + resx + 7, iconY + 440 + resy, 3, m_dwCurTime);
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(iconX + 380 + resx + 10 - 5, iconY + 454 + resy, G_cTxt, 255, 255, 255);
		}
	}
	else
	{
		if (m_iSuperAttackLeft > 0)
		{
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont(iconX + 380 + resx + 10 - 5, iconY + 454 + resy, G_cTxt, 10, 10, 10);
		}
	}
}

void CGame::_Draw_CharacterBody(short sX, short sY, short sType)
{
	uint32_t dwTime = m_dwCurTime;
	int  iR, iG, iB;

	if (sType <= 3)
	{
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX, sY, sType - 1, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
	else
	{
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX, sY, sType - 4, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 + 40]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 + 40]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
}


void CGame::EnableDialogBox(int iBoxID, int cType, int sV1, int sV2, char* pString)
{
	int i;
	short sX, sY;

	switch (iBoxID) {
	case DialogBoxId::RepairAll: //50Cent - Repair all
		m_dialogBoxManager.Info(DialogBoxId::RepairAll).cMode = cType;
		break;
	case DialogBoxId::UpgradeAll:
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false)
		{
			m_dialogBoxManager.Info(iBoxID).bFlag = false;
			m_dialogBoxManager.Info(iBoxID).cMode = cType;
			m_dialogBoxManager.Info(iBoxID).sV2 = -1;
			m_dialogBoxManager.Info(iBoxID).sV3 = -1;
			m_dialogBoxManager.Info(iBoxID).sV1 = sV1;
			m_dialogBoxManager.Info(iBoxID).dwV1 = 0;
		}
		break;
	case DialogBoxId::SaleMenu:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) == false)
		{
			switch (cType) {
			case 0:
				break;
			default:
				_LoadShopMenuContents(cType);
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV1 = cType;
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).cMode = 0;
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sView = 0;
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).bFlag = true;
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV3 = 1;
				break;
			}
		}
		break;

	case DialogBoxId::LevelUpSetting: // levelup diag
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
			m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sV1 = m_iLU_Point;
		}
		break;

	case DialogBoxId::Magic: // Magic Dialog
		break;

	case DialogBoxId::ItemDropConfirm:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == false) {
			m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sView = cType;
		}
		break;

	case DialogBoxId::WarningBattleArea:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::WarningBattleArea) == false) {
			m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sView = cType;
		}
		break;

	case DialogBoxId::GuildMenu:
		if (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1) {
			sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
		}
		break;

	case DialogBoxId::ItemDropExternal: // demande quantit�
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == false)
		{
			m_dialogBoxManager.Info(iBoxID).cMode = 1;
			m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView = cType;
			EndInputString();
			std::memset(m_cAmountString, 0, sizeof(m_cAmountString));
			wsprintf(m_cAmountString, "%d", sV1);
			sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
			StartInputString(sX + 40, sY + 57, 11, m_cAmountString, false);
		}
		else
		{
			if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1)
			{
				sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
				sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
				EndInputString();
				StartInputString(sX + 40, sY + 57, 11, m_cAmountString, false);
			}
		}
		break;

	case DialogBoxId::Text:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Text) == false)
		{
			switch (cType) {
			case 0:
				m_dialogBoxManager.Info(DialogBoxId::Text).cMode = 0;
				m_dialogBoxManager.Info(DialogBoxId::Text).sView = 0;
				break;
			default:
				_LoadTextDlgContents(cType);
				m_dialogBoxManager.Info(DialogBoxId::Text).cMode = 0;
				m_dialogBoxManager.Info(DialogBoxId::Text).sView = 0;
				break;
			}
		}
		break;

	case DialogBoxId::SystemMenu:
		break;

	case DialogBoxId::NpcActionQuery: // Talk to npc or unicorn
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1] = false;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV1 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV2 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV3 =
				m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV4 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV5 = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sV6 = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV2 = sV2;
		}
		break;

	case DialogBoxId::NpcTalk:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcTalk) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV1 = _iLoadTextDlgContents2(sV1 + 20);
			m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV2 = sV1 + 20;
		}
		break;

	case DialogBoxId::Map:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Map) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Map).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Map).sV2 = sV2;

			m_dialogBoxManager.Info(DialogBoxId::Map).sSizeX = 290;
			m_dialogBoxManager.Info(DialogBoxId::Map).sSizeY = 290;
		}
		break;

	case DialogBoxId::SellOrRepair:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) {
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1 = sV1;		// ItemID
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV2 = sV2;
			if (cType == 2)
			{
				m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sX;
				m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY = m_dialogBoxManager.Info(DialogBoxId::SaleMenu).sY;
			}
		}
		break;

	case DialogBoxId::Skill:
		break;

	case DialogBoxId::Fishing:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Fishing) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Fishing).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Fishing).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Fishing).sV2 = sV2;
			m_bSkillUsingStatus = true;
		}
		break;

	case DialogBoxId::Noticement:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Noticement) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Noticement).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Noticement).sV1 = sV1;
			m_dialogBoxManager.Info(DialogBoxId::Noticement).sV2 = sV2;
		}
		break;

	case DialogBoxId::Manufacture:
		switch (cType) {
		case DialogBoxId::CharacterInfo:
		case DialogBoxId::Inventory: //
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_bSkillUsingStatus = true;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 195;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 215;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;

		case DialogBoxId::Magic:	//
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = 0;
				m_bSkillUsingStatus = true;
				_bCheckBuildItemStatus();
				//m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX = 0;
				//m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 270;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 381;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;

		case DialogBoxId::WarningBattleArea:
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[2] = sV1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[3] = sV2;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 270;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 381;
				m_bSkillUsingStatus = true;
				_bCheckBuildItemStatus();
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;
			// Crafting
		case DialogBoxId::GuildMenu:
		case DialogBoxId::GuildOperation:
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == false)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = cType;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_bSkillUsingStatus = true;
				//_bCheckCraftItemStatus();
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX = 195;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeY = 215;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			}
			break;
		}
		break;

	case DialogBoxId::Exchange: // Snoopy: 7 mar 06 (multitrade) case rewriten
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Exchange).cMode = cType;
			for (i = 0; i < 8; i++)
			{
				std::memset(m_stDialogBoxExchangeInfo[i].cStr1, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
				std::memset(m_stDialogBoxExchangeInfo[i].cStr2, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
				m_stDialogBoxExchangeInfo[i].sV1 = -1;
				m_stDialogBoxExchangeInfo[i].sV2 = -1;
				m_stDialogBoxExchangeInfo[i].sV3 = -1;
				m_stDialogBoxExchangeInfo[i].sV4 = -1;
				m_stDialogBoxExchangeInfo[i].sV5 = -1;
				m_stDialogBoxExchangeInfo[i].sV6 = -1;
				m_stDialogBoxExchangeInfo[i].sV7 = -1;
				m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			}
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		}
		break;

	case DialogBoxId::ConfirmExchange: // Snoopy: 7 mar 06 (MultiTrade) Confirmation dialog
		break;

	case DialogBoxId::Quest:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Quest) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Quest).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Quest).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::Quest).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
		}
		break;

	case DialogBoxId::Party:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Party) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Party).sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX + 20;
			m_dialogBoxManager.Info(DialogBoxId::Party).sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY + 20;
		}
		break;

	case DialogBoxId::CrusadeJob:
		if ((m_iHP <= 0) || (m_bCitizen == false)) return;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::CrusadeJob) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sX = 360 + SCREENX;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sY = 65 + SCREENY;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeJob).sV1 = sV1;
		}
		break;

	case DialogBoxId::ItemUpgrade:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
		}
		else if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == false)
		{
			int iSoX, iSoM;
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pItemList[i] != 0)
				{
					if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
					if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
				}
			if ((iSoX > 0) || (iSoM > 0))
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 6; // Stone upgrade
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV2 = iSoX;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV3 = iSoM;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
			}
			else if (m_iGizonItemUpgradeLeft > 0)
			{
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).dwV1 = 0;
			}
			else
			{
				AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10); // "Stone of Xelima or Merien is not present."
				return;
			}
		}
		break;

	case DialogBoxId::MagicShop:
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			if (m_cSkillMastery[4] == 0) {
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::MagicShop);
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, 0, 480, 0);
				return;
			}
			else {
				m_dialogBoxManager.Info(iBoxID).cMode = 0;
				m_dialogBoxManager.Info(iBoxID).sView = 0;
			}
		}
		break;

	case DialogBoxId::Bank:
		EndInputString();
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			m_dialogBoxManager.Info(iBoxID).cMode = 0;
			m_dialogBoxManager.Info(iBoxID).sView = 0;
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Inventory, 0, 0, 0);
		}
		break;

	case DialogBoxId::Slates: // Slates
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Slates) == false) {
			m_dialogBoxManager.Info(DialogBoxId::Slates).sView = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cMode = cType;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV5 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sV6 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[1] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[4] = 0;

			m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeX = 180;
			m_dialogBoxManager.Info(DialogBoxId::Slates).sSizeY = 183;

			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		}
		break;
	case DialogBoxId::ChangeStatsMajestic: // Diuuude: Change stats window
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ChangeStatsMajestic) == false) {
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX = m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sX + 10;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY = m_dialogBoxManager.Info(DialogBoxId::LevelUpSetting).sY + 10;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).cMode = 0;
			m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sView = 0;
			m_bSkillUsingStatus = false;
		}
		break;
	case DialogBoxId::Resurrect: // Snoopy: Resurection
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Resurrect) == false)
		{
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sX = 185;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sY = 100;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).cMode = 0;
			m_dialogBoxManager.Info(DialogBoxId::Resurrect).sView = 0;
			m_bSkillUsingStatus = false;
		}
		break;

	default:
		EndInputString();
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false) {
			m_dialogBoxManager.Info(iBoxID).cMode = 0;
			m_dialogBoxManager.Info(iBoxID).sView = 0;
		}
		break;
	}
	if (iBoxID != 30)
	{
		if (m_dialogBoxManager.IsEnabled(iBoxID) == false)
		{
			int tmpx = 720;
			int tmpy = 520;
			if (m_dialogBoxManager.Info(iBoxID).sY > tmpy) m_dialogBoxManager.Info(iBoxID).sY = tmpy + 10;
			if (m_dialogBoxManager.Info(iBoxID).sX > tmpx) m_dialogBoxManager.Info(iBoxID).sX = tmpx;
			if ((m_dialogBoxManager.Info(iBoxID).sX + m_dialogBoxManager.Info(iBoxID).sSizeX) < 10) m_dialogBoxManager.Info(iBoxID).sX += 20;
			if ((m_dialogBoxManager.Info(iBoxID).sY + m_dialogBoxManager.Info(iBoxID).sSizeY) < 10) m_dialogBoxManager.Info(iBoxID).sY += 20;
		}
	}
	m_dialogBoxManager.SetEnabled(iBoxID, true);
	if (pString != 0) strcpy(m_dialogBoxManager.Info(iBoxID).cStr, pString);
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == iBoxID) m_dialogBoxManager.SetOrderAt(i, 0);
	//Snoopy: 39->59
	for (i = 1; i < 59; i++)
		if ((m_dialogBoxManager.OrderAt(i - 1) == 0) && (m_dialogBoxManager.OrderAt(i) != 0)) {
			m_dialogBoxManager.SetOrderAt(i - 1, m_dialogBoxManager.OrderAt(i));
			m_dialogBoxManager.SetOrderAt(i, 0);
		}
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == 0) {
			m_dialogBoxManager.SetOrderAt(i, static_cast<char>(iBoxID));
			return;
		}
}

void CGame::DisableDialogBox(int iBoxID)
{
	int i;

	switch (iBoxID) {
	case DialogBoxId::ItemDropConfirm:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropConfirm).sView] = false;
		break;

	case DialogBoxId::WarningBattleArea:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sView] = false;
		break;

	case DialogBoxId::GuildMenu:
		if (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1)
			EndInputString();
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
		break;

	case DialogBoxId::SaleMenu:
		for (i = 0; i < DEF_MAXMENUITEMS; i++)
			if (m_pItemForSaleList[i] != 0) {
				delete m_pItemForSaleList[i];
				m_pItemForSaleList[i] = 0;
			}
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 0;
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = 0; // v1.4
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = 0;
		m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = 0;
		break;

	case DialogBoxId::Bank:
		if (m_dialogBoxManager.Info(DialogBoxId::Bank).cMode < 0) return;
		break;

	case DialogBoxId::ItemDropExternal:
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1) {
			EndInputString();
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = false;
		}
		break;

	case DialogBoxId::NpcActionQuery: // v1.4
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV1] = false;
		break;

	case DialogBoxId::NpcTalk:
		if (m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV2 == 500)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GETMAGICABILITY, 0, 0, 0, 0, 0);
		}
		break;

	case DialogBoxId::Fishing:
		m_bSkillUsingStatus = false;
		break;

	case DialogBoxId::Manufacture:
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] = false;
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1) m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] = false;
		m_bSkillUsingStatus = false;
		break;

	case DialogBoxId::Exchange: //Snoopy: 7 mar 06 (multiTrade) case rewriten
		for (i = 0; i < 8; i++)
		{
			std::memset(m_stDialogBoxExchangeInfo[i].cStr1, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
			std::memset(m_stDialogBoxExchangeInfo[i].cStr2, 0, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
			m_stDialogBoxExchangeInfo[i].sV1 = -1;
			m_stDialogBoxExchangeInfo[i].sV2 = -1;
			m_stDialogBoxExchangeInfo[i].sV3 = -1;
			m_stDialogBoxExchangeInfo[i].sV4 = -1;
			m_stDialogBoxExchangeInfo[i].sV5 = -1;
			m_stDialogBoxExchangeInfo[i].sV6 = -1;
			m_stDialogBoxExchangeInfo[i].sV7 = -1;
			m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			if (m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] == true)
				m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] = false;
		}
		break;


	case DialogBoxId::SellList:
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		{
			if (m_stSellItemList[i].iIndex != -1) m_bIsItemDisabled[m_stSellItemList[i].iIndex] = false;
			m_stSellItemList[i].iIndex = -1;
			m_stSellItemList[i].iAmount = 0;
		}
		break;

	case DialogBoxId::ItemUpgrade:
		if (m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 != -1)
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		break;

	case DialogBoxId::Slates:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV1] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV2] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV3] = false;
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Slates).sV4] = false;

		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr2, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr2));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr3, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr3));
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr4, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Slates).cStr4));
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV5 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV6 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV9 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV10 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV11 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV12 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV13 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).sV14 = -1;
		m_dialogBoxManager.Info(DialogBoxId::Slates).dwV1 = 0;
		m_dialogBoxManager.Info(DialogBoxId::Slates).dwV2 = 0;
		break;

	case DialogBoxId::ChangeStatsMajestic:
		cStateChange1 = 0;
		cStateChange2 = 0;
		cStateChange3 = 0;
		/*	m_cLU_Str = 0;
			m_cLU_Vit = 0;
			m_cLU_Dex = 0;
			m_cLU_Int = 0;
			m_cLU_Mag = 0;
			m_cLU_Char = 0;*/
		break;

	}

	// Call OnDisable for migrated dialogs
	if (auto* pDlg = m_dialogBoxManager.GetDialogBox(iBoxID))
		pDlg->OnDisable();

	m_dialogBoxManager.SetEnabled(iBoxID, false);
	// Snoopy: 39->59
	for (i = 0; i < 59; i++)
		if (m_dialogBoxManager.OrderAt(i) == iBoxID)
			m_dialogBoxManager.SetOrderAt(i, 0);

	// Snoopy: 39->59
	for (i = 1; i < 59; i++)
		if ((m_dialogBoxManager.OrderAt(i - 1) == 0) && (m_dialogBoxManager.OrderAt(i) != 0))
		{
			m_dialogBoxManager.SetOrderAt(i - 1, m_dialogBoxManager.OrderAt(i));
			m_dialogBoxManager.SetOrderAt(i, 0);
		}
}


int CGame::iGetTopDialogBoxIndex()
{
	int i;
	//Snoopy: 38->58
	for (i = 58; i >= 0; i--)
		if (m_dialogBoxManager.OrderAt(i) != 0)
			return m_dialogBoxManager.OrderAt(i);

	return 0;
}

void CGame::DrawChatMsgs(short sX, short sY, short dX, short dY)
{
	int i;

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY)) {

				switch (m_pChatMsgList[i]->m_cType) {
				case 41:
				case 42:
				case 21:
				case 22:
				case 23:
					DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, false);
					break;
				}
			}

	m_DDraw._GetBackBufferDC();
	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY)) {

				switch (m_pChatMsgList[i]->m_cType) {
				case 41:
				case 42:
				case 21:
				case 22:
				case 23:
					break;

				case 20:
				default:
					DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, true);
					break;
				}
			}
	m_DDraw._ReleaseBackBufferDC();
}



void CGame::_LoadTextDlgContents(int cType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	// cType
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else
	{
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0)
	{
		m_pMsgTextList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
}



int CGame::_iLoadTextDlgContents2(int iType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;
	}
	// cType
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", iType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");
	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return -1;
	else
	{
		pContents = new char[dwFileSize + 1];
		if (pContents == 0) return -1;
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0)
	{
		m_pMsgTextList2[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
	return iIndex;
}




void CGame::_LoadGameMsgTextContents()
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = ";\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;

	for (i = 0; i < DEF_MAXGAMEMSGS; i++) {
		if (m_pGameMsgList[i] != 0)
			delete m_pGameMsgList[i];
		m_pGameMsgList[i] = 0;
	}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	strcpy(cTemp, "GameMsgList");

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);

	token = strtok(pContents, seps);
	while (token != 0) {
		m_pGameMsgList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}

	delete[] pContents;
}

void CGame::DlgBoxClick_Party(short msX, short msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::Party).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Party).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::Party).cMode) {
	case 0:
		if (m_iPartyStatus == 0)
		{
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100))
			{
				m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 2;
				m_bIsGetPointingMode = true;
				m_iPointCommandType = 200;
				PlaySound('E', 14, 5);
			}
		}

		if (m_iPartyStatus != 0)
		{
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120))
			{
				m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 11;
				PlaySound('E', 14, 5);
			}
		}

		if (m_iPartyStatus != 0)
		{
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140))
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, 0, 2, 0, 0, m_cMCName);
				m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 4;
				PlaySound('E', 14, 5);
			}
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) m_dialogBoxManager.DisableDialogBox(DialogBoxId::Party);
		break;

	case 1:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 1, 0, 0, m_dialogBoxManager.Info(DialogBoxId::Party).cStr);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Party);
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 0, 0, 0, m_dialogBoxManager.Info(DialogBoxId::Party).cStr);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Party);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 3:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 2, 0, 0, m_dialogBoxManager.Info(DialogBoxId::Party).cStr);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Party);
			PlaySound('E', 14, 5);
		}
		break;

	case 4:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 11:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, 0, 0, 0, 0, m_cMCName);
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 5;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::_RequestMapStatus(char* pMapName, int iMode)
{
	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_MAPSTATUS, 0, iMode, 0, 0, pMapName);
}

void CGame::AddMapStatusInfo(char* pData, bool bIsLastData)
{
	char cTotal;
	short sIndex;
	int i;

	std::memset(m_cStatusMapName, 0, sizeof(m_cStatusMapName));

	const auto* header = hb::net::PacketCast<hb::net::PacketNotifyMapStatusHeader>(
		pData, sizeof(hb::net::PacketNotifyMapStatusHeader));
	if (!header) return;
	memcpy(m_cStatusMapName, header->map_name, sizeof(header->map_name));
	sIndex = header->index;
	cTotal = header->total;

	const auto* entries = reinterpret_cast<const hb::net::PacketNotifyMapStatusEntry*>(header + 1);

	for (i = 1; i <= cTotal; i++) {
		m_stCrusadeStructureInfo[sIndex].cType = entries->type;
		m_stCrusadeStructureInfo[sIndex].sX = entries->x;
		m_stCrusadeStructureInfo[sIndex].sY = entries->y;
		m_stCrusadeStructureInfo[sIndex].cSide = entries->side;
		entries++;

		sIndex++;
	}

	if (bIsLastData == true) {
		while (sIndex < DEF_MAXCRUSADESTRUCTURES) {
			m_stCrusadeStructureInfo[sIndex].cType = 0;
			m_stCrusadeStructureInfo[sIndex].sX = 0;
			m_stCrusadeStructureInfo[sIndex].sY = 0;
			m_stCrusadeStructureInfo[sIndex].cSide = 0;
			sIndex++;
		}
	}
}

bool CGame::GetText(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	int len;
	HIMC hIMC = 0;
	if (m_pInputBuffer == 0) return false;
	switch (msg) {
	case WM_IME_COMPOSITION:
		std::memset(m_cEdit, 0, sizeof(m_cEdit));
		if (lparam & GCS_RESULTSTR)
		{
			hIMC = ImmGetContext(hWnd);
			len = ImmGetCompositionString(hIMC, GCS_RESULTSTR, 0, 0);
			if (len > 4) len = 4;
			ImmGetCompositionString(hIMC, GCS_RESULTSTR, m_cEdit, len);
			ImmReleaseContext(hWnd, hIMC);
			len = strlen(m_pInputBuffer) + strlen(m_cEdit);
			if (len < m_cInputMaxLen) strcpy(m_pInputBuffer + strlen(m_pInputBuffer), m_cEdit);
			std::memset(m_cEdit, 0, sizeof(m_cEdit));
		}
		else if (lparam & GCS_COMPSTR)
		{
			hIMC = ImmGetContext(hWnd);
			len = ImmGetCompositionString(hIMC, GCS_COMPSTR, 0, 0);
			if (len > 4) len = 4;
			ImmGetCompositionString(hIMC, GCS_COMPSTR, m_cEdit, len);
			ImmReleaseContext(hWnd, hIMC);
			len = strlen(m_pInputBuffer) + strlen(m_cEdit);
			if (len >= m_cInputMaxLen) std::memset(m_cEdit, 0, sizeof(m_cEdit));
		}
		return true;

	case WM_CHAR:
		if (wparam == 8)
		{
			if (strlen(m_pInputBuffer) > 0)
			{
				len = strlen(m_pInputBuffer);
				switch (GetCharKind(m_pInputBuffer, len - 1)) {
				case 1:
					m_pInputBuffer[len - 1] = 0;
					break;
				case 2:
				case 3:
					m_pInputBuffer[len - 2] = 0;
					m_pInputBuffer[len - 1] = 0;
					break;
				}
				std::memset(m_cEdit, 0, sizeof(m_cEdit));
			}
		}
		else if ((wparam != 9) && (wparam != 13) && (wparam != 27))
		{
			len = strlen(m_pInputBuffer);
			if (len >= m_cInputMaxLen - 1) return false;
			m_pInputBuffer[len] = wparam & 0xff;
			m_pInputBuffer[len + 1] = 0;
		}
		return true;
	}
	return false;
}

int CGame::GetCharKind(char* str, int index)
{
	int kind = 1;
	do
	{
		if (kind == 2) kind = 3;
		else
		{
			if ((unsigned char)*str < 128) kind = 1;
			else kind = 2;
		}
		str++;
		index--;
	} while (index >= 0);
	return kind;
}

void CGame::ShowReceivedString(bool bIsHide)
{
	// Safety check: m_pInputBuffer may not be initialized yet
	if (m_pInputBuffer == nullptr) return;

	std::memset(G_cTxt, 0, sizeof(G_cTxt));

	strcpy(G_cTxt, m_pInputBuffer);
	if ((m_cEdit[0] != 0) && (strlen(m_pInputBuffer) + strlen(m_cEdit) + 1 <= m_cInputMaxLen))
	{
		strcpy(G_cTxt + strlen(m_pInputBuffer), m_cEdit);
	}

	if (bIsHide == true)
	{
		for (unsigned char i = 0; i < strlen(G_cTxt); i++)
			if (G_cTxt[i] != 0) G_cTxt[i] = '*';
	}

	if ((G_dwGlobalTime % 400) < 210) G_cTxt[strlen(G_cTxt)] = '_';

	PutString(m_iInputX + 1, m_iInputY + 1, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX, m_iInputY + 1, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX + 1, m_iInputY, G_cTxt, RGB(0, 0, 0));
	PutString(m_iInputX, m_iInputY, G_cTxt, RGB(255, 255, 255));
}

void CGame::ClearInputString()
{
	if (m_pInputBuffer != 0)	std::memset(m_pInputBuffer, 0, sizeof(m_pInputBuffer));
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
}

void CGame::StartInputString(int sX, int sY, unsigned char iLen, char* pBuffer, bool bIsHide)
{
	m_bInputStatus = true;
	m_iInputX = sX;
	m_iInputY = sY;
	m_pInputBuffer = pBuffer;
	std::memset(m_cEdit, 0, sizeof(m_cEdit));
	m_cInputMaxLen = iLen;
}

void CGame::EndInputString()
{
	m_bInputStatus = false;
	int len = strlen(m_cEdit);
	if (len > 0)
	{
		m_cEdit[len] = 0;
		strcpy(m_pInputBuffer + strlen(m_pInputBuffer), m_cEdit);
		std::memset(m_cEdit, 0, sizeof(m_cEdit));
	}
}

void CGame::ReceiveString(char* pString)
{
	strcpy(pString, m_pInputBuffer);
}

void CGame::DrawNewDialogBox(char cType, int sX, int sY, int iFrame, bool bIsNoColorKey, bool bIsTrans)
{
	uint32_t dwTime = G_dwGlobalTime;

	if (m_pSprite[cType] == 0) return;
	if (bIsNoColorKey == false)
	{
		if (bIsTrans == true)
			m_pSprite[cType]->PutTransSprite2(sX, sY, iFrame, dwTime);
		else m_pSprite[cType]->PutSpriteFast(sX, sY, iFrame, dwTime);
	}
	else m_pSprite[cType]->PutSpriteFastNoColorKey(sX, sY, iFrame, dwTime);
}

void CGame::DlgBoxClick_Commander(int msX, int msY) // Snoopy: Fixed for 351
{
	short sX, sY, tX, tY;
	double d1, d2, d3;
	if (m_bIsCrusadeMode == false) return;
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode) {
	case 0: // Main
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			if (m_iTeleportLocX == -1)
			{
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else
			{
				m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 46 + 100) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 3;
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1 = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 46 + 150) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 4;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 808, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Set TP
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278) && (msY >= sY + 60) && (msY <= sY + 60 + 272))
		{
			d1 = (double)(msX - (sX + 15));
			d2 = (double)(524.0f); //(752.0f);
			d3 = (d2 * d1) / 279.0f;
			tX = (int)d3;
			d1 = (double)(msY - (sY + 60));
			d2 = (double)(524.0f); //(680.0f);
			d3 = (d2 * d1) / (280.0f); //253.0f;
			tY = (int)d3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 494) tX = 494;//722;
			if (tY > 494) tY = 494;//650;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDTELEPORTLOC, 0, tX, tY, 0, "middleland");
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
			_RequestMapStatus("middleland", 1);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 809, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 2: // Use TP
		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 810, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 3: // Summon Unit
		if (m_bAresden == true)
		{
			if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 3000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 47, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 2000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 46, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 43, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1500)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 51, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
		}
		else if (m_bAresden == false)
		{
			if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 3000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 45, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 2000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 44, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1000)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 43, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
			if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1500)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 51, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
				}
			}
		}
		if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 140) && (msY < sY + 160))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1 = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 160) && (msY < sY + 175))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1 = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 811, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 4: // Set constr
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272))
		{
			d1 = (double)(msX - (sX + 15));
			d2 = (double)(524.0);//(752.0f);
			d3 = (d2 * d1) / 279.0f;
			tX = (int)d3;
			d1 = (double)(msY - (sY + 60));
			d2 = (double)(524.0);//(680.0f);
			d3 = (d2 * d1) / (280.0);//253.0f;
			tY = (int)d3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 494) tX = 494;//722;
			if (tY > 494) tY = 494;//650;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC, 0, tX, tY, 0, "middleland");
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
			_RequestMapStatus("middleland", 1);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 812, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_Constructor(int msX, int msY)  // Snoopy: Fixed for 351
{
	short sX, sY;
	if (m_bIsCrusadeMode == false) return;
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode) {
	case 0: // Main
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			if (m_iConstructLocX == -1)
			{
				SetTopMsg(m_pGameMsgList[14]->m_pMsg, 5);
			}
			else
			{
				m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode = 1;
				PlaySound('E', 14, 5);
			}
		}
		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			if (m_iTeleportLocX == -1)
			{
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else
			{
				m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 805, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Choose building
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 38, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
			PlaySound('E', 14, 5);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
		}
		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 39, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
			PlaySound('E', 14, 5);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
		}
		if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 36, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
			PlaySound('E', 14, 5);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
		}
		if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, 0, 37, 1, m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1, 0);
			PlaySound('E', 14, 5);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
		}

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 806, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 2: // Use TP
		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 807, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_Soldier(int msX, int msY) // Snoopy: Fixed for 351
{
	short sX, sY;
	if (m_bIsCrusadeMode == false) return;
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).cMode) {
	case 0: // Main dlg
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			if (m_iTeleportLocX == -1)
			{
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else
			{
				m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).cMode = 1;
				PlaySound('E', 14, 5);
			}
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 803, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Use TP
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46 + 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeSoldier);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 804, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::SetCameraShakingEffect(short sDist, int iMul)
{
	int iDegree;

	iDegree = 5 - sDist;
	if (iDegree <= 0) iDegree = 0;
	iDegree *= 2;

	if (iMul != 0) iDegree *= iMul;

	if (iDegree <= 2) return;

	m_iCameraShakingDegree = iDegree;
}

void CGame::MeteorStrikeComing(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[0]->m_pMsg, 5);
		break;
	case 2: //
		SetTopMsg(m_pGameMsgList[10]->m_pMsg, 10);
		break;
	case 3: //
		SetTopMsg(m_pGameMsgList[91]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[11]->m_pMsg, 10);
		break;
	}
}

void CGame::DrawObjectFOE(int ix, int iy, int iFrame)
{
	if (_iGetFOE(_tmp_iStatus) < 0) // red crusade circle
	{
		if (iFrame <= 4) m_pEffectSpr[38]->PutTransSprite(ix, iy, iFrame, G_dwGlobalTime);
	}
}

void CGame::SetTopMsg(char* pString, unsigned char iLastSec)
{
	std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	strcpy(m_cTopMsg, pString);

	m_iTopMsgLastSec = iLastSec;
	m_dwTopMsgTime = G_dwGlobalTime;
}

void CGame::DrawTopMsg()
{
	if (strlen(m_cTopMsg) == 0) return;
	m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, 30);

	if ((((G_dwGlobalTime - m_dwTopMsgTime) / 250) % 2) == 0)
		PutAlignedString(0, LOGICAL_MAX_X, 10, m_cTopMsg, 255, 255, 0);

	if (G_dwGlobalTime > (m_iTopMsgLastSec * 1000 + m_dwTopMsgTime)) {
		std::memset(m_cTopMsg, 0, sizeof(m_cTopMsg));
	}
}

void CGame::DrawDialogBox_Slates(short msX, short msY, short msZ, char cLB)
{
	int iAdjX, iAdjY;
	short sX, sY;
	uint32_t dwTime = m_dwCurTime;

	iAdjX = 5;
	iAdjY = 8;

	switch (m_dialogBoxManager.Info(DialogBoxId::Slates).cMode) {
		// Slates Dialog - Diuuude
	case 1:
		sX = m_dialogBoxManager.Info(DialogBoxId::Slates).sX;
		sY = m_dialogBoxManager.Info(DialogBoxId::Slates).sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX, sY, 4);

		if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX + 20, sY + 12, 5);
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX + 20, sY + 87, 6);
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX + 85, sY + 32, 7);
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX + 70, sY + 97, 8);
		}

		if ((m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 != -1)) {
			if ((msX >= sX + 120) && (msX <= sX + 180) && (msY >= sY + 150) && (msY <= sY + 165))
				PutString_SprFont(sX + 120, sY + 150, "Casting", 6, 6, 20);
			else PutString_SprFont(sX + 120, sY + 150, "Casting", 0, 0, 7);
		}

		break;

		// Slates Dialog - Diuuude
	case 2:
		PlaySound('E', 16, 0);
		if (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] != 0)
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Slates).sX + iAdjX + (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] * 2)));
			sY = m_dialogBoxManager.Info(DialogBoxId::Slates).sY + iAdjY + (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] * 2)));
		}
		else
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Slates).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::Slates).sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY]->PutSpriteFast(sX, sY, 4, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY]->PutSpriteFast(sX + 22, sY + 14, 3, dwTime);
		//PutString_SprFont(sX + iAdjX + 170, sY + iAdjY + 170, "KURURURURURURURURU!!!", 20,6,6);
		PutAlignedString(199, 438, 201, "KURURURURURURURURU!!!", 220, 140, 160);
		PutAlignedString(200, 439, 200, "KURURURURURURURURU!!!", 90, 220, 200);

		if ((dwTime - m_dialogBoxManager.Info(DialogBoxId::Slates).dwT1) > 1000)
		{
			m_dialogBoxManager.Info(DialogBoxId::Slates).dwT1 = dwTime;
			m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0]++;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Slates).cStr[0] >= 5)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_CREATESLATE, 0, m_dialogBoxManager.Info(DialogBoxId::Slates).sV1, m_dialogBoxManager.Info(DialogBoxId::Slates).sV2, m_dialogBoxManager.Info(DialogBoxId::Slates).sV3, 0, m_dialogBoxManager.Info(DialogBoxId::Slates).sV4);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Slates);
		}
		break;
	}
}

void CGame::DlgBoxClick_Slates(short msX, short msY)
{
	int iAdjX, iAdjY;
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::Slates).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Slates).sY;
	iAdjX = 5;
	iAdjY = 8;
	switch (m_dialogBoxManager.Info(DialogBoxId::Slates).cMode) {
		// Slates DialogBox - Diuuude
	case 1:
		if ((m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 != -1) && (m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 != -1)) {
			if ((msX >= sX + 120) && (msX <= sX + 180) && (msY >= sY + 150) && (msY <= sY + 165)) {
				m_dialogBoxManager.Info(DialogBoxId::Slates).cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		break;
	}
}

void CGame::CannotConstruct(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[18]->m_pMsg, 5);
		break;

	case 2: //
		wsprintf(G_cTxt, "%s XY(%d, %d)", m_pGameMsgList[19]->m_pMsg, m_iConstructLocX, m_iConstructLocY);
		SetTopMsg(G_cTxt, 5);
		break;

	case 3: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;

	}
}

void CGame::DisplayCommaNumber_G_cTxt(uint32_t iGold)
{
	char cGold[20];
	int iStrLen;
	std::memset(cGold, 0, sizeof(cGold));
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	ltoa(iGold, cGold, 10);
#ifdef DEF_COMMA_GOLD
	iStrLen = strlen(cGold);
	iStrLen--;
	int cnt = 0;
	for (int i = 0; i < iStrLen + 1; i++)
	{
		if ((cnt != 0) && ((cnt + 1) % 4 == 0))
		{
			G_cTxt[cnt] = ',';
			i--;
		}
		else G_cTxt[cnt] = cGold[iStrLen - i];
		cnt++;
	}
	iStrLen = strlen(G_cTxt);
	G_cTxt[iStrLen] = '\0';
	strrev(G_cTxt);
#else
	strcpy(G_cTxt, cGold);
#endif
}

void CGame::CrusadeContributionResult(int iWarContribution)
{
	int i;
	char cTemp[120];
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (iWarContribution > 0)
	{
		PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[22]->m_pMsg, 0); // Congratulations! Your nation
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[23]->m_pMsg, 0); // was victory in the battle!
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, m_pGameMsgList[24]->m_pMsg, 0); // As a victorious citizen
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[25]->m_pMsg, 0); // You will receive
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[26]->m_pMsg, 0); // a prize
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[27]->m_pMsg, 0); // Experience point of the battle contribution:
		std::memset(cTemp, 0, sizeof(cTemp));											//
		wsprintf(cTemp, "+%dExp Points!", iWarContribution);
		m_pMsgTextList[8] = new class CMsg(0, cTemp, 0);
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);

	}
	else if (iWarContribution < 0)
	{
		PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[28]->m_pMsg, 0); // Unfortunately! Your country
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[29]->m_pMsg, 0); // have lost the all out war.
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, m_pGameMsgList[30]->m_pMsg, 0); // As a losser citizen;
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[31]->m_pMsg, 0); // the prize that accomplishes
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[32]->m_pMsg, 0); // will not be given.
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[33]->m_pMsg, 0); // I hope you to win
		m_pMsgTextList[8] = new class CMsg(0, m_pGameMsgList[34]->m_pMsg, 0); // in the next battle
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else if (iWarContribution == 0)
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[50]->m_pMsg, 0); // The battle that you have participated
		m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[51]->m_pMsg, 0); // is already finished;
		m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[52]->m_pMsg, 0); //
		m_pMsgTextList[3] = new class CMsg(0, " ", 0);
		m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[53]->m_pMsg, 0); // You must connect after finishing
		m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[54]->m_pMsg, 0); // the previous and before starting
		m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[55]->m_pMsg, 0); // the next battle so you can receive
		m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[56]->m_pMsg, 0); // the prize
		for (i = 8; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
}


void CGame::CrusadeWarResult(int iWinnerSide)
{
	int i, iPlayerSide;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (m_bCitizen == false) iPlayerSide = 0;
	else if (m_bAresden == true) iPlayerSide = 1;
	else if (m_bAresden == false) iPlayerSide = 2;
	if (iPlayerSide == 0)
	{
		switch (iWinnerSide) {
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[36]->m_pMsg, 0); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[37]->m_pMsg, 0); // battle
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			break;
		}
		for (i = 4; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (iWinnerSide == 0)
		{
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[36]->m_pMsg, 0); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[37]->m_pMsg, 0); // battle
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			for (i = 4; i < 18; i++)
				m_pMsgTextList[i] = new class CMsg(0, " ", 0);
		}
		else
		{
			if (iWinnerSide == iPlayerSide)
			{
				PlaySound('E', 23, 0, 0);
				PlaySound('C', 21, 0, 0);
				PlaySound('C', 22, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!;
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[42]->m_pMsg, 0); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[43]->m_pMsg, 0); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[44]->m_pMsg, 0); // You will receive
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[45]->m_pMsg, 0); // a prize
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[42]->m_pMsg, 0); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[43]->m_pMsg, 0); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[44]->m_pMsg, 0); // You will receive
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[45]->m_pMsg, 0); // a prize
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if (iWinnerSide != iPlayerSide)
			{
				PlaySound('E', 24, 0, 0);
				PlaySound('C', 12, 0, 0);
				PlaySound('C', 13, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[38]->m_pMsg, 0); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[39]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[46]->m_pMsg, 0); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[47]->m_pMsg, 0); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[48]->m_pMsg, 0); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[49]->m_pMsg, 0); // will not be given.
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(0, m_pGameMsgList[35]->m_pMsg, 0); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(0, m_pGameMsgList[40]->m_pMsg, 0); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(0, m_pGameMsgList[41]->m_pMsg, 0); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(0, " ", 0);
					m_pMsgTextList[4] = new class CMsg(0, m_pGameMsgList[46]->m_pMsg, 0); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(0, m_pGameMsgList[47]->m_pMsg, 0); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(0, m_pGameMsgList[48]->m_pMsg, 0); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(0, m_pGameMsgList[49]->m_pMsg, 0); // will not be given.
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
		}
	}
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeSoldier);
}

void CGame::_Draw_UpdateScreen_OnCreateNewAccount()
{
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, SCREENX, SCREENY, 0, true);
	PutString2(329 + SCREENX, 110 + SCREENY, m_cAccountName, 200, 200, 200);
	PutString(329 + SCREENX, 125 + SCREENY, m_cAccountPassword, RGB(200, 200, 200), true, 1);
	PutString(329 + SCREENX, 140 + SCREENY, m_cAccountPassword, RGB(200, 200, 200), true, 1);
	PutString2(300 + SCREENX, 202 + SCREENY, m_cAccountCountry, 200, 200, 200);
	PutString2(300 + SCREENX, 218 + SCREENY, m_cAccountSSN, 200, 200, 200);
	PutString2(194 + SCREENX, 257 + SCREENY, m_cEmailAddr, 200, 200, 200);
}

void CGame::DrawChatMsgBox(short sX, short sY, int iChatIndex, bool bIsPreDC)
{
	char cMsg[100], cMsgA[22], cMsgB[22], cMsgC[22], * cp;
	int  iRet, iLines, i, iSize, iSize2, iLoc, iFontSize;
	uint32_t dwTime;
	COLORREF rgb;
	bool bIsTrans;
	RECT rcRect;
	SIZE Size;

	std::memset(cMsg, 0, sizeof(cMsg));
	std::memset(cMsgA, 0, sizeof(cMsgA));
	std::memset(cMsgB, 0, sizeof(cMsgB));
	std::memset(cMsgC, 0, sizeof(cMsgC));

	dwTime = m_pChatMsgList[iChatIndex]->m_dwTime;
	strcpy(cMsg, m_pChatMsgList[iChatIndex]->m_pMsg);
	cp = (char*)cMsg;
	iLines = 0;

	rgb = RGB(255, 255, 255);
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 1:
		rgb = RGB(255, 255, 255);
		break;
	case 20:
		rgb = RGB(255, 255, 20);
		// �޽��� ǥ�ÿ� �����̰� �ɸ���.
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	case 41:
		rgb = RGB(255, 80, 80);
		break;

	case 42:
		rgb = RGB(255, 80, 80);
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgA, cp, 20);

		iRet = GetCharKind(cMsgA, 19);
		if (iRet == CODE_HAN1) {
			cMsgA[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 1;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgB, cp, 20);

		iRet = GetCharKind(cMsgB, 19);
		if (iRet == CODE_HAN1) {
			cMsgB[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 2;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgC, cp, 20);

		iRet = GetCharKind(cMsgC, 19);
		if (iRet == CODE_HAN1) {
			cMsgC[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 3;
	}

	iSize = 0;
	for (i = 0; i < 20; i++)
		if (cMsgA[i] != 0)

			if ((unsigned char)cMsgA[i] >= 128) {
				iSize += 5;	//6
				i++;
			}
			else iSize += 4;

	iLoc = m_dwCurTime - dwTime;
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 21:
	case 22:
	case 23://...
		if (iLoc > 80) iLoc = 10;
		else iLoc = iLoc >> 3;
		break;
	default://
		if (iLoc > 352) iLoc = 9;
		else if (iLoc > 320) iLoc = 10;
		else iLoc = iLoc >> 5;
		break;
	}

	if (m_cDetailLevel == 0)
		bIsTrans = false;
	else bIsTrans = true;

	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 41:
	case 42:
		iSize2 = 0;
		for (i = 0; i < 100; i++)
			if (cMsg[i] != 0)
				if ((unsigned char)cMsg[i] >= 128) {
					iSize2 += 5;
					i++;
				}
				else iSize2 += 4;
		if (CMisc::bCheckIMEString(cMsg) == false)
		{
			PutString(sX - iSize2, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
			PutString(sX - iSize2 + 1, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
		}
		else PutString_SprFont3(sX - iSize2, sY - 65 - iLoc, cMsg, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, false, 0);
		break;

	case 21:
	case 22:
	case 23:
		iFontSize = 23 - (int)m_pChatMsgList[iChatIndex]->m_cType;
		switch (iLines) {
		case 1:
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		case 2:
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgB, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		case 3:
			PutString_SprFont3(sX - iSize, sY - 97 - iLoc, cMsgA, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgB, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgC, m_wR[13] * 2, m_wG[13] * 2, m_wB[13] * 2, bIsTrans, iFontSize);
			break;
		}
		break;

	case 20:
	default:
		if (bIsPreDC == false)
			m_DDraw._GetBackBufferDC();

		GetTextExtentPoint32(m_DDraw.m_hDC, cMsg, strlen(cMsg), &Size);

		switch (Size.cx / 160) {
		case 0:
			SetRect(&rcRect, sX - 80 + 1, sY - 65 - iLoc, sX + 80 + 1, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 65 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 65 - iLoc, sX + 80, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 1:
			SetRect(&rcRect, sX - 80 + 1, sY - 83 - iLoc, sX + 80 + 1, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 83 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 83 - iLoc, sX + 80, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 2:
			SetRect(&rcRect, sX - 80 + 1, sY - 101 - iLoc, sX + 80 + 1, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 101 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 101 - iLoc, sX + 80, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 3:
			SetRect(&rcRect, sX - 80 + 1, sY - 119 - iLoc, sX + 80 + 1, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 119 - iLoc + 1, sX + 80, sY - iLoc + 1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0, 0, 0));

			SetRect(&rcRect, sX - 80, sY - 119 - iLoc, sX + 80, sY - iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		}

		if (bIsPreDC == false)
			m_DDraw._ReleaseBackBufferDC();
		break;
	}
}

void CGame::ClearContents_OnSelectCharacter()
{
	m_cCurFocus = 1;
}



void CGame::UpdateScreen_OnSelectCharacter()
{
	short sX, sY, msX, msY, msZ;
	char  cLB, cRB, cTotalChar;
	char  cMIresult;
	static class CMouseInterface* pMI;
	uint32_t dwTime;
	static DWORD dwCTime;

	int iMIbuttonNum;

	dwTime = GameClock::GetTimeMS();
	sX = 0;
	sY = 0;
	cTotalChar = 0;

	if (m_cGameModeCount == 0)
	{
		G_cSpriteAlphaDegree = 1;
		InitGameSettings();
		pMI = new class CMouseInterface;
		pMI->AddRect(100 + SCREENX, 50 + SCREENY, 210 + SCREENX, 250 + SCREENY);
		pMI->AddRect(211 + SCREENX, 50 + SCREENY, 321 + SCREENX, 250 + SCREENY);
		pMI->AddRect(322 + SCREENX, 50 + SCREENY, 431 + SCREENX, 250 + SCREENY);
		pMI->AddRect(432 + SCREENX, 50 + SCREENY, 542 + SCREENX, 250 + SCREENY);

		pMI->AddRect(360 + SCREENX, 283 + SCREENY, 545 + SCREENX, 315 + SCREENY);
		pMI->AddRect(360 + SCREENX, 316 + SCREENY, 545 + SCREENX, 345 + SCREENY);
		pMI->AddRect(360 + SCREENX, 346 + SCREENY, 545 + SCREENX, 375 + SCREENY);
		pMI->AddRect(360 + SCREENX, 376 + SCREENY, 545 + SCREENX, 405 + SCREENY);
		pMI->AddRect(360 + SCREENX, 406 + SCREENY, 545 + SCREENX, 435 + SCREENY);

		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1)		   m_cCurFocus = 1;

		m_cArrowPressed = 0;
		m_bEnterPressed = false;

		dwCTime = GameClock::GetTimeMS();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = false;
		return;
	}

	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus - 1] != 0)
		{
			if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
			{
				std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
				m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
				if (CMisc::bCheckValidString(m_cPlayerName) == true)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
					m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
					m_pLSock->bInitBufferSize(30000);
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					std::memset(m_cMsg, 0, sizeof(m_cMsg));
					strcpy(m_cMsg, "33");
					std::memset(m_cMapName, 0, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
					delete pMI;
					return;
				}
			}
		}
		else
		{
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete pMI;
			return;
		}
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(sX, sY, msX, msY);

	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else
			{
				if (m_pCharList[m_cCurFocus - 1] != 0)
				{
					if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
					{
						std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
						if (CMisc::bCheckValidString(m_cPlayerName) == true)
						{
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
							m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
							m_pLSock->bInitBufferSize(30000);
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							std::memset(m_cMsg, 0, sizeof(m_cMsg));
							strcpy(m_cMsg, "33");
							std::memset(m_cMapName, 0, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
							delete pMI;
							return;
						}
					}
				}
				else
				{
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete pMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
				{
					std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;

					if (CMisc::bCheckValidString(m_cPlayerName) == true) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
						m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
						m_pLSock->bInitBufferSize(30000);
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						std::memset(m_cMsg, 0, sizeof(m_cMsg));
						strcpy(m_cMsg, "33");
						std::memset(m_cMapName, 0, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
						delete pMI;
						return;
					}
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4)
			{
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete pMI;
				return;
			}
			break;

		case 7:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus;
				delete pMI;
				return;
			}
			break;

		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete pMI;
			return;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
	//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);
}

bool CGame::bDlgBoxPress_Character(short msX, short msY)
{
	int i;
	short sX, sY, sSprH, sFrame;
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS];

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return false;

	sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY;
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) cEquipPoiStatus[i] = -1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}

	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 41, sY + 137, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if ((cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1))
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	return false;
}

void CGame::CivilRightAdmissionHandler(char* pData)
{
	uint16_t wResult;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResult = header->msg_type;

	switch (wResult) {
	case 0:
		m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).cMode = 4;
		break;

	case 1:
		m_dialogBoxManager.Info(DialogBoxId::CityHallMenu).cMode = 3;
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseCivilRight>(
			pData, sizeof(hb::net::PacketResponseCivilRight));
		if (!pkt) return;
		std::memset(m_cLocation, 0, sizeof(m_cLocation));
		memcpy(m_cLocation, pkt->location, 10);
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{
			m_bAresden = true;
			m_bCitizen = true;
			m_bHunter = false;
		}
		else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{
			m_bAresden = true;
			m_bCitizen = true;
			m_bHunter = true;
		}
		else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{
			m_bAresden = false;
			m_bCitizen = true;
			m_bHunter = false;
		}
		else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{
			m_bAresden = false;
			m_bCitizen = true;
			m_bHunter = true;
		}
		else
		{
			m_bAresden = true;
			m_bCitizen = false;
			m_bHunter = true;
		}
		break;
	}
}

void CGame::_RemoveChatMsgListByObjectID(int iObjectID)
{
	int i;

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if ((m_pChatMsgList[i] != 0) && (m_pChatMsgList[i]->m_iObjectID == iObjectID)) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = 0;
		}
}

void CGame::PlaySound(char cType, int iNum, int iDist, long lPan)
{
	// Forward to AudioManager
	SoundType type;
	switch (cType)
	{
	case 'C':
		type = SoundType::Character;
		break;
	case 'M':
		type = SoundType::Monster;
		break;
	case 'E':
		type = SoundType::Effect;
		break;
	default:
		return;
	}
	AudioManager::Get().PlaySound(type, iNum, iDist, static_cast<int>(lPan));
}


bool CGame::_bCheckItemByType(char cType)
{
	int i;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_pItemList[i]->m_cItemType == cType)) return true;

	return false;
}


void CGame::DynamicObjectHandler(char* pData)
{
	short sX, sY, sV1, sV2, sV3;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseDynamicObject>(
		pData, sizeof(hb::net::PacketResponseDynamicObject));
	if (!pkt) return;
	sX = pkt->x;
	sY = pkt->y;
	sV1 = pkt->v1;
	sV2 = pkt->v2;
	sV3 = pkt->v3;

	switch (pkt->header.msg_type) {
	case DEF_MSGTYPE_CONFIRM:// Dynamic Object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, sV1, true);
		break;

	case DEF_MSGTYPE_REJECT:// Dynamic object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, 0, true);
		break;
	}
}

bool CGame::_bIsItemOnHand() // Snoopy: Fixed to remove ShieldCast
{
	int i;
	uint16_t wWeaponType;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if ((m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
				return true;
		}
	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
			{
				wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
				// Snoopy 34 for all wands.
				if ((wWeaponType >= 34) && (wWeaponType < 40)) return false;
				//else if( wWeaponType == 27 ) return false; // Farming's hoe !
				else return true;
			}
		}
	return false;
}

int CGame::_iCalcTotalWeight()
{
	int i, iWeight, iCnt, iTemp;
	iCnt = 0;
	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			if ((m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				|| (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW))
			{
				iTemp = m_pItemList[i]->m_wWeight * m_pItemList[i]->m_dwCount;
				if (strcmp(m_pItemList[i]->m_cName, "Gold") == 0) iTemp = iTemp / 20;
				iWeight += iTemp;
			}
			else iWeight += m_pItemList[i]->m_wWeight;
			iCnt++;
		}

	return iWeight;
}

void CGame::DlgBoxClick_ItemSellorRepair(short msX, short msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode) {
	case 1:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Sell
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SELLITEMCONFIRM, 0, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV4, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV3, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1]->m_cName); //v1.2
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode = 3;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1] = false;
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
		}
		break;

	case 2:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Repair
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM, 0, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1, 0, 0, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1]->m_cName);
			m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode = 4;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1] = false;
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
		}
		break;
	}
}
uint32_t CGame::iGetLevelExp(int iLevel)
{
	uint32_t iRet;
	if (iLevel == 0) return 0;
	iRet = iGetLevelExp(iLevel - 1) + iLevel * (50 + (iLevel * (iLevel / 17) * (iLevel / 17)));
	return iRet;
}

int CGame::_iGetTotalItemNum()
{
	int i, iCnt;
	iCnt = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] != 0) iCnt++;
	return iCnt;
}

bool CGame::bCheckExID(char* pName)
{
	if (m_pExID == 0) return false;
	if (memcmp(m_cPlayerName, pName, 10) == 0) return false;
	char cTxt[12];
	std::memset(cTxt, 0, sizeof(cTxt));
	memcpy(cTxt, m_pExID->m_pMsg, strlen(m_pExID->m_pMsg));
	if (memcmp(cTxt, pName, 10) == 0) return true;
	else return false;
}

void CGame::DrawWhetherEffects()
{
#define MAXNUM 1000
	static int ix1[MAXNUM];
	static int iy2[MAXNUM];
	static int iFrame[MAXNUM];
	static int iNum = 0;
	int i;
	short dX, dY, sCnt;
	char cTempFrame;
	uint32_t dwTime = m_dwCurTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}

		for (i = 0; i < sCnt; i++)
		{
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20) && (m_stWhetherObject[i].sX != 0))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				cTempFrame = 16 + (m_stWhetherObject[i].cStep / 6);
				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			}
			else if ((m_stWhetherObject[i].cStep >= 20) && (m_stWhetherObject[i].cStep < 25) && (m_stWhetherObject[i].sX != 0))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite(dX, dY, m_stWhetherObject[i].cStep, dwTime);
			}
		}
		break;

	case 4:
	case 5:
	case 6: // Snow
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;

				// Snoopy: Snow on lower bar
				if (dY >= 460)
				{
					cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20) * 3;
					dX = m_stWhetherObject[i].sBX;
					dY = 426;
				}
				else cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20) * 3 + (rand() % 3);

				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);

				if (m_bIsXmas == true)
				{
					if (dY == 478 - 53)
					{
						ix1[iNum] = dX;
						iy2[iNum] = dY + (rand() % 5);
						iFrame[iNum] = cTempFrame;
						iNum++;
					}
					if (iNum >= MAXNUM) iNum = 0;
				}
			}
		}
		if (m_bIsXmas == true)
		{
			for (i = 0; i <= MAXNUM; i++)
			{
				if (iy2[i] > 10) m_pEffectSpr[11]->PutTransSprite(ix1[i], iy2[i], iFrame[i], dwTime);
			}
		}
		break;
	}
}

void CGame::WhetherObjectFrameCounter()
{
	int i;
	short sCnt;
	char  cAdd;
	uint32_t dwTime = m_dwCurTime;

	if ((dwTime - m_dwWOFtime) < 30) return;
	m_dwWOFtime = dwTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // Rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20))
			{
				cAdd = (40 - m_stWhetherObject[i].cStep);
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;
				if (cAdd != 0)
					m_stWhetherObject[i].sX = m_stWhetherObject[i].sX - 1;
			}
			else if (m_stWhetherObject[i].cStep >= 25)
			{
				if (m_bIsWhetherEffect == false)
				{
					m_stWhetherObject[i].sX = 0;
					m_stWhetherObject[i].sY = 0;
					m_stWhetherObject[i].cStep = 30;
				}
				else
				{
					m_stWhetherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % LOGICAL_WIDTH) - LOGICAL_HEIGHT) + 240;
					m_stWhetherObject[i].cStep = -1 * (rand() % 10);
				}
			}
		}
		break;

	case 4:
	case 5:
	case 6:
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{
				cAdd = (80 - m_stWhetherObject[i].cStep) / 10;
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;

				//Snoopy: Snow on lower bar
				if (m_stWhetherObject[i].sY > (426 + m_sViewPointY))
				{
					m_stWhetherObject[i].sY = 470 + m_sViewPointY;
					if ((rand() % 10) != 2) m_stWhetherObject[i].cStep--;
					if (m_stWhetherObject[i].sBX == 0) m_stWhetherObject[i].sBX = m_stWhetherObject[i].sX - m_sViewPointX;


				}
				else m_stWhetherObject[i].sX += 1 - (rand() % 3);
			}
			else if (m_stWhetherObject[i].cStep >= 80)
			{
				if (m_bIsWhetherEffect == false)
				{
					m_stWhetherObject[i].sX = 0;
					m_stWhetherObject[i].sY = 0;
					m_stWhetherObject[i].sBX = 0;
					m_stWhetherObject[i].cStep = 80;
				}
				else
				{
					m_stWhetherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % LOGICAL_WIDTH) - LOGICAL_HEIGHT) + LOGICAL_HEIGHT;
					m_stWhetherObject[i].cStep = -1 * (rand() % 10);
					m_stWhetherObject[i].sBX = 0;
				}
			}
		}
		break;
	}
}

void CGame::SetWhetherStatus(bool bStart, char cType)
{
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);

	// Always stop weather sounds first when changing weather
	AudioManager::Get().StopSound(SoundType::Effect, 38);

	if (bStart == true)
	{
		m_bIsWhetherEffect = true;
		m_cWhetherEffectType = cType;

		// Rain sound (types 1-3)
		if (AudioManager::Get().IsSoundEnabled() && (cType >= 1) && (cType <= 3))
			AudioManager::Get().PlaySoundLoop(SoundType::Effect, 38);

		for (int i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
		{
			m_stWhetherObject[i].sX = 1;
			m_stWhetherObject[i].sBX = 1;
			m_stWhetherObject[i].sY = 1;
			m_stWhetherObject[i].cStep = -1 * (rand() % 40);
		}

		// Snow BGM (types 4-6)
		if (cType >= 4 && cType <= 6)
		{
			if (AudioManager::Get().IsMusicEnabled()) StartBGM();
		}
	}
	else
	{
		m_bIsWhetherEffect = false;
		m_cWhetherEffectType = 0;
	}
}

void CGame::DrawLine(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
	int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
	int iResultX, iResultY;
	WORD* pDst;

	if ((x0 == x1) && (y0 == y1)) return;
	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1 - x0;
	dy = y1 - y0;
	if (dx >= 0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}
	if (dy >= 0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}
	if (dx > dy)
	{
		for (index = 0; index <= dx; index++)
		{
			error += dy;
			if (error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
	else
	{
		for (index = 0; index <= dy; index++)
		{
			error += dx;
			if (error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
}


void CGame::DrawLine2(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
	int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
	int iResultX, iResultY;
	WORD* pDst;
	if ((x0 == x1) && (y0 == y1)) return;

	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1 - x0;
	dy = y1 - y0;
	if (dx >= 0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}
	if (dy >= 0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}
	if (dx > dy)
	{
		for (index = 0; index <= dx; index++)
		{
			error += dy;
			if (error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
	else
	{
		for (index = 0; index <= dy; index++)
		{
			error += dx;
			if (error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < LOGICAL_MAX_X) && (iResultY >= 0) && (iResultY < LOGICAL_MAX_Y)) {
				pDst = (WORD*)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0xF800) >> 11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0] & 0x7E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 11) | (dstG << 5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x7C00) >> 10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0] & 0x3E0) >> 5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0] & 0x1F)][iB];
					*pDst = (WORD)((dstR << 10) | (dstG << 5) | dstB);
					break;
				}
			}
		}
	}
}

void CGame::_DrawThunderEffect(int sX, int sY, int dX, int dY, int rX, int rY, char cType)
{
	int j, iErr, pX1, pY1, iX1, iY1, tX, tY;
	char cDir;
	uint32_t dwTime;
	uint16_t wR1, wG1, wB1, wR2, wG2, wB2, wR3, wG3, wB3, wR4, wG4, wB4;
	dwTime = m_dwCurTime;
	sX = pX1 = iX1 = tX = sX;
	sY = pY1 = iY1 = tY = sY;
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 100), &wR1, &wG1, &wB1);
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(30, 30, 100), &wR2, &wG2, &wB2);
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0, 0, 30), &wR3, &wG3, &wB3);
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 200), &wR4, &wG4, &wB4);

	for (j = 0; j < 100; j++)
	{
		switch (cType) {
		case 1:
			DrawLine(pX1, pY1, iX1, iY1, 15, 15, 20);
			DrawLine(pX1 - 1, pY1, iX1 - 1, iY1, wR1, wG1, wB1);
			DrawLine(pX1 + 1, pY1, iX1 + 1, iY1, wR1, wG1, wB1);
			DrawLine(pX1, pY1 - 1, iX1, iY1 - 1, wR1, wG1, wB1);
			DrawLine(pX1, pY1 + 1, iX1, iY1 + 1, wR1, wG1, wB1);

			DrawLine(pX1 - 2, pY1, iX1 - 2, iY1, wR2, wG2, wB2);
			DrawLine(pX1 + 2, pY1, iX1 + 2, iY1, wR2, wG2, wB2);
			DrawLine(pX1, pY1 - 2, iX1, iY1 - 2, wR2, wG2, wB2);
			DrawLine(pX1, pY1 + 2, iX1, iY1 + 2, wR2, wG2, wB2);

			DrawLine(pX1 - 1, pY1 - 1, iX1 - 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
			DrawLine(pX1 - 1, pY1 + 1, iX1 - 1, iY1 + 1, wR3, wG3, wB3);
			break;

		case 2:
			DrawLine2(pX1, pY1, iX1, iY1, wR4, wG4, wB4);
			break;
		}
		iErr = 0;
		CMisc::GetPoint(sX, sY, dX, dY, &tX, &tY, &iErr, j * 10);
		pX1 = iX1;
		pY1 = iY1;
		cDir = CMisc::cGetNextMoveDir(iX1, iY1, tX, tY);
		switch (cDir) {
		case 1:	rY -= 5; break;
		case 2: rY -= 5; rX += 5; break;
		case 3:	rX += 5; break;
		case 4: rX += 5; rY += 5; break;
		case 5: rY += 5; break;
		case 6: rX -= 5; rY += 5; break;
		case 7: rX -= 5; break;
		case 8: rX -= 5; rY -= 5; break;
		}
		if (rX < -20) rX = -20;
		if (rX > 20) rX = 20;
		if (rY < -20) rY = -20;
		if (rY > 20) rY = 20;
		iX1 = iX1 + rX;
		iY1 = iY1 + rY;
		if ((abs(tX - dX) < 5) && (abs(tY - dY) < 5)) break;
	}
	switch (cType) {
	case 1:
		m_pEffectSpr[6]->PutTransSprite(iX1, iY1, (rand() % 2), dwTime);
		break;
	}
}

bool CGame::bDlgBoxPress_SkillDlg(short msX, short msY)
{
	int i, iAdjX, iAdjY;
	char  cItemID;
	short sX, sY, x1, y1, x2, y2, sArray[10];
	sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
	iAdjX = 5;
	iAdjY = 10;
	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					return true;
				}
			}
		break;

	case 4:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
					return true;
				}
			}
		break;
		// Crafting
	case 7:
		std::memset(sArray, 0, sizeof(sArray));
		sArray[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
		sArray[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
		sArray[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
		sArray[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
		sArray[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
		sArray[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;
		for (i = 1; i <= 6; i++)
			if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
			{
				cItemID = (char)sArray[i];
				switch (i) {
				case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 40, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 115, m_pItemList[cItemID]->m_sSpriteFrame); break;
				case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 75 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
				}
				x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
				y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
				x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
				y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
				if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
				{
					switch (i) {
					case 1: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1; break;
					case 2: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1; break;
					case 3: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1; break;
					case 4: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1; break;
					case 5: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1; break;
					case 6: m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1; break;
					}
					m_bIsItemDisabled[cItemID] = false;
					m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
					m_stMCursor.sSelectedObjectID = cItemID;
					m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
					m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					return true;
				}
			}
		break;
	}

	return false;
}
// Snoopy: added StormBlade
int CGame::_iGetAttackType()
{
	uint16_t wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[5] >= 100)) return 20;
		else return 1;		// Boxe
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[7] >= 100)) return 21;
		else return 1;		//Dag, SS
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Added Kloness Esterk
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[9] >= 100)) return 22;
			else return 1;  // Esterk
		}
		else if (wWeaponType == 15)
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 30;
			else return 5;  // StormBlade
		}
		else
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 23;
			else return 1;	// LongSwords
		}
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[10] >= 100)) return 24;
		else return 1;		// Haches
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[14] >= 100)) return 26;
		else return 1;		// Hammers
	}
	else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[21] >= 100)) return 27;
		else return 1;		// Wands
	}
	else if (wWeaponType >= 40)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[6] >= 100)) return 25;
		else return 2;		// Bows
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[8] >= 100)) return 23;
		else return 1;		// LS
	}
	return 0;
}

int CGame::_iGetWeaponSkillType()
{
	uint16_t wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{
		return 5; // Openhand
	}
	else if ((wWeaponType >= 1) && (wWeaponType < 3))
	{
		return 7; // SS
	}
	else if ((wWeaponType >= 3) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Esterk or KlonessEsterk
			return 9; // Fencing
		else return 8; // LS
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		return 10; // Axe (20..28)
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		return 14; // Hammer (30,31,32)
	}
	else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{
		return 21; // Wand
	}
	else if (wWeaponType >= 40)
	{
		return 6;  // Bow
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		return 8;  // LS LightingBlade || BlackShadow
	}
	return 1; // Fishing !
}

void CGame::NotifyMsg_AdminInfo(char* pData)
{
	char cStr[256];
	int iV1, iV2, iV3, iV4, iV5;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyAdminInfo>(
		pData, sizeof(hb::net::PacketNotifyAdminInfo));
	if (!pkt) return;
	iV1 = pkt->v1;
	iV2 = pkt->v2;
	iV3 = pkt->v3;
	iV4 = pkt->v4;
	iV5 = pkt->v5;

	std::memset(cStr, 0, sizeof(cStr));
	wsprintf(cStr, "%d %d %d %d %d", iV1, iV2, iV3, iV4, iV5);
	AddEventList(cStr);
}

bool CGame::_bCheckBadWords(char* pMsg)
{
	char cStr[500];
	int i, iLen;
	std::memset(cStr, 0, sizeof(cStr));
	strcpy(cStr, pMsg);
	iLen = strlen(cStr);

	for (i = 0; i < iLen; i++) {
		if (m_pCGameMonitor->bCheckBadWord((char*)(cStr + i)) == true) return true;
		if ((unsigned char)cStr[i] >= 128) i++;
	}

	return false;
}

/*********************************************************************************************************************
**  void CGame::bItemDrop_ExchangeDialog(short msX, short msY)	(snoopy)											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void CGame::bItemDrop_ExchangeDialog(short msX, short msY)
{
	char cItemID;
	if (m_cCommand < 0) return;
	if (m_stDialogBoxExchangeInfo[3].sV1 != -1) return; //Do not accept item's drop if already 4 items.

	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1000;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = cItemID;
		//m_dialogBoxManager.Info(DialogBoxId::Exchange).sView = cItemID;
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		return;
	}
	else // hum? d�j� on affiche? , bon je d�sactive, ca devrait plut�t s'afficher lors du retour du serveur.
	{	/*m_dialogBoxManager.Info(DialogBoxId::Exchange).sV1 = m_pItemList[cItemID]->m_sSprite;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV2 = m_pItemList[cItemID]->m_sSpriteFrame;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV3 = 1;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sV4 = m_pItemList[cItemID]->m_cItemColor;
		m_dialogBoxManager.Info(DialogBoxId::Exchange).sView = cItemID;*/
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		m_bIsItemDisabled[cItemID] = true;
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, 0, cItemID, 1, 0, 0);
		//	   :bSendCommand(DWORD dwMsgID,        WORD wCommand,             char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
		return;
	}
}
/*********************************************************************************************************************
**  void CGame::DlgBoxClick_Exchange(short msX, short msY)		(snoopy)											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void CGame::DlgBoxClick_Exchange(short msX, short msY)
{
	short sX, sY;
	sX = m_dialogBoxManager.Info(DialogBoxId::Exchange).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Exchange).sY;
	switch (m_dialogBoxManager.Info(DialogBoxId::Exchange).cMode) {
	case 1: // Not yet confirmed the exchange
		if ((msX >= sX + 220) && (msX <= sX + 220 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)) // Exchange
		{
			if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
			{	/*bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CONFIRMEXCHANGEITEM, 0
					, m_stDialogBoxExchangeInfo[0].sV1 // ItemID; inutilis� par serveur
					, m_stDialogBoxExchangeInfo[0].sV3 // Amount; inutilis� par serveur
					, 0, 0);	*/
				PlaySound('E', 14, 5);
				m_dialogBoxManager.Info(DialogBoxId::Exchange).cMode = 2;
				// Show confirmation Diag instead.
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::ConfirmExchange, 0, 0, 0);
				m_dialogBoxManager.Info(DialogBoxId::ConfirmExchange).cMode = 1;
			}
			return;
		}
		if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)
			&& (m_dialogBoxManager.IsEnabled(DialogBoxId::ConfirmExchange) == false)) // Cancel only possible if confirmation is not activated
		{
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Exchange);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Map);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0);
			PlaySound('E', 14, 5);
			return;
		}
		break;

	case 2: // Someone already confirmed the exchange
		/*	if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY))  // Cancel
			{	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Exchange);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::Map);
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0);
				PlaySound('E', 14, 5);
				return;
			}*/
		break;
	}
}
void CGame::DlgBoxClick_Quest(int msX, int msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::Quest).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Quest).sY;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Quest);
		PlaySound('E', 14, 5);
	}
}

int CGame::_iGetBankItemCount()
{
	int i, iCnt;

	iCnt = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0) iCnt++;

	return iCnt;
}

bool CGame::_bDecodeBuildItemContents()
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE* pFile;
	uint32_t dwFileSize;
	char* pBuffer;
	bool   bRet;
	int    i;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{
			delete m_pBuildItemList[i];
			m_pBuildItemList[i] = 0;
		}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	strcpy(cTemp, "BItemcfg");
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return false;
	else
	{
		pBuffer = new char[dwFileSize + 1];
		std::memset(pBuffer, 0, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);
		bRet = __bDecodeBuildItemContents(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
	return bRet;
}

bool CGame::_bCheckBuildItemStatus()
{
	int iIndex, i, j, iMatch, iCount;
	char cTempName[21];
	int  iItemCount[DEF_MAXITEMS];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0)
		{
			delete m_pDispBuildItemList[i];
			m_pDispBuildItemList[i] = 0;
		}
	iIndex = 0;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{	// Skill-Limit
			if (m_cSkillMastery[13] >= m_pBuildItemList[i]->m_iSkillLimit)
			{
				iMatch = 0;
				m_pDispBuildItemList[iIndex] = new class CBuildItem;
				memcpy(m_pDispBuildItemList[iIndex]->m_cName, m_pBuildItemList[i]->m_cName, 20);

				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName1, m_pBuildItemList[i]->m_cElementName1, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName2, m_pBuildItemList[i]->m_cElementName2, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName3, m_pBuildItemList[i]->m_cElementName3, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName4, m_pBuildItemList[i]->m_cElementName4, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName5, m_pBuildItemList[i]->m_cElementName5, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName6, m_pBuildItemList[i]->m_cElementName6, 20);

				m_pDispBuildItemList[iIndex]->m_iElementCount[1] = m_pBuildItemList[i]->m_iElementCount[1];
				m_pDispBuildItemList[iIndex]->m_iElementCount[2] = m_pBuildItemList[i]->m_iElementCount[2];
				m_pDispBuildItemList[iIndex]->m_iElementCount[3] = m_pBuildItemList[i]->m_iElementCount[3];
				m_pDispBuildItemList[iIndex]->m_iElementCount[4] = m_pBuildItemList[i]->m_iElementCount[4];
				m_pDispBuildItemList[iIndex]->m_iElementCount[5] = m_pBuildItemList[i]->m_iElementCount[5];
				m_pDispBuildItemList[iIndex]->m_iElementCount[6] = m_pBuildItemList[i]->m_iElementCount[6];

				m_pDispBuildItemList[iIndex]->m_iSprH = m_pBuildItemList[i]->m_iSprH;
				m_pDispBuildItemList[iIndex]->m_iSprFrame = m_pBuildItemList[i]->m_iSprFrame;
				m_pDispBuildItemList[iIndex]->m_iMaxSkill = m_pBuildItemList[i]->m_iMaxSkill;
				m_pDispBuildItemList[iIndex]->m_iSkillLimit = m_pBuildItemList[i]->m_iSkillLimit;

				// ItemCount
				for (j = 0; j < DEF_MAXITEMS; j++)
					if (m_pItemList[j] != 0)
						iItemCount[j] = m_pItemList[j]->m_dwCount;
					else iItemCount[j] = 0;

				// Element1
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName1, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[1];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0) {
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[1] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP2;
							}
						}
				}

			CBIS_STEP2:;
				// Element2
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName2, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[2];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[2] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP3;
							}
						}
				}

			CBIS_STEP3:;
				// Element3
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName3, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[3];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[3] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP4;
							}
						}
				}

			CBIS_STEP4:;
				// Element4 �˻�
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName4, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[4];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[4] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP5;
							}
						}
				}

			CBIS_STEP5:;

				// Element5
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName5, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[5];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[5] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP6;
							}
						}
				}

			CBIS_STEP6:;

				// Element6
				std::memset(cTempName, 0, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName6, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[6];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < DEF_MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[6] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP7;
							}
						}
				}

			CBIS_STEP7:;

				if (iMatch == 6) m_pDispBuildItemList[iIndex]->m_bBuildEnabled = true;
				iIndex++;
			}
		}
	return true;
}

bool CGame::_ItemDropHistory(char* ItemName)
{
	bool bFlag = false;
	if (m_iItemDropCnt == 0)
	{
		strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
		m_iItemDropCnt++;
		return true;
	}
	if ((1 <= m_iItemDropCnt) && (20 >= m_iItemDropCnt))
	{
		for (int i = 0; i < m_iItemDropCnt; i++)
		{
			if (strcmp(m_cItemDrop[i], ItemName) == 0)
			{
				bFlag = true;
				break;
			}
		}
		if (bFlag)
		{
			if (m_bItemDrop)
				return false;
			else
				return true;
		}

		if (20 < m_iItemDropCnt)
		{
			for (int i = 0; i < m_iItemDropCnt; i++)
				strcpy(m_cItemDrop[i - 1], ItemName);
			strcpy(m_cItemDrop[20], ItemName);
			m_iItemDropCnt = 21;
		}
		else
		{
			strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
			m_iItemDropCnt++;
		}
	}
	return true;
}


bool CGame::__bDecodeBuildItemContents(char* pBuffer)
{
	char* pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iIndex = 0;
	pContents = pBuffer;
	token = strtok(pContents, seps);

	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					std::memset(m_pBuildItemList[iIndex]->m_cName, 0, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // m_cElementName1
					std::memset(m_pBuildItemList[iIndex]->m_cElementName1, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName1));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName1, token, strlen(token));
					cReadModeB = 4;
					break;
				case 4: // m_iElementCount1
					m_pBuildItemList[iIndex]->m_iElementCount[1] = atoi(token);
					cReadModeB = 5;
					break;
				case 5: // m_cElementName2
					std::memset(m_pBuildItemList[iIndex]->m_cElementName2, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName2));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName2, token, strlen(token));
					cReadModeB = 6;
					break;
				case 6: // m_iElementCount2
					m_pBuildItemList[iIndex]->m_iElementCount[2] = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_cElementName3
					std::memset(m_pBuildItemList[iIndex]->m_cElementName3, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName3));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName3, token, strlen(token));
					cReadModeB = 8;
					break;
				case 8: // m_iElementCount3
					m_pBuildItemList[iIndex]->m_iElementCount[3] = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_cElementName4
					std::memset(m_pBuildItemList[iIndex]->m_cElementName4, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName4));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName4, token, strlen(token));
					cReadModeB = 10;
					break;
				case 10: // m_iElementCount4
					m_pBuildItemList[iIndex]->m_iElementCount[4] = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_cElementName5
					std::memset(m_pBuildItemList[iIndex]->m_cElementName5, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName5));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName5, token, strlen(token));
					cReadModeB = 12;
					break;
				case 12: // m_iElementCount5
					m_pBuildItemList[iIndex]->m_iElementCount[5] = atoi(token);
					cReadModeB = 13;
					break;
				case 13: // m_cElementName6
					std::memset(m_pBuildItemList[iIndex]->m_cElementName6, 0, sizeof(m_pBuildItemList[iIndex]->m_cElementName6));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName6, token, strlen(token));
					cReadModeB = 14;
					break;
				case 14: // m_iElementCount6
					m_pBuildItemList[iIndex]->m_iElementCount[6] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					m_pBuildItemList[iIndex]->m_iSprH = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					m_pBuildItemList[iIndex]->m_iSprFrame = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					iIndex++;
					break;
				}
				break;

			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "BuildItem", 9) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
		}
		token = strtok(NULL, seps);
	}
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}


bool CGame::_bCheckCurrentBuildItemStatus()
{
	int i, iCount2, iMatch, iIndex, iItemIndex[7];
	int iCount;
	int iItemCount[7];
	char cTempName[21];
	bool bItemFlag[7];

	iIndex = m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0];

	if (m_pBuildItemList[iIndex] == 0) return false;

	iItemIndex[1] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1;
	iItemIndex[2] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2;
	iItemIndex[3] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3;
	iItemIndex[4] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4;
	iItemIndex[5] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5;
	iItemIndex[6] = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6;

	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1)
			iItemCount[i] = m_pItemList[iItemIndex[i]]->m_dwCount;
		else iItemCount[i] = 0;
	iMatch = 0;
	for (i = 1; i <= 6; i++) bItemFlag[i] = false;

	// Element1
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName1, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[1];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP2;
			}
		}
	}

CCBIS_STEP2:;

	// Element2
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName2, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[2];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP3;
			}
		}
	}

CCBIS_STEP3:;


	// Element3
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName3, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[3];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP4;
			}
		}
	}

CCBIS_STEP4:;

	// Element4
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName4, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[4];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP5;
			}
		}
	}

CCBIS_STEP5:;

	// Element5
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName5, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[5];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP6;
			}
		}
	}

CCBIS_STEP6:;

	// Element6
	std::memset(cTempName, 0, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName6, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[6];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP7;
			}
		}
	}

CCBIS_STEP7:;

	iCount = 0;
	for (i = 1; i <= 6; i++)
		if (m_pDispBuildItemList[iIndex]->m_iElementCount[i] != 0) iCount++;
	iCount2 = 0;
	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1) iCount2++;
	if ((iMatch == 6) && (iCount == iCount2)) return true;
	return false;
}

void CGame::NoticementHandler(char* pData)
{
	FILE* pFile;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	switch (header->msg_type) {
	case DEF_MSGTYPE_CONFIRM:
	case DEF_MSGTYPE_REJECT:
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseNoticementText>(
			pData, sizeof(hb::net::PacketResponseNoticementText));
		if (!pkt) return;
		pFile = fopen("contents\\contents1000.txt", "wt");
		if (pFile == 0) return;
		fwrite(pkt->text, strlen(pkt->text), 1, pFile);
		fclose(pFile);
		m_dialogBoxManager.Info(DialogBoxId::Text).sX = 20;
		m_dialogBoxManager.Info(DialogBoxId::Text).sY = 65;
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 1000, 0, 0);
		break;
	}
	AddEventList("Press F1 for news and help.", 10);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Help, 0, 0, 0);

}

int CGame::_iGetFOE(int iStatus)
{
	bool bPK, bCitizen, bAresden, bHunter;
	if (m_iPKCount != 0) return -1;
	//	CLEROTH			0x00000000 status is int NOT short ( 3.51 )
	if (iStatus & 0x80000000) bPK = true;
	else bPK = false;
	if (iStatus & 0x40000000) bCitizen = true;
	else bCitizen = false;
	if (iStatus & 0x20000000) bAresden = true;
	else bAresden = false;
	if (iStatus & 0x10000000) bHunter = true;
	else bHunter = false;
	if (bPK == true) return -2;
	if (bCitizen == false) return 0;
	if (m_bCitizen == false) return 0;
	if ((m_bAresden == true) && (bAresden == true)) return 1;
	if ((m_bAresden == false) && (bAresden == false)) return 1;
	if (m_bIsCrusadeMode == true) return -1;
	else
	{
		if ((m_bHunter == false) && (bHunter == false)) return -1;
		else return 0;
	}
}

void CGame::_SetIlusionEffect(int iOwnerH)
{
	char cDir;

	m_iIlusionOwnerH = iOwnerH;

	std::memset(m_cName_IE, 0, sizeof(m_cName_IE));
	m_pMapData->GetOwnerStatusByObjectID(iOwnerH, &m_cIlusionOwnerType, &cDir, &m_sAppr1_IE, &m_sAppr2_IE, &m_sAppr3_IE, &m_sAppr4_IE, &m_iStatus_IE, &m_iApprColor_IE, m_cName_IE);
}

void CGame::ResponsePanningHandler(char* pData)
{
	char cDir;
	short sX, sY;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponsePanningHeader>(
		pData, sizeof(hb::net::PacketResponsePanningHeader));
	if (!pkt) return;
	sX = pkt->x;
	sY = pkt->y;
	cDir = static_cast<char>(pkt->dir);

	switch (cDir) {
	case 1: m_sViewDstY -= 32; m_sPlayerY--; break;
	case 2: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX += 32; m_sPlayerX++; break;
	case 3: m_sViewDstX += 32; m_sPlayerX++; break;
	case 4: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX += 32; m_sPlayerX++; break;
	case 5: m_sViewDstY += 32; m_sPlayerY++; break;
	case 6: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX -= 32; m_sPlayerX--; break;
	case 7: m_sViewDstX -= 32; m_sPlayerX--; break;
	case 8: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX -= 32; m_sPlayerX--; break;
	}

	m_pMapData->ShiftMapData(cDir);
	const char* mapData = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponsePanningHeader);
	_ReadMapData(sX, sY, mapData);

	m_bIsRedrawPDBGS = true;

	m_bIsObserverCommanded = false;
}

bool CGame::bReadItemNameConfigFile()
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t dwFileSize;
	char* cp, * token, cReadModeA, cReadModeB;
	char seps[] = "=\n";
	int iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile("contents\\ItemName.cfg", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen("contents\\ItemName.cfg", "rt");
	if (pFile == 0) return false;
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);
		while (token != 0) {

			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						m_pItemNameList[iIndex] = new class CItemName;
						strcpy(m_pItemNameList[iIndex]->m_cOriginName, token);
						cReadModeB = 2;
						break;

					case 2:
						strcpy(m_pItemNameList[iIndex]->m_cName, token);
						cReadModeA = 0;
						cReadModeB = 0;
						iIndex++;
						break;
					}
				}
			}
			else {
				if (memcmp(token, "Item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = strtok(0, seps);
		}
		delete[] cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

/*********************************************************************************************************************
**  void CGame::NotifyMsg_SetExchangeItem(char *pData)		(snoopy)												**
**  description			:: Recieve a msg from gserver and sets the item												**
**********************************************************************************************************************/
void CGame::NotifyMsg_SetExchangeItem(char* pData)
{
	short sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
	int iAmount, i;
	char cColor, cItemName[24], cCharName[12];
	DWORD dwAttribute;
	std::memset(cItemName, 0, sizeof(cItemName));
	std::memset(cCharName, 0, sizeof(cCharName));

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyExchangeItem>(
		pData, sizeof(hb::net::PacketNotifyExchangeItem));
	if (!pkt) return;
	sDir = static_cast<short>(pkt->dir);
	sSprite = pkt->sprite;
	sSpriteFrame = pkt->sprite_frame;
	iAmount = pkt->amount;
	cColor = static_cast<char>(pkt->color);
	sCurLife = pkt->cur_life;
	sMaxLife = pkt->max_life;
	sPerformance = pkt->performance;
	memcpy(cItemName, pkt->item_name, 20);
	memcpy(cCharName, pkt->char_name, 10);
	dwAttribute = pkt->attribute;

	if (sDir >= 1000)  // Set the item I want to exchange
	{
		i = 0;
		while (m_stDialogBoxExchangeInfo[i].sV1 != -1)
		{
			i++;
			if (i >= 4) return; // Error situation
		}
	}
	else // Set the item he proposes me.
	{
		i = 4;
		while (m_stDialogBoxExchangeInfo[i].sV1 != -1)
		{
			i++;
			if (i >= 8) return; // Error situation
		}
	}
	m_stDialogBoxExchangeInfo[i].sV1 = sSprite;
	m_stDialogBoxExchangeInfo[i].sV2 = sSpriteFrame;
	m_stDialogBoxExchangeInfo[i].sV3 = iAmount;
	m_stDialogBoxExchangeInfo[i].sV4 = cColor;
	m_stDialogBoxExchangeInfo[i].sV5 = (int)sCurLife;
	m_stDialogBoxExchangeInfo[i].sV6 = (int)sMaxLife;
	m_stDialogBoxExchangeInfo[i].sV7 = (int)sPerformance;
	memcpy(m_stDialogBoxExchangeInfo[i].cStr1, cItemName, 20);
	memcpy(m_stDialogBoxExchangeInfo[i].cStr2, cCharName, 10);
	m_stDialogBoxExchangeInfo[i].dwV1 = dwAttribute;
	//if (i<4) m_stDialogBoxExchangeInfo[i].sItemID = sDir -1000;
}

void CGame::NotifyMsg_DismissGuildApprove(char* pData)
{
	char cName[24], cLocation[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDismissGuildApprove>(
		pData, sizeof(hb::net::PacketNotifyDismissGuildApprove));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	std::memset(cLocation, 0, sizeof(cLocation));
	memcpy(cName, pkt->guild_name, 20);
	memcpy(cLocation, pkt->location, 10);
	std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	std::memset(m_cLocation, 0, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else
	{
		m_bAresden = true;
		m_bCitizen = false;
		m_bHunter = true;
	}
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 5);
}

void CGame::NotifyMsg_DismissGuildReject(char* pData)
{
	char cName[21];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDismissGuildReject>(
		pData, sizeof(hb::net::PacketNotifyDismissGuildReject));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->guild_name, 20);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 6);
}

void CGame::NotifyMsg_DownSkillIndexSet(char* pData)
{
	short sSkillIndex;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDownSkillIndexSet>(
		pData, sizeof(hb::net::PacketNotifyDownSkillIndexSet));
	if (!pkt) return;
	sSkillIndex = static_cast<short>(pkt->skill_index);
	m_iDownSkillIndex = sSkillIndex;
	m_dialogBoxManager.Info(DialogBoxId::Skill).bFlag = false;
}

void CGame::NotifyMsg_FishChance(char* pData)
{
	int iFishChance;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyFishChance>(
		pData, sizeof(hb::net::PacketNotifyFishChance));
	if (!pkt) return;
	iFishChance = pkt->chance;
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sV1 = iFishChance;
}

void CGame::NotifyMsg_GuildDisbanded(char* pData)
{
	char cName[24], cLocation[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGuildDisbanded>(
		pData, sizeof(hb::net::PacketNotifyGuildDisbanded));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	std::memset(cLocation, 0, sizeof(cLocation));
	memcpy(cName, pkt->guild_name, 20);
	memcpy(cLocation, pkt->location, 10);
	CMisc::ReplaceString(cName, '_', ' ');
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 7);
	std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	std::memset(m_cLocation, 0, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else
	{
		m_bAresden = true;
		m_bCitizen = false;
		m_bHunter = true;
	}
}

void CGame::NotifyMsg_WhetherChange(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyWhetherChange>(
		pData, sizeof(hb::net::PacketNotifyWhetherChange));
	if (!pkt) return;
	m_cWhetherStatus = static_cast<char>(pkt->status);

	if (m_cWhetherStatus != 0)
		SetWhetherStatus(true, m_cWhetherStatus);
	else SetWhetherStatus(false, 0);
}

void CGame::NotifyMsg_TimeChange(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyTimeChange>(
		pData, sizeof(hb::net::PacketNotifyTimeChange));
	if (!pkt) return;
	G_cSpriteAlphaDegree = static_cast<char>(pkt->sprite_alpha);
	switch (G_cSpriteAlphaDegree) {
	case 1:	m_bIsXmas = false; PlaySound('E', 32, 0); break;
	case 2: m_bIsXmas = false; PlaySound('E', 31, 0); break;
	case 3: // Snoopy Special night with chrismas bulbs
		if (m_cWhetherEffectType > 3) m_bIsXmas = true;
		else m_bIsXmas = false;
		PlaySound('E', 31, 0);
		G_cSpriteAlphaDegree = 2; break;
	}
	m_cGameModeCount = 1;
	m_bIsRedrawPDBGS = true;
}

void CGame::NotifyMsg_RepairItemPrice(char* pData)
{
	char cName[21];
	DWORD wV1, wV2, wV3, wV4;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyRepairItemPrice>(
		pData, sizeof(hb::net::PacketNotifyRepairItemPrice));
	if (!pkt) return;
	wV1 = pkt->v1;
	wV2 = pkt->v2;
	wV3 = pkt->v3;
	wV4 = pkt->v4;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->item_name, 20);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::SellOrRepair, 2, wV1, wV2);
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV3 = wV3;
}

void CGame::NotifyMsg_SellItemPrice(char* pData)
{
	char cName[21];
	DWORD wV1, wV2, wV3, wV4;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySellItemPrice>(
		pData, sizeof(hb::net::PacketNotifySellItemPrice));
	if (!pkt) return;
	wV1 = pkt->v1;
	wV2 = pkt->v2;
	wV3 = pkt->v3;
	wV4 = pkt->v4;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->item_name, 20);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::SellOrRepair, 1, wV1, wV2);
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV3 = wV3;
	m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV4 = wV4;
}

void CGame::NotifyMsg_QueryDismissGuildPermission(char* pData)
{
	char cName[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQueryDismissGuildPermission>(
		pData, sizeof(hb::net::PacketNotifyQueryDismissGuildPermission));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 2);
}


void CGame::NotifyMsg_QueryJoinGuildPermission(char* pData)
{
	char cName[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQueryJoinGuildPermission>(
		pData, sizeof(hb::net::PacketNotifyQueryJoinGuildPermission));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 1);
}


void CGame::NotifyMsg_QuestContents(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQuestContents>(
		pData, sizeof(hb::net::PacketNotifyQuestContents));
	if (!pkt) return;
	m_stQuest.sWho = pkt->who;
	m_stQuest.sQuestType = pkt->quest_type;
	m_stQuest.sContribution = pkt->contribution;
	m_stQuest.sTargetType = pkt->target_type;
	m_stQuest.sTargetCount = pkt->target_count;
	m_stQuest.sX = pkt->x;
	m_stQuest.sY = pkt->y;
	m_stQuest.sRange = pkt->range;
	m_stQuest.bIsQuestCompleted = (pkt->is_completed != 0);
	std::memset(m_stQuest.cTargetName, 0, sizeof(m_stQuest.cTargetName));
	memcpy(m_stQuest.cTargetName, pkt->target_name, 20);
	// v2.05
	//AddEventList(m_pGameMsgList[92]->m_pMsg, 10);
}

void CGame::NotifyMsg_PlayerProfile(char* pData)
{
	char cTemp[500];
	int i;
	std::memset(cTemp, 0, sizeof(cTemp));
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPlayerProfile>(
		pData, sizeof(hb::net::PacketNotifyPlayerProfile));
	if (!pkt) return;
	strcpy(cTemp, pkt->text);
	for (i = 0; i < 500; i++)
		if (cTemp[i] == '_') cTemp[i] = ' ';
	AddEventList(cTemp, 10);
}

void CGame::NotifyMsg_NoticeMsg(char* pData)
{
	char cMsg[1000];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNoticeMsg>(
		pData, sizeof(hb::net::PacketNotifyNoticeMsg));
	if (!pkt) return;
	strcpy(cMsg, pkt->text);
	AddEventList(cMsg, 10);
}
/*********************************************************************************************************************
**  void CGame::NotifyMsg_OpenExchageWindow(char *pData)		(snoopy)											**
**  description			:: Recieve a msg from gserver and sets the item	and opens trade windows						**
**********************************************************************************************************************/
void CGame::NotifyMsg_OpenExchageWindow(char* pData)
{
	short sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
	int iAmount;
	char cColor, cItemName[24], cCharName[12];
	DWORD dwAttribute;
	std::memset(cItemName, 0, sizeof(cItemName));
	std::memset(cCharName, 0, sizeof(cCharName));

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyExchangeItem>(
		pData, sizeof(hb::net::PacketNotifyExchangeItem));
	if (!pkt) return;
	sDir = static_cast<short>(pkt->dir);
	sSprite = pkt->sprite;
	sSpriteFrame = pkt->sprite_frame;
	iAmount = pkt->amount;
	cColor = static_cast<char>(pkt->color);
	sCurLife = pkt->cur_life;
	sMaxLife = pkt->max_life;
	sPerformance = pkt->performance;
	memcpy(cItemName, pkt->item_name, 20);
	memcpy(cCharName, pkt->char_name, 10);
	dwAttribute = pkt->attribute;

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Exchange, 1, 0, 0, 0);
	int i;
	if (sDir >= 1000)  // Set the item I want to exchange
	{
		i = 0;
		while (m_stDialogBoxExchangeInfo[i].sV1 != -1)
		{
			i++;
			if (i >= 4) return; // Error situation
		}
		if ((sDir > 1000) && (i == 0))
		{
			m_bIsItemDisabled[sDir - 1000] = true;
			m_stDialogBoxExchangeInfo[0].sItemID = sDir - 1000;
		}
	}
	else // Set the item he proposes me.
	{
		i = 4;
		while (m_stDialogBoxExchangeInfo[i].sV1 != -1)
		{
			i++;
			if (i >= 8) return; // Error situation
		}
	}
	m_stDialogBoxExchangeInfo[i].sV1 = sSprite;
	m_stDialogBoxExchangeInfo[i].sV2 = sSpriteFrame;
	m_stDialogBoxExchangeInfo[i].sV3 = iAmount;
	m_stDialogBoxExchangeInfo[i].sV4 = cColor;
	m_stDialogBoxExchangeInfo[i].sV5 = (int)sCurLife;
	m_stDialogBoxExchangeInfo[i].sV6 = (int)sMaxLife;
	m_stDialogBoxExchangeInfo[i].sV7 = (int)sPerformance;
	memcpy(m_stDialogBoxExchangeInfo[i].cStr1, cItemName, 20);
	memcpy(m_stDialogBoxExchangeInfo[i].cStr2, cCharName, 10);
	m_stDialogBoxExchangeInfo[i].dwV1 = dwAttribute;
}

void CGame::NotifyMsg_JoinGuildApprove(char* pData)
{
	char cName[21];
	short sRank;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyJoinGuildApprove>(
		pData, sizeof(hb::net::PacketNotifyJoinGuildApprove));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->guild_name, 20);
	sRank = pkt->rank;
	std::memset(m_cGuildName, 0, sizeof(m_cGuildName));
	strcpy(m_cGuildName, cName);
	m_iGuildRank = sRank;
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 3);
}


void CGame::NotifyMsg_JoinGuildReject(char* pData)
{
	char cName[21];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyJoinGuildReject>(
		pData, sizeof(hb::net::PacketNotifyJoinGuildReject));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->guild_name, 20);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuildOperation, 0, 0, 0);
	_PutGuildOperationList(cName, 4);
}

/*********************************************************************************************************************
** void CGame::CreateScreenShot()										(snoopy)									**
**  description			:: Fixed Screen Shots																		**
**********************************************************************************************************************/
void CGame::CreateScreenShot()
{	//HelShot20060307_173003_Warehouse000.jpg
	int i;
	FILE* pFile;
	char cFn[256];
	char LongMapName[128];
	char SStime[32];
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	std::memset(LongMapName, 0, sizeof(LongMapName));
	GetOfficialMapName(m_cMapName, LongMapName);
	std::memset(SStime, 0, sizeof(SStime));
	wsprintf(SStime, "%02d:%02d - %02d:%02d:%02d"
		, SysTime.wMonth, SysTime.wDay
		, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
		, LongMapName);
	PutAlignedString(500 + SCREENX, 650 + SCREENY, 30, SStime, 255, 255, 255); //ScreenShot time
	PutString_SprFont3(500 + SCREENX, 390 + SCREENY, " Client coded by", 20, 20, 0, true, 2);
	PutString_SprFont3(500 + SCREENX, 405 + SCREENY, "Diuuude & Snoopy81", 0, 20, 20, true, 2);

	PutAlignedString(500 + SCREENX, LOGICAL_HEIGHT + SCREENY, 15, MSG_WORLDNAME1, 255, 255, 255);//"ABADDON Server"

	for (i = 0; i < 1000; i++)
	{
		std::memset(cFn, 0, sizeof(cFn));
		wsprintf(cFn, "Save\\HelShot%04d%02d%02d_%02d%02d%02d_%s%03d.bmp"
			, SysTime.wYear, SysTime.wMonth, SysTime.wDay
			, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
			, LongMapName
			, i);
		_mkdir("SAVE");
		pFile = fopen(cFn, "rb");
		if (pFile == 0)
		{
			m_DDraw.Screenshot(cFn, m_DDraw.m_lpBackB4);

			wsprintf(G_cTxt, NOTIFYMSG_CREATE_SCREENSHOT1, cFn);
			AddEventList(G_cTxt, 10);
			return;
		}
		fclose(pFile);
	}
	AddEventList(NOTIFYMSG_CREATE_SCREENSHOT2, 10);
}




bool CGame::_bDraw_OnCreateNewCharacter(char* pName, short msX, short msY, int iPoint)
{
	bool bFlag = true;
	uint32_t dwTime = GameClock::GetTimeMS();
	int i = 0;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWCHAR, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 69, true);
	PutAlignedString(64 + SCREENX, 282 + SCREENX, 90 + SCREENY, _BDRAW_ON_CREATE_NEW_CHARACTER1, 5, 5, 5);//"
	PutAlignedString(57 + SCREENX, 191 + SCREENX, 110 + SCREENY, DEF_MSG_CHARACTERNAME, 5, 5, 5);//"Character Name"
	if (m_cCurFocus != 1) PutString(197 + SCREENX, 112 + SCREENY, pName, RGB(25, 35, 25));
	PutAlignedString(64 + SCREENX, 282 + SCREENX, 140 + SCREENY, _BDRAW_ON_CREATE_NEW_CHARACTER2, 5, 5, 5);//"
	PutString(100 + SCREENX, 160 + SCREENY, DEF_MSG_GENDER, RGB(5, 5, 5));//"Gender"
	PutString(100 + SCREENX, 175 + SCREENY, DEF_MSG_SKINCOLOR, RGB(5, 5, 5));//"Skin Color"
	PutString(100 + SCREENX, 190 + SCREENY, DEF_MSG_HAIRSTYLE, RGB(5, 5, 5));//"Hair Style"
	PutString(100 + SCREENX, 205 + SCREENY, DEF_MSG_HAIRCOLOR, RGB(5, 5, 5));//"Hair Color"
	PutString(100 + SCREENX, 220 + SCREENY, DEF_MSG_UNDERWEARCOLOR, RGB(5, 5, 5));//"Underwear Color"
	//PutAlignedString(64, 282, 245, _BDRAW_ON_CREATE_NEW_CHARACTER3, 5,5,5);
	//wsprintf(G_cTxt, _BDRAW_ON_CREATE_NEW_CHARACTER4,  iPoint);//" %d points"
	//PutAlignedString(64, 282, 260, G_cTxt, 15,10,10);
	PutString(100 + SCREENX, 275 + SCREENY, DEF_MSG_STRENGTH, RGB(5, 5, 5));//"Strength"
	PutString(100 + SCREENX, 292 + SCREENY, DEF_MSG_VITALITY, RGB(5, 5, 5));//"Vitality"
	PutString(100 + SCREENX, 309 + SCREENY, DEF_MSG_DEXTERITY, RGB(5, 5, 5));//"Dexterity"
	PutString(100 + SCREENX, 326 + SCREENY, DEF_MSG_INTELLIGENCE, RGB(5, 5, 5));//"Intelligence"
	PutString(100 + SCREENX, 343 + SCREENY, DEF_MSG_MAGIC, RGB(5, 5, 5));//"Magic"
	PutString(100 + SCREENX, 360 + SCREENY, DEF_MSG_CHARISMA, RGB(5, 5, 5));//"Charisma"

	wsprintf(G_cTxt, "%d", m_ccStr);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccVit);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccDex);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccInt);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccMag);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));
	wsprintf(G_cTxt, "%d", m_ccChr);
	PutString(204 + SCREENX, 277 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	if (strlen(pName) <= 0) bFlag = false;
	if (iPoint > 0) bFlag = false;
	if (CMisc::bCheckValidName(pName) == false) bFlag = false;
	if (_bCheckBadWords(pName) == true) bFlag = false;

	if ((bFlag == true) && (m_cCurFocus == 2)) m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384 + SCREENX, 445 + SCREENY, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384 + SCREENX, 445 + SCREENY, 24, dwTime);
	if (m_cCurFocus == 3)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500 + SCREENX, 445 + SCREENY, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500 + SCREENX, 445 + SCREENY, 16, dwTime);
	if (m_cCurFocus == 4)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60 + SCREENX, 445 + SCREENY, 68, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60 + SCREENX, 445 + SCREENY, 67, dwTime);
	if (m_cCurFocus == 5)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145 + SCREENX, 445 + SCREENY, 66, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145 + SCREENX, 445 + SCREENY, 65, dwTime);
	if (m_cCurFocus == 6)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230 + SCREENX, 445 + SCREENY, 64, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230 + SCREENX, 445 + SCREENY, 63, dwTime);
	/*if (m_cCurFocus == 4)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 245, 68, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 245, 67, dwTime);
	if (m_cCurFocus == 5)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 245, 66, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 245, 65, dwTime);
	if (m_cCurFocus == 6)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 245, 64, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 245, 63, dwTime);*/

	ShowReceivedString();

	switch (m_cGender) {
	case 1:	_tmp_sOwnerType = 1; break;
	case 2:	_tmp_sOwnerType = 4; break; //@@@@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!!
	}
	_tmp_sOwnerType += m_cSkinCol - 1;
	_tmp_cDir = m_cMenuDir;
	_tmp_sAppr1 = 0;
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cUnderCol);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairStyle << 8);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairCol << 4);
	_tmp_sAppr2 = 0;
	_tmp_sAppr3 = 0;
	_tmp_sAppr4 = 0;
	std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
	memcpy(_tmp_cName, m_cPlayerName, 10);
	_tmp_cAction = DEF_OBJECTMOVE;
	_tmp_cFrame = m_cMenuFrame;

	_Draw_CharacterBody(507 + SCREENX, 267 + SCREENY, _tmp_sOwnerType);

	DrawObject_OnMove_ForMenu(0 + SCREENX, 0 + SCREENY, 500 + SCREENX, 174 + SCREENY, false, dwTime, msX, msY);

	i = 0;

	PutString(445 + SCREENX, 192 + SCREENY, DEF_MSG_HITPOINT, RGB(5, 5, 5));//"Hit Point"
	wsprintf(G_cTxt, "%d", m_ccVit * 3 + 2 + m_ccStr / 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	PutString(445 + SCREENX, 208 + SCREENY, DEF_MSG_MANAPOINT, RGB(5, 5, 5));//"Mana Point"
	wsprintf(G_cTxt, "%d", m_ccMag * 2 + 2 + m_ccInt / 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	PutString(445 + SCREENX, 224 + SCREENY, DEF_MSG_STAMINARPOINT, RGB(5, 5, 5));//"Staminar Point"
	wsprintf(G_cTxt, "%d", m_ccStr * 2 + 2);
	PutString(550 + SCREENX, 192 + 16 * i++ + SCREENY, G_cTxt, RGB(25, 35, 25));

	return bFlag;
}


#ifdef DEF_MAKE_ACCOUNT

void CGame::_LoadAgreementTextContents(char cType)
{
	char* pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	uint32_t dwFileSize;
	HANDLE hFile;
	FILE* pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pAgreeMsgTextList[i] != 0)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = 0;
	}

	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cFileName, 0, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else {
		pContents = new char[dwFileSize + 1];
		std::memset(pContents, 0, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);
	token = strtok(pContents, seps);
	while (token != 0) {
		m_pAgreeMsgTextList[iIndex] = new class CMsg(0, token, 0);
		token = strtok(NULL, seps);
		iIndex++;
	}
	delete[] pContents;
}

void CGame::UpdateScreen_OnAgreement()
{
	short sX, sY, msX, msY, msZ;
	char  cLB, cRB;
	char  cMIresult;
	static class CMouseInterface* pMI;
	int i, iTotalLines, iPointerLoc;
	uint32_t dwTime = GameClock::GetTimeMS();
	double d1, d2, d3;
	int iMIbuttonNum;

	sX = 121;
	sY = 22;

	if (m_cGameModeCount == 0) {
		m_iAgreeView = 0;
		_LoadAgreementTextContents(0);

		pMI = new class CMouseInterface;
		pMI->AddRect(sX + 82 - 105, sY + 355, sX + 131 - 105, sY + 374);
		pMI->AddRect(sX + 235 - 105, sY + 355, sX + 303 - 105, sY + 375);
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	if (m_bEnterPressed == true) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
		ClearContents_OnCreateNewAccount();
		delete pMI;
		return;
	}
	if (m_bEscPressed == true) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = false;
		return;
	}
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1: // Agree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			ClearContents_OnCreateNewAccount();
			delete pMI;
			return;

		case 2:	// Disagree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_AGREEMENT, 0, 0, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 43, 38, 12, false);

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
		if (m_pAgreeMsgTextList[i] != 0) iTotalLines++;

	d1 = (double)m_iAgreeView;
	d2 = (double)(iTotalLines - 20);
	d3 = (double)d1 / d2;
	d1 = 338.0f * d3;
	iPointerLoc = (int)d1;
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 361 - 112, sY + 37 + 13 + iPointerLoc, 7, dwTime);

	for (i = 0; i < 20; i++)
		if (m_pAgreeMsgTextList[i + m_iAgreeView] != 0) {
			PutAlignedString(60, 360, sY + 65 + i * 13, m_pAgreeMsgTextList[i + m_iAgreeView]->m_pMsg, 45, 25, 25);
		}

	if (msZ != 0)
	{
		m_iAgreeView = m_iAgreeView - msZ / 60;
		m_DInput.m_sZ = 0;
	}
	if (cLB != 0 && iTotalLines > 20)
	{
		if ((msX >= sX + 345 - 112) && (msX <= sX + 380 - 112) && (msY >= sY + 50) && (msY <= sY + 395))
		{
			d1 = (double)(msY - (sY + 37 + 13));
			d2 = (double)(iTotalLines - 17);
			d3 = (double)(d1 * d2) / (338.0f);
			m_iAgreeView = (int)d3;
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSprite(sX + 361 - 112, sY + 37 + 13 + iPointerLoc, 4, dwTime);
		}
	}
	if (m_iAgreeView < 0) m_iAgreeView = 0;
	if (iTotalLines > 20 && m_iAgreeView > iTotalLines - 20) m_iAgreeView = iTotalLines - 20;

	if ((msX > sX + 82 - 105) && (msX < sX + 131 - 105) && (msY > sY + 355 - 3) && (msY < sY + 374 + 3))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 - 23 + 45 - 105, sY + 265 + 90, 13);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 - 23 + 45 - 105, sY + 265 + 90, 12);

	if ((msX > sX + 235 - 105) && (msX < sX + 303 - 105) && (msY > sY + 355 - 3) && (msY < sY + 375 + 3))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 - 23 + 45 - 105, sY + 265 + 90, 15);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 - 23 + 45 - 105, sY + 265 + 90, 14);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
	//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);
}

#endif //endif from #ifdef DEF_MAKE_ACCOUNT



void CGame::OnSysKeyDown(WPARAM wParam)
{
	switch (wParam)
	{
	case VK_SHIFT:
		m_bShiftPressed = true;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = true;
		break;
	case VK_RETURN:
		m_bEnterPressed = true;
		break;
	}
}

void CGame::OnSysKeyUp(WPARAM wParam)
{
	switch (wParam)
	{
	case VK_SHIFT:
		m_bShiftPressed = false;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = false;
		break;
	case VK_RETURN:
		m_bEnterPressed = false;
		if (m_bToggleScreen == true)
		{
			m_bIsRedrawPDBGS = true;
			m_DDraw.ChangeDisplayMode(G_hWnd);
		}
		break;
	case VK_ESCAPE:
		m_bEscPressed = false;

	}
}

void CGame::OnKeyUp(WPARAM wParam)
{
	int i = 0;
	uint32_t dwTime = GameClock::GetTimeMS();

	switch (wParam) {
	case VK_SHIFT:
		m_bShiftPressed = false;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = false;
		break;
	case 65://'A'
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			if (m_bForceAttack)
			{
				m_bForceAttack = false;
				AddEventList(DEF_MSG_FORCEATTACK_OFF, 10);
			}
			else
			{
				m_bForceAttack = true;
				AddEventList(DEF_MSG_FORCEATTACK_ON, 10);
			}
		}
		break;
	case 69://'E'
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			if (m_bCtrlPressed)
			{
				if (m_dialogBoxManager.IsEnabled(DialogBoxId::Unknown54) == false && m_dialogBoxManager.IsEnabled(DialogBoxId::Unknown58) == false)
				{
					m_dialogBoxManager.EnableDialogBox(DialogBoxId::Unknown58, 0, 0, 0);
				}
				else
				{
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::Unknown58);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::Unknown54);
				}
			}
		}
		break;
	case 68://'D'
		if (m_bCtrlPressed == true && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			m_cDetailLevel++;
			if (m_cDetailLevel > 2) m_cDetailLevel = 0;
			switch (m_cDetailLevel) {
			case 0:
				AddEventList(NOTIFY_MSG_DETAIL_LEVEL_LOW, 10);
				break;
			case 1:
				AddEventList(NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10);
				break;
			case 2:
				AddEventList(NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10);
				break;
			}
		}
		break;

	case 72: // 'H' // Snoopy: Mimics VK_F1
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Help) == false)
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::Help, 0, 0, 0);
			else
			{
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::Help);
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
			}
		}
		break;

	case 87: // 'W' // Snoopy: mimics VK_F11 Togles transparency
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			m_bDialogTrans = !m_bDialogTrans;
		}
		break;

	case 88: // 'X' // Snoopy: mimics VK_F12 Logout Window
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::SystemMenu) == false)
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::SystemMenu, 0, 0, 0);
			else m_dialogBoxManager.DisableDialogBox(DialogBoxId::SystemMenu);
		}
		break;

	case 77://'M'
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			if (m_bCtrlPressed)
			{
				if (m_dialogBoxManager.IsEnabled(DialogBoxId::GuideMap) == true) m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuideMap);
				else m_dialogBoxManager.EnableDialogBox(DialogBoxId::GuideMap, 0, 0, 0, 0);
			}
		}
		break;

#ifdef _DEBUG
	case 81://'Q'
		if ((m_bCtrlPressed == true) && (m_cGameMode == DEF_GAMEMODE_ONMAINGAME))
		{
			std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
			strcpy(m_cChatMsg, "/enableadmincommand 147258 ");
			StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
			//ClearInputString();
		}
		break;
#endif

	case 82://'R'
		if (m_bCtrlPressed == true && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			if (m_bRunningMode)
			{
				m_bRunningMode = false;
				AddEventList(NOTIFY_MSG_CONVERT_WALKING_MODE, 10);
			}
			else
			{
				m_bRunningMode = true;
				AddEventList(NOTIFY_MSG_CONVERT_RUNNING_MODE, 10);
			}
		}
		break;

	case 83://'S'
		if (m_bCtrlPressed == true && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			if (AudioManager::Get().IsMusicEnabled()) // Music Off
			{
				AudioManager::Get().SetMusicEnabled(false);
				AudioManager::Get().StopMusic();
				AddEventList(NOTIFY_MSG_MUSIC_OFF, 10);
				break;
			}
			else if (AudioManager::Get().IsSoundEnabled())
			{
				AudioManager::Get().StopSound(SoundType::Effect, 38);
				AudioManager::Get().SetSoundEnabled(false);
				AddEventList(NOTIFY_MSG_SOUND_OFF, 10);
				break;
			}
			else 	// Music On
			{
				if (AudioManager::Get().IsSoundAvailable())
				{
					AudioManager::Get().SetMusicEnabled(true);
					AddEventList(NOTIFY_MSG_MUSIC_ON, 10);
				}
				if (AudioManager::Get().IsSoundAvailable())
				{
					AudioManager::Get().SetSoundEnabled(true);
					AddEventList(NOTIFY_MSG_SOUND_ON, 10);
				}
				StartBGM();
			}
		}
		break;

	case 84: //'T'
		if (m_bCtrlPressed == true && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus))
		{
			char tempid[100], cLB, cRB;
			short sX, sY, msX, msY, msZ;
			sX = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sY;
			std::memset(tempid, 0, sizeof(tempid));
			m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
			if (m_dialogBoxManager.IsEnabled(DialogBoxId::ChatHistory) == true && (msX >= sX + 20) && (msX <= sX + 360) && (msY >= sY + 35) && (msY <= sY + 139))
			{
				char* token, cBuff[64];
				char   seps[] = ":";
				int i = (139 - msY + sY) / 13;
				if (m_pChatScrollList[i + m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sView] == 0) return;
				if (m_pChatScrollList[i + m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sView]->m_pMsg[0] == ' ') i++;
				strcpy(cBuff, m_pChatScrollList[i + m_dialogBoxManager.Info(DialogBoxId::ChatHistory).sView]->m_pMsg);
				token = strtok(cBuff, seps);
				wsprintf(tempid, "/to %s", token);
				bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, tempid);
			}
			else if (_tmp_sOwnerType < 7 && (strlen(_tmp_cName) > 0) && (m_iIlusionOwnerH == 0)
				&& ((m_bIsCrusadeMode == false) || _iGetFOE(_tmp_iStatus) >= 0))
			{
				wsprintf(tempid, "/to %s", _tmp_cName);
				bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, tempid);
			}
			else
			{
				EndInputString();
				wsprintf(m_cChatMsg, "/to ");
				StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
			}
		}
		break;
	case 107: //'+'
		if (m_bInputStatus == false) m_bZoomMap = true;
		break;
	case 109: //'-'
		if (m_bInputStatus == false) m_bZoomMap = false;
		break;

	case VK_F2:
		UseShortCut(2);
		break;

	case VK_F3:
		UseShortCut(3);
		break;

	case VK_INSERT:
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == true)
		{
			AddEventList(USE_RED_POTION1, 10);
			return;
		}
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == true)
		{
			AddEventList(USE_RED_POTION2, 10);
			return;
		}
		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_bIsItemDisabled[i] != true) &&
				(m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 1))
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, i, 0, 0, 0);
				m_bIsItemDisabled[i] = true;
				m_bItemUsingStatus = true;
				return;
			}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_bIsItemDisabled[i] != true) &&
				(m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 2))
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, i, 0, 0, 0);
				m_bIsItemDisabled[i] = true;
				m_bItemUsingStatus = true;
				return;
			}
		break;

	case VK_DELETE:
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == true)
		{
			AddEventList(USE_BLUE_POTION1, 10);
			return;
		}
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == true)
		{
			AddEventList(USE_BLUE_POTION2, 10);
			return;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_bIsItemDisabled[i] != true) &&
				(m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 3))
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, i, 0, 0, 0);
				m_bIsItemDisabled[i] = true;
				m_bItemUsingStatus = true;
				return;
			}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_bIsItemDisabled[i] != true) &&
				(m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 4))
			{
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, i, 0, 0, 0);
				m_bIsItemDisabled[i] = true;
				m_bItemUsingStatus = true;
				return;
			}
		break;

	case VK_END:
		if (((m_dialogBoxManager.IsEnabled(DialogBoxId::GuildMenu) == true) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::GuildMenu)) ||
			((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::ItemDropExternal)))
		{
		}
		else if ((!m_bInputStatus) && (m_cBackupChatMsg[0] != '!') && (m_cBackupChatMsg[0] != '~') && (m_cBackupChatMsg[0] != '^') &&
			(m_cBackupChatMsg[0] != '@'))
		{
			std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
			strcpy(m_cChatMsg, m_cBackupChatMsg);
			StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
		}
		break;

	case VK_F4:
		if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		UseMagic(m_sMagicShortCut);
		break;

	case VK_F5:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::CharacterInfo) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::CharacterInfo, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::CharacterInfo);
		break;

	case VK_F6:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Inventory) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Inventory, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::Inventory);
		break;

	case VK_F7:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Magic) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::Magic);
		break;

	case VK_F8:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Skill) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Skill, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::Skill);
		break;

	case VK_F9:
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ChatHistory) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::ChatHistory, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::ChatHistory);
		break;

	case VK_F12:
		if (m_bInputStatus) return;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::SystemMenu) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::SystemMenu, 0, 0, 0);
		else m_dialogBoxManager.DisableDialogBox(DialogBoxId::SystemMenu);
		break;

	case VK_F1:
		//if (m_bInputStatus) return;
		//if (m_dialogBoxManager.IsEnabled(DialogBoxId::Help) == false) // 35 CLEROTH
		//	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Help, 0, 0, 0);
		//else
		//{	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Help);
		//	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
		//}
		UseShortCut(1);
		break;

	case VK_UP:
		m_cArrowPressed = 1;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			int iTotalMsg = 0;
			for (int i = DEF_MAXWHISPERMSG - 1; i >= 0; i--)
			{
				if (m_pWhisperMsg[i] != 0)
				{
					iTotalMsg = i;
					break;
				}
			}
			m_cWhisperIndex++;
			if (m_cWhisperIndex > iTotalMsg) m_cWhisperIndex = 0;
			if (m_cWhisperIndex < 0) m_cWhisperIndex = iTotalMsg;
			if (m_pWhisperMsg[m_cWhisperIndex] != 0) {
				EndInputString();
				wsprintf(m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg);
				StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
			}
		}
		break;

	case VK_RIGHT:
		m_cArrowPressed = 2;
		break;

	case VK_DOWN:
		m_cArrowPressed = 3;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			int iTotalMsg = 0;
			for (int i = DEF_MAXWHISPERMSG - 1; i >= 0; i--)
			{
				if (m_pWhisperMsg[i] != 0)
				{
					iTotalMsg = i;
					break;
				}
			}
			m_cWhisperIndex--;
			if (m_cWhisperIndex < 0) m_cWhisperIndex = iTotalMsg;
			if (m_cWhisperIndex > iTotalMsg) m_cWhisperIndex = 0;
			if (m_pWhisperMsg[m_cWhisperIndex] != 0) {
				EndInputString();
				wsprintf(m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg);
				StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
			}
		}
		break;

	case VK_LEFT:
		m_cArrowPressed = 4;
		break;

	case VK_SNAPSHOT:
		CreateScreenShot();
		break;

#ifndef DEF_USING_WIN_IME
	case VK_TAB:
		if (m_bShiftPressed)
		{
			m_cCurFocus--;
			if (m_cCurFocus < 1) m_cCurFocus = m_cMaxFocus;
		}
		else
		{
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		}
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, 0, 0, 0, 0, 0);
		}
		break;

	case VK_RETURN:
		m_bEnterPressed = true;
		break;
#endif

	case VK_HOME:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLESAFEATTACKMODE, 0, 0, 0, 0, 0);
		}
		break;

	case VK_ESCAPE:
		m_bEscPressed = true;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			if ((m_bIsObserverMode == true) && (m_bShiftPressed)) { //ObserverMode Shift+Esc
				// Log Out
				if (m_cLogOutCount == -1) m_cLogOutCount = 1;
				m_dialogBoxManager.DisableDialogBox(DialogBoxId::SystemMenu);
				PlaySound('E', 14, 5);
			}
			else if (m_cLogOutCount != -1) {
				if (m_bForceDisconn == false) { //Esc
					m_cLogOutCount = -1;
					AddEventList(DLGBOX_CLICK_SYSMENU2, 10);
				}
			}
			if (m_bIsGetPointingMode == true) {
				m_bIsGetPointingMode = false;
				AddEventList(COMMAND_PROCESSOR1, 10);
			}
			m_bIsF1HelpWindowEnabled = false;
		}
		break;

	case 33:
		if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		if (m_bInputStatus) return;
		if (m_bIsSpecialAbilityEnabled == true)
		{
			if (m_iSpecialAbilityType != 0) {
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY, 0, 0, 0, 0, 0);
				m_bIsSpecialAbilityEnabled = false;
			}
			else AddEventList(ON_KEY_UP26, 10);
		}
		else {
			if (m_iSpecialAbilityType == 0) AddEventList(ON_KEY_UP26, 10);
			else {
				if ((m_sPlayerAppr4 & 0x00F0) != 0) {
					AddEventList(ON_KEY_UP28, 10);
					return;
				}

				i = (dwTime - m_dwSpecialAbilitySettingTime) / 1000;
				i = m_iSpecialAbilityTimeLeftSec - i;
				if (i < 0) i = 0;

				std::memset(G_cTxt, 0, sizeof(G_cTxt));
				if (i < 60) {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP29, i); break;//"
					case 2: wsprintf(G_cTxt, ON_KEY_UP30, i); break;//"
					case 3: wsprintf(G_cTxt, ON_KEY_UP31, i); break;//"
					case 4: wsprintf(G_cTxt, ON_KEY_UP32, i); break;//"
					case 5: wsprintf(G_cTxt, ON_KEY_UP33, i); break;//"
					case 50:wsprintf(G_cTxt, ON_KEY_UP34, i); break;//"
					case 51:wsprintf(G_cTxt, ON_KEY_UP35, i); break;//"
					case 52:wsprintf(G_cTxt, ON_KEY_UP36, i); break;//"
					}
				}
				else {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP37, i / 60); break;//"
					case 2: wsprintf(G_cTxt, ON_KEY_UP38, i / 60); break;//"
					case 3: wsprintf(G_cTxt, ON_KEY_UP39, i / 60); break;//"
					case 4: wsprintf(G_cTxt, ON_KEY_UP40, i / 60); break;//"
					case 5: wsprintf(G_cTxt, ON_KEY_UP41, i / 60); break;//"
					case 50:wsprintf(G_cTxt, ON_KEY_UP42, i / 60); break;//"
					case 51:wsprintf(G_cTxt, ON_KEY_UP43, i / 60); break;//"
					case 52:wsprintf(G_cTxt, ON_KEY_UP44, i / 60); break;//"
					}
				}
				AddEventList(G_cTxt, 10);
			}
		}
		break;
	}
}

void CGame::OnKeyDown(WPARAM wParam)
{
	switch (wParam) {
	case VK_CONTROL:
		m_bCtrlPressed = true;
		break;
	case VK_SHIFT:
		m_bShiftPressed = true;
		break;
	case VK_INSERT:
	case VK_DELETE:
	case VK_TAB:
	case VK_RETURN:
	case VK_ESCAPE:
	case VK_END:
	case VK_HOME:
	case VK_F1:
	case VK_F2:
	case VK_F3:
	case VK_F4:
	case VK_F5:
	case VK_F6:
	case VK_F7:
	case VK_F8:
	case VK_F9:
	case VK_F10:
	case VK_F11:
	case VK_F12:
	case VK_PRIOR: // Page-Up
	case VK_NEXT: // Page-Down
	case VK_LWIN:
	case VK_RWIN:
	case VK_MULTIPLY:
	case VK_ADD: //'+'
	case VK_SEPARATOR:
	case VK_SUBTRACT: //'-'
	case VK_DECIMAL:
	case VK_DIVIDE:
	case VK_NUMLOCK:
	case VK_SCROLL:
		break;

	default:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			if (m_bCtrlPressed)
			{
				switch (wParam) {
				case 48: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 9; break; // 0
				case 49: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 0; break; // 1
				case 50: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 1; break; // 2
				case 51: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 2; break; // 3
				case 52: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 3; break; // 4
				case 53: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 4; break; // 5
				case 54: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 5; break; // 6
				case 55: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 6; break; // 7
				case 56: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 7; break; // 8
				case 57: m_dialogBoxManager.EnableDialogBox(DialogBoxId::Magic, 0, 0, 0); m_dialogBoxManager.Info(DialogBoxId::Magic).sView = 8; break; // 9
				}
			}
			else if ((m_bInputStatus == false) && (GetAsyncKeyState(VK_MENU) >> 15 == false))
			{
				StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
				ClearInputString();
			}
		}
		break;
	}
}


// ============================================================================
// Separated Update/Draw Methods (Phase 3 refactor)
// ============================================================================

// Quit screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Quit()
{
	char cMIresult;
	int  iMIbuttonNum;

	static class CMouseInterface* pMI;

	if (m_cGameModeCount == 0) {
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pGSock != 0)
		{
			delete m_pGSock;
			m_pGSock = 0;
		}
		m_bEscPressed = false;
		m_bEnterPressed = false;
		pMI = new class CMouseInterface;
		pMI->AddRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
		m_bEnterPressed = false;
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	// Handle escape/enter to quit immediately
	if (m_bEscPressed == true || m_bEnterPressed == true) {
		m_bEscPressed = false;
		m_bEnterPressed = false;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Auto-quit after timeout
	if (m_cGameModeCount == 100)
	{
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Check for click
	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1)) {
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		delete pMI;
		return;
	}
}

// Quit screen - Draw phase (rendering only)
void CGame::DrawScreen_Quit()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0 + SCREENX, 0 + SCREENY, 0, true);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 255 + SCREENX, 123 + SCREENY, 1, true);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT]->PutTransSprite25(255 + SCREENX, 123 + SCREENY, 1, true);
	DrawVersion(true);

	// Draw cursor at position captured during Update phase
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// VersionNotMatch screen - Update phase (logic/input handling)
void CGame::UpdateScreen_VersionNotMatch()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;

	if (m_cGameModeCount == 0)
	{
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pGSock != 0)
		{
			delete m_pGSock;
			m_pGSock = 0;
		}
		pMI = new class CMouseInterface;
		pMI->AddRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
		m_bEnterPressed = false;
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	if (m_bEscPressed == true || m_bEnterPressed == true)
	{
		m_bEscPressed = false;
		m_bEnterPressed = false;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1))
	{
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, 0, 0);
		return;
	}
}

// VersionNotMatch screen - Draw phase (rendering only)
void CGame::DrawScreen_VersionNotMatch()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0, 0, 0, true);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162, 125, 2);
	PutAlignedString(168, 474, 160, UPDATE_SCREEN_ON_VERSION_NO_MATCH1);
	PutAlignedString(168, 474, 180, UPDATE_SCREEN_ON_VERSION_NO_MATCH2);
	PutAlignedString(168, 474, 250, MSG_HOMEPAGE);
	DrawVersion();

	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// ConnectionLost screen - Update phase (logic/input handling)
void CGame::UpdateScreen_ConnectionLost()
{
	static DWORD dwTime;
	if (m_cGameModeCount == 0)
	{
		dwTime = GameClock::GetTimeMS();
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Auto-transition after 5 seconds
	if ((GameClock::GetTimeMS() - m_dwTime) > 5000)
	{
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		}
	}
}

// ConnectionLost screen - Draw phase (rendering only)
void CGame::DrawScreen_ConnectionLost()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	PutString_SprFont(172 + 54 + SCREENX, 180 + SCREENY, "Connection Lost!", 7, 0, 0);
	PutString(172 + 50 + SCREENX, 180 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTION_LOST, RGB(0, 0, 0));
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// Msg screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Msg()
{
	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Auto-transition after 1.5 seconds
	if ((G_dwGlobalTime - m_dwTime) > 1500)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
}

// Msg screen - Draw phase (rendering only)
void CGame::DrawScreen_Msg()
{
	uint32_t dwTime = G_dwGlobalTime;
	PutString(10, 10, m_cMsg, RGB(255, 155, 155), false, 1);
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// WaitingResponse screen - Update phase (logic/input handling)
void CGame::UpdateScreen_WaitingResponse()
{
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		m_bEnterPressed = false;
		m_bEscPressed = false;
		dwCTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true)
	{
		if ((dwTime - m_dwTime) > 7000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		m_bEscPressed = false;
		return;
	}

	// Animation frame updates
	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// WaitingResponse screen - Draw phase (rendering only)
void CGame::DrawScreen_WaitingResponse()
{
	short sX, sY;
	uint32_t dwTime = GameClock::GetTimeMS();

	m_bIsHideLocalCursor = true;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;
	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;
	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;
	case '4':// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '5':
		break;
	}
	m_bIsHideLocalCursor = false;

	m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	PutString_SprFont(172 + 44 - 17 + SCREENX, 190 + SCREENY, "Connected. Waiting for response...", 7, 0, 0);

	if ((dwTime - m_dwTime) > 7000)
	{
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE1);
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 45 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE2);
	}
	else PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WATING_RESPONSE3);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 8, dwTime);
}

// Connecting screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Connecting()
{
	static DWORD dwMTime, dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = false;
		m_bEscPressed = false;
		dwCTime = dwMTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true) {
		if ((dwTime - m_dwTime) > 1000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		m_bEscPressed = false;
		return;
	}

	if ((dwTime - dwMTime) > 150) dwMTime = dwTime;

	// Animation frame updates
	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// Connecting screen - Draw phase (rendering only)
void CGame::DrawScreen_Connecting()
{
	short sX, sY;
	uint32_t dwTime = GameClock::GetTimeMS();

	m_bIsHideLocalCursor = true;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;
	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;
	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;
	case '4':
		// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '5':
		break;
	}
	m_bIsHideLocalCursor = false;

	m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);
	wsprintf(G_cTxt, "Connecting to Server... %3dSec", (dwTime - m_dwTime) / 1000);
	PutString_SprFont(172 + 35 + SCREENX, 190 + SCREENY, G_cTxt, 7, 0, 0);

	if ((dwTime - m_dwTime) > 7000)
	{
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTING1);
		PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 45 + SCREENY, UPDATE_SCREEN_ON_CONNECTING2);
	}
	else PutAlignedString(180 + SCREENX, 463 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_CONNECTING3);
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 8, dwTime);
}

// QueryForceLogin screen - Update phase (logic/input handling)
void CGame::UpdateScreen_QueryForceLogin()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(200 + SCREENX, 244 + SCREENY, 200 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		pMI->AddRect(370 + SCREENX, 244 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		m_bEnterPressed = false;
		m_bEscPressed = false;
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = false;
		return;
	}

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Animation frame updates
	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
			m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NOENTER_FORCEDISCONN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}
}

// QueryForceLogin screen - Draw phase (rendering only)
void CGame::DrawScreen_QueryForceLogin()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 130 + SCREENY, 2);

	PutString_SprFont(172 + 86 + SCREENX, 160 + SCREENY, "Character on Use", 7, 0, 0);
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN1);
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 215 + SCREENY, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN2);

	if ((m_sFrameMouseX >= 200 + SCREENX) && (m_sFrameMouseX <= 200 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 18);

	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 2);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// QueryDeleteCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_QueryDeleteCharacter()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static DWORD dwCTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		pMI = new class CMouseInterface;
		pMI->AddRect(200 + SCREENX, 244 + SCREENY, 200 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		pMI->AddRect(370 + SCREENX, 244 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 244 + DEF_BTNSZY + SCREENY);
		m_bEnterPressed = false;
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = false;
		return;
	}

	// Poll mouse input and store for Draw phase
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Animation frame updates
	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_DELETECHARACTER;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}
}

// QueryDeleteCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_QueryDeleteCharacter()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	UpdateScreen_OnSelectCharacter(0, 0, 500, 70);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6))
	{
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}
	else if (m_cGameModeCount >= 6)
	{
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
		m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	PutString_SprFont(172 + 86 + SCREENX, 160 + SCREENY, "Delete Character", 7, 0, 0);
	PutString(215 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER1, RGB(5, 5, 5));
	PutString(335 + SCREENX, 199 + SCREENY, "__________", RGB(5, 5, 5));
	PutString(335 + SCREENX, 195 + SCREENY, m_pCharList[m_wEnterGameType - 1]->m_cName, RGB(25, 35, 25));
	PutAlignedString(178 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER2);

	if ((m_sFrameMouseX >= 200 + SCREENX) && (m_sFrameMouseX <= 200 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200 + SCREENX, 244 + SCREENY, 18);

	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 244 + SCREENY) && (m_sFrameMouseY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 2);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// MainMenu screen - Update phase (logic/input handling)
void CGame::UpdateScreen_MainMenu()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;

	m_iItemDropCnt = 0;
	m_bItemDrop = false;

	if (m_cGameModeCount == 0)
	{
		if (G_pCalcSocket != 0)
		{
			delete G_pCalcSocket;
			G_pCalcSocket = 0;
		}
		if (m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != 0)
		{
			delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = 0;
		}
		EndInputString();
		pMI = new class CMouseInterface;

		pMI->AddRect(384 + SCREENX, 177 + SCREENY, 548 + SCREENX, 198 + SCREENY);
		pMI->AddRect(384 + SCREENX, 215 + SCREENY, 548 + SCREENX, 236 + SCREENY);
		pMI->AddRect(384 + SCREENX, 254 + SCREENY, 548 + SCREENX, 275 + SCREENY);
		m_DInput.m_sX = 400;
		m_DInput.m_sY = 240;

		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = false;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Poll mouse input
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	// Update focus based on mouse position
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 177 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 198 + SCREENY)) m_cCurFocus = 1;
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 215 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 236 + SCREENY)) m_cCurFocus = 2;
	if ((m_sFrameMouseX >= 384 + SCREENX) && (m_sFrameMouseY >= 254 + SCREENY) && (m_sFrameMouseX <= 548 + SCREENX) && (m_sFrameMouseY <= 275 + SCREENY)) m_cCurFocus = 3;

	if (m_cArrowPressed != 0) {
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == true) {
		PlaySound('E', 14, 5);
		m_bEnterPressed = false;
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
#else
			GoHomepage();
#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);
		m_cCurFocus = iMIbuttonNum;
		switch (iMIbuttonNum)
		{
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;
		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
#else
			GoHomepage();
#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
}

// MainMenu screen - Draw phase (rendering only)
void CGame::DrawScreen_MainMenu()
{
	uint32_t dwTime = G_dwGlobalTime;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, 0 + SCREENX, 0 + SCREENY, 0, true);

	switch (m_cCurFocus) {
	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384 + SCREENX, 177 + SCREENY, 1, dwTime);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384 + SCREENX, 215 + SCREENY, 2, dwTime);
		break;
	case 3:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384 + SCREENX, 254 + SCREENY, 3, dwTime);
		break;
	}

	DrawVersion(true);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// WaitInitData screen - Update phase (logic/input handling)
void CGame::UpdateScreen_WaitInitData()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = false;
		m_bEscPressed = false;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true) {
		if ((dwTime - m_dwTime) > 7000)
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != 0)
			{
				delete m_pLSock;
				m_pLSock = 0;
			}
			if (m_pGSock != 0)
			{
				delete m_pGSock;
				m_pGSock = 0;
			}
		}
		m_bEscPressed = false;
		return;
	}

	// Poll mouse input
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);
}

// WaitInitData screen - Draw phase (rendering only)
void CGame::DrawScreen_WaitInitData()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	wsprintf(G_cTxt, "Waiting for response... %dsec", (dwTime - m_dwTime) / 1000);
	PutString_SprFont(172 + 44 + SCREENX, 190 + SCREENY, G_cTxt, 7, 0, 0);
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(174 + SCREENX, 467 + SCREENX, 190 + 30 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA1);
		PutAlignedString(174 + SCREENX, 467 + SCREENX, 190 + 45 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA2);
	}
	else PutAlignedString(174 + SCREENX, 467 + SCREENX, 195 + 30 + SCREENY, UPDATE_SCREEN_ON_WAIT_INIT_DATA3);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 8, dwTime);
}

// SelectServer screen - Update phase (logic/input handling)
void CGame::UpdateScreen_SelectServer()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static char cPrevFocus;

	if (m_cGameModeCount == 0) {
		EndInputString();

		pMI = new class CMouseInterface;
		pMI->AddRect(130, 177, 270, 198);
		pMI->AddRect(130, 199, 270, 225);
		pMI->AddRect(256, 279, 331, 308);

		cPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = false;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;
		PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
			if (strlen(m_cWorldServerName) == 0)
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, NAME_WORLDNAME1);
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;
		case 2:
			std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS2");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;
		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if (m_bEscPressed == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = false;
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{
		cPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			if (m_cCurFocus == 1) {
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, NAME_WORLDNAME1);
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 1;
			break;
		case 2:
			if (m_cCurFocus == 2) {
				std::memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS2");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 2;
			break;
		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 130) && (m_sFrameMouseX <= 295) && (m_sFrameMouseY >= 175) && (m_sFrameMouseY <= 198)) m_cCurFocus = 1;
	if ((m_sFrameMouseX >= 130) && (m_sFrameMouseX <= 295) && (m_sFrameMouseY >= 199) && (m_sFrameMouseY <= 225)) m_cCurFocus = 2;
	if ((m_sFrameMouseX >= 256) && (m_sFrameMouseX <= 331) && (m_sFrameMouseY >= 279) && (m_sFrameMouseY <= 308)) m_cCurFocus = 3;
}

// SelectServer screen - Draw phase (rendering only)
void CGame::DrawScreen_SelectServer()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0, 0, 0, true);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 40, 121, 1, true);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(40, 121, 1, true);

	if (m_cGameModeCount > 20)
	{
		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 138, 177, 5, true);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 130, 205, 6, true);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256, 282, 4, true);
	}
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// File-scope static variables for Login screen input buffers
// Shared between UpdateScreen_Login and DrawScreen_Login
static char s_cLoginName[12];
static char s_cLoginPassword[12];

// Login screen - Update phase (logic/input handling)
void CGame::UpdateScreen_Login()
{
	char cMIresult;
	int  iMIbuttonNum;
	static class CMouseInterface* pMI;
	static char cPrevFocus;

	if (m_cGameModeCount == 0)
	{
		EndInputString();
		pMI = new class CMouseInterface;
		pMI->AddRect(80 + SCREENX, 151 + SCREENY, 337 + SCREENX, 179 + SCREENY);
		pMI->AddRect(80 + SCREENX, 180 + SCREENY, 337 + SCREENX, 205 + SCREENY);
		pMI->AddRect(80 + SCREENX, 280 + SCREENY, 163 + SCREENX, 302 + SCREENY);
		pMI->AddRect(258 + SCREENX, 280 + SCREENY, 327 + SCREENX, 302 + SCREENY);
		cPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 4;
		m_bEnterPressed = false;
		m_cArrowPressed = 0;
		std::memset(s_cLoginName, 0, sizeof(s_cLoginName));
		std::memset(s_cLoginPassword, 0, sizeof(s_cLoginPassword));
		StartInputString(180 + SCREENX, 162 + SCREENY, 11, s_cLoginName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 2:
		case 3:
			if ((strlen(s_cLoginName) == 0) || (strlen(s_cLoginPassword) == 0)) break;
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, s_cLoginName);
			strcpy(m_cAccountPassword, s_cLoginPassword);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;
		case 4:
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
		}
	}

	if (m_bEscPressed == true)
	{
		EndInputString();
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = false;
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(180 + SCREENX, 162 + SCREENY, 11, s_cLoginName);
			break;
		case 2:
			StartInputString(180 + SCREENX, 185 + SCREENY, 11, s_cLoginPassword, true);
			break;
		case 3:
		case 4:
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = pMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cCurFocus = 2;
			break;
		case 3:
			if ((strlen(s_cLoginName) == 0) || (strlen(s_cLoginPassword) == 0)) break;
			EndInputString();
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, s_cLoginName);
			strcpy(m_cAccountPassword, s_cLoginPassword);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;
		case 4:
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 80 + SCREENX) && (m_sFrameMouseX <= 163 + SCREENX) && (m_sFrameMouseY >= 280 + SCREENY) && (m_sFrameMouseY <= 302 + SCREENY)) m_cCurFocus = 3;
	if ((m_sFrameMouseX >= 258 + SCREENX) && (m_sFrameMouseX <= 327 + SCREENX) && (m_sFrameMouseY >= 280 + SCREENY) && (m_sFrameMouseY <= 302 + SCREENY)) m_cCurFocus = 4;
}

// Login screen - Draw phase (rendering only)
void CGame::DrawScreen_Login()
{
	// Use shared static buffers from UpdateScreen_Login
	_Draw_OnLogin(s_cLoginName, s_cLoginPassword, m_sFrameMouseX, m_sFrameMouseY, m_cGameModeCount);
}

// Loading screen - Update phase (resource loading)
void CGame::UpdateScreen_Loading()
{
	// The loading screen loads resources progressively
	// All the resource loading happens in UpdateScreen_OnLoading
	// We call it here since it needs to happen
	UpdateScreen_OnLoading(false);
}

// Loading screen - Draw phase (progress display)
void CGame::DrawScreen_Loading()
{
	// Draw progress
	UpdateScreen_OnLoading_Progress();

	// Poll mouse for cursor
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	uint32_t dwTime = GameClock::GetTimeMS();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// LogResMsg screen - Update phase (logic/input handling)
void CGame::UpdateScreen_LogResMsg()
{
	// This screen is complex - handled in DrawScreen_LogResMsg via original method
}

// LogResMsg screen - Draw phase (rendering only)
void CGame::DrawScreen_LogResMsg()
{
	// This screen is complex - delegate to original combined method
	UpdateScreen_OnLogResMsg();
}

// File-scope static variables for ChangePassword screen input buffers
// Shared between UpdateScreen_ChangePassword and DrawScreen_ChangePassword
static char s_cChgPwdName[12];
static char s_cChgPwdPassword[12];
static char s_cChgPwdNewPassword[12];
static char s_cChgPwdNewPassConfirm[12];
static char s_cChgPwdPrevFocus;
static DWORD s_dwChgPwdCTime;
static class CMouseInterface* s_pChgPwdMI;

// ChangePassword screen - Update phase (logic/input handling)
void CGame::UpdateScreen_ChangePassword()
{
	char cMIresult;
	int  iMIbuttonNum;

	if (m_cGameModeCount == 0) {
		EndInputString();

		s_pChgPwdMI = new class CMouseInterface;
		s_pChgPwdMI->AddRect(300 + SCREENX, 148 + SCREENY, 425 + SCREENX, 170 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 172 + SCREENY, 425 + SCREENX, 194 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 196 + SCREENY, 425 + SCREENX, 218 + SCREENY);
		s_pChgPwdMI->AddRect(300 + SCREENX, 220 + SCREENY, 425 + SCREENX, 242 + SCREENY);

		s_pChgPwdMI->AddRect(197 + SCREENX, 320 + SCREENY, 197 + DEF_BTNSZX + SCREENX, 320 + DEF_BTNSZY + SCREENY);
		s_pChgPwdMI->AddRect(370 + SCREENX, 320 + SCREENY, 370 + DEF_BTNSZX + SCREENX, 320 + DEF_BTNSZY + SCREENY);

		s_cChgPwdPrevFocus = 2;
		m_cCurFocus = 2;
		m_cMaxFocus = 6;
		m_bEnterPressed = false;
		m_cArrowPressed = 0;

		std::memset(s_cChgPwdName, 0, sizeof(s_cChgPwdName));
		std::memset(s_cChgPwdPassword, 0, sizeof(s_cChgPwdPassword));
		std::memset(s_cChgPwdNewPassword, 0, sizeof(s_cChgPwdNewPassword));
		std::memset(s_cChgPwdNewPassConfirm, 0, sizeof(s_cChgPwdNewPassConfirm));

		strcpy(s_cChgPwdName, m_cAccountName);
		StartInputString(314 + SCREENX, 179 + SCREENY, 11, s_cChgPwdPassword);
		ClearInputString();
		s_dwChgPwdCTime = GameClock::GetTimeMS();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	uint32_t dwTime = GameClock::GetTimeMS();
	if ((dwTime - s_dwChgPwdCTime) > 100) {
		m_cMenuFrame++;
		s_dwChgPwdCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == true)
	{
		PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 5:	// Connect
			if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
				(CMisc::bCheckValidName(s_cChgPwdNewPassword) == false) || (CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) == false) ||
				(strlen(s_cChgPwdNewPassword) == 0) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0)) break;

			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
			std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, s_cChgPwdName);
			strcpy(m_cAccountPassword, s_cChgPwdPassword);
			strcpy(m_cNewPassword, s_cChgPwdNewPassword);
			strcpy(m_cNewPassConfirm, s_cChgPwdNewPassConfirm);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete s_pChgPwdMI;
			return;

		case 6:	// Cancel
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pChgPwdMI;
			return;
		}
		m_bEnterPressed = false;
	}

	if (m_bEscPressed == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pChgPwdMI;
		m_bEscPressed = false;
		return;
	}

	if (s_cChgPwdPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(314 + SCREENX, 155 + SCREENY, 11, s_cChgPwdName);
			break;
		case 2:
			StartInputString(314 + SCREENX, 179 + SCREENY, 11, s_cChgPwdPassword);
			break;
		case 3:
			StartInputString(314 + SCREENX, 203 + SCREENY, 11, s_cChgPwdNewPassword);
			break;
		case 4:
			StartInputString(314 + SCREENX, 227 + SCREENY, 11, s_cChgPwdNewPassConfirm);
			break;
		}
		s_cChgPwdPrevFocus = m_cCurFocus;
	}

	// Poll mouse input
	m_DInput.UpdateMouseState(&m_sFrameMouseX, &m_sFrameMouseY, &m_sFrameMouseZ, &m_cFrameMouseLB, &m_cFrameMouseRB);

	iMIbuttonNum = s_pChgPwdMI->iGetStatus(m_sFrameMouseX, m_sFrameMouseY, m_cFrameMouseLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus = iMIbuttonNum;
			break;

		case 5:
			if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
				(CMisc::bCheckValidName(s_cChgPwdNewPassword) == false) || (CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) == false) ||
				(strlen(s_cChgPwdNewPassword) == 0) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0)) break;

			EndInputString();
			std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
			std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
			std::memset(m_cNewPassword, 0, sizeof(m_cNewPassword));
			std::memset(m_cNewPassConfirm, 0, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, s_cChgPwdName);
			strcpy(m_cAccountPassword, s_cChgPwdPassword);
			strcpy(m_cNewPassword, s_cChgPwdNewPassword);
			strcpy(m_cNewPassConfirm, s_cChgPwdNewPassConfirm);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete s_pChgPwdMI;
			return;

		case 6:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pChgPwdMI;
			return;
		}
	}

	if ((m_sFrameMouseX >= 197 + SCREENX) && (m_sFrameMouseX <= 197 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 320 + SCREENY) && (m_sFrameMouseY <= 320 + DEF_BTNSZY + SCREENY)) m_cCurFocus = 5;
	if ((m_sFrameMouseX >= 370 + SCREENX) && (m_sFrameMouseX <= 370 + DEF_BTNSZX + SCREENX) && (m_sFrameMouseY >= 320 + SCREENY) && (m_sFrameMouseY <= 320 + DEF_BTNSZY + SCREENY)) m_cCurFocus = 6;
}

// ChangePassword screen - Draw phase (rendering only)
void CGame::DrawScreen_ChangePassword()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	bool bFlag = true;

	// Draw background (SelectCharacter screen)
	UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
	m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	// Draw dialog boxes
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + SCREENX, 112 + SCREENY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 153 + SCREENX, 112 + SCREENY, 13);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157 + SCREENX, 112 + 109 + SCREENY, 7);

	// Draw labels
	PutString(206 + SCREENX, 155 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD1, RGB(25, 35, 25));
	PutString(206 + SCREENX, 179 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD2, RGB(25, 35, 25));
	PutString(206 + SCREENX, 203 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD3, RGB(25, 35, 25));
	PutString(206 + SCREENX, 227 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD4, RGB(25, 35, 25));

	// Draw input field values
	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidString(s_cChgPwdName) != false)
			PutString(314 + SCREENX, 155 + SCREENY, s_cChgPwdName, RGB(25, 35, 25));
		else PutString(314 + SCREENX, 155 + SCREENY, s_cChgPwdName, RGB(55, 18, 13));
	}
	if ((CMisc::bCheckValidString(s_cChgPwdName) == false) || (strlen(s_cChgPwdName) == 0)) bFlag = false;

	if (m_cCurFocus != 2) {
		if ((CMisc::bCheckValidString(s_cChgPwdPassword) != false))
			PutString(314 + SCREENX, 179 + SCREENY, s_cChgPwdPassword, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 179 + SCREENY, s_cChgPwdPassword, RGB(55, 18, 13), true, 3);
	}

	if (m_cCurFocus != 3) {
		if ((CMisc::bCheckValidName(s_cChgPwdNewPassword) != false))
			PutString(314 + SCREENX, 203 + SCREENY, s_cChgPwdNewPassword, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 203 + SCREENY, s_cChgPwdNewPassword, RGB(55, 18, 13), true, 3);
	}

	if (m_cCurFocus != 4) {
		if ((CMisc::bCheckValidName(s_cChgPwdNewPassConfirm) != false))
			PutString(314 + SCREENX, 227 + SCREENY, s_cChgPwdNewPassConfirm, RGB(25, 35, 25), true, 3);
		else PutString(314 + SCREENX, 227 + SCREENY, s_cChgPwdNewPassConfirm, RGB(55, 18, 13), true, 3);
	}

	if ((CMisc::bCheckValidString(s_cChgPwdPassword) == false) || (strlen(s_cChgPwdPassword) == 0) ||
		(strlen(s_cChgPwdNewPassword) < 8) || (memcmp(s_cChgPwdNewPassword, s_cChgPwdNewPassConfirm, 10) != 0) ||
		(memcmp(s_cChgPwdPassword, s_cChgPwdNewPassword, 10) == 0)) bFlag = false;

	// Show active input string
	if (m_cCurFocus == 1) ShowReceivedString();
	else if ((m_cCurFocus == 2) || (m_cCurFocus == 3) || (m_cCurFocus == 4)) ShowReceivedString(true);

	// Help text
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 258 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD5);
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 273 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD6);
	PutAlignedString(153 + SCREENX, 487 + SCREENX, 288 + SCREENY, UPDATE_SCREEN_ON_CHANGE_PASSWORD7);

	// Buttons
	if ((bFlag == true) && (m_cCurFocus == 5))
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197 + SCREENX, 320 + SCREENY, 21, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197 + SCREENX, 320 + SCREENY, 20, dwTime);

	if (m_cCurFocus == 6)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370 + SCREENX, 320 + SCREENY, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370 + SCREENX, 320 + SCREENY, 16, dwTime);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
}

// File-scope static variables for CreateNewAccount screen input buffers
// Shared between UpdateScreen_CreateNewAccount and DrawScreen_CreateNewAccount
static char s_cNewAcctName[12];
static char s_cNewAcctPassword[12];
static char s_cNewAcctConfirm[12];
static char s_cNewAcctSSN_A[8];
static char s_cNewAcctSSN_B[8];
static char s_cNewAcctQuiz[44];
static char s_cNewAcctTempQuiz[44];
static char s_cNewAcctAnswer[20];
static char s_cNewAcctPrevFocus;
static class CMouseInterface* s_pNewAcctMI;
static short s_sNewAcctMsX;
static short s_sNewAcctMsY;
static char s_cNewAcctPrevLB;

// CreateNewAccount screen - Update phase (logic/input handling)
void CGame::UpdateScreen_CreateNewAccount()
{
#ifdef DEF_MAKE_ACCOUNT
	char cMIresult;
	int iMIbuttonNum;
	short msX, msY, msZ;
	char cLB, cRB;

	if (m_cGameModeCount == 0)
	{
		EndInputString();

		s_pNewAcctMI = new class CMouseInterface;
		// Input field areas
		s_pNewAcctMI->AddRect(427 + SCREENX, 84 + SCREENY - 5, 550 + SCREENX, 84 + SCREENY + 15);   // 1: Account
		s_pNewAcctMI->AddRect(427 + SCREENX, 106 + SCREENY - 5, 550 + SCREENX, 106 + SCREENY + 15); // 2: Password
		s_pNewAcctMI->AddRect(427 + SCREENX, 129 + SCREENY - 5, 550 + SCREENX, 129 + SCREENY + 15); // 3: Confirm
		s_pNewAcctMI->AddRect(311 + SCREENX, 215 + SCREENY - 5, 550 + SCREENX, 215 + SCREENY + 15); // 4: Email
		s_pNewAcctMI->AddRect(311 + SCREENX, 253 + SCREENY - 5, 550 + SCREENX, 253 + SCREENY + 15); // 5: Quiz
		s_pNewAcctMI->AddRect(311 + SCREENX, 291 + SCREENY - 5, 550 + SCREENX, 291 + SCREENY + 15); // 6: Answer
		// Button areas (left to right: Create, Clear, Cancel)
		s_pNewAcctMI->AddRect(297 + SCREENX, 398 + SCREENY, 297 + 72 + SCREENX, 398 + 20 + SCREENY); // 7: Create (left)
		s_pNewAcctMI->AddRect(392 + SCREENX, 398 + SCREENY, 392 + 72 + SCREENX, 398 + 20 + SCREENY); // 8: Clear (center)
		s_pNewAcctMI->AddRect(488 + SCREENX, 398 + SCREENY, 488 + 72 + SCREENX, 398 + 20 + SCREENY); // 9: Cancel (right)

		s_cNewAcctPrevFocus = 1;
		s_cNewAcctPrevLB = 0;
		m_cCurFocus = 1;
		m_cMaxFocus = 9;
		m_bEnterPressed = false;
		m_cArrowPressed = 0;

		std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
		std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
		std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
		std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
		std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
		std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));

		StartInputString(427 + SCREENX, 84 + SCREENY, 11, s_cNewAcctName);
		ClearInputString();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	// Handle arrow key navigation
	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1: // Up
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3: // Down
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	// Handle focus change - switch input field
	if (s_cNewAcctPrevFocus != m_cCurFocus)
	{
		EndInputString();
		switch (m_cCurFocus) {
		case 1: StartInputString(427 + SCREENX, 84 + SCREENY, 11, s_cNewAcctName); break;
		case 2: StartInputString(427 + SCREENX, 106 + SCREENY, 11, s_cNewAcctPassword); break;
		case 3: StartInputString(427 + SCREENX, 129 + SCREENY, 11, s_cNewAcctConfirm); break;
		case 4: StartInputString(311 + SCREENX, 215 + SCREENY, 50, m_cEmailAddr); break;
		case 5: StartInputString(311 + SCREENX, 253 + SCREENY, 43, s_cNewAcctQuiz); break;
		case 6: StartInputString(311 + SCREENX, 291 + SCREENY, 19, s_cNewAcctAnswer); break;
		}
		s_cNewAcctPrevFocus = m_cCurFocus;
	}

	// Handle Enter key
	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;
		PlaySound('E', 14, 5);

		if (m_cCurFocus <= 6)
		{
			// Move to next input field
			m_cCurFocus++;
			if (m_cCurFocus > 6) m_cCurFocus = 7; // Move to Create button
		}
		else if (m_cCurFocus == 7)
		{
			// Create button - validate and submit
			wsprintf(s_cNewAcctTempQuiz, "%s", s_cNewAcctQuiz);
			CMisc::ReplaceString(s_cNewAcctTempQuiz, ' ', '_');
			bool bValid = true;
			if (strlen(s_cNewAcctName) == 0) bValid = false;
			if (strlen(s_cNewAcctPassword) == 0) bValid = false;
			if (strlen(s_cNewAcctConfirm) == 0) bValid = false;
			if (CMisc::bIsValidEmail(m_cEmailAddr) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctName) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctPassword) == false) bValid = false;
			if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) != 0) bValid = false;
			if (strlen(s_cNewAcctTempQuiz) == 0) bValid = false;
			if (strlen(s_cNewAcctAnswer) == 0) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) == false) bValid = false;
			if (CMisc::bCheckValidName(s_cNewAcctAnswer) == false) bValid = false;

			if (bValid)
			{
				// Copy to game account fields
				std::memset(m_cAccountName, 0, sizeof(m_cAccountName));
				std::memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));
				std::memset(m_cAccountQuiz, 0, sizeof(m_cAccountQuiz));
				std::memset(m_cAccountAnswer, 0, sizeof(m_cAccountAnswer));
				strcpy(m_cAccountName, s_cNewAcctName);
				strcpy(m_cAccountPassword, s_cNewAcctPassword);
				strcpy(m_cAccountQuiz, s_cNewAcctQuiz);
				strcpy(m_cAccountAnswer, s_cNewAcctAnswer);

				// Connect to server
				m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort);
				m_pLSock->bInitBufferSize(30000);
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
				std::memset(m_cMsg, 0, sizeof(m_cMsg));
				strcpy(m_cMsg, "01");
				delete s_pNewAcctMI;
				return;
			}
		}
		else if (m_cCurFocus == 8)
		{
			// Clear - clear all input fields (center button)
			EndInputString();
			std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
			std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
			std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
			std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
			std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
			std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));
			m_cCurFocus = 1;
			s_cNewAcctPrevFocus = 0; // Force focus switch to restart input
		}
		else if (m_cCurFocus == 9)
		{
			// Cancel - go back to main menu (right button)
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pNewAcctMI;
			return;
		}
	}

	// Handle Escape key
	if (m_bEscPressed == true)
	{
		m_bEscPressed = false;
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pNewAcctMI;
		return;
	}

	// Poll mouse input
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_sFrameMouseX = msX;
	m_sFrameMouseY = msY;
	s_sNewAcctMsX = msX;
	s_sNewAcctMsY = msY;

	// Detect mouse click (button was down, now released)
	bool bMouseClick = (s_cNewAcctPrevLB != 0 && cLB == 0);
	s_cNewAcctPrevLB = cLB;

	// Handle mouse clicks on input fields via CMouseInterface
	iMIbuttonNum = s_pNewAcctMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		if (iMIbuttonNum >= 1 && iMIbuttonNum <= 6)
		{
			// Clicked on an input field
			PlaySound('E', 14, 5);
			m_cCurFocus = iMIbuttonNum;
		}
	}

	// Handle mouse clicks on buttons using direct position check
	// Button order left to right: Create, Clear, Cancel
	if (bMouseClick)
	{
		// Button 7: Create (at 297, 398 - size 72x20) - LEFT
		bool bOverCreate = (msX >= 297 + SCREENX && msX <= 297 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);
		// Button 8: Clear (at 392, 398 - size 72x20) - CENTER
		bool bOverClear = (msX >= 392 + SCREENX && msX <= 392 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);
		// Button 9: Cancel (at 488, 398 - size 72x20) - RIGHT
		bool bOverCancel = (msX >= 488 + SCREENX && msX <= 488 + 72 + SCREENX &&
			msY >= 398 + SCREENY && msY <= 398 + 20 + SCREENY);

		if (bOverCreate)
		{
			PlaySound('E', 14, 5);
			m_cCurFocus = 7;
			m_bEnterPressed = true; // Trigger Enter handling
		}
		else if (bOverClear)
		{
			PlaySound('E', 14, 5);
			EndInputString();
			std::memset(s_cNewAcctName, 0, sizeof(s_cNewAcctName));
			std::memset(s_cNewAcctPassword, 0, sizeof(s_cNewAcctPassword));
			std::memset(s_cNewAcctConfirm, 0, sizeof(s_cNewAcctConfirm));
			std::memset(m_cEmailAddr, 0, sizeof(m_cEmailAddr));
			std::memset(s_cNewAcctQuiz, 0, sizeof(s_cNewAcctQuiz));
			std::memset(s_cNewAcctAnswer, 0, sizeof(s_cNewAcctAnswer));
			m_cCurFocus = 1;
			s_cNewAcctPrevFocus = 0; // Force focus switch to restart input
		}
		else if (bOverCancel)
		{
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pNewAcctMI;
			return;
		}
	}
#endif
}

// CreateNewAccount screen - Draw phase (rendering only)
void CGame::DrawScreen_CreateNewAccount()
{
#ifdef DEF_MAKE_ACCOUNT
	uint32_t dwTime = GameClock::GetTimeMS();
	int iFlag = 0;

	// Compute validation flags for display
	wsprintf(s_cNewAcctTempQuiz, "%s", s_cNewAcctQuiz);
	CMisc::ReplaceString(s_cNewAcctTempQuiz, ' ', '_');

	if (CMisc::bCheckValidName(s_cNewAcctAnswer) == false)		iFlag = 13;
	if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) == false)	iFlag = 12;
	if (strlen(s_cNewAcctAnswer) == 0)							iFlag = 11;
	if (strlen(s_cNewAcctTempQuiz) == 0)						iFlag = 10;
	if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) != 0)	iFlag = 9;
	if (CMisc::bCheckValidName(s_cNewAcctPassword) == false)	iFlag = 7;
	if (CMisc::bCheckValidName(s_cNewAcctName) == false)		iFlag = 6;
	if (CMisc::bIsValidEmail(m_cEmailAddr) == false)			iFlag = 5;
	if (strlen(s_cNewAcctConfirm) == 0)							iFlag = 3;
	if (strlen(s_cNewAcctPassword) == 0)						iFlag = 2;
	if (strlen(s_cNewAcctName) == 0)							iFlag = 1;

	// Draw background
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0 + SCREENX, 0 + SCREENY, 0, true);

	// Draw labels
	PutString(377 + SCREENX, 84 + SCREENY, "Account:", RGB(100, 100, 200));
	PutString(372 + SCREENX, 106 + SCREENY, "Password:", RGB(100, 100, 200));
	PutString(372 + SCREENX, 129 + SCREENY, "(confirm)", RGB(100, 100, 200));
	PutString(271 + SCREENX, 215 + SCREENY, "eMail:", RGB(100, 100, 200));
	PutString(276 + SCREENX, 253 + SCREENY, "Quiz:", RGB(100, 100, 200));
	PutString(266 + SCREENX, 291 + SCREENY, "Answer:", RGB(100, 100, 200));

	// Show active input string
	if ((m_cCurFocus == 2) || (m_cCurFocus == 3))
		ShowReceivedString(true);
	else if ((m_cCurFocus == 1) || (m_cCurFocus == 4) || (m_cCurFocus == 5) || (m_cCurFocus == 6))
		ShowReceivedString();

	// Draw input field values
	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidName(s_cNewAcctName) != false)
			PutString2(427 + SCREENX, 84 + SCREENY, s_cNewAcctName, 100, 200, 100);
		else PutString2(427 + SCREENX, 84 + SCREENY, s_cNewAcctName, 200, 100, 100);
	}
	if (m_cCurFocus != 2) {
		if (CMisc::bCheckValidName(s_cNewAcctPassword) != false)
			PutString(427 + SCREENX, 106 + SCREENY, s_cNewAcctPassword, RGB(100, 200, 100), true, 1);
		else PutString(427 + SCREENX, 106 + SCREENY, s_cNewAcctPassword, RGB(200, 100, 100), true, 1);
	}
	if (m_cCurFocus != 3) {
		if (memcmp(s_cNewAcctPassword, s_cNewAcctConfirm, 10) == 0)
			PutString(427 + SCREENX, 129 + SCREENY, s_cNewAcctConfirm, RGB(100, 200, 100), true, 1);
		else PutString(427 + SCREENX, 129 + SCREENY, s_cNewAcctConfirm, RGB(200, 100, 100), true, 1);
	}
	if (m_cCurFocus != 4) {
		if (CMisc::bIsValidEmail(m_cEmailAddr))
			PutString2(311 + SCREENX, 48 + 190 - 25 + 2 + SCREENY, m_cEmailAddr, 100, 200, 100);
		else PutString2(311 + SCREENX, 48 + 190 - 25 + 2 + SCREENY, m_cEmailAddr, 200, 100, 100);
	}
	if (m_cCurFocus != 5) {
		if (CMisc::bCheckValidName(s_cNewAcctTempQuiz) != false)
			PutString2(311 + SCREENX, 48 + 226 - 25 + 4 + SCREENY, s_cNewAcctQuiz, 100, 200, 100);
	}
	if (m_cCurFocus != 6) {
		if (CMisc::bCheckValidName(s_cNewAcctAnswer) != false)
			PutString2(311 + SCREENX, 291 + SCREENY, s_cNewAcctAnswer, 100, 200, 100);
	}

	// Draw help text based on focus
	switch (m_cCurFocus) {
	case 1:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT1);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT2);
		break;
	case 2:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT4);
		break;
	case 3:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT8);
		break;
	case 4:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT21);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT22);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 360 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT23);
		break;
	case 5:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT25);
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT26);
		break;
	case 6:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT29);
		break;
	case 7:
		switch (iFlag) {
		case 0:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT33);
			break;
		case 1:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT35);
			break;
		case 2:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT38);
			break;
		case 3:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT42);
			break;
		case 5:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT50);
			break;
		case 6:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT52);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT53);
			break;
		case 7:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT56);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT57);
			break;
		case 9:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT63);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT64);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 360 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT65);
			break;
		case 10:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT67);
			break;
		case 11:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT69);
			break;
		case 12:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT73);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT74);
			break;
		case 13:
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT77);
			PutAlignedString(290 + SCREENX, 575 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT78);
			break;
		}
		break;
	case 8:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT80);
		break;
	case 9:
		PutAlignedString(290 + SCREENX, 575 + SCREENX, 330 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT81);
		break;
	}

	// Draw buttons - highlight on focus OR mouse hover
	// Button order left to right: Create, Clear, Cancel

	// Button 7: Create (at 297, 398 - size 72x20) - LEFT
	bool bHoverCreate = (s_sNewAcctMsX >= 297 + SCREENX && s_sNewAcctMsX <= 297 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if ((iFlag == 0) && (m_cCurFocus == 7 || bHoverCreate))
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199 + 98 + SCREENX, 398 + SCREENY, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199 + 98 + SCREENX, 398 + SCREENY, 24, dwTime);

	// Button 8: Clear (at 392, 398 - size 72x20) - CENTER
	bool bHoverClear = (s_sNewAcctMsX >= 392 + SCREENX && s_sNewAcctMsX <= 392 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if (m_cCurFocus == 8 || bHoverClear)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294 + 98 + SCREENX, 398 + SCREENY, 27, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294 + 98 + SCREENX, 398 + SCREENY, 26, dwTime);

	// Button 9: Cancel (at 488, 398 - size 72x20) - RIGHT
	bool bHoverCancel = (s_sNewAcctMsX >= 488 + SCREENX && s_sNewAcctMsX <= 488 + 72 + SCREENX &&
		s_sNewAcctMsY >= 398 + SCREENY && s_sNewAcctMsY <= 398 + 20 + SCREENY);
	if (m_cCurFocus == 9 || bHoverCancel)
		m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390 + 98 + SCREENX, 398 + SCREENY, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390 + 98 + SCREENX, 398 + SCREENY, 16, dwTime);

	DrawVersion(true);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(m_sFrameMouseX, m_sFrameMouseY, 0, dwTime);
#endif
}

// File-scope static variables for SelectCharacter screen
// Shared between UpdateScreen_SelectCharacter and DrawScreen_SelectCharacter
static class CMouseInterface* s_pSelCharMI;
static DWORD s_dwSelCharCTime;
static short s_sSelCharMsX;
static short s_sSelCharMsY;

// SelectCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_SelectCharacter()
{
	short msX, msY, msZ;
	char cLB, cRB;
	char cMIresult;
	int iMIbuttonNum;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		G_cSpriteAlphaDegree = 1;
		InitGameSettings();
		s_pSelCharMI = new class CMouseInterface;
		s_pSelCharMI->AddRect(100 + SCREENX, 50 + SCREENY, 210 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(211 + SCREENX, 50 + SCREENY, 321 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(322 + SCREENX, 50 + SCREENY, 431 + SCREENX, 250 + SCREENY);
		s_pSelCharMI->AddRect(432 + SCREENX, 50 + SCREENY, 542 + SCREENX, 250 + SCREENY);

		s_pSelCharMI->AddRect(360 + SCREENX, 283 + SCREENY, 545 + SCREENX, 315 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 316 + SCREENY, 545 + SCREENX, 345 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 346 + SCREENY, 545 + SCREENX, 375 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 376 + SCREENY, 545 + SCREENX, 405 + SCREENY);
		s_pSelCharMI->AddRect(360 + SCREENX, 406 + SCREENY, 545 + SCREENX, 435 + SCREENY);

		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1) m_cCurFocus = 1;

		m_cArrowPressed = 0;
		m_bEnterPressed = false;

		s_dwSelCharCTime = GameClock::GetTimeMS();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == true)
	{
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete s_pSelCharMI;
		m_bEscPressed = false;
		return;
	}

	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus - 1] != 0)
		{
			if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
			{
				std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
				m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
				if (CMisc::bCheckValidString(m_cPlayerName) == true)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
					m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
					m_pLSock->bInitBufferSize(30000);
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					std::memset(m_cMsg, 0, sizeof(m_cMsg));
					strcpy(m_cMsg, "33");
					std::memset(m_cMapName, 0, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
					delete s_pSelCharMI;
					return;
				}
			}
		}
		else
		{
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete s_pSelCharMI;
			return;
		}
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	s_sSelCharMsX = msX;
	s_sSelCharMsY = msY;

	if ((dwTime - s_dwSelCharCTime) > 100)
	{
		m_cMenuFrame++;
		s_dwSelCharCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = s_pSelCharMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else
			{
				if (m_pCharList[m_cCurFocus - 1] != 0)
				{
					if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
					{
						std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;
						if (CMisc::bCheckValidString(m_cPlayerName) == true)
						{
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
							m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
							m_pLSock->bInitBufferSize(30000);
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							std::memset(m_cMsg, 0, sizeof(m_cMsg));
							strcpy(m_cMsg, "33");
							std::memset(m_cMapName, 0, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
							delete s_pSelCharMI;
							return;
						}
					}
				}
				else
				{
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete s_pSelCharMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				if (m_pCharList[m_cCurFocus - 1]->m_sSex != 0)
				{
					std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus - 1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus - 1]->m_sLevel;

					if (CMisc::bCheckValidString(m_cPlayerName) == true) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
						m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
						m_pLSock->bInitBufferSize(30000);
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						std::memset(m_cMsg, 0, sizeof(m_cMsg));
						strcpy(m_cMsg, "33");
						std::memset(m_cMapName, 0, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus - 1]->m_cMapName, 10);
						delete s_pSelCharMI;
						return;
					}
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4)
			{
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete s_pSelCharMI;
				return;
			}
			break;

		case 7:
			if (m_pCharList[m_cCurFocus - 1] != 0)
			{
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus;
				delete s_pSelCharMI;
				return;
			}
			break;

		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete s_pSelCharMI;
			return;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete s_pSelCharMI;
			return;
		}
	}
}

// SelectCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_SelectCharacter()
{
	uint32_t dwTime = GameClock::GetTimeMS();

	// Call the parametered draw version with stored mouse coordinates
	UpdateScreen_OnSelectCharacter(0, 10, s_sSelCharMsX, s_sSelCharMsY);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(s_sSelCharMsX, s_sSelCharMsY, 0, dwTime);
}

// File-scope static variables for CreateNewCharacter screen
// Shared between UpdateScreen_CreateNewCharacter and DrawScreen_CreateNewCharacter
static class CMouseInterface* s_pNewCharMI;
static int s_iNewCharPoint;
static char s_cNewCharName[12];
static char s_cNewCharPrevFocus;
static DWORD s_dwNewCharMTime;
static short s_sNewCharMsX;
static short s_sNewCharMsY;
static bool s_bNewCharFlag;

// CreateNewCharacter screen - Update phase (logic/input handling)
void CGame::UpdateScreen_CreateNewCharacter()
{
	int iMIbuttonNum;
	char cLB, cRB, cMIresult;
	short msX, msY, msZ;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		s_pNewCharMI = new class CMouseInterface;
		s_pNewCharMI->AddRect(65 + 4 + SCREENX, 65 + 45 + SCREENY, 275 + 4 + SCREENX, 82 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 111 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 124 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 111 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 124 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 126 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 139 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 126 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 139 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 141 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 154 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 141 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 154 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 156 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 169 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 156 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 169 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 171 + 45 + SCREENY, 274 + 4 - 21 + SCREENX, 184 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 171 + 45 + SCREENY, 289 + 4 - 13 + SCREENX, 184 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 231 + 45 + SCREENY, 253 + 4 + SCREENX, 244 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 231 + 45 + SCREENY, 276 + 4 + SCREENX, 244 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 246 + 45 + SCREENY, 253 + 4 + SCREENX, 259 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 246 + 45 + SCREENY, 276 + 4 + SCREENX, 259 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 261 + 45 + SCREENY, 253 + 4 + SCREENX, 274 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 261 + 45 + SCREENY, 276 + 4 + SCREENX, 274 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 276 + 45 + SCREENY, 253 + 4 + SCREENX, 289 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 276 + 45 + SCREENY, 276 + 4 + SCREENX, 289 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 291 + 45 + SCREENY, 253 + 4 + SCREENX, 304 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 291 + 45 + SCREENY, 276 + 4 + SCREENX, 304 + 45 + SCREENY);

		s_pNewCharMI->AddRect(232 + 4 + SCREENX, 306 + 45 + SCREENY, 253 + 4 + SCREENX, 319 + 45 + SCREENY);
		s_pNewCharMI->AddRect(255 + 4 + SCREENX, 306 + 45 + SCREENY, 276 + 4 + SCREENX, 319 + 45 + SCREENY);

		s_pNewCharMI->AddRect(384 + SCREENX, 445 + SCREENY, 384 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(500 + SCREENX, 445 + SCREENY, 500 + 72 + SCREENX, 445 + 15 + SCREENY);

		s_pNewCharMI->AddRect(60 + SCREENX, 445 + SCREENY, 60 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(145 + SCREENX, 445 + SCREENY, 145 + 72 + SCREENX, 445 + 15 + SCREENY);
		s_pNewCharMI->AddRect(230 + SCREENX, 445 + SCREENY, 230 + 72 + SCREENX, 445 + 15 + SCREENY);

		s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
		s_iNewCharPoint = 70 - s_iNewCharPoint;
		s_cNewCharPrevFocus = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 6;
		m_bEnterPressed = false;
		m_cArrowPressed = 0;
		s_dwNewCharMTime = GameClock::GetTimeMS();
		std::memset(s_cNewCharName, 0, sizeof(s_cNewCharName));
		StartInputString(193 + 4 + SCREENX, 65 + 45 + SCREENY, 11, s_cNewCharName);
		ClearInputString();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (s_cNewCharPrevFocus != m_cCurFocus) {
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(193 + 4 + SCREENX, 65 + 45 + SCREENY, 11, s_cNewCharName);
			break;
		}
		s_cNewCharPrevFocus = m_cCurFocus;
	}

	if (m_bEscPressed == true) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete s_pNewCharMI;
		m_bEscPressed = false;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	s_sNewCharMsX = msX;
	s_sNewCharMsY = msY;

	// Compute whether character creation is valid (drawing moved to DrawScreen)
	s_bNewCharFlag = true;
	if (strlen(s_cNewCharName) <= 0) s_bNewCharFlag = false;
	if (s_iNewCharPoint > 0) s_bNewCharFlag = false;
	if (CMisc::bCheckValidName(s_cNewCharName) == false) s_bNewCharFlag = false;
	if (_bCheckBadWords(s_cNewCharName) == true) s_bNewCharFlag = false;

	if ((dwTime - s_dwNewCharMTime) > 100)
	{
		m_cMenuFrame++;
		s_dwNewCharMTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = s_pNewCharMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cGender--;
			if (m_cGender < 1) m_cGender = 2;
			break;
		case 3:
			m_cGender++;
			if (m_cGender > 2) m_cGender = 1;
			break;
		case 4:
			m_cSkinCol--;
			if (m_cSkinCol < 1) m_cSkinCol = 3;
			break;
		case 5:
			m_cSkinCol++;
			if (m_cSkinCol > 3) m_cSkinCol = 1;
			break;
		case 6:
			m_cHairStyle--;
			if (m_cHairStyle < 0) m_cHairStyle = 7;
			break;
		case 7:
			m_cHairStyle++;
			if (m_cHairStyle > 7) m_cHairStyle = 0;
			break;
		case 8:
			m_cHairCol--;
			if (m_cHairCol < 0) m_cHairCol = 15;
			break;
		case 9:
			m_cHairCol++;
			if (m_cHairCol > 15) m_cHairCol = 0;
			break;
		case 10:
			m_cUnderCol--;
			if (m_cUnderCol < 0) m_cUnderCol = 7;
			break;
		case 11:
			m_cUnderCol++;
			if (m_cUnderCol > 7) m_cUnderCol = 0;
			break;
		case 12:
			if (s_iNewCharPoint > 0) {
				if (m_ccStr < 14) {
					m_ccStr++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 13:
			if (m_ccStr > 10) {
				m_ccStr--;
				s_iNewCharPoint++;
			}
			break;
		case 14:
			if (s_iNewCharPoint > 0) {
				if (m_ccVit < 14) {
					m_ccVit++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 15:
			if (m_ccVit > 10) {
				m_ccVit--;
				s_iNewCharPoint++;
			}
			break;
		case 16:
			if (s_iNewCharPoint > 0) {
				if (m_ccDex < 14) {
					m_ccDex++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 17:
			if (m_ccDex > 10) {
				m_ccDex--;
				s_iNewCharPoint++;
			}
			break;
		case 18:
			if (s_iNewCharPoint > 0) {
				if (m_ccInt < 14) {
					m_ccInt++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 19:
			if (m_ccInt > 10) {
				m_ccInt--;
				s_iNewCharPoint++;
			}
			break;
		case 20:
			if (s_iNewCharPoint > 0) {
				if (m_ccMag < 14) {
					m_ccMag++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 21:
			if (m_ccMag > 10) {
				m_ccMag--;
				s_iNewCharPoint++;
			}
			break;
		case 22:
			if (s_iNewCharPoint > 0) {
				if (m_ccChr < 14) {
					m_ccChr++;
					s_iNewCharPoint--;
				}
			}
			break;
		case 23:
			if (m_ccChr > 10)
			{
				m_ccChr--;
				s_iNewCharPoint++;
			}
			break;

		case 24:
			if (m_cCurFocus != 2)
			{
				m_cCurFocus = 2;
				return;
			}
			if (s_bNewCharFlag == false) return;
			if (CMisc::bCheckValidName(s_cNewCharName) == false) break;
			std::memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
			strcpy(m_cPlayerName, s_cNewCharName);
			m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort + (rand() % 1));
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWCHARACTER;
			std::memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "22");
			delete s_pNewCharMI;
			return;

		case 25:
			if (m_cCurFocus != 3)
			{
				m_cCurFocus = 3;
				return;
			}
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete s_pNewCharMI;
			return;

		case 26: // WARRIOR
			if (m_cCurFocus != 4)
			{
				m_cCurFocus = 4;
				return;
			}

			m_ccMag = 10;
			m_ccInt = 10;
			m_ccChr = 10;
			m_ccStr = 14;
			m_ccVit = 12;
			m_ccDex = 14;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;

		case 27: // MAGE
			if (m_cCurFocus != 5) {
				m_cCurFocus = 5;
				return;
			}

			m_ccMag = 14;
			m_ccInt = 14;
			m_ccChr = 10;
			m_ccStr = 10;
			m_ccVit = 12;
			m_ccDex = 10;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;

		case 28: // PRIEST
			if (m_cCurFocus != 6) {
				m_cCurFocus = 6;
				return;
			}

			m_ccMag = 12;
			m_ccInt = 10;
			m_ccChr = 14;
			m_ccStr = 14;
			m_ccVit = 10;
			m_ccDex = 10;
			s_iNewCharPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			s_iNewCharPoint = 70 - s_iNewCharPoint;
			break;
		}
	}
}

// CreateNewCharacter screen - Draw phase (rendering only)
void CGame::DrawScreen_CreateNewCharacter()
{
	int i = 0;
	short msX = s_sNewCharMsX;
	short msY = s_sNewCharMsY;
	uint32_t dwTime = GameClock::GetTimeMS();

	// Draw the main character creation UI
	_bDraw_OnCreateNewCharacter(s_cNewCharName, msX, msY, s_iNewCharPoint);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	// Tooltip drawing based on mouse position
	if ((msX >= 65 + 4 - 127 + SCREENX) && (msX <= 275 + 4 + SCREENX) && (msY >= 65 + 45 + SCREENY) && (msY <= 82 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER1);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 111 + 45 + SCREENY) && (msY <= 124 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER2);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 126 + 45 + SCREENY) && (msY <= 139 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER3);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 141 + 45 + SCREENY) && (msY <= 154 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER4);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 156 + 45 + SCREENY) && (msY <= 169 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER5);
	}
	else if ((msX >= 261 + 4 - 212 + SCREENX) && (msX <= 289 + 4 + SCREENX) && (msY >= 171 + 45 + SCREENY) && (msY <= 184 + 45 + SCREENY)) {
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER6);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 231 + 45 + SCREENY) && (msY <= 244 + 45 + SCREENY)) {
		// Str tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER7);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER8);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER9);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER10);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER11);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 246 + 45 + SCREENY) && (msY <= 259 + 45 + SCREENY)) {
		// Vit tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER12);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER13);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER14);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER15);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER16);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 261 + 45 + SCREENY) && (msY <= 274 + 45 + SCREENY)) {
		// Dex tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER17);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER18);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER19);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER20);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 276 + 45 + SCREENY) && (msY <= 289 + 45 + SCREENY)) {
		// Int tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER21);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER22);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER23);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER24);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 291 + 45 + SCREENY) && (msY <= 304 + 45 + SCREENY)) {
		// Mag tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER25);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER26);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER27);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER28);
	}
	else if ((msX >= 240 + 4 - 175 + SCREENX) && (msX <= 268 + 4 + SCREENX) && (msY >= 306 + 45 + SCREENY) && (msY <= 319 + 45 + SCREENY)) {
		// Charisma tooltip
		i = 0;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER29);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER30);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER31);
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER32);
	}
	else if ((msX >= 384 + SCREENX) && (msX <= 384 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 2;
		if (strlen(s_cNewCharName) <= 0)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER35);
		}
		else if (s_iNewCharPoint > 0)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER36);
		}
		else if (CMisc::bCheckValidName(s_cNewCharName) == false)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER39);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER40);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41);
		}
		else if (_bCheckBadWords(s_cNewCharName) == true)
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER42);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER43);
		}
		else
		{
			i = 0;
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER44);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER45);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER46);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER47);
			PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + 16 * i++ + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48);
		}
	}
	else if ((msX >= 500 + SCREENX) && (msX <= 500 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY))
	{
		m_cCurFocus = 3;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER49);
	}

	if ((msX >= 60 + SCREENX) && (msX <= 60 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 4;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER50);
	}

	if ((msX >= 145 + SCREENX) && (msX <= 145 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 5;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER51);
	}

	if ((msX >= 230 + SCREENX) && (msX <= 230 + 72 + SCREENX) && (msY >= 445 + SCREENY) && (msY <= 445 + 15 + SCREENY)) {
		m_cCurFocus = 6;
		PutAlignedString(370 + SCREENX, 580 + SCREENX, 345 + SCREENY, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER52);
	}
}


void CGame::UpdateScreen_OnSelectCharacter(short sX, short sY, short msX, short msY, bool bIgnoreFocus)
{
	int i;
	int iYear, iMonth, iDay, iHour, iMinute;
	__int64 iTemp1, iTemp2;
	char cTotalChar = 0;
	uint32_t dwTime = GameClock::GetTimeMS();
	sY = 10;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_SELECTCHAR, 0 + SCREENX, 0 + SCREENY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 50);

	iTemp1 = 0;
	iTemp2 = 0;
	iYear = iMonth = iDay = iHour = iMinute = 0;
	for (i = 0; i < 4; i++)
	{
		if ((m_cCurFocus - 1 == i) && (bIgnoreFocus == false))
			m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i * 109 - 7 + SCREENX, 63 - 9 + SCREENY, 62, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i * 109 - 7 + SCREENX, 63 - 9 + SCREENY, 61, dwTime);

		if (m_pCharList[i] != 0)
		{
			cTotalChar++;
			switch (m_pCharList[i]->m_sSex) {
			case 1:	_tmp_sOwnerType = 1; break;
			case 2:	_tmp_sOwnerType = 4; break;
			}
			_tmp_sOwnerType += m_pCharList[i]->m_sSkinCol - 1;
			_tmp_cDir = m_cMenuDir;
			_tmp_sAppr1 = m_pCharList[i]->m_sAppr1;
			_tmp_sAppr2 = m_pCharList[i]->m_sAppr2;
			_tmp_sAppr3 = m_pCharList[i]->m_sAppr3;
			_tmp_sAppr4 = m_pCharList[i]->m_sAppr4;
			_tmp_iApprColor = m_pCharList[i]->m_iApprColor; // v1.4

			std::memset(_tmp_cName, 0, sizeof(_tmp_cName));
			memcpy(_tmp_cName, m_pCharList[i]->m_cName, 10);
			// CLEROTH - NO USE
			_tmp_cAction = DEF_OBJECTMOVE;
			_tmp_cFrame = m_cMenuFrame;

			if (m_pCharList[i]->m_sSex != 0)
			{
				if (CMisc::bCheckValidString(m_pCharList[i]->m_cName) == true)
				{
					m_pEffectSpr[0]->PutTransSprite(sX + 157 + i * 109 + SCREENX, sY + 138 + SCREENY, 1, dwTime);
					DrawObject_OnMove_ForMenu(0, 0, sX + 157 + i * 109 + SCREENX, sY + 138 + SCREENY, false, dwTime, 0, 0);
					PutString(sX + 112 + i * 109 + SCREENX, sY + 179 - 9 + SCREENY, m_pCharList[i]->m_cName, RGB(51, 0, 51));//25,35,25);
					int	_sLevel = m_pCharList[i]->m_sLevel;
					wsprintf(G_cTxt, "%d", _sLevel);
					PutString(sX + 138 + i * 109 + SCREENX, sY + 196 - 10 + SCREENY, G_cTxt, RGB(51, 0, 51)); //25,35,25);

					DisplayCommaNumber_G_cTxt(m_pCharList[i]->m_iExp);
					PutString(sX + 138 + i * 109 + SCREENX, sY + 211 - 10 + SCREENY, G_cTxt, RGB(51, 0, 51)); //25,35,25);
				}
				iTemp2 = m_pCharList[i]->m_iYear * 1000000 + m_pCharList[i]->m_iMonth * 60000 + m_pCharList[i]->m_iDay * 1700 + m_pCharList[i]->m_iHour * 70 + m_pCharList[i]->m_iMinute;
				if (iTemp1 < iTemp2)
				{
					iYear = m_pCharList[i]->m_iYear;
					iMonth = m_pCharList[i]->m_iMonth;
					iDay = m_pCharList[i]->m_iDay;
					iHour = m_pCharList[i]->m_iHour;
					iMinute = m_pCharList[i]->m_iMinute;
					iTemp1 = iTemp2;
				}
			}
		}
	}
	i = 0;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 51);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 52);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 53);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 54);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 55);

	if ((msX > 360 + SCREENX) && (msY >= 283 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 315 + SCREENY)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 56);
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER1);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER2);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER3);//"
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER4);//"
	}
	else
		if ((msX > 360 + SCREENX) && (msY >= 316 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 345 + SCREENY)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 57);
			PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER5);//"

		}
		else
			if ((msX > 360 + SCREENX) && (msY >= 346 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 375 + SCREENY)) {

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 58);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER6);//"
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER7);//"

			}
			else if ((msX > 360 + SCREENX) && (msY >= 376 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 405 + SCREENY))
			{
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 59);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER12);//"
			}
			else if ((msX > 360 + SCREENX) && (msY >= 406 + SCREENY) && (msX < 545 + SCREENX) & (msY <= 435 + SCREENY)) {
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0 + SCREENX, 0 + SCREENY, 60);
				PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"
			}
			else
			{
				if (cTotalChar == 0)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER14);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER15);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER16);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER17);//"New Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER18);//"
				}
				else if (cTotalChar < 4)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 275 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER19);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER20);//"Play�
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER21);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER22);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER23);//"Delete Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 350 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER24);//"
				}
				if (cTotalChar == 4)
				{
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 290 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER25);//"
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 305 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER26);//"Play
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 320 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER27);//"Delete Character
					PutAlignedString(98 + SCREENX, 357 + SCREENX, 335 + 15 + SCREENY, UPDATE_SCREEN_ON_SELECT_CHARACTER28);//"
				}
			}
	int iTempMon, iTempDay, iTempHour, iTempMin;
	iTempMon = iTempDay = iTempHour = iTempMin = 0;

	if (m_iAccntYear != 0)
	{
		iTempMin = (m_iTimeLeftSecAccount / 60);
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
	}
	else
	{
		if (m_iTimeLeftSecAccount > 0)
		{
			iTempDay = (m_iTimeLeftSecAccount / (60 * 60 * 24));
			iTempHour = (m_iTimeLeftSecAccount / (60 * 60)) % 24;
			iTempMin = (m_iTimeLeftSecAccount / 60) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER39);
	}
	PutAlignedString(98 + SCREENX, 357 + SCREENX, 385 + 10 + SCREENY, G_cTxt);

	if (m_iIpYear != 0)
	{
		iTempHour = (m_iTimeLeftSecIP / (60 * 60));
		iTempMin = (m_iTimeLeftSecIP / 60) % 60;
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER40, m_iIpYear, m_iIpMonth, m_iIpDay, iTempHour, iTempMin);
	}
	else
	{
		if (m_iTimeLeftSecIP > 0)
		{
			iTempDay = (m_iTimeLeftSecIP / (60 * 60 * 24));
			iTempHour = (m_iTimeLeftSecIP / (60 * 60)) % 24;
			iTempMin = (m_iTimeLeftSecIP / 60) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER41, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER42);
	}
	PutAlignedString(98 + SCREENX, 357 + SCREENX, 400 + 10 + SCREENY, G_cTxt);
	if (iYear != 0)
	{
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER43, iYear, iMonth, iDay, iHour, iMinute);
		PutAlignedString(98 + SCREENX, 357 + SCREENX, 415 + 10 + SCREENY, G_cTxt);
	}

#ifdef _DEBUG
	PutAlignedString(122, 315, 456, UPDATE_SCREEN_ON_SELECT_CHARACTER36);//"Test Server"
#else
	if (strcmp(m_cWorldServerName, NAME_WORLDNAME1) == 0)
		PutAlignedString(129 + SCREENX, 321 + SCREENX, 456 + SCREENY, MSG_WORLDNAME1);//"ABADDON Server"
	else if (strcmp(m_cWorldServerName, "WS2") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME2);//"APOCALYPSE Server"
	else if (strcmp(m_cWorldServerName, "WS3") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME3);//"3rd Server"
	else if (strcmp(m_cWorldServerName, "WS4") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME4);//"4th Server"
	else if (strcmp(m_cWorldServerName, "WS5") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME5);//"5th Server"
	else if (strcmp(m_cWorldServerName, "WS6") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME6);//"6th Server"
	else if (strcmp(m_cWorldServerName, "WS7") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME7);//"7th Server"
	else if (strcmp(m_cWorldServerName, "WS8") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME8);//"8th Server"
	else if (strcmp(m_cWorldServerName, "WS9") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME9);//"9th Server"
	else if (strcmp(m_cWorldServerName, "WS10") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME10);//"10th Server"
	else if (strcmp(m_cWorldServerName, "WS11") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME11);//"11th Server"
	else if (strcmp(m_cWorldServerName, "WS12") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME12);//"12th Server"
	else if (strcmp(m_cWorldServerName, "WS13") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME13);//"13th Server"
	else if (strcmp(m_cWorldServerName, "WS14") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME14);//"14th Server"
	else if (strcmp(m_cWorldServerName, "WS15") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME15);//"15th Server"
	else if (strcmp(m_cWorldServerName, "WS16") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME16);//"16th Server"
#endif



}



void CGame::NotifyMsgHandler(char* pData)
{
	DWORD* dwp, dwTime, dwTemp;
	WORD* wp, wEventType, wType, wValue, wCount;
	char* cp, cTemp[510], cTxt[120], cName[21], cDesc[11];
	short* sp, sX, sY, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9;
	int* ip, i, iV1, iV2, iV3, iV4, iType, iValue;

	dwTime = GameClock::GetTimeMS();

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wEventType = header->msg_type;

	switch (wEventType) {
	case DEF_NOTIFY_SLATE_BERSERK:		// reversed by Snoopy: 0x0BED
		AddEventList(DEF_MSG_NOTIFY_SLATE_BERSERK, 10);//"Berserk magic casted!"
		m_bUsingSlate = true;
		break;

	case DEF_NOTIFY_LOTERY_LOST:		// reversed by Snoopy: 0x0BEE:
		AddEventList(DEF_MSG_NOTIFY_LOTERY_LOST, 10);//"You draw a blank. Please try again next time.."
		break;

	case DEF_NOTIFY_0BEF:				// 0x0BEF: // Snoopy: Crash or closes the client? (Calls SE entry !)
		// I'm noot sure at all of this function's result, so let's quit game...

		break;

	case DEF_NOTIFY_CRAFTING_SUCCESS:	//reversed by Snoopy: 0x0BF0:
		m_iContribution -= m_iContributionPrice;
		m_iContributionPrice = 0;
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Noticement);
		AddEventList(NOTIFY_MSG_HANDLER42, 10);		// "Item manufacture success!"
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
		m_iContributionPrice = 0;
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCraftingFail>(
				pData, sizeof(hb::net::PacketNotifyCraftingFail));
			if (!pkt) return;
			iV1 = pkt->reason; // Error reason
		}
		switch (iV1) {
		case 1:
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_NO_PART, 10);		// "There is not enough material"
			PlaySound('E', 24, 5);
			break;
		case 2:
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_NO_CONTRIB, 10);	// "There is not enough Contribution Point"
			PlaySound('E', 24, 5);
			break;
		default:
		case 3:
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_FAILED, 10);		// "Crafting failed"
			PlaySound('E', 24, 5);
			break;
		}
		break;

	case DEF_NOTIFY_ANGELIC_STATS:		// reversed by Snoopy: 0x0BF2
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyAngelicStats>(
			pData, sizeof(hb::net::PacketNotifyAngelicStats));
		if (!pkt) return;
		m_iAngelicStr = pkt->str;
		m_iAngelicInt = pkt->intel;
		m_iAngelicDex = pkt->dex;
		m_iAngelicMag = pkt->mag;
	}
	break;

	case DEF_NOTIFY_CURLIFESPAN:
		NotifyMsg_CurLifeSpan(pData);
		break;

	case DEF_NOTIFY_ANGEL_FAILED:		// reversed by Snoopy: 0x0BF4
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyAngelFailed>(
			pData, sizeof(hb::net::PacketNotifyAngelFailed));
		if (!pkt) return;
		iV1 = pkt->reason;
	}
	switch (iV1) {
	case 1: // "BFB9BBF3C4A120BECAC0BA20B9F6B1D7C0D4B4CFB4D92E20A4D02E2EA4D0" (Stolen bytes ?)
		AddEventList(DEF_MSG_NOTIFY_ANGEL_FAILED, 10); //"Impossible to get a Tutelary Angel." // Invented by Snoopy.
		break;
	case 2: //
		AddEventList(DEF_MSG_NOTIFY_ANGEL_MAJESTIC, 10);//"You need additional Majesty Points."
		break;
	case 3: //
		AddEventList(DEF_MSG_NOTIFY_ANGEL_LOW_LVL, 10); //"Only Majesty characters can receive Tutelary Angel"
		break;
	}
	break;

	case DEF_NOTIFY_ANGEL_RECEIVED:		// reversed by Snoopy: 0x0BF5:
		AddEventList(DEF_MSG_NOTIFY_ANGEL_RECEIVED, 10);// "You have received the Tutelary Angel."
		break;

	case DEF_NOTIFY_SPELL_SKILL:		// reversed by Snoopy: 0x0BF6
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySpellSkill>(
			pData, sizeof(hb::net::PacketNotifySpellSkill));
		if (!pkt) return;
		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			m_cMagicMastery[i] = pkt->magic_mastery[i];
		}
		for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
			m_cSkillMastery[i] = pkt->skill_mastery[i];
			if (m_pSkillCfgList[i] != 0)
				m_pSkillCfgList[i]->m_iLevel = pkt->skill_mastery[i];
		}
	}
	break;

	case DEF_NOTIFY_NORECALL: // Snoopy 0x0BD1
		AddEventList("You can not recall in this map.", 10);
		break;

	case DEF_NOTIFY_APOCGATESTARTMSG: // Snoopy 0x0BD2
		SetTopMsg("The portal to the Apocalypse is opened.", 10);
		break;

	case DEF_NOTIFY_APOCGATEENDMSG: // Snoopy 0x0BD3
		SetTopMsg("The portal to the Apocalypse is closed.", 10);
		break;

	case DEF_NOTIFY_APOCGATEOPEN: // Snoopy ;  Case BD4 of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyApocGateOpen>(
			pData, sizeof(hb::net::PacketNotifyApocGateOpen));
		if (!pkt) return;
		m_iGatePositX = pkt->gate_x;
		m_iGatePositY = pkt->gate_y;
		std::memset(m_cGateMapName, 0, sizeof(m_cGateMapName));
		memcpy(m_cGateMapName, pkt->map_name, sizeof(pkt->map_name));
	}
	break;

	case DEF_NOTIFY_QUESTCOUNTER: // Snoopy;  Case BE2 of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQuestCounter>(
			pData, sizeof(hb::net::PacketNotifyQuestCounter));
		if (!pkt) return;
		m_stQuest.sCurrentCount = static_cast<short>(pkt->current_count);
	}
	break;

	case DEF_NOTIFY_MONSTERCOUNT: // Snoopy ;  Case BE3 of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMonsterCount>(
			pData, sizeof(hb::net::PacketNotifyMonsterCount));
		if (!pkt) return;
		sV1 = pkt->count;
	}
	wsprintf(cTxt, "Rest Monster :%d", sV1);
	AddEventList(cTxt, 10);
	break;

	case DEF_NOTIFY_APOCGATECLOSE: // Snoopy ;  Case BD5 of switch 00454077
		m_iGatePositX = m_iGatePositY = -1;
		std::memset(m_cGateMapName, 0, sizeof(m_cGateMapName));
		break;

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS: // Snoopy ;  Case BD7 of switch 00454077
		AddEventList("You are recalled by force, because the Apocalypse is started.", 10);
		break;

	case DEF_NOTIFY_ABADDONKILLED: // Snoopy ;  Case BD6 of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyAbaddonKilled>(
			pData, sizeof(hb::net::PacketNotifyAbaddonKilled));
		if (!pkt) return;
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->killer_name, sizeof(pkt->killer_name));
	}
	wsprintf(G_cTxt, "Abaddon is destroyed by %s", cTxt);
	AddEventList(G_cTxt, 10);
	break;

	//case DEF_NOTIFY_0BE5: // Snoopy Abaddon's related? Thunder?;  Case BE5 of switch 00454077
	//	/*00454255  |> B8 01000000    MOV EAX,1         ;  Case BE5 of switch 00454077
	//	0045425A  |. 5F             POP EDI
	//	0045425B  |. 8985 D8380700  MOV DWORD PTR SS:[EBP+738D8],EAX
	//	00454261  |. 8985 DC380700  MOV DWORD PTR SS:[EBP+738DC],EAX
	//	00454267  |. 8B85 88250700  MOV EAX,DWORD PTR SS:[EBP+72588]
	//	0045426D  |. 5E             POP ESI
	//	0045426E  |. 8985 E0380700  MOV DWORD PTR SS:[EBP+738E0],EAX
	//	00454274  |. 5D             POP EBP
	//	00454275  |. 5B             POP EBX
	//	00454276  |. 81C4 10080000  ADD ESP,810
	//	0045427C  |. C2 0400        RETN 4*/

	//	break;

	case DEF_NOTIFY_RESURRECTPLAYER: // Case BE9 of switch 00454077
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Resurrect, 0, 0, 0);
		break;

	case DEF_NOTIFY_HELDENIANTELEPORT: //;  Case BE6 of switch 00454077
		SetTopMsg("Teleport to Heldenian field is available from now. Magic casting is forbidden until real battle.", 10);
		break;

	case DEF_NOTIFY_HELDENIANEND: //    ;  Case BE7 of switch 00454077
		SetTopMsg("Heldenian holy war has been closed.", 10);
		break;

	case DEF_NOTIFY_0BE8: // ;  Case BE8 of switch 00454077
		SetTopMsg("Characters will be recalled by force as Heldenian begins.", 10);
		break;

	case DEF_NOTIFY_HELDENIANSTART: //  Case BEA of switch 00454077
		SetTopMsg("Heldenian real battle has been started form now on.", 10);
		break;

	case DEF_NOTIFY_HELDENIANVICTORY: // Case BEB of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyHeldenianVictory>(
			pData, sizeof(hb::net::PacketNotifyHeldenianVictory));
		if (!pkt) return;
		sV1 = pkt->side;
	}
	ShowHeldenianVictory(sV1);
	m_iHeldenianAresdenLeftTower = -1;
	m_iHeldenianElvineLeftTower = -1;
	m_iHeldenianAresdenFlags = -1;
	m_iHeldenianElvineFlags = -1;
	break;

	case DEF_NOTIFY_HELDENIANCOUNT: // Case BEC of switch 00454077
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyHeldenianCount>(
			pData, sizeof(hb::net::PacketNotifyHeldenianCount));
		if (!pkt) return;
		m_iHeldenianAresdenLeftTower = pkt->aresden_tower_left;
		m_iHeldenianElvineLeftTower = pkt->elvine_tower_left;
		m_iHeldenianAresdenFlags = pkt->aresden_flags;
		m_iHeldenianElvineFlags = pkt->elvine_flags;
	}
	break;

	// Slates - Diuuude
	case DEF_NOTIFY_SLATE_CREATESUCCESS:	// 0x0BC1
		AddEventList(DEF_MSG_NOTIFY_SLATE_CREATESUCCESS, 10);
		break;
	case DEF_NOTIFY_SLATE_CREATEFAIL:		// 0x0BC2
		AddEventList(DEF_MSG_NOTIFY_SLATE_CREATEFAIL, 10);
		break;
	case DEF_NOTIFY_SLATE_INVINCIBLE:		// 0x0BD8
		AddEventList(DEF_MSG_NOTIFY_SLATE_INVINCIBLE, 10);
		m_bUsingSlate = true;
		break;
	case DEF_NOTIFY_SLATE_MANA:				// 0x0BD9
		AddEventList(DEF_MSG_NOTIFY_SLATE_MANA, 10);
		m_bUsingSlate = true;
		break;
	case DEF_NOTIFY_SLATE_EXP:				// 0x0BE0
		AddEventList(DEF_MSG_NOTIFY_SLATE_EXP, 10);
		m_bUsingSlate = true;
		break;
	case DEF_NOTIFY_SLATE_STATUS:			// 0x0BE1
		AddEventList(DEF_MSG_NOTIFY_SLATECLEAR, 10); // "The effect of the prophecy-slate is disappeared."
		m_bUsingSlate = false;
		break;

		// MJ Stats Change - Diuuude: Erreur, ici il s'agit de sorts et skills, le serveur comme la v351 sont aussi bugu�s !
	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 0x0BB5
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyStateChangeSuccess>(
			pData, sizeof(hb::net::PacketNotifyStateChangeSuccess));
		if (!pkt) return;
		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			m_cMagicMastery[i] = pkt->magic_mastery[i];
		}
		for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
			m_cSkillMastery[i] = pkt->skill_mastery[i];
			if (m_pSkillCfgList[i] != 0)
				m_pSkillCfgList[i]->m_iLevel = pkt->skill_mastery[i];
		}
	}
	// MJ Stats Change - Diuuude
	m_iStr += m_cLU_Str;
	m_iVit += m_cLU_Vit;
	m_iDex += m_cLU_Dex;
	m_iInt += m_cLU_Int;
	m_iMag += m_cLU_Mag;
	m_iCharisma += m_cLU_Char;
	m_iLU_Point = m_iLevel * 3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
	AddEventList("Your stat has been changed.", 10); // "Your stat has been changed."
	break;

	case DEF_NOTIFY_LEVELUP: // 0x0B16
		NotifyMsg_LevelUp(pData);
		break;

	case DEF_NOTIFY_STATECHANGE_FAILED:		// 0x0BB6
		m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		m_iLU_Point = m_iLevel * 3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
		AddEventList("Your stat has not been changed.", 10);
		break;

	case DEF_NOTIFY_SETTING_FAILED: // 0x0BB4 -  Case BB4 of switch 00454077
		AddEventList("Your stat has not been changed.", 10);
		m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		m_iLU_Point = m_iLevel * 3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
		break;

		// CLEROTH - LU
	case DEF_NOTIFY_SETTING_SUCCESS: // 0x0BB3 - envoie le niv et les stats
		NotifyMsg_SettingSuccess(pData);
		break;

	case DEF_NOTIFY_AGRICULTURENOAREA:		// 0x0BB2
		AddEventList(DEF_MSG_NOTIFY_AGRICULTURENOAREA, 10);
		break;
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:	// 0x0BB1
		AddEventList(DEF_MSG_NOTIFY_AGRICULTURESKILLLIMIT, 10);
		break;

	case DEF_NOTIFY_NOMOREAGRICULTURE:		// 0x0BB0
		AddEventList(DEF_MSG_NOTIFY_NOMOREAGRICULTURE, 10);
		break;
	case DEF_NOTIFY_SPAWNEVENT:				// 0x0BAA
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySpawnEvent>(
			pData, sizeof(hb::net::PacketNotifySpawnEvent));
		if (!pkt) return;
		m_sMonsterID = pkt->monster_id;
		m_sEventX = pkt->x;
		m_sEventY = pkt->y;
	}
	m_dwMonsterEventTime = dwTime;
	break;

	case DEF_NOTIFY_CHANGEPLAYMODE:			// 0x0BA9
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyChangePlayMode>(
			pData, sizeof(hb::net::PacketNotifyChangePlayMode));
		if (!pkt) return;
		memcpy(m_cLocation, pkt->location, sizeof(pkt->location));
	}
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = true;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = false;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = false;
		m_bCitizen = true;
		m_bHunter = true;
	}
	else
	{
		m_bAresden = true;
		m_bCitizen = false;
		m_bHunter = true;
	}
	AddEventList(DEF_MSG_GAMEMODE_CHANGED, 10);
	break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:	 //   0x0BA6
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyReqGuildNameAnswer>(
			pData, sizeof(hb::net::PacketNotifyReqGuildNameAnswer));
		if (!pkt) return;
		sV1 = pkt->guild_rank;
		sV2 = pkt->index;
		std::memset(cTemp, 0, sizeof(cTemp));
		memcpy(cTemp, pkt->guild_name, sizeof(pkt->guild_name));
	}

	std::memset(m_stGuildName[sV2].cGuildName, 0, sizeof(m_stGuildName[sV2].cGuildName));
	strcpy(m_stGuildName[sV2].cGuildName, cTemp);
	m_stGuildName[sV2].iGuildRank = sV1;
	for (i = 0; i < 20; i++) if (m_stGuildName[sV2].cGuildName[i] == '_') m_stGuildName[sV2].cGuildName[i] = ' ';
	break;

	case DEF_NOTIFY_FORCERECALLTIME: // 0x0BA7
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyForceRecallTime>(
			pData, sizeof(hb::net::PacketNotifyForceRecallTime));
		if (!pkt) return;
		sV1 = pkt->seconds_left;
	}
	if ((int)(sV1 / 20) > 0)
		wsprintf(G_cTxt, NOTIFY_MSG_FORCERECALLTIME1, (int)(sV1 / 20));
	else
		wsprintf(G_cTxt, NOTIFY_MSG_FORCERECALLTIME2);
	AddEventList(G_cTxt, 10);
	break;

	case DEF_NOTIFY_GIZONITEMUPGRADELEFT: // 0x0BA4// Item upgrade is possible.
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGizonItemUpgradeLeft>(
			pData, sizeof(hb::net::PacketNotifyGizonItemUpgradeLeft));
		if (!pkt) return;
		m_iGizonItemUpgradeLeft = pkt->left;
		switch (pkt->reason) {
		case 1: //
			AddEventList(NOTIFY_MSG_HANDLER_GIZONITEMUPGRADELEFT1, 10);
			break;
		}
	}
	//wsprintf(G_cTxt,"majesty: %d", m_iGizonItemUpgradeLeft);
	//DebugLog(G_cTxt);
	break;

	case DEF_NOTIFY_GIZONEITEMCHANGE: // 0x0BA5
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGizonItemChange>(
			pData, sizeof(hb::net::PacketNotifyGizonItemChange));
		if (!pkt) return;
		sV1 = pkt->item_index;
		m_pItemList[sV1]->m_cItemType = pkt->item_type;
		m_pItemList[sV1]->m_wCurLifeSpan = pkt->cur_lifespan;
		m_pItemList[sV1]->m_sSprite = pkt->sprite;
		m_pItemList[sV1]->m_sSpriteFrame = pkt->sprite_frame;
		m_pItemList[sV1]->m_cItemColor = pkt->item_color;
		m_pItemList[sV1]->m_sItemSpecEffectValue2 = pkt->spec_value2;
		m_pItemList[sV1]->m_dwAttribute = pkt->attribute;
		std::memset(m_pItemList[sV1]->m_cName, 0, sizeof(m_pItemList[sV1]->m_cName));
		memcpy(m_pItemList[sV1]->m_cName, pkt->item_name, sizeof(pkt->item_name));
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == true)
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 3; // succes
	}
	PlaySound('E', 23, 5);
	switch (m_sPlayerType) {
	case 1:
	case 2:
	case 3:
		PlaySound('C', 21, 0);
		break;

	case 4:
	case 5:
	case 6:
		PlaySound('C', 22, 0);
		break;
	}
	break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE: // 0x0BA3
	case 0x0BC0: // 0x0BC0 Unknown msg, but real in client v3.51
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemAttributeChange>(
			pData, sizeof(hb::net::PacketNotifyItemAttributeChange));
		if (!pkt) return;
		sV1 = pkt->item_index;
		dwTemp = m_pItemList[sV1]->m_dwAttribute;
		m_pItemList[sV1]->m_dwAttribute = pkt->attribute;
		if (pkt->spec_value1 != 0)
			m_pItemList[sV1]->m_sItemSpecEffectValue1 = static_cast<short>(pkt->spec_value1);
		if (pkt->spec_value2 != 0)
			m_pItemList[sV1]->m_sItemSpecEffectValue2 = static_cast<short>(pkt->spec_value2);
	}
	if (dwTemp == m_pItemList[sV1]->m_dwAttribute)
	{
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == true)
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 4;// Failed
		}
		PlaySound('E', 24, 5);
	}
	else
	{
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == true)
		{
			m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 3; // Success
		}
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
	}
	break;

	case DEF_NOTIFY_ITEMUPGRADEFAIL:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemUpgradeFail>(
			pData, sizeof(hb::net::PacketNotifyItemUpgradeFail));
		if (!pkt) return;
		sV1 = pkt->reason;
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade) == false) return;
	PlaySound('E', 24, 5);
	switch (sV1) {
	case 1:
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 8; // Failed
		break;
	case 2:
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 9; // Failed
		break;
	case 3:
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode = 10; // Failed
		break;
	}
	break;

	case DEF_NOTIFY_PARTY:
	{
		const auto* basic = hb::net::PacketCast<hb::net::PacketNotifyPartyBasic>(
			pData, sizeof(hb::net::PacketNotifyPartyBasic));
		if (!basic) return;
		sV1 = basic->type;
		sV2 = basic->v2;
		sV3 = basic->v3;
		sV4 = basic->v4;
	}
	switch (sV1) {
	case 1: //
		switch (sV2) {
		case 0:
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 9;
			break;

		case 1:
			m_iPartyStatus = 1;
			m_iTotalPartyMember = 0;
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 8;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, 0, 2, 0, 0, m_cMCName);
			break;
		}
		break;

	case 2: //
		m_iPartyStatus = 0;
		m_iTotalPartyMember = 0;
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 10;
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
		break;

	case 4:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPartyName>(
			pData, sizeof(hb::net::PacketNotifyPartyName));
		if (!pkt) return;
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->name, sizeof(pkt->name));
	}

	switch (sV2) {
	case 0: //
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 9;
		break;

	case 1: //
		if (strcmp(cTxt, m_cPlayerName) == 0) {
			m_iPartyStatus = 2;
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 8;
		}
		else {
			wsprintf(G_cTxt, NOTIFY_MSG_HANDLER1, cTxt);
			AddEventList(G_cTxt, 10);
		}

		m_iTotalPartyMember++;
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (strlen(m_stPartyMemberNameList[i].cName) == 0) {
				std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
				memcpy(m_stPartyMemberNameList[i].cName, cTxt, 10);
				goto NMH_LOOPBREAK1;
			}
	NMH_LOOPBREAK1:;
		break;

	case 2: //
		break;
	}
	break;

	case 5: //
		m_iTotalPartyMember = 0;
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));

		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPartyList>(
				pData, sizeof(hb::net::PacketNotifyPartyList));
			if (!pkt) return;
			const char* names = pkt->names;
			m_iTotalPartyMember = pkt->count;
			for (i = 1; i <= pkt->count; i++) {
				std::memset(m_stPartyMemberNameList[i - 1].cName, 0, sizeof(m_stPartyMemberNameList[i - 1].cName));
				memcpy(m_stPartyMemberNameList[i - 1].cName, names, 10);
				names += 11;
			}
		}
		break;

	default:
		break;

	case 6:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPartyName>(
			pData, sizeof(hb::net::PacketNotifyPartyName));
		if (!pkt) return;
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->name, sizeof(pkt->name));
	}

	switch (sV2) {
	case 0: //
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 7;
		break;

	case 1: //
		if (strcmp(cTxt, m_cPlayerName) == 0) {
			m_iPartyStatus = 0;
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 6;
		}
		else {
			wsprintf(G_cTxt, NOTIFY_MSG_HANDLER2, cTxt);
			AddEventList(G_cTxt, 10);
		}
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (strcmp(m_stPartyMemberNameList[i].cName, cTxt) == 0) {
				std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
				m_iTotalPartyMember--;
				goto NMH_LOOPBREAK2;
			}
	NMH_LOOPBREAK2:;
		break;
	}
	break;

	case 7: //
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 9;
		break;

	case 8: //
		m_iPartyStatus = 0;
		m_iTotalPartyMember = 0;
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) std::memset(m_stPartyMemberNameList[i].cName, 0, sizeof(m_stPartyMemberNameList[i].cName));
		break;
	}
	break;

	case DEF_NOTIFY_CANNOTCONSTRUCT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotConstruct>(
			pData, sizeof(hb::net::PacketNotifyCannotConstruct));
		if (!pkt) return;
		sV1 = pkt->reason;
	}

	CannotConstruct(sV1);
	PlaySound('E', 25, 0, 0);
	break;

	case DEF_NOTIFY_TCLOC:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyTCLoc>(
			pData, sizeof(hb::net::PacketNotifyTCLoc));
		if (!pkt) return;
		m_iTeleportLocX = pkt->dest_x;
		m_iTeleportLocY = pkt->dest_y;
		std::memset(m_cTeleportMapName, 0, sizeof(m_cTeleportMapName));
		memcpy(m_cTeleportMapName, pkt->teleport_map, sizeof(pkt->teleport_map));
		m_iConstructLocX = pkt->construct_x;
		m_iConstructLocY = pkt->construct_y;
		std::memset(m_cConstructMapName, 0, sizeof(m_cConstructMapName));
		memcpy(m_cConstructMapName, pkt->construct_map, sizeof(pkt->construct_map));
	}
	break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyConstructionPoint>(
			pData, sizeof(hb::net::PacketNotifyConstructionPoint));
		if (!pkt) return;
		sV1 = pkt->construction_point;
		sV2 = pkt->war_contribution;
		sV3 = pkt->notify_type;
	}

	if (sV3 == 0) {
		if ((sV1 > m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
			wsprintf(G_cTxt, "%s +%d, %s +%d", m_pGameMsgList[13]->m_pMsg, (sV1 - m_iConstructionPoint), m_pGameMsgList[21]->m_pMsg, (sV2 - m_iWarContribution));
			SetTopMsg(G_cTxt, 5);
			PlaySound('E', 23, 0, 0);
		}

		if ((sV1 > m_iConstructionPoint) && (sV2 == m_iWarContribution)) {
			if (m_iCrusadeDuty == 3) {
				wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[13]->m_pMsg, sV1 - m_iConstructionPoint);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 23, 0, 0);
			}
		}

		if ((sV1 == m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
			wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[21]->m_pMsg, sV2 - m_iWarContribution);
			SetTopMsg(G_cTxt, 5);
			PlaySound('E', 23, 0, 0);
		}

		if (sV1 < m_iConstructionPoint) {
			if (m_iCrusadeDuty == 3) {
				wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[13]->m_pMsg, m_iConstructionPoint - sV1);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 25, 0, 0);
			}
		}

		if (sV2 < m_iWarContribution) {
			wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[21]->m_pMsg, m_iWarContribution - sV2);
			SetTopMsg(G_cTxt, 5);
			PlaySound('E', 24, 0, 0);
		}
	}

	m_iConstructionPoint = sV1;
	m_iWarContribution = sV2;
	break;

	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
		SetTopMsg(m_pGameMsgList[12]->m_pMsg, 5);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_GRANDMAGICRESULT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGrandMagicResult>(
			pData, sizeof(hb::net::PacketNotifyGrandMagicResult));
		if (!pkt) return;
		sV1 = pkt->crashed_structures;
		sV2 = pkt->structure_damage;
		sV3 = pkt->casualities;
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->map_name, sizeof(pkt->map_name));
		sV4 = pkt->active_structure;
		sV5 = pkt->value_count;
		sV6 = sV7 = sV8 = sV9 = 0;
		if (sV5 > 0) sV6 = pkt->values[0];
		if (sV5 > 1) sV7 = pkt->values[1];
		if (sV5 > 2) sV8 = pkt->values[2];
		if (sV5 > 3) sV9 = pkt->values[3];
	}

	GrandMagicResult(cTxt, sV1, sV2, sV3, sV4, sV6, sV7, sV8, sV9);
	break;

	case DEF_NOTIFY_METEORSTRIKECOMING:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMeteorStrikeComing>(
			pData, sizeof(hb::net::PacketNotifyMeteorStrikeComing));
		if (!pkt) return;
		sV1 = pkt->phase;
	}
	MeteorStrikeComing(sV1);
	PlaySound('E', 25, 0, 0);
	break;

	case DEF_NOTIFY_METEORSTRIKEHIT:
		SetTopMsg(m_pGameMsgList[17]->m_pMsg, 5);
		//StartMeteorStrikeEffect
		for (i = 0; i < 36; i++) bAddNewEffect(60, m_sViewPointX + (rand() % LOGICAL_MAX_X), m_sViewPointY + (rand() % LOGICAL_MAX_Y), 0, 0, -(rand() % 80));
		break;

	case DEF_NOTIFY_MAPSTATUSNEXT:
		AddMapStatusInfo(pData, false);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		AddMapStatusInfo(pData, true);
		break;

	case DEF_NOTIFY_LOCKEDMAP:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyLockedMap>(
			pData, sizeof(hb::net::PacketNotifyLockedMap));
		if (!pkt) return;
		sV1 = pkt->seconds_left;
		std::memset(cTemp, 0, sizeof(cTemp));
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->map_name, sizeof(pkt->map_name));
	}

	GetOfficialMapName(cTxt, cTemp);
	wsprintf(G_cTxt, NOTIFY_MSG_HANDLER3, sV1, cTemp);
	SetTopMsg(G_cTxt, 10);
	PlaySound('E', 25, 0, 0);
	break;

	case DEF_NOTIFY_CRUSADE: // Crusade msg
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCrusade>(
			pData, sizeof(hb::net::PacketNotifyCrusade));
		if (!pkt) return;
		iV1 = pkt->crusade_mode;
		iV2 = pkt->crusade_duty;
		iV3 = pkt->v3;
		iV4 = pkt->v4;
	}
	if (m_bIsCrusadeMode == false)
	{
		if (iV1 != 0) // begin crusade
		{
			m_bIsCrusadeMode = true;
			m_iCrusadeDuty = iV2;
			if ((m_iCrusadeDuty != 3) && (m_bCitizen == true))
				_RequestMapStatus("middleland", 3);
			if (m_iCrusadeDuty != 0)
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::CrusadeJob, 2, iV2, 0);
			else m_dialogBoxManager.EnableDialogBox(DialogBoxId::CrusadeJob, 1, 0, 0);
			if (m_bCitizen == false) m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, LOGICAL_WIDTH, 0, 0);
			else if (m_bAresden == true) m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 801, 0, 0);
			else if (m_bAresden == false) m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 802, 0, 0);
			if (m_bCitizen == false) SetTopMsg(NOTIFY_MSG_CRUSADESTART_NONE, 10);
			else SetTopMsg(m_pGameMsgList[9]->m_pMsg, 10);
			PlaySound('E', 25, 0, 0);
		}
		if (iV3 != 0) // Crusade finished, show XP result screen
		{
			CrusadeContributionResult(iV3);
		}
		if (iV4 == -1) // The crusade you played in was finished.
		{
			CrusadeContributionResult(0); // You connect in this crusade, but did not connect after previous one => no XP....
		}
	}
	else
	{
		if (iV1 == 0) // crusade finished show result (1st result: winner)
		{
			m_bIsCrusadeMode = false;
			m_iCrusadeDuty = 0;
			CrusadeWarResult(iV4);
			SetTopMsg(m_pGameMsgList[57]->m_pMsg, 8);
		}
		else
		{
			if (m_iCrusadeDuty != iV2)
			{
				m_iCrusadeDuty = iV2;
				m_dialogBoxManager.EnableDialogBox(DialogBoxId::CrusadeJob, 2, iV2, 0);
				PlaySound('E', 25, 0, 0);
			}
		}
		if (iV4 == -1)
		{
			CrusadeContributionResult(0); // You connect in this crusade, but did not connect after previous one => no XP....
		}
	}
	break;

	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySpecialAbilityStatus>(
			pData, sizeof(hb::net::PacketNotifySpecialAbilityStatus));
		if (!pkt) return;
		sV1 = pkt->status_type;
		sV2 = pkt->ability_type;
		sV3 = pkt->seconds_left;
	}
	if (sV1 == 1) // Use SA
	{
		PlaySound('E', 35, 0);
		AddEventList(NOTIFY_MSG_HANDLER4, 10); // "Use special ability!"
		switch (sV2) {
		case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER5, sV3); break;//"You are untouchable for %d seconds!"
		case 2: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER6, sV3); break;//"
		case 3: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER7, sV3); break;//"
		case 4: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER8, sV3); break;//"
		case 5: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER9, sV3); break;//"
		case 50:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER10, sV3); break;//"
		case 51:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER11, sV3); break;//"
		case 52:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER12, sV3); break;//"
		case 55: // Spell effect
			if (sV3 > 90)
				wsprintf(G_cTxt, "You cast a powerfull incantation, you can't use it again before %d minutes.", sV3 / 60);
			else
				wsprintf(G_cTxt, "You cast a powerfull incantation, you can't use it again before %d seconds.", sV3);
			break;
		}
		AddEventList(G_cTxt, 10);
	}
	else if (sV1 == 2) // Finished using
	{
		if (m_iSpecialAbilityType != (int)sV2)
		{
			PlaySound('E', 34, 0);
			AddEventList(NOTIFY_MSG_HANDLER13, 10);//"Special ability has been set!"
			if (sV3 >= 60)
			{
				switch (sV2) {
				case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER14, sV3 / 60); AddEventList(G_cTxt, 10); break;//"Ability that decreases enemy's HP by 50%: Can use after %dMin"
				case 2: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER15, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 3: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER16, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 4: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER17, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 5: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER18, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 50:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER19, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 51:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER20, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				case 52:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER21, sV3 / 60); AddEventList(G_cTxt, 10); break;//"
				}
			}
			else
			{
				switch (sV2) {
				case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER22, sV3); AddEventList(G_cTxt, 10); break;//"
				case 2: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER23, sV3); AddEventList(G_cTxt, 10); break;//"
				case 3: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER24, sV3); AddEventList(G_cTxt, 10); break;//"
				case 4: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER25, sV3); AddEventList(G_cTxt, 10); break;//"
				case 5: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER26, sV3); AddEventList(G_cTxt, 10); break;//"
				case 50:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER27, sV3); AddEventList(G_cTxt, 10); break;//"
				case 51:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER28, sV3); AddEventList(G_cTxt, 10); break;//"
				case 52:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER29, sV3); AddEventList(G_cTxt, 10); break;//""Ability that makes character untouchable: Can use after %dSec"
				}
			}
		}
		m_iSpecialAbilityType = (int)sV2;
		m_dwSpecialAbilitySettingTime = dwTime;
		m_iSpecialAbilityTimeLeftSec = (int)sV3;
	}
	else if (sV1 == 3)  // End of using time
	{
		m_bIsSpecialAbilityEnabled = false;
		m_dwSpecialAbilitySettingTime = dwTime;
		if (sV3 == 0)
		{
			m_iSpecialAbilityTimeLeftSec = 1200;
			AddEventList(NOTIFY_MSG_HANDLER30, 10);//"Special ability has run out! Will be available in 20 minutes."
		}
		else
		{
			m_iSpecialAbilityTimeLeftSec = (int)sV3;
			if (sV3 > 90)
				wsprintf(G_cTxt, "Special ability has run out! Will be available in %d minutes.", sV3 / 60);
			else wsprintf(G_cTxt, "Special ability has run out! Will be available in %d seconds.", sV3);
			AddEventList(G_cTxt, 10);
		}
	}
	else if (sV1 == 4) // Unequiped the SA item
	{
		AddEventList(NOTIFY_MSG_HANDLER31, 10);//"Special ability has been released."
		m_iSpecialAbilityType = 0;
	}
	else if (sV1 == 5) // Angel
	{
		PlaySound('E', 52, 0); // Angel
	}
	break;

	case DEF_NOTIFY_SPECIALABILITYENABLED:
		if (m_bIsSpecialAbilityEnabled == false) {
			PlaySound('E', 30, 5);
			AddEventList(NOTIFY_MSG_HANDLER32, 10);//"
		}
		m_bIsSpecialAbilityEnabled = true;
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyEnergySphereGoalIn>(
			pData, sizeof(hb::net::PacketNotifyEnergySphereGoalIn));
		if (!pkt) return;
		sV1 = pkt->result;
		sV2 = pkt->side;
		sV3 = pkt->goal;
		std::memset(cTxt, 0, sizeof(cTxt));
		memcpy(cTxt, pkt->name, sizeof(pkt->name));
	}

	if (sV2 == sV3)
	{
		PlaySound('E', 24, 0);
		if (strcmp(cTxt, m_cPlayerName) == 0)
		{
			AddEventList(NOTIFY_MSG_HANDLER33, 10);//You pushed energy sphere to enemy's energy portal! Contribution point will be decreased by 10 points."
			m_iContribution += sV1; // fixed, server must match...
			m_iContributionPrice = 0;
			if (m_iContribution < 0) m_iContribution = 0;
		}
		else {
			std::memset(G_cTxt, 0, sizeof(G_cTxt));
			if (m_bAresden == true) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34, cTxt);//"%s(Aresden) pushed energy sphere to enemy's portal!!..."
			else if (m_bAresden == false) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34_ELV, cTxt);//"%s(Elvine) pushed energy sphere to enemy's portal!!..."
			AddEventList(G_cTxt, 10);
		}
	}
	else
	{
		PlaySound('E', 23, 0);
		if (strcmp(cTxt, m_cPlayerName) == 0)
		{
			switch (m_sPlayerType) {
			case 1:
			case 2:
			case 3:	PlaySound('C', 21, 0); break;
			case 4:
			case 5:
			case 6:	PlaySound('C', 22, 0); break;
			}
			AddEventList(NOTIFY_MSG_HANDLER35, 10);//"Congulaturations! You brought energy sphere to energy portal and earned experience and prize gold!"

			m_iContribution += 5;
			if (m_iContribution < 0) m_iContribution = 0;
		}
		else
		{
			std::memset(G_cTxt, 0, sizeof(G_cTxt));
			if (sV3 == 1)
			{
				wsprintf(G_cTxt, NOTIFY_MSG_HANDLER36, cTxt);//"Elvine %s : Goal in!"
				AddEventList(G_cTxt, 10);
			}
			else if (sV3 == 2)
			{
				wsprintf(G_cTxt, NOTIFY_MSG_HANDLER37, cTxt);//"Aresden %s : Goal in!"
				AddEventList(G_cTxt, 10);
			}
		}
	}
	break;

	case DEF_NOTIFY_ENERGYSPHERECREATED:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyEnergySphereCreated>(
			pData, sizeof(hb::net::PacketNotifyEnergySphereCreated));
		if (!pkt) return;
		sV1 = pkt->x;
		sV2 = pkt->y;
	}
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	wsprintf(G_cTxt, NOTIFY_MSG_HANDLER38, sV1, sV2);//"Energy sphere was dropped in (%d, %d) of middleland!"
	AddEventList(G_cTxt, 10);
	AddEventList(NOTIFY_MSG_HANDLER39, 10);//"A player who pushed energy sphere to the energy portal of his city will earn many Exp and Contribution."
	break;

	case DEF_NOTIFY_QUERY_JOINPARTY:
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Party, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 1;
		std::memset(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Party).cStr));
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQueryJoinParty>(
				pData, sizeof(hb::net::PacketNotifyQueryJoinParty));
			if (!pkt) return;
			strcpy(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, pkt->name);
		}
		break;

	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyResponseCreateNewParty>(
			pData, sizeof(hb::net::PacketNotifyResponseCreateNewParty));
		if (!pkt) return;
		if ((bool)pkt->result == true)
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 2;
		}
		else
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 3;
		}
	}
	break;

	//50Cent - HP Bar
	case DEF_SEND_NPCHP:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNpcHp>(
			pData, sizeof(hb::net::PacketNotifyNpcHp));
		if (!pkt) return;
		iNpcHP = pkt->hp;
		iNpcMaxHP = pkt->max_hp;
	}
	break;

	case DEF_NOTIFY_DAMAGEMOVE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDamageMove>(
			pData, sizeof(hb::net::PacketNotifyDamageMove));
		if (!pkt) return;
		m_sDamageMove = pkt->dir;
		m_sDamageMoveAmount = pkt->amount;
	}
	break;

	case DEF_NOTIFY_OBSERVERMODE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyObserverMode>(
			pData, sizeof(hb::net::PacketNotifyObserverMode));
		if (!pkt) return;
		if (pkt->enabled == 1)
		{
			AddEventList(NOTIFY_MSG_HANDLER40);//"Observer Mode On. Press 'SHIFT + ESC' to Log Out..."
			m_bIsObserverMode = true;
			m_dwObserverCamTime = GameClock::GetTimeMS();
			char cName[12];
			std::memset(cName, 0, sizeof(cName));
			memcpy(cName, m_cPlayerName, 10);
			m_pMapData->bSetOwner(m_sPlayerObjectID, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, cName, 0, 0, 0, 0);
		}
		else
		{
			AddEventList(NOTIFY_MSG_HANDLER41);//"Observer Mode Off"
			m_bIsObserverMode = false;
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, m_iPlayerStatus, m_cPlayerName, DEF_OBJECTSTOP, 0, 0, 0);
		}
	}
	break;

	case DEF_NOTIFY_BUILDITEMSUCCESS:
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyBuildItemResult>(
				pData, sizeof(hb::net::PacketNotifyBuildItemResult));
			if (!pkt) return;
			sV1 = pkt->item_id;
			sV2 = pkt->item_count;
		}
		if (sV1 < 10000)
		{
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 6, 1, sV1, 0);
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = sV2;
		}
		else
		{
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 6, 1, -1 * (sV1 - 10000), 0);
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = sV2;
		}
		AddEventList(NOTIFY_MSG_HANDLER42, 10);
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_BUILDITEMFAIL:
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 6, 0, 0);
		AddEventList(NOTIFY_MSG_HANDLER43, 10);
		PlaySound('E', 24, 5);
		break;

	case DEF_NOTIFY_QUESTREWARD:
		NotifyMsg_QuestReward(pData);
		break;

	case DEF_NOTIFY_QUESTCOMPLETED:
		m_stQuest.bIsQuestCompleted = true;
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Quest);
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Quest, 1, 0, 0);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:	PlaySound('C', 21, 0); break;
		case 4:
		case 5:
		case 6:	PlaySound('C', 22, 0); break;
		}
		PlaySound('E', 23, 0);
		AddEventList(NOTIFY_MSG_HANDLER44, 10);
		break;

	case DEF_NOTIFY_QUESTABORTED:
		m_stQuest.sQuestType = 0;
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Quest);
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::Quest, 2, 0, 0);
		break;

	case DEF_NOTIFY_QUESTCONTENTS:
		NotifyMsg_QuestContents(pData);
		break;

	case DEF_NOTIFY_ITEMCOLORCHANGE:
		NotifyMsg_ItemColorChange(pData);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		NotifyMsg_DropItemFin_CountChanged(pData);
		break;

	case DEF_NOTIFY_CANNOTGIVEITEM:
		NotifyMsg_CannotGiveItem(pData);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		NotifyMsg_GiveItemFin_CountChanged(pData);
		break;

	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
		AddEventList(NOTIFYMSG_EXCHANGEITEM_COMPLETE1, 10);
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Exchange);
		//Snoopy: MultiTrade
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::ConfirmExchange);
		PlaySound('E', 23, 5);
		break;

	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		PlaySound('E', 24, 5);
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM1, 10);
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM2, 10);
		//Snoopy: MultiTrade
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::ConfirmExchange);
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Exchange);
		break;

	case DEF_NOTIFY_SETEXCHANGEITEM:
		NotifyMsg_SetExchangeItem(pData);
		break;

	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		NotifyMsg_OpenExchageWindow(pData);
		break;

	case DEF_NOTIFY_NOTFLAGSPOT:
		AddEventList(NOTIFY_MSG_HANDLER45, 10);
		break;

	case DEF_NOTIFY_ITEMPOSLIST:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemPosList>(
			pData, sizeof(hb::net::PacketNotifyItemPosList));
		if (!pkt) return;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sX = pkt->positions[i * 2];
			sY = pkt->positions[i * 2 + 1];
			if (m_pItemList[i] != 0) {
				if (sY < -10) sY = -10;
				if (sX < 0)   sX = 0;
				if (sX > 170) sX = 170;
				if (sY > 95)  sY = 95;

				m_pItemList[i]->m_sX = sX;
				m_pItemList[i]->m_sY = sY;
			}
		}
	}
	break;

	case DEF_NOTIFY_ENEMYKILLS:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyEnemyKills>(
			pData, sizeof(hb::net::PacketNotifyEnemyKills));
		if (!pkt) return;
		m_iEnemyKillCount = pkt->count;
	}
	break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
		NotifyMsg_DownSkillIndexSet(pData);
		break;

	case DEF_NOTIFY_ADMINIFO:
		NotifyMsg_AdminInfo(pData);
		break;

	case DEF_NOTIFY_NPCTALK:
		NpcTalkHandler(pData);
		break;

	case DEF_NOTIFY_PORTIONSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER46, 10);
		break;

	case DEF_NOTIFY_PORTIONFAIL:
		AddEventList(NOTIFY_MSG_HANDLER47, 10);
		break;

	case DEF_NOTIFY_LOWPORTIONSKILL:
		AddEventList(NOTIFY_MSG_HANDLER48, 10);
		break;

	case DEF_NOTIFY_NOMATCHINGPORTION:
		AddEventList(NOTIFY_MSG_HANDLER49, 10);
		break;

	case DEF_NOTIFY_SUPERATTACKLEFT:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySuperAttackLeft>(
			pData, sizeof(hb::net::PacketNotifySuperAttackLeft));
		if (!pkt) return;
		m_iSuperAttackLeft = pkt->left;
	}
	break;

	case DEF_NOTIFY_SAFEATTACKMODE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySafeAttackMode>(
			pData, sizeof(hb::net::PacketNotifySafeAttackMode));
		if (!pkt) return;
		switch (pkt->enabled) {
		case 1:
			if (!m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER50, 10);//"
			m_bIsSafeAttackMode = true;
			break;
		case 0:
			if (m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER51, 10);//"
			m_bIsSafeAttackMode = false;
			break;
		}
	}
	break;

	case DEF_NOTIFY_IPACCOUNTINFO:
		std::memset(cTemp, 0, sizeof(cTemp));
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyIpAccountInfo>(
				pData, sizeof(hb::net::PacketNotifyIpAccountInfo));
			if (!pkt) return;
			strcpy(cTemp, pkt->text);
		}
		AddEventList(cTemp);
		break;

	case DEF_NOTIFY_REWARDGOLD:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyRewardGold>(
			pData, sizeof(hb::net::PacketNotifyRewardGold));
		if (!pkt) return;
		m_iRewardGold = pkt->gold;
	}
	break;

	case DEF_NOTIFY_SERVERSHUTDOWN:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyServerShutdown>(
			pData, sizeof(hb::net::PacketNotifyServerShutdown));
		if (!pkt) return;
		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Noticement) == false)
			m_dialogBoxManager.EnableDialogBox(DialogBoxId::Noticement, pkt->mode, 0, 0);
		else m_dialogBoxManager.Info(DialogBoxId::Noticement).cMode = pkt->mode;
	}
	PlaySound('E', 27, 0);
	break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
		NotifyMsg_GlobalAttackMode(pData);
		break;

	case DEF_NOTIFY_WHETHERCHANGE:
		NotifyMsg_WhetherChange(pData);
		break;

	case DEF_NOTIFY_FISHCANCELED:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyFishCanceled>(
			pData, sizeof(hb::net::PacketNotifyFishCanceled));
		if (!pkt) return;
		switch (pkt->reason) {
		case 0:
			AddEventList(NOTIFY_MSG_HANDLER52, 10);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);
			break;

		case 1:
			AddEventList(NOTIFY_MSG_HANDLER53, 10);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);
			break;

		case 2:
			AddEventList(NOTIFY_MSG_HANDLER54, 10);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);
			break;
		}
	}
	break;

	case DEF_NOTIFY_FISHSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER55, 10);
		PlaySound('E', 23, 5);
		PlaySound('E', 17, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_FISHFAIL:
		AddEventList(NOTIFY_MSG_HANDLER56, 10);
		PlaySound('E', 24, 5);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		NotifyMsg_FishChance(pData);
		break;

	case DEF_NOTIFY_EVENTFISHMODE:
		NotifyMsg_EventFishMode(pData);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		NotifyMsg_NoticeMsg(pData);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		NotifyMsg_RatingPlayer(pData);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		NotifyMsg_CannotRating(pData);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		AddEventList(NOTIFY_MSG_HANDLER58, 10);
		break;

	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER59, 10);
		break;
	case DEF_NOTIFY_SUCCESSBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER60, 10);
		break;
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER61, 10);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		NotifyMsg_PlayerShutUp(pData);
		break;

	case DEF_NOTIFY_TIMECHANGE:
		NotifyMsg_TimeChange(pData);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		AddEventList(NOTIFY_MSG_HANDLER62, 10);
		break;

	case DEF_NOTIFY_HUNGER:
		NotifyMsg_Hunger(pData);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		NotifyMsg_PlayerProfile(pData);
		break;

	case DEF_NOTIFY_WHISPERMODEON:
		NotifyMsg_WhisperMode(true, pData);
		break;

	case DEF_NOTIFY_WHISPERMODEOFF:
		NotifyMsg_WhisperMode(false, pData);
		break;

	case DEF_NOTIFY_PLAYERONGAME:
		NotifyMsg_PlayerStatus(true, pData);
		break;

	case DEF_NOTIFY_PLAYERNOTONGAME:
		NotifyMsg_PlayerStatus(false, pData);
		break;

	case DEF_NOTIFY_CHARISMA:
		NotifyMsg_Charisma(pData);
		break;

	case DEF_NOTIFY_ITEMSOLD:
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
		break;

	case DEF_NOTIFY_ITEMREPAIRED:
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
		NotifyMsg_ItemRepaired(pData);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
		NotifyMsg_CannotRepairItem(pData);
		break;

	case DEF_NOTIFY_CANNOTSELLITEM:
		NotifyMsg_CannotSellItem(pData);
		break;

		//50Cent - Repair All
	case DEF_NOTIFY_REPAIRALLPRICES:
		NotifyMsg_RepairAllPrices(pData);
		break;

	case DEF_NOTIFY_REPAIRITEMPRICE:
		NotifyMsg_RepairItemPrice(pData);
		break;

	case DEF_NOTIFY_SELLITEMPRICE:
		NotifyMsg_SellItemPrice(pData);
		break;

	case DEF_NOTIFY_SHOWMAP:
		NotifyMsg_ShowMap(pData);
		break;

	case DEF_NOTIFY_SKILLUSINGEND:
		NotifyMsg_SkillUsingEnd(pData);
		break;

	case DEF_NOTIFY_TOTALUSERS:
		NotifyMsg_TotalUsers(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTOFF:
		NotifyMsg_MagicEffectOff(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTON:
		NotifyMsg_MagicEffectOn(pData);
		break;

	case DEF_NOTIFY_CANNOTITEMTOBANK:
		AddEventList(NOTIFY_MSG_HANDLER63, 10);
		break;

	case DEF_NOTIFY_SERVERCHANGE:
		NotifyMsg_ServerChange(pData);
		break;

	case DEF_NOTIFY_SKILL:
		NotifyMsg_Skill(pData);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		NotifyMsg_SetItemCount(pData);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		NotifyMsg_ItemDepleted_EraseItem(pData);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		NotifyMsg_DropItemFin_EraseItem(pData);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		NotifyMsg_GiveItemFin_EraseItem(pData);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		NotifyMsg_EnemyKillReward(pData);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		NotifyMsg_PKcaptured(pData);
		break;

	case DEF_NOTIFY_PKPENALTY:
		NotifyMsg_PKpenalty(pData);
		break;

	case DEF_NOTIFY_ITEMTOBANK:
		NotifyMsg_ItemToBank(pData);
		break;

	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER64, 10);
		break;

	case DEF_NOTIFY_LIMITEDLEVEL:
		AddEventList(NOTIFYMSG_LIMITED_LEVEL1, 10);
		break;

	case DEF_NOTIFY_ITEMLIFESPANEND:
		NotifyMsg_ItemLifeSpanEnd(pData);
		break;

	case DEF_NOTIFY_ITEMRELEASED:
		NotifyMsg_ItemReleased(pData);
		break;

	case DEF_NOTIFY_ITEMOBTAINED:
		NotifyMsg_ItemObtained(pData);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		NotifyMsg_ItemPurchased(pData);
		break;

	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
		NotifyMsg_QueryJoinGuildPermission(pData);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
		NotifyMsg_QueryDismissGuildPermission(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		NotifyMsg_JoinGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
		NotifyMsg_JoinGuildReject(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		NotifyMsg_DismissGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		NotifyMsg_DismissGuildReject(pData);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		AddEventList(NOTIFY_MSG_HANDLER65, 10);//"
		AddEventList(NOTIFY_MSG_HANDLER66, 10);//"
		// Bank dialog Box
		m_dialogBoxManager.Info(DialogBoxId::Bank).cMode = 0;
		break;

	case DEF_NOTIFY_NOTENOUGHGOLD:
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
		AddEventList(NOTIFY_MSG_HANDLER67, 10);//"Gold
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNotEnoughGold>(
				pData, sizeof(hb::net::PacketNotifyNotEnoughGold));
			if (!pkt) return;
			if (pkt->item_index >= 0) {
				m_bIsItemDisabled[pkt->item_index] = false;
			}
		}
		break;

	case DEF_NOTIFY_HP:
		NotifyMsg_HP(pData);
		break;
	case DEF_NOTIFY_MP:
		NotifyMsg_MP(pData);
		break;
	case DEF_NOTIFY_SP:
		NotifyMsg_SP(pData);
		break;
	case DEF_NOTIFY_KILLED:
		NotifyMsg_Killed(pData);
		break;
	case DEF_NOTIFY_EXP:
		NotifyMsg_Exp(pData);
		break;
	case DEF_NOTIFY_GUILDDISBANDED:
		NotifyMsg_GuildDisbanded(pData);
		break;
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		NotifyMsg_CannotJoinMoreGuildsMan(pData);
		break;
	case DEF_NOTIFY_NEWGUILDSMAN:
		NotifyMsg_NewGuildsMan(pData);
		break;
	case DEF_NOTIFY_DISMISSGUILDSMAN:
		NotifyMsg_DismissGuildsMan(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYSUCCESS:
		NotifyMsg_MagicStudySuccess(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYFAIL:
		NotifyMsg_MagicStudyFail(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINSUCCESS:
		NotifyMsg_SkillTrainSuccess(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINFAIL:
		break;
	case DEF_NOTIFY_FORCEDISCONN:
		NotifyMsg_ForceDisconn(pData);
		break;
	case DEF_NOTIFY_FIGHTZONERESERVE:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyFightZoneReserve>(
			pData, sizeof(hb::net::PacketNotifyFightZoneReserve));
		if (!pkt) return;
		switch (pkt->result) {
		case -5:
			AddEventList(NOTIFY_MSG_HANDLER68, 10);
			break;
		case -4:
			AddEventList(NOTIFY_MSG_HANDLER69, 10);
			break;
		case -3:
			AddEventList(NOTIFY_MSG_HANDLER70, 10);
			break;
		case -2:
			m_iFightzoneNumber = 0;
			AddEventList(NOTIFY_MSG_HANDLER71, 10);
			break;
		case -1:
			m_iFightzoneNumber = m_iFightzoneNumber * -1;
			AddEventList(NOTIFY_MSG_HANDLER72, 10);
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			wsprintf(cTxt, NOTIFY_MSG_HANDLER73, pkt->result);//"
			AddEventList(cTxt, 10);
			break;
		}
	}
	break;
	}
}

void CGame::ReserveFightzoneResponseHandler(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseFightzoneReserve>(
		pData, sizeof(hb::net::PacketResponseFightzoneReserve));
	if (!pkt) return;
	switch (pkt->header.msg_type) {
	case DEF_MSGTYPE_CONFIRM:
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER1, 10);
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 14;
		m_iFightzoneNumber = m_iFightzoneNumberTemp;
		break;

	case DEF_MSGTYPE_REJECT:
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER2, 10);
		m_iFightzoneNumberTemp = 0;

		if (pkt->result == 0) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 15;
		}
		else if (pkt->result == -1) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 16;
		}
		else if (pkt->result == -2) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 17;
		}
		else if (pkt->result == -3) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 21;
		}
		else if (pkt->result == -4) {
			m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 22;
		}
		break;
	}
}

void CGame::NotifyMsg_CurLifeSpan(char* pData)
{
	int iItemIndex;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCurLifeSpan>(
		pData, sizeof(hb::net::PacketNotifyCurLifeSpan));
	if (!pkt) return;
	iItemIndex = pkt->item_index;
	m_pItemList[iItemIndex]->m_wCurLifeSpan = static_cast<WORD>(pkt->cur_lifespan);
}

void CGame::UpdateScreen_OnLogResMsg()
{
	short msX, msY, msZ, sX, sY;
	char  cLB, cRB;
	uint32_t dwTime = GameClock::GetTimeMS();
	static DWORD dwCTime;
	static class CMouseInterface* pMI;
	int   iMIbuttonNum;
	char  cMIresult;


	if (m_cGameModeCount == 0)
	{
		pMI = new class CMouseInterface;
		pMI->AddRect(370 + SCREENX, 240 + SCREENY, 370 + SCREENX + DEF_BTNSZX, 240 + SCREENY + DEF_BTNSZY);
		m_bEnterPressed = false;
		m_bEscPressed = false;
		m_cArrowPressed = 0;
		dwCTime = GameClock::GetTimeMS();
		AudioManager::Get().StopSound(SoundType::Effect, 38);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == true || m_bEnterPressed) {
		switch (m_cMsg[0]) {
		case '0':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			break;
		case '1':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '2':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			break;
		case '3':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '4':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '5':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '6':
			switch (m_cMsg[1]) {
			case 'B':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			}
			break;
		case '7':
		case '8':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		}

		delete pMI;
		m_bEscPressed = false;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	switch (m_cMsg[0]) {
	case '0':
	case '5':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
	case '7':
		sX = 146;
		sY = 114;

		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;

	case '2':
	case '4':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		sX = 0;
		sY = 0;
		UpdateScreen_OnSelectCharacter(sX, sY, 0, 0);
		break;

	case '6':
		sX = 146;
		sY = 114;

		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, true);
		break;
	case '8':
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, true);
		break;
	}

	m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162 + SCREENX, 125 + SCREENY, 2);

	if ((msX >= 370 + SCREENX) && (msX <= 370 + DEF_BTNSZX + SCREENX) && (msY >= 244 + SCREENY) && (msY <= 244 + DEF_BTNSZY + SCREENY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370 + SCREENX, 244 + SCREENY, 0);

	switch (m_cMsg[1]) {
	case '1':
		PutString_SprFont(172 + 70 + SCREENX, 165 + SCREENY, "Password is not correct!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG5);//"
		break;

	case '2':
		PutString_SprFont(172 + 70 + SCREENX, 165 + SCREENY, "Not existing account!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG6);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 215 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG7);//"
		break;

	case '3':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG8);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG9);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 225 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG10);//"
		break;

	case '4':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "New account created.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG11);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG12);//"
		break;

	case '5':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "Can not create new account!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG13);//"
		break;

	case '6':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not create new account!", 7, 0, 0);
		PutString_SprFont(172 + 24 + SCREENX, 180 + SCREENY, "Already existing account name.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 205 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG14);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG15);//"
		break;

	case '7':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "New character created.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG16);//"
		break;

	case '8':
		PutString_SprFont(172 + 58 + SCREENX, 165 + SCREENY, "Can not create new character!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG17);//"
		break;

	case '9':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not create new character!", 7, 0, 0);
		PutString_SprFont(172 + 24 + SCREENX, 180 + SCREENY, "Already existing character name.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 205 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG18);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 220 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG19);//"
		break;

	case 'A':
		PutString_SprFont(172 + 36 + 45 + SCREENX, 165 + SCREENY, "Character deleted.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG20);//"

		break;
	case 'B':
		PutString_SprFont(172 + 36 + 45 + SCREENX, 165 + SCREENY, "Password changed.", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG21);//"
		break;
	case 'C':
		PutString_SprFont(172 + 36 + SCREENX, 165 + SCREENY, "Can not change password!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG22);//"
		break;

	case 'D':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG23);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG24);//"
		break;

	case 'E':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG25);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG26);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 225 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG27);//"
		break;

	case 'F':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG28);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG29);//"
		break;

	case 'G':
		PutString_SprFont(172 + 10 + 34 + SCREENX, 165 + SCREENY, "Can not connect to game server!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG30);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG31);//"
		break;

	case 'H':
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Connection Rejected!", 7, 0, 0);
		if (m_iBlockYear == 0) {
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG32);//"
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG33);//"
		}
		else {
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG34);//"
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_LOG_MSG35, m_iBlockYear, m_iBlockMonth, m_iBlockDay);//"
			PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, G_cTxt);
		}
		break;

	case 'I': //
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Not Enough Point!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "�I�ƨϥδ����w����, �Ц�GD2S.gamania.com�����ϥδ���");

		break;

	case 'J': // v2.15 2002-5-21
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "World Server Full", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Please ! Try Other World Server");
		break;

	case 'M': 	// v2.18
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Your password expired", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Please! Change password");
		break;


	case 'U': // v2.15
		PutString_SprFont(172 + 68 + SCREENX, 165 + SCREENY, "Keycode input Success!", 7, 0, 0);
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, "Keycode Registration successed.");

		break;

	case 'X':
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG38);//"
		PutAlignedString(198 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG39);//"
		break;

	case 'Y':
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG40);//"
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;

	case 'Z':
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 195 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG42);//"
		PutAlignedString(178 + SCREENX, 453 + SCREENX, 210 + SCREENY, UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1:
			switch (m_cMsg[0]) {
			case '0':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
				break;
			case '1':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '2':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				break;
			case '3':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '4':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '5':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '6':
				switch (m_cMsg[1]) {
				case 'B':
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
					break;
				case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				}
				break;
			case '7':
			case '8':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			}
			delete pMI;
			return;
		}
	}

	if ((dwTime - dwCTime) > 100)
	{
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
}

void CGame::RetrieveItemHandler(char* pData)
{
	char cBankItemIndex, cItemIndex, cTxt[120];
	int j;
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	if (header->msg_type != DEF_MSGTYPE_REJECT)
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseRetrieveItem>(
			pData, sizeof(hb::net::PacketResponseRetrieveItem));
		if (!pkt) return;
		cBankItemIndex = static_cast<char>(pkt->bank_index);
		cItemIndex = static_cast<char>(pkt->item_index);

		if (m_pBankList[cBankItemIndex] != 0) {
			// v1.42
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pBankList[cBankItemIndex], cStr1, cStr2, cStr3);

			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//""You took out %s."
			AddEventList(cTxt, 10);

			if ((m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW))
			{
				if (m_pItemList[cItemIndex] == 0) goto RIH_STEP2;
				delete m_pBankList[cBankItemIndex];
				m_pBankList[cBankItemIndex] = 0;
				for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{
					if ((m_pBankList[j + 1] != 0) && (m_pBankList[j] == 0))
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
			else
			{
			RIH_STEP2:;
				if (m_pItemList[cItemIndex] != 0) return;
				short nX, nY;
				nX = 40;
				nY = 30;
				for (j = 0; j < DEF_MAXITEMS; j++)
				{
					if ((m_pItemList[j] != 0) && (memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0))
					{
						nX = m_pItemList[j]->m_sX + 1;
						nY = m_pItemList[j]->m_sY + 1;
						break;
					}
				}
				m_pItemList[cItemIndex] = m_pBankList[cBankItemIndex];
				m_pItemList[cItemIndex]->m_sX = nX;
				m_pItemList[cItemIndex]->m_sY = nY;
				bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemIndex, nX, nY, 0, 0);

				for (j = 0; j < DEF_MAXITEMS; j++)
					if (m_cItemOrder[j] == -1)
					{
						m_cItemOrder[j] = cItemIndex;
						break;
					}
				m_bIsItemEquipped[cItemIndex] = false;
				m_bIsItemDisabled[cItemIndex] = false;
				m_pBankList[cBankItemIndex] = 0;
				for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{
					if ((m_pBankList[j + 1] != 0) && (m_pBankList[j] == 0))
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
		}
	}
	m_dialogBoxManager.Info(DialogBoxId::Bank).cMode = 0;
}

void CGame::EraseItem(char cItemID)
{
	int i;
	char cStr1[64], cStr2[64], cStr3[64];
	std::memset(cStr1, 0, sizeof(cStr1));
	std::memset(cStr2, 0, sizeof(cStr2));
	std::memset(cStr3, 0, sizeof(cStr3));
	for (i = 0; i < 6; i++)
	{
		if (m_sShortCut[i] == cItemID)
		{
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
			if (i < 3) wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 1);
			else wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 7);
			AddEventList(G_cTxt, 10);
			m_sShortCut[i] = -1;
		}
	}

	if (cItemID == m_sRecentShortCut)
		m_sRecentShortCut = -1;
	// ItemOrder
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == cItemID)
			m_cItemOrder[i] = -1;
	for (i = 1; i < DEF_MAXITEMS; i++)
		if ((m_cItemOrder[i - 1] == -1) && (m_cItemOrder[i] != -1))
		{
			m_cItemOrder[i - 1] = m_cItemOrder[i];
			m_cItemOrder[i] = -1;
		}
	// ItemList
	delete m_pItemList[cItemID];
	m_pItemList[cItemID] = 0;
	m_bIsItemEquipped[cItemID] = false;
	m_bIsItemDisabled[cItemID] = false;
}

void CGame::DlbBoxDoubleClick_Character(short msX, short msY)
{
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS], cItemID = -1;
	short sX, sY, sSprH, sFrame;
	int i;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) return;
	sX = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CharacterInfo).sY;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 41, sY + 137, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6)) {
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}

	if (cItemID == -1 || m_pItemList[cItemID] == 0) return;
	if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) || (m_pItemList[cItemID]->m_dwCount > 1)) return;
	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) == true) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 == 24))
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, 0, cItemID, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3, 0, m_pItemList[cItemID]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); // v1.4
	else {
		if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
		{
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
			std::memset(G_cTxt, 0, sizeof(G_cTxt));
			wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"
			AddEventList(G_cTxt, 10);
			if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
			else PlaySound('E', 29, 0);

			// Remove Angelic Stats
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
			{
				char cItemID = m_stMCursor.sSelectedObjectID;
				if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
				{
					m_iAngelicStr = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
				{
					m_iAngelicDex = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
				{
					m_iAngelicInt = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
				{
					m_iAngelicMag = 0;
				}
			}
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
			m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
			m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
			m_stMCursor.cSelectedObjectType = 0;
			m_stMCursor.sSelectedObjectID = 0;
		}
	}
}

void CGame::DlbBoxDoubleClick_GuideMap(short msX, short msY)
{
	short si = m_stMCursor.sCursorFrame;
	if (si != 0) return;
	if (m_cMapIndex < 0) return;

	short sX, sY, shX, shY, szX, szY;
	sX = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX;
	szY = m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY;
	if (sX < 20) sX = 0;
	if (sY < 20) sY = 0;
	if (sX > LOGICAL_MAX_X - 128 - 20) sX = LOGICAL_MAX_X - 128;
	if (sY > 547 - 128 - 20) sY = 547 - 128;
	if (m_bZoomMap)
	{
		shX = m_sPlayerX - 64;
		shY = m_sPlayerY - 64;
		if (shX < 0) shX = 0;
		if (shY < 0) shY = 0;
		if (shX > m_pMapData->m_sMapSizeX - 128) shX = m_pMapData->m_sMapSizeX - 128;
		if (shY > m_pMapData->m_sMapSizeY - 128) shY = m_pMapData->m_sMapSizeY - 128;
		shX = shX + msX - sX;
		shY = shY + msY - sY;
	}
	else
	{
		shX = (m_pMapData->m_sMapSizeX * (msX - sX)) / 128;
		shY = (m_pMapData->m_sMapSizeX * (msY - sY)) / 128;
	}
	if (shX < 30 || shY < 30) return;
	if (shX > m_pMapData->m_sMapSizeX - 30 || shY > m_pMapData->m_sMapSizeY - 30) return;
	if ((m_bRunningMode == true) && (m_iSP > 0))
		m_cCommand = DEF_OBJECTRUN;
	else m_cCommand = DEF_OBJECTMOVE;
	m_sCommX = shX;
	m_sCommY = shY;
	GetPlayerTurn();
}

void CGame::DlbBoxDoubleClick_Inventory(short msX, short msY)
{
	int i;
	char  cItemID, cTxt[120];
	short sX, sY, x1, x2, y1, y2;
	char cStr1[64], cStr2[64], cStr3[64];
	//if (m_iHP <= 0) return;
	if (m_bItemUsingStatus == true)
	{
		AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY1, 10);
		return;
	}
	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] == -1) continue;
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
		if (m_pItemList[cItemID] == 0) continue;

		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
		// Order
		x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
		y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
		x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
		y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

		if ((m_bIsItemDisabled[cItemID] == false) && (m_bIsItemEquipped[cItemID] == false) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
		{	// Order
			_SetItemOrder(0, cItemID);
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);

			if (m_dialogBoxManager.IsEnabled(DialogBoxId::SaleMenu) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == false) && (m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 == 24))
			{
				if (m_pItemList[cItemID]->m_cEquipPos != DEF_EQUIPPOS_NONE)
				{
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, 0, cItemID, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3, 0, m_pItemList[cItemID]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); // v1.4
					return;
				}
			}

			if (m_dialogBoxManager.IsEnabled(DialogBoxId::Bank))
			{	// centu - wh
				bItemDrop_Bank(msX, msY);
				return;
			}
			else if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellList))
			{	// centu - sell
				bItemDrop_SellList(msX, msY);
				return;
			}
			else if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemUpgrade))
			{	// centu - upgrade
				bItemDrop_ItemUpgrade();
				return;
			}

			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_PERM)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT))
			{
				if (bCheckItemOperationEnabled(cItemID) == false) return;
				if ((GameClock::GetTimeMS() - m_dwDamagedTime) < 10000)
				{
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 9))
					{
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
					}
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 89))
					{
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
					}
				}
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, cItemID, 0, 0, 0);

				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)
					|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT))
				{
					m_bIsItemDisabled[cItemID] = true;
					m_bItemUsingStatus = true;
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					m_bIsGetPointingMode = true;
					m_iPointCommandType = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY7, cStr1);//"Item %s: Select a position which you want to use."
					AddEventList(cTxt, 10);
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY13, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					m_bIsGetPointingMode = true;
					m_iPointCommandType = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY8, cStr1);//"Item %s: Select an item which you want to use."
					AddEventList(cTxt, 10);
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX)
			{
				if (_bIsItemOnHand() == true)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}

				if (m_bSkillUsingStatus == true) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}

				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}
				else
				{
					switch (m_pItemList[cItemID]->m_sSpriteFrame) {
					case 55: // Alchemy pot
						if (m_cSkillMastery[12] == 0)
						{
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY9, 10);//"You should learn alchemy skill to use this item."
						}
						else
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 1, 0, 0, 0);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);//"Using alchemy skill..."
						}
						break;
					case 113: // Smith's Anvil
						if (m_cSkillMastery[13] == 0)
						{
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY11, 10);//"You should learn manufacturing skill to use this item.."
						}
						else
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 3, 0, 0, 0);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"Using a manufacturing skill..."
						}
						break;

						// Crafting
					case 0:
						//if (m_pItemList[i]->m_sSprite == 22)
					{
						m_dialogBoxManager.EnableDialogBox(DialogBoxId::Manufacture, 7, 0, 0, 0);
						AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY17, 10);	//  "Initiating item Crafting..."
					}
					break;

					case 151:
					case 152:
					case 153:
					case 154:
						m_dialogBoxManager.EnableDialogBox(DialogBoxId::Slates, 1, 0, 0, 0);
						break;
					}
				}
			}
			// Dblclick Alchemy bowl
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 1))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			// Dblclick Manuf box
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 4))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			// Crafting
			// Dblclick Crafting box
			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true) && (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode == 7))
			{
				bItemDrop_SkillDialog();
				//bItemDrop_ExternalScreen(cItemID, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX+50, m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY+50);
			}
			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			{
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = (short)cItemID;
				bItemDrop_Character();
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
			}
			return;
		}
	}
}



void CGame::DrawNpcName(short sX, short sY, short sOwnerType, int iStatus)
{
	char cTxt[32], cTxt2[64];
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	GetNpcName(sOwnerType, cTxt);
	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"
	PutString2(sX, sY, cTxt, 255, 255, 255);
	if (m_bIsObserverMode == true) PutString2(sX, sY + 14, cTxt, 50, 50, 255);
	else if (m_bIsConfusion || (m_iIlusionOwnerH != 0))
	{
		std::memset(cTxt, 0, sizeof(cTxt));
		strcpy(cTxt, DRAW_OBJECT_NAME87);//"(Unknown)"
		PutString2(sX, sY + 14, cTxt, 150, 150, 150); // v2.171
	}/*else
	{	switch( _iGetFOE(iStatus) ){
		case -2:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
		case -1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
		case 0:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME88, 50,50,255); // "Neutral"
			break;
		case 1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME89, 30,255,30); // "(Friendly)"
			break;
	}	}*/
#ifdef _DEBUG
	wsprintf(cTxt2, "Status: 0x%.8X ", iStatus);
	PutString2(sX, sY + 42, cTxt2, 30, 255, 30);
	std::memset(cTxt2, 0, sizeof(cTxt2));
#endif

	switch ((iStatus & 0x0F00) >> 8) {
	case 0: break;
	case 1: strcpy(cTxt2, DRAW_OBJECT_NAME52); break;//"Clairvoyant"
	case 2: strcpy(cTxt2, DRAW_OBJECT_NAME53); break;//"Destruction of Magic Protection"
	case 3: strcpy(cTxt2, DRAW_OBJECT_NAME54); break;//"Anti-Physical Damage"
	case 4: strcpy(cTxt2, DRAW_OBJECT_NAME55); break;//"Anti-Magic Damage"
	case 5: strcpy(cTxt2, DRAW_OBJECT_NAME56); break;//"Poisonous"
	case 6: strcpy(cTxt2, DRAW_OBJECT_NAME57); break;//"Critical Poisonous"
	case 7: strcpy(cTxt2, DRAW_OBJECT_NAME58); break;//"Explosive"
	case 8: strcpy(cTxt2, DRAW_OBJECT_NAME59); break;//"Critical Explosive"
	}
	if (CMisc::bCheckIMEString(cTxt2)) PutString_SprFont3(sX, sY + 22, cTxt2, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
	else PutString2(sX, sY + 28, cTxt2, 240, 240, 70);

	// centu: no muestra la barra de hp de algunos npc
	switch (sOwnerType) {
	case 15:
	case 19:
	case 20:
	case 24:
	case 25:
	case 26:
	case 42:
	case 55:
	case 56:
	case 67:
	case 68:
	case 69:
	case 64:
	{
		switch ((_tmp_sAppr2 & 0xFF00) >> 8) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		default:
			break;
		}
	}
	case 90:
		break;
	default:
		if (iNpcHP > 0)
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS]->PutSpriteFastWidth(sX, sY + 16, 18, 75, m_dwCurTime, false);
			int iBarWidth2 = (iNpcHP * 75) / iNpcMaxHP;
			if (iBarWidth2 < 0) iBarWidth2 = 0;
			if (iBarWidth2 > 75) iBarWidth2 = 75;
			m_pSprite[DEF_SPRID_INTERFACE_ND_PARTYSTATUS]->PutSpriteFastWidth(sX, sY + 16, 19, iBarWidth2, m_dwCurTime, false); // 16
		}
		break;
	}
}

void CGame::DrawObjectName(short sX, short sY, char* pName, int iStatus)
{
	char cTxt[64], cTxt2[64];
	short sR, sG, sB;
	int i, iGuildIndex, iFOE, iAddY = 0;
	bool bPK, bCitizen, bAresden, bHunter;
	iFOE = _iGetFOE(iStatus);
	if (iFOE < 0)
	{
		sR = 255; sG = 0; sB = 0;
	}
	else if (iFOE == 0)
	{
		sR = 50; sG = 50; sB = 255;
	}
	else
	{
		sR = 30; sG = 200; sB = 30;
	}
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));

	if (m_iIlusionOwnerH == 0)
	{
		if (m_bIsCrusadeMode == false) wsprintf(cTxt, "%s", pName);
		else
		{
			if (_tmp_wObjectID >= 10000) strcpy(cTxt, NPC_NAME_MERCENARY); //"Mercenary"
			else
			{
				if (iFOE == -1) wsprintf(cTxt, "%d", _tmp_wObjectID);
				else strcpy(cTxt, pName);
			}
		}
		if (m_iPartyStatus != 0)
		{
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			{
				if (strcmp(m_stPartyMemberNameList[i].cName, pName) == 0)
				{
					strcat(cTxt, BGET_NPC_NAME23); // ", Party Member"
					break;
				}
			}
		}
	}
	else strcpy(cTxt, "?????");

	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255, 255, 255);
	std::memset(cTxt, 0, sizeof(cTxt));

	if (memcmp(m_cPlayerName, pName, 10) == 0)
	{
		if (m_iGuildRank == 0)
		{
			wsprintf(G_cTxt, DEF_MSG_GUILDMASTER, m_cGuildName);//" Guildmaster)"
			PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
			iAddY = 14;
		}
		if (m_iGuildRank > 0)
		{
			wsprintf(G_cTxt, DEF_MSG_GUILDSMAN, m_cGuildName);//" Guildsman)"
			PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
			iAddY = 14;
		}
		if (m_iPKCount != 0)
		{
			bPK = true;
			sR = 255; sG = 0; sB = 0;
		}
		else
		{
			bPK = false;
			sR = 30; sG = 200; sB = 30;
		}
		bCitizen = m_bCitizen;
		bAresden = m_bAresden;
		bHunter = m_bHunter;
	}
	else
	{	// CLEROTH - CRASH BUG ( STATUS )
		if (iStatus & 0x80000000) bPK = true;
		else bPK = false;
		if (iStatus & 0x40000000) bCitizen = true;
		else bCitizen = false;
		if (iStatus & 0x20000000) bAresden = true;
		else bAresden = false;
		if (iStatus & 0x10000000) bHunter = true;
		else bHunter = false;
		if (m_bIsCrusadeMode == false || iFOE >= 0)
		{
			if (FindGuildName(pName, &iGuildIndex) == true)
			{
				if (m_stGuildName[iGuildIndex].cGuildName[0] != 0)
				{
					if (strcmp(m_stGuildName[iGuildIndex].cGuildName, "NONE") != 0)
					{
						if (m_stGuildName[iGuildIndex].iGuildRank == 0)
						{
							wsprintf(G_cTxt, DEF_MSG_GUILDMASTER, m_stGuildName[iGuildIndex].cGuildName);//
							PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
						else if (m_stGuildName[iGuildIndex].iGuildRank > 0)
						{
							wsprintf(G_cTxt, DEF_MSG_GUILDSMAN, m_stGuildName[iGuildIndex].cGuildName);//"
							PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
					}
					else
					{
						m_stGuildName[iGuildIndex].dwRefTime = 0;
					}
				}
			}
			else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQGUILDNAME, 0, _tmp_wObjectID, iGuildIndex, 0, 0);
		}
	}

	if (bCitizen == false)	strcpy(cTxt, DRAW_OBJECT_NAME60);// "Traveller"
	else
	{
		if (bAresden)
		{
			if (bHunter == true) strcpy(cTxt, DEF_MSG_ARECIVIL); // "Aresden Civilian"
			else strcpy(cTxt, DEF_MSG_ARESOLDIER); // "Aresden Combatant"
		}
		else
		{
			if (bHunter == true) strcpy(cTxt, DEF_MSG_ELVCIVIL);// "Elvine Civilian"
			else strcpy(cTxt, DEF_MSG_ELVSOLDIER);	// "Elvine Combatant"
		}
	}
	if (bPK == true)
	{
		if (bCitizen == false) strcpy(cTxt, DEF_MSG_PK);	//"Criminal"
		else
		{
			if (bAresden) strcpy(cTxt, DEF_MSG_AREPK);// "Aresden Criminal"
			else strcpy(cTxt, DEF_MSG_ELVPK);  // "Elvine Criminal"
		}
	}
	PutString2(sX, sY + 14 + iAddY, cTxt, sR, sG, sB);

#ifdef _DEBUG
	wsprintf(cTxt2, "Status: 0x%.8X ", iStatus);
	PutString2(sX, sY + 42, cTxt2, 30, 255, 30);
	std::memset(cTxt2, 0, sizeof(cTxt2));
#endif
}

bool CGame::FindGuildName(char* pName, int* ipIndex)
{
	int i, iRet = 0;
	uint32_t dwTmpTime;
	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		if (memcmp(m_stGuildName[i].cCharName, pName, 10) == 0)
		{
			m_stGuildName[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return true;
		}
	}
	dwTmpTime = m_stGuildName[0].dwRefTime;
	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		if (m_stGuildName[i].dwRefTime < dwTmpTime)
		{
			iRet = i;
			dwTmpTime = m_stGuildName[i].dwRefTime;
		}
	}
	std::memset(m_stGuildName[iRet].cGuildName, 0, sizeof(m_stGuildName[iRet].cGuildName));
	memcpy(m_stGuildName[iRet].cCharName, pName, 10);
	m_stGuildName[iRet].dwRefTime = m_dwCurTime;
	m_stGuildName[iRet].iGuildRank = -1;
	*ipIndex = iRet;
	return false;
}


void CGame::DrawVersion(bool bAuthor)
{
	uint32_t dwTime = GameClock::GetTimeMS();
	uint16_t wR, wG, wB;
	CMisc::ColorTransfer(m_DDraw.m_cPixelFormat, RGB(140, 140, 140), &wR, &wG, &wB);
	// Ver
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(14 + SCREENX, 463 + SCREENY, 19, wR, wG, wB, dwTime);
	// Upper Version
	wsprintf(G_cTxt, "%d", DEF_UPPERVERSION);
	PutString_SprNum(36 + SCREENX, 463 + SCREENY, G_cTxt, 140, 140, 140);
	// .
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(42 + SCREENX, 463 + SCREENY, 18, wR, wG, wB, dwTime);
	// Lower Version
	wsprintf(G_cTxt, "%d", DEF_LOWERVERSION);
	PutString_SprNum(46 + SCREENX, 463 + SCREENY, G_cTxt, 140, 140, 140);
	if (bAuthor == false) return;
	// Of course it's easy to remove those lines, but those people deserve some credit
	// at least for releasing their work....
	PutString2(14 + SCREENX, 375 + SCREENY, "V3.51 compatibility by Cleroth", 220, 200, 200);
	PutString2(14 + SCREENX, 390 + SCREENY, "V3.51 dialogs by Diuuude", 220, 200, 200);
	PutString2(14 + SCREENX, 405 + SCREENY, "Effects, mobs, Apocalypse, Heldenian,", 220, 200, 200);
	PutString2(14 + SCREENX, 420 + SCREENY, "& finalizing by Snoopy81", 220, 200, 200);
	PutString2(14 + SCREENX, 435 + SCREENY, "Angels & Crafting by Snoopy81", 220, 200, 200);

}

char CGame::GetOfficialMapName(char* pMapName, char* pName)
{	// MapIndex
	if (strcmp(pMapName, "middleland") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME28);	// Middleland
		return 4;
	}
	else if (strcmp(pMapName, "huntzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME31);	// Death Valley
		return 0;
	}
	else if (strcmp(pMapName, "huntzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME29);	// Rocky Highland
		return 1;
	}
	else if (strcmp(pMapName, "elvuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME57);	// Eldiniel Garden
		return 2;
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME24);	// Elvine City
		return 3;
	}
	else if (strcmp(pMapName, "elvfarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME2);	// Elvine Farm
		return 5;
	}
	else if (strcmp(pMapName, "arefarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME1);	// Aresden Farm
		return 6;
	}
	else if (strcmp(pMapName, "default") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME3);	// Beginner Zone
		return 7;
	}
	else if (strcmp(pMapName, "huntzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME32);	// Silent Wood
		return 8;
	}
	else if (strcmp(pMapName, "huntzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME30);	// Eternal Field
		return 9;
	}
	else if (strcmp(pMapName, "areuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME56);	// Aresien Garden
		return 10;
	}
	else if (strcmp(pMapName, "aresden") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME22);	// Aresden City
		return 11;
	}
	else if (strcmp(pMapName, "dglv2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME25);	// Dungeon L2
		return 12;
	}
	else if (strcmp(pMapName, "dglv3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME26);	// Dungeon L3
		return 13;
	}
	else if (strcmp(pMapName, "dglv4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME53);	// Dungeon L4
		return 14;
	}
	else if (strcmp(pMapName, "elvined1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME23);	// Elvine Dungeon
		return 15;
	}
	else if (strcmp(pMapName, "aresdend1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME21);	// Aresden Dungeon
		return 16;
	}
	else if (strcmp(pMapName, "bisle") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME27);	// Bleeding Island
		return 17;
	}
	else if (strcmp(pMapName, "toh1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME60);	// Tower of Hell 1
		return 18;
	}
	else if (strcmp(pMapName, "toh2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME61);	// Tower of Hell 2
		return 19;
	}
	else if (strcmp(pMapName, "toh3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME62);	// Tower of Hell 3
		return 20;
	}
	else if (strcmp(pMapName, "middled1x") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME58);	// Middleland Mine
		return 21;
	}
	else if (strcmp(pMapName, "middled1n") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME59);	// Middleland Dungeon
		return 22;
	}
	else if (strcmp(pMapName, "2ndmiddle") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME65);	// Promiseland
		return 23;
	}
	else if (strcmp(pMapName, "icebound") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME66);	// Ice Map
		return 24;
		// Snoopy:
	}
	else if (strcmp(pMapName, "druncncity") == 0) // Snoopy: Apocalypse maps
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME70);
		return 25;
	}
	else if (strcmp(pMapName, "inferniaA") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME71);
		return 26;
	}
	else if (strcmp(pMapName, "inferniaB") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME72);
		return 27;
	}
	else if (strcmp(pMapName, "maze") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME73);
		return 28;
	}
	else if (strcmp(pMapName, "procella") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME74);
		return 29;
	}
	else if (strcmp(pMapName, "abaddon") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME75);
		return 30;
	}
	else if (strcmp(pMapName, "BtField") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME76);
		return 35;
	}
	else if (strcmp(pMapName, "GodH") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME77);
		return 36;
	}
	else if (strcmp(pMapName, "HRampart") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME78);
		return 37;
	}
	else if (strcmp(pMapName, "cityhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME35);	// Aresden Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "cityhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME36);	// Elvine Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME37);	// Aresden Guildhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME38);	// Elvine Guildhall
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_1", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME33);	// Aresden Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_2", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME34);	// Elvine Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "gshop_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME39);	// Aresden Shop
		return -1;
	}
	else if (memcmp(pMapName, "gshop_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME40);	// Elvine Shop
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME43);	// Aresden Warehouse
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME44);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "arewrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME45);	// Aresden Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "elvwrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME46);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME41);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME42);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "cath_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME47);	// Aresien Church
		return -1;
	}
	else if (strcmp(pMapName, "cath_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME48);	// Eldiniel Church
		return -1;
	}
	else if (strcmp(pMapName, "resurr1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME54);	// Revival Zone
		return -1;
	}
	else if (strcmp(pMapName, "resurr2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME55);	// Revival Zone
		return -1;
	}
	else if (strcmp(pMapName, "arebrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME4);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME5);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME6);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "arebrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME7);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME8);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME9);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME10);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME11);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME12);	// Arena 1
		return -1;
	}
	else if (strcmp(pMapName, "fightzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME13);	// Arena 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME14);	// Arena 3
		return -1;
	}
	else if (strcmp(pMapName, "fightzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME15);	// Arena 4
		return -1;
	}
	else if (strcmp(pMapName, "fightzone5") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME16);	// Arena 5
		return -1;
	}
	else if (strcmp(pMapName, "fightzone6") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME17);	// Arena 6
		return -1;
	}
	else if (strcmp(pMapName, "fightzone7") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME18);	// Arena 7
		return -1;
	}
	else if (strcmp(pMapName, "fightzone8") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME19);	// Arena 8
		return -1;
	}
	else if (strcmp(pMapName, "fightzone9") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME20);	// Arena 9
		return -1;
	}
	else if (strcmp(pMapName, "arejail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME63);	// Aresden Jail
		return -1;
	}
	else if (strcmp(pMapName, "elvjail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME64);	// Elvine Jail
		return -1;
	}
	else if (strcmp(pMapName, "CmdHall_1") == 0) // Snoopy: Commander Halls
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
	else if (strcmp(pMapName, "CmdHall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
	else
	{
		strcpy(pName, pMapName);
		return -1;
	}
}

bool CGame::bCheckLocalChatCommand(char* pMsg)
{
	return ChatCommandManager::Get().ProcessCommand(pMsg);
}

bool CGame::bCheckItemOperationEnabled(char cItemID)
{
	if (m_pItemList[cItemID] == 0) return false;
	if (m_cCommand < 0) return false;
	if (m_bIsTeleportRequested == true) return false;
	if (m_bIsItemDisabled[cItemID] == true) return false;

	if ((m_pItemList[cItemID]->m_sSpriteFrame == 155) && (m_bUsingSlate == true))
	{
		if ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37))
		{
			AddEventList(DEF_MSG_NOTIFY_SLATE_WRONG_MAP, 10); // "You cannot use it right here."
			return false;
		}
		AddEventList(DEF_MSG_NOTIFY_SLATE_ALREADYUSING, 10); // Already Using Another Slate
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::Exchange) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellList) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	return true;
}

void CGame::ClearSkillUsingStatus()
{
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(CLEAR_SKILL_USING_STATUS1, 10);//"
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
		if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/) {
			m_cCommand = DEF_OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
		}
	}
	m_bSkillUsingStatus = false;
}


void CGame::NpcTalkHandler(char* pData)
{
	char cRewardName[21], cTargetName[21], cTemp[21], cTxt[250];
	short sType, sResponse;
	int iAmount, iIndex, iContribution, iX, iY, iRange;
	int iTargetType, iTargetCount, iQuestionType;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNpcTalk>(
		pData, sizeof(hb::net::PacketNotifyNpcTalk));
	if (!pkt) return;

	sType = pkt->type;
	sResponse = pkt->response;
	iAmount = pkt->amount;
	iContribution = pkt->contribution;
	iTargetType = pkt->target_type;
	iTargetCount = pkt->target_count;
	iX = pkt->x;
	iY = pkt->y;
	iRange = pkt->range;

	std::memset(cRewardName, 0, sizeof(cRewardName));
	memcpy(cRewardName, pkt->reward_name, 20);
	std::memset(cTargetName, 0, sizeof(cTargetName));
	memcpy(cTargetName, pkt->target_name, 20);

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, sResponse, sType, 0);

	if ((sType >= 1) && (sType <= 100))
	{
		iIndex = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
		iQuestionType = 0;
		switch (sType) {
		case 1: //Monster Hunt
			std::memset(cTemp, 0, sizeof(cTemp));
			GetNpcName(iTargetType, cTemp);
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, NPC_TALK_HANDLER16, iTargetCount, cTemp);
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER17);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER18, cTemp);//"Map : %s"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				if (iX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER19, iX, iY, iRange);//"Position: %d,%d within %d blocks"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}

				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER20, iContribution);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 7: //
			std::memset(cTxt, 0, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER21, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER22);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER23, cTemp);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				if (iX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER24, iX, iY, iRange);
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}

				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER25, iContribution);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 10: // Crusade
			std::memset(cTxt, 0, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER26, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER27);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER28);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER29);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, NPC_TALK_HANDLER30);//"
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, " ");
			m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
			iIndex++;

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER31);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER32, cTemp);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;
			}
			iQuestionType = 2;
			break;
		}

		switch (iQuestionType) {
		case 1:
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER33, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER34, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			break;

		case 2:
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER35, 0);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
			iIndex++;
			break;

		default: break;
		}
	}
}

void CGame::GetNpcName(short sType, char* pName)
{
	switch (sType)
	{
	case 10: strcpy(pName, NPC_NAME_SLIME); break;
	case 11: strcpy(pName, NPC_NAME_SKELETON); break;
	case 12: strcpy(pName, NPC_NAME_STONEGOLEM); break;
	case 13: strcpy(pName, NPC_NAME_CYCLOPS); break;
	case 14: strcpy(pName, NPC_NAME_ORC); break;
	case 15: strcpy(pName, NPC_NAME_SHOP_KEEPER); break;
	case 16: strcpy(pName, NPC_NAME_GIANTANT); break;
	case 17: strcpy(pName, NPC_NAME_GIANTSCORPION); break;
	case 18: strcpy(pName, NPC_NAME_ZOMBIE); break;
	case 19: strcpy(pName, NPC_NAME_MAGICIAN); break;
	case 20: strcpy(pName, NPC_NAME_WAREHOUSE_KEEPER); break;
	case 21: strcpy(pName, NPC_NAME_GUARD); break;
	case 22: strcpy(pName, NPC_NAME_SNAKE); break;
	case 23: strcpy(pName, NPC_NAME_CLAYGOLEM); break;
	case 24: strcpy(pName, NPC_NAME_BLACKSMITH_KEEPER); break;
	case 25: strcpy(pName, NPC_NAME_CITYHALL_OFFICER); break;
	case 26: strcpy(pName, NPC_NAME_GUILDHALL_OFFICER); break;
	case 27: strcpy(pName, NPC_NAME_HELHOUND); break;
	case 28: strcpy(pName, NPC_NAME_TROLL); break;
	case 29: strcpy(pName, NPC_NAME_OGRE); break;
	case 30: strcpy(pName, NPC_NAME_LICHE); break;
	case 31: strcpy(pName, NPC_NAME_DEMON); break;
	case 32: strcpy(pName, NPC_NAME_UNICORN); break;
	case 33: strcpy(pName, NPC_NAME_WEREWOLF); break;
	case 34: strcpy(pName, NPC_NAME_DUMMY); break;
	case 35: strcpy(pName, NPC_NAME_ENERGYSPHERE); break;
	case 36:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_ARROWGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_ARROWGUARDTOWER);
		break;
	case 37:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_CANNONGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_CANNONGUARDTOWER);
		break;
	case 38:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_MANACOLLECTOR_CK);
		else strcpy(pName, NPC_NAME_MANACOLLECTOR);
		break;
	case 39:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_DETECTOR_CK);
		else strcpy(pName, NPC_NAME_DETECTOR);
		break;
	case 40: strcpy(pName, NPC_NAME_ENERGYSHIELD); break;
	case 41: strcpy(pName, NPC_NAME_GRANDMAGICGENERATOR); break;
	case 42: strcpy(pName, NPC_NAME_MANASTONE); break;
	case 43: strcpy(pName, NPC_NAME_LIGHTWARBEETLE); break;
	case 44: strcpy(pName, NPC_NAME_GODSHANDKNIGHT); break;
	case 45: strcpy(pName, NPC_NAME_GODSHANDKNIGHT_CK); break;
	case 46: strcpy(pName, NPC_NAME_TEMPLEKNIGHT); break;
	case 47: strcpy(pName, NPC_NAME_BATTLEGOLEM); break;
	case 48: strcpy(pName, NPC_NAME_STALKER); break;
	case 49: strcpy(pName, NPC_NAME_HELLCLAW); break;
	case 50: strcpy(pName, NPC_NAME_TIGERWORM); break;
	case 51: strcpy(pName, NPC_NAME_CATAPULT); break;
	case 52: strcpy(pName, NPC_NAME_GARGOYLE); break;
	case 53: strcpy(pName, NPC_NAME_BEHOLDER); break;
	case 54: strcpy(pName, NPC_NAME_DARKELF); break;
	case 55: strcpy(pName, NPC_NAME_RABBIT); break;
	case 56: strcpy(pName, NPC_NAME_CAT); break;
	case 57: strcpy(pName, NPC_NAME_FROG); break;
	case 58: strcpy(pName, NPC_NAME_MOUNTAIN_GIANT); break;
	case 59: strcpy(pName, NPC_NAME_ETTIN); break;
	case 60: strcpy(pName, NPC_NAME_CANNIBAL); break;
	case 61: strcpy(pName, NPC_NAME_RUDOLPH); break;
	case 62: strcpy(pName, NPC_NAME_DIREBOAR); break;
	case 63: strcpy(pName, NPC_NAME_FROST); break;
	case 64:
	{
		switch ((_tmp_sAppr2 & 0xFF00) >> 8) {
		case 1:	strcpy(pName, NPC_NAME_WATERMELON);	break;
		case 2: strcpy(pName, NPC_NAME_PUMPKIN); break;
		case 3: strcpy(pName, NPC_NAME_GARLIC); break;
		case 4: strcpy(pName, NPC_NAME_BARLEY); break;
		case 5:	strcpy(pName, NPC_NAME_CARROT); break;
		case 6: strcpy(pName, NPC_NAME_RADISH); break;
		case 7: strcpy(pName, NPC_NAME_CORN); break;
		case 8: strcpy(pName, NPC_NAME_BFLOWER); break;
		case 9: strcpy(pName, NPC_NAME_MELON); break;
		case 10: strcpy(pName, NPC_NAME_TOMATO); break;
		case 11: strcpy(pName, NPC_NAME_GRAPPE); break;
		case 12: strcpy(pName, NPC_NAME_BLUEGRAPPE); break;
		case 13: strcpy(pName, NPC_NAME_MUSHROM); break;
		case 14: strcpy(pName, NPC_NAME_GINSENG); break;
		default: strcpy(pName, NPC_NAME_CROP); break;
		}
	}
	break;
	case 65: strcpy(pName, NPC_NAME_ICEGOLEM); break;
	case 66: strcpy(pName, NPC_NAME_WYVERN); break;
	case 67: strcpy(pName, NPC_NAME_MCGAFFIN); break;
	case 68: strcpy(pName, NPC_NAME_PERRY); break;
	case 69: strcpy(pName, NPC_NAME_DEVLIN); break;

	case 70: strcpy(pName, NPC_NAME_DRAGON); break;
	case 71: strcpy(pName, NPC_NAME_CENTAUR); break;
	case 72: strcpy(pName, NPC_NAME_CLAWTUR); break;
	case 73: strcpy(pName, NPC_NAME_FIREWYV); break;
	case 74: strcpy(pName, NPC_NAME_GICRAYF); break;
	case 75: strcpy(pName, NPC_NAME_GILIZAR); break;
	case 76: strcpy(pName, NPC_NAME_GITREE); break;
	case 77: strcpy(pName, NPC_NAME_MASTORC); break;
	case 78: strcpy(pName, NPC_NAME_MINAUS); break;
	case 79: strcpy(pName, NPC_NAME_NIZIE); break;

	case 80: strcpy(pName, NPC_NAME_TENTOCL); break;
	case 81: strcpy(pName, NPC_NAME_ABADDON); break;
	case 82: strcpy(pName, NPC_NAME_SORCERS); break;
	case 83: strcpy(pName, NPC_NAME_ATK); break;
	case 84: strcpy(pName, NPC_NAME_MASTELF); break;
	case 85: strcpy(pName, NPC_NAME_DSK); break;
	case 86: strcpy(pName, NPC_NAME_HBT); break;
	case 87: strcpy(pName, NPC_NAME_CT); break;
	case 88: strcpy(pName, NPC_NAME_BARBAR); break;
	case 89: strcpy(pName, NPC_NAME_AGC); break;
	case 90: strcpy(pName, NPC_NAME_GAIL); break;
	case 91: strcpy(pName, NPC_NAME_GATE); break;

		// CLEROTH - NEW MONSTERS
	case 110: strcpy(pName, NPC_NAME_AIRLEMENTAL); break;
	}
}

void CGame::GetItemName(CItem* pItem, char* pStr1, char* pStr2, char* pStr3)
{
	int i;
	char cTxt[256], cTxt2[256], cName[51];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	std::memset(cName, 0, sizeof(cName));
	std::memset(pStr1, 0, sizeof(pStr1));
	std::memset(pStr2, 0, sizeof(pStr2));
	std::memset(pStr3, 0, sizeof(pStr3));

	strcpy(cName, pItem->m_cName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
		if ((m_pItemNameList[i] != 0) && (strcmp(m_pItemNameList[i]->m_cOriginName, pItem->m_cName) == 0))
		{
			strcpy(cName, m_pItemNameList[i]->m_cName);
			break;
		}

	if (0 == memcmp(pItem->m_cName, "AcientTablet", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "NecklaceOf", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DarkElfBow", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DarkExecutor", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "The_Devastator", 14)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "DemonSlayer", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "LightingBlade", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "5thAnniversary", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "RubyRing", 8)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "SapphireRing", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Ringof", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicNecklace", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicWand(M.Shield)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "MagicWand(MS30-LLF)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Merien", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "BerserkWand", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "ResurWand", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Blood", 5)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Swordof", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "StoneOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "ZemstoneofSacrifice", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "StormBringer", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Aresden", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Elvine", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "EmeraldRing", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Excaliber", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Xelima", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "Kloness", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "aHeroOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(pItem->m_cName, "eHeroOf", 7)) m_bIsSpecial = true;
	if ((pItem->m_dwAttribute & 0x00000001) != 0)
	{
		m_bIsSpecial = true;
		strcpy(pStr1, cName);
		if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
			wsprintf(pStr2, GET_ITEM_NAME1, pItem->m_sItemSpecEffectValue2);		//"Purity: %d%%"
		else
		{	// Crafting Magins completion fix
			if (pItem->m_cEquipPos == DEF_EQUIPPOS_LFINGER)
			{
				wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2);	//"Completion:
			}
			else
			{
				wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2 + 100);	//"Completion: +100
			}
		}
	}
	else
	{
		if (pItem->m_dwCount == 1)
			wsprintf(G_cTxt, "%s", cName);
		else wsprintf(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, pItem->m_dwCount, cName);//"%d %s"
		strcpy(pStr1, G_cTxt);
	}

	if ((pItem->m_dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		dwType2 = (pItem->m_dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (pItem->m_dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3);   break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4);   break; // "Poisoning "
			case 3: strcpy(cTxt, GET_ITEM_NAME5);   break; // "Righteous "
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6);   break; // "Agile "
			case 6: strcpy(cTxt, GET_ITEM_NAME7);   break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8);   break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9);   break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10);  break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			std::memset(pStr1, 0, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break; // "Critical Hit Damage+%d"
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break; // "Poison Damage+%d"
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break; // "Attack Speed -1"
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0) {
				std::memset(cTxt, 0, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2 * 7); break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2 * 7); break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2 * 7); break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2 * 7); break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2 * 7); break;//"SPrec
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2 * 7); break;//"MPrec
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2 * 7); break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2 * 3); break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2 * 3); break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);   break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;//"Gold +%
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (pItem->m_dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char*)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			std::memset(cTxt, 0, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			std::memset(cTxt2, 0, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			std::memset(pStr1, 0, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

void CGame::GetItemName(char* cItemName, uint32_t dwAttribute, char* pStr1, char* pStr2, char* pStr3)
{
	int i;
	char cTxt[256], cTxt2[256], cName[51];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	std::memset(cName, 0, sizeof(cName));
	std::memset(pStr1, 0, sizeof(pStr1));
	std::memset(pStr2, 0, sizeof(pStr2));
	std::memset(pStr3, 0, sizeof(pStr3));

	strcpy(cName, cItemName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
		if ((m_pItemNameList[i] != 0) && (strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0)) {
			strcpy(cName, m_pItemNameList[i]->m_cName);
			break;
		}

	if (0 == memcmp(cItemName, "AcientTablet", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "NecklaceOf", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "DarkElfBow", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "DarkExecutor", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "The_Devastator", 14)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "DemonSlayer", 10)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "LightingBlade", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "5thAnniversary", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "RubyRing", 8)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "SapphireRing", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Ringof", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "MagicNecklace", 13)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "MagicWand(M.Shield)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "MagicWand(MS30-LLF)", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Merien", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "BerserkWand", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "ResurWand", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Blood", 5)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Swordof", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "StoneOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "ZemstoneofSacrifice", 19)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "StormBringer", 12)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Aresden", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Elvine", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "EmeraldRing", 11)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Excaliber", 9)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Xelima", 6)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "Kloness", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "aHeroOf", 7)) m_bIsSpecial = true;
	else if (0 == memcmp(cItemName, "eHeroOf", 7)) m_bIsSpecial = true;
	strcpy(pStr1, cName);

	if ((dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (dwAttribute & 0x000F0000) >> 16;
		dwType2 = (dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3); break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4); break;
			case 3: strcpy(cTxt, GET_ITEM_NAME5); break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6); break;
			case 6: strcpy(cTxt, GET_ITEM_NAME7); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8); break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10); break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			std::memset(pStr1, 0, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			std::memset(cTxt, 0, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break;
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2 * 7);  break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2 * 7);  break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2 * 7);  break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2 * 7);  break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2 * 7);  break;
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2 * 7);  break;
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2 * 7);  break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2 * 3);  break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2 * 3);  break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);    break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char*)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			std::memset(cTxt, 0, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			std::memset(cTxt2, 0, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			std::memset(pStr1, 0, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else
		{
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

void CGame::_CalcSocketClosed()
{
	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{
		delete m_pGSock;
		m_pGSock = 0;
		m_bEscPressed = false;
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		ChangeGameMode(DEF_GAMEMODE_ONQUIT);
	}
}

void CGame::PointCommandHandler(int indexX, int indexY, char cItemID)
{
	char cTemp[31];
	if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200))
	{
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_MAGIC, 0, indexX, indexY, m_iPointCommandType, 0);
	}
	else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50))
	{
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, 0, m_iPointCommandType, indexX, indexY, cTemp, cItemID); // v1.4

		if (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			m_bSkillUsingStatus = true;
	}
	else if (m_iPointCommandType == 200) // Normal Hand
	{
		if ((strlen(m_cMCName) == 0) || (strcmp(m_cMCName, m_cPlayerName) == 0) || (m_cMCName[0] == '_'))
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 0;
			PlaySound('E', 14, 5);
			AddEventList(POINT_COMMAND_HANDLER1, 10);
		}
		else
		{
			m_dialogBoxManager.Info(DialogBoxId::Party).cMode = 3;
			PlaySound('E', 14, 5);
			std::memset(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::Party).cStr));
			strcpy(m_dialogBoxManager.Info(DialogBoxId::Party).cStr, m_cMCName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, 0, 1, 0, 0, m_cMCName);
			return;
		}
	}
}

// File-scope static variables for OnGame screen
// Shared between UpdateScreen_OnGame and DrawScreen_OnGame
static short s_sOnGameMsX, s_sOnGameMsY, s_sOnGameMsZ;
static char s_cOnGameLB, s_cOnGameRB;
static uint32_t s_dwOnGameTime;
static short s_sOnGameDivX, s_sOnGameModX, s_sOnGameDivY, s_sOnGameModY;
static short s_sOnGamePivotX, s_sOnGamePivotY;
static short s_sOnGameVPXsave, s_sOnGameVPYsave;
static DWORD s_dwOnGamePrevChatTime = 0;

// OnGame screen - Update phase (logic/input handling)
void CGame::UpdateScreen_OnGame()
{
	short sVal, absX, absY, tX, tY;
	int i, iAmount;

	s_dwOnGameTime = GameClock::GetTimeMS();

	if (m_cGameModeCount == 0)
	{
		m_dwFPStime = m_dwCheckConnTime = m_dwCheckSprTime = m_dwCheckChatTime = s_dwOnGameTime;
		m_sFrameCount = 0;
		if (AudioManager::Get().IsMusicEnabled()) StartBGM();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 20) m_cGameModeCount = 20;

	m_DInput.UpdateMouseState(&s_sOnGameMsX, &s_sOnGameMsY, &s_sOnGameMsZ, &s_cOnGameLB, &s_cOnGameRB);
	m_dwCurTime = GameClock::GetTimeMS();

	// Sync manager singletons with game state
	// Camera: sync view position (pixel coords to tile coords)
	Camera::Get().SetViewPosition(m_sViewPointX / 32, m_sViewPointY / 32);

	// AudioManager: update listener position to player location
	AudioManager::Get().SetListenerPosition(m_sPlayerX, m_sPlayerY);

	// WeatherManager: sync with legacy weather status
	WeatherType currentWeather = WeatherManager::FromLegacyWeather(m_cWhetherStatus);
	if (WeatherManager::Get().GetCurrentWeather() != currentWeather)
	{
		WeatherManager::Get().SetWeatherImmediate(currentWeather);
	}

	// Enter key handling
	if (m_bEnterPressed == true)
	{
		m_bEnterPressed = false;

		if ((m_dialogBoxManager.IsEnabled(DialogBoxId::GuildMenu) == true) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::GuildMenu)) {
			EndInputString();
			m_bEnterPressed = false;
			if (strlen(m_cGuildName) == 0) return;
			if (strcmp(m_cGuildName, "NONE") != 0) {
				bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
				m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 2;
			}
		}
		else if ((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::ItemDropExternal)) {
			EndInputString();

			if (m_bSkillUsingStatus == true) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) && ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2))) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if ((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true) || (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true) || (m_dialogBoxManager.IsEnabled(DialogBoxId::Manufacture) == true)) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if (strlen(m_cAmountString) == 0) return;
			iAmount = atoi(m_cAmountString);

			if ((int)(m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount) < iAmount) {
				iAmount = m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount;
			}

			if (iAmount != 0) {
				if ((int)(m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_dwCount) >= iAmount) {
					if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 != 0) {
						absX = abs(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 - m_sPlayerX);
						absY = abs(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 - m_sPlayerY);

						if ((absX == 0) && (absY == 0))
							AddEventList(UPDATE_SCREEN_ONGAME5, 10);
						else if ((absX <= 8) && (absY <= 8)) {
							switch (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3) {
							case 1: case 2: case 3: case 4: case 5: case 6:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 1, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								strcpy(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr);
								break;
							case 20:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 3, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV5 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV6 = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								GetNpcName(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
								break;
							case 15: case 24:
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 2, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3);
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = iAmount;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV4 = m_wCommObjectID;
								tX = s_sOnGameMsX - 117; tY = s_sOnGameMsY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX; m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								std::memset(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr));
								GetNpcName(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3, m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cStr);
								break;
							case 1000:
								if (m_stDialogBoxExchangeInfo[0].sV1 == -1) m_stDialogBoxExchangeInfo[0].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[1].sV1 == -1) m_stDialogBoxExchangeInfo[1].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[2].sV1 == -1) m_stDialogBoxExchangeInfo[2].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else if (m_stDialogBoxExchangeInfo[3].sV1 == -1) m_stDialogBoxExchangeInfo[3].sItemID = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
								else return;
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, 0, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4, iAmount, 0, 0);
								break;
							case 1001:
								for (i = 0; i < DEF_MAXSELLLIST; i++)
									if (m_stSellItemList[i].iIndex == -1) {
										m_stSellItemList[i].iIndex = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4;
										m_stSellItemList[i].iAmount = iAmount;
										m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4] = true;
										break;
									}
								if (i == DEF_MAXSELLLIST) AddEventList(UPDATE_SCREEN_ONGAME6, 10);
								break;
							case 1002:
								if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS - 1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
								else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, iAmount, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4);
								break;
							default:
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, (char)(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView), iAmount, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_cName);
								break;
							}
							m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = true;
						}
						else AddEventList(UPDATE_SCREEN_ONGAME7, 10);
					}
					else {
						if (iAmount <= 0) AddEventList(UPDATE_SCREEN_ONGAME8, 10);
						else {
							bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, 0, m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView, iAmount, 0, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView]->m_cName);
							m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sView] = true;
						}
					}
				}
				else AddEventList(UPDATE_SCREEN_ONGAME9, 10);
			}
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ItemDropExternal);
		}
		else
		{
			if (!m_bInputStatus) {
				switch (m_cBackupChatMsg[0]) {
				case '!': case '@': case '#': case '$': case '^':
					std::memset(m_cChatMsg, 0, sizeof(m_cChatMsg));
					m_cChatMsg[0] = m_cBackupChatMsg[0];
					StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
					break;
				default:
					StartInputString(CHAT_INPUT_X, CHAT_INPUT_Y, sizeof(m_cChatMsg), m_cChatMsg);
					ClearInputString();
					break;
				}
			}
			else {
				EndInputString();
				std::memset(G_cTxt, 0, sizeof(G_cTxt));
				ReceiveString((char*)G_cTxt);
				std::memset(m_cBackupChatMsg, 0, sizeof(m_cBackupChatMsg));
				strcpy(m_cBackupChatMsg, G_cTxt);
				if ((m_dwCurTime - s_dwOnGamePrevChatTime) >= 700) {
					s_dwOnGamePrevChatTime = m_dwCurTime;
					m_curse.ConvertString(G_cTxt, strlen(G_cTxt));
					if (strlen(G_cTxt) > 0) {
						if ((G_cTxt[0] == '!') || (G_cTxt[0] == '~')) {
							if (CMisc::bCheckIMEString(G_cTxt) == false) return;
						}
						bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, G_cTxt);
					}
				}
			}
		}
	}

	// Save viewport and apply camera shake
	s_sOnGameVPXsave = m_sViewPointX;
	s_sOnGameVPYsave = m_sViewPointY;

	if (m_iCameraShakingDegree > 0) {
		m_sViewPointX += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree * 2);
		m_sViewPointY += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree * 2);
		m_iCameraShakingDegree--;
		if (m_iCameraShakingDegree <= 0) m_iCameraShakingDegree = 0;
	}

	// Calculate viewport tile coordinates
	s_sOnGamePivotX = m_pMapData->m_sPivotX;
	s_sOnGamePivotY = m_pMapData->m_sPivotY;
	sVal = m_sViewPointX - (s_sOnGamePivotX * 32);
	s_sOnGameDivX = sVal / 32;
	s_sOnGameModX = sVal % 32;
	sVal = m_sViewPointY - (s_sOnGamePivotY * 32);
	s_sOnGameDivY = sVal / 32;
	s_sOnGameModY = sVal % 32;

	// Logout countdown
	if (m_cLogOutCount > 0) {
		if ((s_dwOnGameTime - m_dwLogOutCountTime) > 1000) {
			m_cLogOutCount--;
			m_dwLogOutCountTime = s_dwOnGameTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME13, m_cLogOutCount);
			AddEventList(G_cTxt, 10);
		}
	}
	if (m_cLogOutCount == 0) {
		WriteSettings(); // Save settings on logout
		delete m_pGSock;
		m_pGSock = 0;
		m_bEscPressed = false;
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}

	// Restart countdown
	if (m_cRestartCount > 0) {
		if ((s_dwOnGameTime - m_dwRestartCountTime) > 1000) {
			m_cRestartCount--;
			m_dwRestartCountTime = s_dwOnGameTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME14, m_cRestartCount);
			AddEventList(G_cTxt, 10);
		}
	}
	if (m_cRestartCount == 0) {
		m_cRestartCount = -1;
		bSendCommand(MSGID_REQUEST_RESTART, 0, 0, 0, 0, 0, 0);
		return;
	}

	// Update frame counters and process commands
	int iUpdateRet = m_pMapData->iObjectFrameCounter(m_cPlayerName, m_sViewPointX, m_sViewPointY);
	bEffectFrameCounter();
	if (iUpdateRet == 2) {
		m_bCommandAvailable = true;
		m_dwCommandTime = 0;
	}
	CommandProcessor(s_sOnGameMsX, s_sOnGameMsY,
		((s_sOnGameDivX + s_sOnGamePivotX) * 32 + s_sOnGameModX + s_sOnGameMsX - 17) / 32 + 1,
		((s_sOnGameDivY + s_sOnGamePivotY) * 32 + s_sOnGameModY + s_sOnGameMsY - 17) / 32 + 1,
		s_cOnGameLB, s_cOnGameRB);

	// Restore viewport
	m_sViewPointX = s_sOnGameVPXsave;
	m_sViewPointY = s_sOnGameVPYsave;

	if (iUpdateRet > 0) CalcViewPoint();

	// Observer mode camera
	if (m_bIsObserverMode) {
		if ((s_dwOnGameTime - m_dwObserverCamTime) > 25) {
			m_dwObserverCamTime = s_dwOnGameTime;
			CalcViewPoint();
		}
	}

	// Draw flag animation
	if (m_bDrawFlagDir == false) {
		m_iDrawFlag++;
		if (m_iDrawFlag >= 25) { m_iDrawFlag = 25; m_bDrawFlagDir = true; }
	}
	else {
		m_iDrawFlag--;
		if (m_iDrawFlag < 0) { m_iDrawFlag = 0; m_bDrawFlagDir = false; }
	}
}

// OnGame screen - Draw phase (rendering only)
void CGame::DrawScreen_OnGame()
{
	char cItemColor;

	// Main scene rendering
	DrawBackground(s_sOnGameDivX, s_sOnGameModX, s_sOnGameDivY, s_sOnGameModY);
	DrawEffectLights();
	DrawObjects(s_sOnGamePivotX, s_sOnGamePivotY, s_sOnGameDivX, s_sOnGameDivY, s_sOnGameModX, s_sOnGameModY, s_sOnGameMsX, s_sOnGameMsY);
	DrawEffects();
	DrawWhetherEffects();
	DrawChatMsgs(-100, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
	WhetherObjectFrameCounter();

	// Apocalypse map effects
	if (m_cMapIndex == 26) {
		m_pEffectSpr[89]->PutTransSprite(1296 - m_sViewPointX, 1283 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[89]->PutTransSprite(1520 - m_sViewPointX, 1123 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[89]->PutTransSprite(1488 - m_sViewPointX, 3971 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[93]->PutTransSprite(2574 - m_sViewPointX, 3677 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[93]->PutTransSprite(3018 - m_sViewPointX, 3973 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
	}
	else if (m_cMapIndex == 27) {
		m_pEffectSpr[89]->PutTransSprite(1293 - m_sViewPointX, 3657 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[89]->PutTransSprite(944 - m_sViewPointX, 3881 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[89]->PutTransSprite(1325 - m_sViewPointX, 4137 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
		m_pEffectSpr[89]->PutTransSprite(1648 - m_sViewPointX, 3913 - m_sViewPointY, _tmp_iEffectFrame % 12, 0);
	}

	// Apocalypse gate
	if ((m_iGatePositX >= m_sViewPointX / 32) && (m_iGatePositX <= m_sViewPointX / 32 + VIEW_TILE_WIDTH)
		&& (m_iGatePositY >= m_sViewPointY / 32) && (m_iGatePositY <= m_sViewPointY / 32 + VIEW_TILE_HEIGHT)) {
		m_pEffectSpr[101]->PutTransSprite(m_iGatePositX * 32 - m_sViewPointX - 96, m_iGatePositY * 32 - m_sViewPointY - 69, _tmp_iEffectFrame % 30, s_dwOnGameTime);
	}

	// UI rendering
	m_dialogBoxManager.DrawDialogBoxs(s_sOnGameMsX, s_sOnGameMsY, s_sOnGameMsZ, s_cOnGameLB);

	if (m_bInputStatus) {
		if (((m_dialogBoxManager.IsEnabled(DialogBoxId::GuildMenu) == true) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1)) ||
			((m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1))) {
		}
		else m_DDraw.DrawShadowBox(0, LOGICAL_HEIGHT - 69, LOGICAL_MAX_X, LOGICAL_HEIGHT - 51);
		ShowReceivedString();
	}

	ShowEventList(m_dwCurTime);

	// Item tooltip on cursor
	if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) &&
		(m_pItemList[m_stMCursor.sSelectedObjectID] != 0)) {
		cItemColor = m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemColor;
		if (cItemColor != 0) {
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(
					s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY,
					m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame,
					m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], s_dwOnGameTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(
					s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY,
					m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame,
					m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], s_dwOnGameTime);
			}
		}
		else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteFast(
			s_sOnGameMsX - m_stMCursor.sDistX, s_sOnGameMsY - m_stMCursor.sDistY,
			m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, s_dwOnGameTime);

		char cStr1[64], cStr2[64], cStr3[64];
		int iLoc;
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		iLoc = 0;
		if (strlen(cStr1) != 0) {
			if (m_bIsSpecial) PutString(s_sOnGameMsX, s_sOnGameMsY + 25, cStr1, RGB(0, 255, 50), false, 1);
			else PutString(s_sOnGameMsX, s_sOnGameMsY + 25, cStr1, RGB(255, 255, 255), false, 1);
			iLoc += 15;
		}
		if (strlen(cStr2) != 0) { PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, cStr2, RGB(150, 150, 150), false, 1); iLoc += 15; }
		if (strlen(cStr3) != 0) { PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, cStr3, RGB(150, 150, 150), false, 1); iLoc += 15; }
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit != 0) && ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_dwAttribute & 0x00000001) == 0)) {
			wsprintf(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight >= 1100)) {
			int _wWeight = 0;
			if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight % 100) _wWeight = 1;
			wsprintf(G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight / 100 + _wWeight);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) {
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME10, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wCurLifeSpan, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wMaxLifeSpan);
			PutString(s_sOnGameMsX, s_sOnGameMsY + 25 + iLoc, G_cTxt, RGB(150, 150, 150), false, 1); iLoc += 15;
		}
		if (iLoc == 15) {
			iLoc = 0;
			for (int iTmp = 0; iTmp < DEF_MAXITEMS; iTmp++) {
				if (m_pItemList[iTmp] != 0) {
					if (strcmp(m_pItemList[iTmp]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName) == 0) iLoc++;
				}
			}
			if (iLoc > 1) {
				wsprintf(G_cTxt, DEF_MSG_TOTAL_NUMBER, iLoc);
				PutString(s_sOnGameMsX, s_sOnGameMsY + 40, G_cTxt, RGB(150, 150, 150), false, 1);
			}
		}
	}

	// Druncncity bubbles
	if (m_cMapIndex == 25)
		bAddNewEffect(13, m_sViewPointX + rand() % LOGICAL_MAX_X, m_sViewPointY + rand() % LOGICAL_MAX_Y, 0, 0, -1 * (rand() % 80), 1);

	// Heldenian tower count
	if ((m_iHeldenianAresdenLeftTower != -1) && (memcmp(m_cCurLocation, "BtField", 7) == 0)) {
		wsprintf(G_cTxt, "Aresden Flags : %d", m_iHeldenianAresdenFlags);
		PutString(10, 140, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Aresden Flags : %d", m_iHeldenianElvineFlags);
		PutString(10, 160, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Aresden's rest building number : %d", m_iHeldenianAresdenLeftTower);
		PutString(10, 180, G_cTxt, RGB(255, 255, 255));
		wsprintf(G_cTxt, "Elvine's rest building number : %d", m_iHeldenianElvineLeftTower);
		PutString(10, 200, G_cTxt, RGB(255, 255, 255));
	}

	DrawTopMsg();

#ifdef _DEBUG
	wsprintf(G_cTxt, "M(%d,%d) T(%d,%d)", s_sOnGameMsX, s_sOnGameMsY, (m_sViewPointX + s_sOnGameMsX + 16) / 32, (m_sViewPointY + s_sOnGameMsY + 16) / 32);
	PutString(s_sOnGameMsX, s_sOnGameMsY + 30, G_cTxt, RGB(255, 255, 255));
#endif

	// Fade-in overlay
	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);
	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0, 0, LOGICAL_MAX_X, LOGICAL_MAX_Y);

	// Cursor
	if (m_bIsObserverMode == true) {
		m_DDraw.PutPixel(s_sOnGameMsX, s_sOnGameMsY, 255, 255, 255);
		m_DDraw.PutPixel(s_sOnGameMsX + 1, s_sOnGameMsY, 255, 255, 255);
		m_DDraw.PutPixel(s_sOnGameMsX - 1, s_sOnGameMsY, 255, 255, 255);
		m_DDraw.PutPixel(s_sOnGameMsX, s_sOnGameMsY + 1, 255, 255, 255);
		m_DDraw.PutPixel(s_sOnGameMsX, s_sOnGameMsY - 1, 255, 255, 255);
	}
	else m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(s_sOnGameMsX, s_sOnGameMsY, m_stMCursor.sCursorFrame, s_dwOnGameTime);

	// FPS display
	if (m_bShowFPS) {
		wsprintf(G_cTxt, "fps : %u", FrameTiming::GetFPS());
		PutString(10, 100, G_cTxt, RGB(255, 255, 255));
	}
}

void CGame::StartBGM()
{
	// Determine track name based on current location
	const char* trackName = "MainTm";

	if ((m_bIsXmas == true) && (m_cWhetherEffectType >= 4))
	{
		trackName = "Carol";
	}
	else if (memcmp(m_cCurLocation, "aresden", 7) == 0)
	{
		trackName = "aresden";
	}
	else if (memcmp(m_cCurLocation, "elvine", 6) == 0)
	{
		trackName = "elvine";
	}
	else if (memcmp(m_cCurLocation, "dglv", 4) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "middled1", 8) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "middleland", 10) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "druncncity", 10) == 0)
	{
		trackName = "druncncity";
	}
	else if (memcmp(m_cCurLocation, "inferniaA", 9) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "inferniaB", 9) == 0)
	{
		trackName = "middleland";
	}
	else if (memcmp(m_cCurLocation, "maze", 4) == 0)
	{
		trackName = "dungeon";
	}
	else if (memcmp(m_cCurLocation, "abaddon", 7) == 0)
	{
		trackName = "abaddon";
	}

	// Forward to AudioManager
	AudioManager::Get().PlayMusic(trackName);
}

void CGame::MotionResponseHandler(char* pData)
{
	WORD wResponse;
	short sX, sY;
	char cDir;
	int iPreHP;
	//						          0 3        4 5						 6 7		8 9		   10	    11
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_CONFIRM(2) | Loc-X(2) | Loc-Y(2) | Dir(1) | MapData ...
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_REJECT(2)  | Loc-X(2) | Loc-Y(2)
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wResponse = header->msg_type;

	switch (wResponse) {
	case DEF_OBJECTMOTION_CONFIRM:
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_ATTACK_CONFIRM:
		m_cCommandCount--;
		if ((m_wLastAttackTargetID >= 10000) && (m_wLastAttackTargetID < 30000)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETNPCHP, 0, m_wLastAttackTargetID, 0, 0, 0);
		}
		break;

	case DEF_OBJECTMOTION_REJECT:
		if (m_iHP <= 0) return;
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionReject>(
				pData, sizeof(hb::net::PacketResponseMotionReject));
			if (!pkt) return;
			m_sPlayerX = pkt->x;
			m_sPlayerY = pkt->y;
		}

		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;

		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = false;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;

		m_bIsRedrawPDBGS = true;
		break;

	case DEF_OBJECTMOVE_CONFIRM:
	{
		const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionMoveConfirm>(
			pData, sizeof(hb::net::PacketResponseMotionMoveConfirm));
		if (!pkt) return;
		sX = pkt->x;
		sY = pkt->y;
		cDir = static_cast<char>(pkt->dir);
		m_iSP = m_iSP - pkt->stamina_cost;
		if (m_iSP < 0) m_iSP = 0;
		// v1.3
		//m_iOccupyStatus = (int)*cp;
		iPreHP = m_iHP;
		m_iHP = pkt->hp;

		if (m_iHP != iPreHP)
		{
			if (m_iHP < iPreHP)
			{
				wsprintf(G_cTxt, NOTIFYMSG_HP_DOWN, iPreHP - m_iHP);
				AddEventList(G_cTxt, 10);
				m_dwDamagedTime = GameClock::GetTimeMS();
				if ((m_cLogOutCount > 0) && (m_bForceDisconn == false))
				{
					m_cLogOutCount = -1;
					AddEventList(MOTION_RESPONSE_HANDLER2, 10);
				}
			}
			else
			{
				wsprintf(G_cTxt, NOTIFYMSG_HP_UP, m_iHP - iPreHP);
				AddEventList(G_cTxt, 10);
			}
		}
		m_pMapData->ShiftMapData(cDir);
		const char* mapData = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseMotionMoveConfirm);
		_ReadMapData(sX, sY, mapData);
		m_bIsRedrawPDBGS = true;
		m_cCommandCount--;
	}
	break;

	case DEF_OBJECTMOVE_REJECT:
		if (m_iHP <= 0) return;
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseMotionMoveReject>(
				pData, sizeof(hb::net::PacketResponseMotionMoveReject));
			if (!pkt) return;
			if (m_sPlayerObjectID != pkt->object_id) return;
			m_sPlayerX = pkt->x;
			m_sPlayerY = pkt->y;
			m_sPlayerType = pkt->type;
			m_cPlayerDir = static_cast<char>(pkt->dir);
			m_sPlayerAppr1 = pkt->appr1;
			m_sPlayerAppr2 = pkt->appr2;
			m_sPlayerAppr3 = pkt->appr3;
			m_sPlayerAppr4 = pkt->appr4;
			m_iPlayerApprColor = pkt->appr_color;
			m_iPlayerStatus = pkt->status;
		}
		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0,
			0, 7);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = false;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;
		m_bIsPrevMoveBlocked = true;
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 12, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 13, 0);
			break;
		}
		//m_bCommandAvailable = true;
		break;
	}
}


void CGame::CommandProcessor(short msX, short msY, short indexX, short indexY, char cLB, char cRB)
{
	char   cDir, absX, absY, cName[12];
	short  sX, sY, sObjectType, tX, tY;
	int iObjectStatus;
	int    iRet;
	uint32_t dwTime = GameClock::GetTimeMS();
	uint16_t wType = 0;
	int i;//, iFOE;
	char   cTxt[120];

	char  pDstName[21];
	short sDstOwnerType;
	int iDstOwnerStatus;

	bool  bGORet;
	// Fixed by Snoopy
	if ((m_bIsObserverCommanded == false) && (m_bIsObserverMode == true))
	{
		if ((msX == 0) && (msY == 0) && (m_sViewDstX > 32 * VIEW_TILE_WIDTH) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 8, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (msY == 0) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 2, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (msY == LOGICAL_MAX_Y) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 4, 0, 0, 0, 0);
		else if ((msX == 0) && (msY == LOGICAL_MAX_Y))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 6, 0, 0, 0, 0);
		else if ((msX == 0) && (m_sViewDstX > 32 * VIEW_TILE_WIDTH))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 7, 0, 0, 0, 0);
		else if ((msX == LOGICAL_MAX_X) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * VIEW_TILE_WIDTH))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 3, 0, 0, 0, 0);
		else if ((msY == 0) && (m_sViewDstY > 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 1, 0, 0, 0, 0);
		else if ((msY == LOGICAL_MAX_Y) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * VIEW_TILE_HEIGHT))
			bSendCommand(MSGID_REQUEST_PANNING, 0, 5, 0, 0, 0, 0);
		else return;

		m_bIsObserverCommanded = true;
		m_cArrowPressed = 0;
		return;
	}

	if (m_bIsObserverMode == true) return;

	if (GetAsyncKeyState(VK_MENU) >> 15) // [ALT]
		m_bSuperAttackMode = true;
	else m_bSuperAttackMode = false;

	switch (m_stMCursor.cPrevStatus) {
	case DEF_CURSORSTATUS_NULL:
		if (cLB != 0)
		{
			iRet = _iCheckDlgBoxFocus(msX, msY, 1);
			if (iRet == 1)
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_SELECTED;
				return;
			}
			else if (iRet == 0)
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_PRESSED;
				// Snoopy: Added Golden LevelUp
				if ((msX > LEVELUP_TEXT_X) && (msX < (LEVELUP_TEXT_X)+75) && (msY > LEVELUP_TEXT_Y) && (msY < (LEVELUP_TEXT_Y)+21))
				{
					if (m_iHP > 0)
					{
						if ((m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) != true) && (m_iLU_Point > 0))
						{
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::LevelUpSetting, 0, 0, 0);
							PlaySound('E', 14, 5);
						}
					}
					else // Centuu : restart
					{
						if (m_cRestartCount == -1)
						{
							m_cRestartCount = 5;
							m_dwRestartCountTime = GameClock::GetTimeMS();
							wsprintf(G_cTxt, DLGBOX_CLICK_SYSMENU1, m_cRestartCount); // "Restarting game....%d"
							AddEventList(G_cTxt, 10);
							PlaySound('E', 14, 5);

						}
					}
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
					return;
				}
			}
			else if (iRet == -1)
			{
				return;
			}
		}
		else if (cRB != 0)
		{
			iRet = _iCheckDlgBoxFocus(msX, msY, 2);
			if (iRet == 1) return;
		}
		break;
	case DEF_CURSORSTATUS_PRESSED:
		if (cLB == 0) // Normal Click
		{
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
		}
		break;
	case DEF_CURSORSTATUS_SELECTED:
		if (cLB == 0)
		{
			//ZeroEoyPnk - Bye delay...
			if (((m_dialogBoxManager.IsEnabled(DialogBoxId::LevelUpSetting) != true) || (m_stMCursor.sSelectedObjectID != 12))
				&& ((m_dialogBoxManager.IsEnabled(DialogBoxId::ChangeStatsMajestic) != true) || (m_stMCursor.sSelectedObjectID != 42)))
			{
				if (((dwTime - m_stMCursor.dwSelectClickTime) < DEF_DOUBLECLICKTIME) 	// Double Click
					&& (msX == m_stMCursor.sClickX) && (msY == m_stMCursor.sClickY))
				{
					m_stMCursor.dwSelectClickTime = m_stMCursor.dwSelectClickTime;
					m_dialogBoxManager._bCheckDlgBoxDoubleClick(msX, msY);
				}
				else // Click
				{
					m_dialogBoxManager._bCheckDlgBoxClick(msX, msY);
					m_stMCursor.sClickX = msX;
					m_stMCursor.sClickY = msY;
				}
			}
			else
			{
				m_dialogBoxManager._bCheckDlgBoxClick(msX, msY);
				m_stMCursor.sClickX = msX;
				m_stMCursor.sClickY = msY;
			}
			m_stMCursor.dwSelectClickTime = dwTime;
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM)
			{
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
			}
			return;
		}
		else 			// v2.05 01-11-30
		{
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;

			if ((m_stMCursor.sPrevX != msX) || (m_stMCursor.sPrevY != msY))
			{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_DRAGGING;
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 30))
				{
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 1))
				{
					EndInputString();
					m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 20;
				}
				// Query Drop Item Amount
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 1))
					// Guild Menu
				{
					EndInputString();
					m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode = 20;
				}
				return;
			}
			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		break;
	case DEF_CURSORSTATUS_DRAGGING:
		if (cLB != 0)
		{
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX)
			{
				// HudPanel is fixed and cannot be moved
				if (m_stMCursor.sSelectedObjectID != DialogBoxId::HudPanel)
				{
					m_dialogBoxManager.Info(m_stMCursor.sSelectedObjectID).sX = msX - m_stMCursor.sDistX;
					m_dialogBoxManager.Info(m_stMCursor.sSelectedObjectID).sY = msY - m_stMCursor.sDistY;
				}
			}
			m_stMCursor.sPrevX = msX;
			m_stMCursor.sPrevY = msY;

			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		if (cLB == 0) {
			switch (m_stMCursor.cSelectedObjectType) {
			case DEF_SELECTEDOBJTYPE_DLGBOX:
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode == 20))
				{
					sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
					sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;
					StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
					m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 1;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode == 20))
				{	// Query Drop Item Amount
					sX = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX;
					sY = m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY;
					StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
					m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cMode = 1;
				}

				if (m_stMCursor.sSelectedObjectID == 9)
				{
					{
						if (msX < 400) //LifeX Fix Map
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX = 0;
						}
						else
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sX = LOGICAL_MAX_X - m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX;
						}

						if (msY < 273)
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY = 0;
						}
						else
						{
							m_dialogBoxManager.Info(DialogBoxId::GuideMap).sY = 547 - m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY;
						}
					}
				}

				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;

			case DEF_SELECTEDOBJTYPE_ITEM:
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;

			default:
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = 0;
				m_stMCursor.sSelectedObjectID = 0;
				break;
			}
			return;
		}
		break;
	}

CP_SKIPMOUSEBUTTONSTATUS:;
	if (m_bCommandAvailable == false) return;
	if ((dwTime - m_dwCommandTime) < 300)
	{
		delete m_pGSock;
		m_pGSock = 0;
		m_bEscPressed = false;
		PlaySound('E', 14, 5);
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}
	if (m_iHP <= 0) return;

	if (m_sDamageMove != 0)
	{
		m_cCommand = DEF_OBJECTDAMAGEMOVE;
		goto MOTION_COMMAND_PROCESS;
	}

	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0))
		RequestTeleportAndWaitData();

	// indexX, indexY
	if (cLB != 0) // Mouse Left button
	{
		if (m_bIsGetPointingMode == true)
		{
			if ((m_sMCX != 0) || (m_sMCY != 0))
				PointCommandHandler(m_sMCX, m_sMCY);
			else PointCommandHandler(indexX, indexY);

			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			m_bIsGetPointingMode = false;
			return;
		}

		m_pMapData->bGetOwner(m_sMCX, m_sMCY - 1, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID); // v1.4
		//m_pMapData->m_pData[dX][dY].m_sItemSprite
		if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && (sObjectType <= 6 || (m_pMapData->m_pData[m_sPlayerX - m_pMapData->m_sPivotX][m_sPlayerY - m_pMapData->m_sPivotY].m_sItemID != 0 && m_pItemConfigList[m_pMapData->m_pData[m_sPlayerX - m_pMapData->m_sPivotX][m_sPlayerY - m_pMapData->m_sPivotY].m_sItemID]->m_sSprite != 0)))
		{//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[15][15].m_sItemSprite != 0 )) {
		 //if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && sObjectType <= 6){
			if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/)
			{
				m_cCommand = DEF_OBJECTGETITEM;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;
			}
		}
		else
		{
			if (memcmp(m_cMCName, m_cPlayerName, 10) == 0) m_sMCY -= 1;
			if ((m_sMCX != 0) && (m_sMCY != 0)) // m_sMCX, m_sMCY
			{
				if (m_bCtrlPressed == true)
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if ((iObjectStatus & 0x10) != 0) return;
					if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;
					m_stMCursor.sCursorFrame = 3;
					absX = abs(m_sPlayerX - m_sMCX);
					absY = abs(m_sPlayerY - m_sMCY);
					if ((absX <= 1) && (absY <= 1))
					{
						wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
						&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
					{
						wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else // Pas au corp � corp
					{
						switch (_iGetWeaponSkillType()) {
						case 6: // Bow
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
							break;

						case 5: // OpenHand
						case 7: // SS
							if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
							{
								if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
								{
									if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
									{
										m_cCommand = DEF_OBJECTATTACKMOVE;
										wType = _iGetAttackType();
									}
									else
									{
										m_cCommand = DEF_OBJECTRUN;
										GetPlayerTurn();
									}
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else
								{
									m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							else
							{
								if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
									&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
									m_cCommand = DEF_OBJECTRUN;	// Staminar
								else m_cCommand = DEF_OBJECTMOVE;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								GetPlayerTurn();
							}
							break;

						case 8: // LS
							if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() != 30)) // Crit without StormBlade
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() == 30))  // Crit with StormBlade (by Snoopy)
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 3) && (absY <= 3)
								&& (_iGetAttackType() == 5))  // Normal hit with StormBlade (by Snoopy)
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else // Swing
							{
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))
									&& (_iGetAttackType() != 5)) // no Dash possible with StormBlade
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
									{
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else
										{
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else
									{
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;

						case 9: // Fencing
							if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;

						case 10: // Axe
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else
							{
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
									{
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else
										{
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else
									{
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						case 14: // Hammer
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						case 21: // Wand
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						}
					}
				}
				else // CTRL not pressed
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6)))
					{
						switch (sObjectType) { 	// CLEROTH - NPC TALK
						case 15: // ShopKeeper-W�
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 5, 11, 1);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 15;
							/*	break;
							}*/
							break;

						case 19: // Gandlf
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 16, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 19;
							/*	break;
							}*/
							break;

						case 20: // Howard
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 14, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 20;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 20;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = m_wCommObjectID;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = m_sMCX;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = m_sMCY;
							/*	break;
							}*/
							break;

						case 24: // Tom
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 5, 11, 2);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 24;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV3 = 24;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4 = m_wCommObjectID;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5 = m_sMCX;
							m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6 = m_sMCY;
							/*	break;
							}*/
							break;

						case 25: // William
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 13, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 25;
							/*	break;
							}*/
							break;

						case 26: // Kennedy
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 0, 7, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 26;
							/*	break;
							}*/
							break;

						case 21: // Guard
							if ((_iGetFOE(iObjectStatus) >= 0) && (!m_bIsCombatMode))
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 21;
							}
							break;
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							if (!m_bIsCombatMode)
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = sObjectType;
							}
							break;

						case 32: // Unicorn
							if (!m_bIsCombatMode)
							{
								m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 4, 0, 0);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
								m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 32;
							}
							break;

						case 90: // Snoopy: Gail
							/*switch (cName[0]) {
							case '1':*/
							m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcActionQuery, 6, 0, 0);
							tX = msX - 117;
							tY = msY - 50;
							if (tX < 0) tX = 0;
							if ((tX + 235) > LOGICAL_MAX_X) tX = LOGICAL_MAX_X - 235;
							if (tY < 0) tY = 0;
							if ((tY + 100) > LOGICAL_MAX_Y) tY = LOGICAL_MAX_Y - 100;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sX = tX;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sY = tY;
							m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).sV3 = 90;
							/*break;
						}*/
							break;

						default: // Other mobs
							if (_iGetFOE(iObjectStatus) >= 0) break;
							if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
							absX = abs(m_sPlayerX - m_sMCX);
							absY = abs(m_sPlayerY - m_sMCY);
							if ((absX <= 1) && (absY <= 1))
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
								&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
							{
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else // Normal hit from a range.
							{
								switch (_iGetWeaponSkillType()) {
								case 6: // Bow
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
									break;

								case 5: // Boxe
								case 7: // SS
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
									break;

								case 8: // LS
									if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
										&& (_iGetAttackType() != 30)) // Crit without StormBlade by Snoopy
									{
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
										&& (_iGetAttackType() == 30)) // Crit with StormBlade by Snoopy
									{
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else if ((absX <= 3) && (absY <= 3)
										&& (_iGetAttackType() == 5)) // Normal hit with StormBlade by Snoopy
									{
										m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 9: // Fencing
									if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
									{
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 10: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 14: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 21: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								}
							}
							break;
						}
					}
					else {
						if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
							(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
							m_cCommand = DEF_OBJECTRUN;
						else m_cCommand = DEF_OBJECTMOVE;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						GetPlayerTurn();
					}
				}
			}
			else
			{
				if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
					(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
					m_cCommand = DEF_OBJECTRUN;
				else m_cCommand = DEF_OBJECTMOVE;
				m_sCommX = indexX;
				m_sCommY = indexY;
				GetPlayerTurn();
			}
		}
	}
	else if (cRB != 0) // Mouse Right button
	{
		m_cCommand = DEF_OBJECTSTOP;
		if (m_bIsGetPointingMode == true)
		{
			m_bIsGetPointingMode = false;
			AddEventList(COMMAND_PROCESSOR1, 10);
		}
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sMCX != 0) && (m_sMCY != 0))
		{
			absX = abs(m_sPlayerX - m_sMCX);
			absY = abs(m_sPlayerY - m_sMCY);
			if (absX == 0 && absY == 0) return;

			if (m_bCtrlPressed == true)
			{
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if ((iObjectStatus & 0x10) != 0) return;
				if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;

				if ((absX <= 1) && (absY <= 1))
				{
					wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
					&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
				{
					wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else
				{
					switch (_iGetWeaponSkillType()) {
					case 6: // Bow
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						wType = _iGetAttackType();
						break;

					case 5: // Boxe
					case 7: // SS
						break;

					case 8: // LS
						if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
							&& (_iGetAttackType() != 30)) // without StormBlade by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
							&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 3) && (absY <= 3)
							&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						break;

					case 9: // Fencing
						if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 10: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 14: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					case 21: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					}
				}
			}
			else // CTRL not pressed
			{
				absX = abs(m_sPlayerX - m_sMCX);
				absY = abs(m_sPlayerY - m_sMCY);
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6))) {
					switch (sObjectType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26: // npcs
						break;

					default: // All "normal mobs"
						if (_iGetFOE(iObjectStatus) >= 0) break;
						if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
						if ((absX <= 1) && (absY <= 1))
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
						{
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else //
						{
							switch (_iGetWeaponSkillType()) {
							case 6: // Bow
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
								break;

							case 5: // Boxe
							case 7: // SS
								break;

							case 8: // LS
								if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() != 30)) // crit without StormBlade by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 3) && (absY <= 3)
									&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
								{
									wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								break;

							case 9: // fencing
								if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;

							case 10: //
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 14: // hammer
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 21: // wand
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							}
						}
						break;
					}
				}
			}
		}
		else
		{
			cDir = CMisc::cGetNextMoveDir(m_sPlayerX, m_sPlayerY, indexX, indexY);
			if (m_iHP <= 0) return;
			if (cDir == 0) return;
			if (m_cPlayerDir == cDir) return;
			ClearSkillUsingStatus();
			m_cPlayerDir = cDir;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTSTOP, m_cPlayerDir, 0, 0, 0, 0);

			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				m_cCommand, 0, 0, 0, 0,
				10);
			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			return;
		}
	}

MOTION_COMMAND_PROCESS:;

	if (m_cCommand != DEF_OBJECTSTOP)
	{
		if (m_iHP <= 0) return;
		if (m_cCommandCount == 5) AddEventList(COMMAND_PROCESSOR2, 10, false);
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sPlayerType >= 0) && (m_sPlayerType > 6))
		{
			switch (m_cCommand) {
			case DEF_OBJECTRUN:
			case DEF_OBJECTMAGIC:
			case DEF_OBJECTGETITEM:
				m_cCommand = DEF_OBJECTSTOP;
				break;
			}
		}

		ClearSkillUsingStatus();

		if ((m_sDamageMove != 0) || (m_sDamageMoveAmount != 0))
		{
			if (m_sDamageMove != 0)
			{
				m_cCommand = DEF_OBJECTDAMAGEMOVE;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;

				// mim crit fixed by kaozures tocado para ande bien by cloud :P
				if (m_bIllusionMVT == true) {
					switch (m_sDamageMove) {
					case 1: m_sCommY++; break;
					case 2: m_sCommX--; m_sCommY++; break;
					case 3: m_sCommX--; break;
					case 4: m_sCommX--; m_sCommY--; break;
					case 5: m_sCommY--; break;
					case 6: m_sCommX++; m_sCommY--; break;
					case 7: m_sCommX++; break;
					case 8: m_sCommX++; m_sCommY++; break;
					}
				}
				else {
					switch (m_sDamageMove) {
					case 1: m_sCommY--; break;
					case 2: m_sCommX++; m_sCommY--; break;
					case 3: m_sCommX++; break;
					case 4: m_sCommX++; m_sCommY++; break;
					case 5: m_sCommY++; break;
					case 6: m_sCommX--; m_sCommY++; break;
					case 7: m_sCommX--; break;
					case 8: m_sCommX--; m_sCommY--; break;
					}
				}
			}

			for (i = 1; i < DEF_MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					std::memset(cTxt, 0, sizeof(cTxt));
					if (m_sDamageMoveAmount > 0)
						wsprintf(cTxt, "-%dPts", m_sDamageMoveAmount); //pts
					else strcpy(cTxt, "Critical!");

					int iFontType;
					if ((m_sDamageMoveAmount >= 0) && (m_sDamageMoveAmount < 12))		iFontType = 21;
					else if ((m_sDamageMoveAmount >= 12) && (m_sDamageMoveAmount < 40)) iFontType = 22;
					else if ((m_sDamageMoveAmount >= 40) || (m_sDamageMoveAmount < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

					if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false) {
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					break;
				}
			m_sDamageMove = 0;
			m_sDamageMoveAmount = 0;
		}

		switch (m_cCommand) {
		case DEF_OBJECTRUN:
		case DEF_OBJECTMOVE:
		case DEF_OBJECTDAMAGEMOVE: // v1.43

			if (m_bParalyze) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID); // v1.4

			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				(bGORet == true) && (sDstOwnerType != 0))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 2) && (abs(m_sPlayerY - m_sCommY) <= 2) &&
				(m_pMapData->m_tile[m_sCommX][m_sCommY].m_bIsMoveAllowed == false))
				m_cCommand = DEF_OBJECTSTOP;
			else
			{
				if (m_cCommand == DEF_OBJECTMOVE)
				{
					if (m_bRunningMode || m_bShiftPressed) m_cCommand = DEF_OBJECTRUN;
				}
				if (m_cCommand == DEF_OBJECTRUN)
				{
					if ((m_bRunningMode == false) && (m_bShiftPressed == false)) m_cCommand = DEF_OBJECTMOVE;
					if (m_iSP < 1) m_cCommand = DEF_OBJECTMOVE;
				}

				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true);
				// Snoopy: Illusion Movement
				if ((m_bIllusionMVT == true) && (m_cCommand != DEF_OBJECTDAMAGEMOVE))
				{
					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, true);
				}
				if (cDir != 0)
				{
					m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, m_cCommand, cDir, 0, 0, 0, 0);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}
					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
						m_iPlayerStatus, m_cPlayerName,
						m_cCommand, 0, 0, 0);
					m_bCommandAvailable = false;
					m_dwCommandTime = GameClock::GetTimeMS();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}

			if (m_cCommand == DEF_OBJECTDAMAGEMOVE)
			{
				m_bIsGetPointingMode = false;
				m_iPointCommandType = -1;
				m_stMCursor.sCursorFrame = 0;
				ClearSkillUsingStatus();
				m_cCommand = DEF_OBJECTSTOP;
			}
			break;

		case DEF_OBJECTATTACK:
			cDir = CMisc::cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY);
			// Snoopy: Illusion movement
			if (m_bIllusionMVT == true)
			{
				cDir += 4;
				if (cDir > 8) cDir -= 8;
			}
			if (cDir != 0)
			{
				if ((wType == 2) || (wType == 25))
				{
					if (_bCheckItemByType(DEF_ITEMTYPE_ARROW) == false)
						wType = 0;
				}
				if (wType >= 20)
				{
					m_iSuperAttackLeft--;
					if (m_iSuperAttackLeft < 0) m_iSuperAttackLeft = 0;
				}
				m_cPlayerDir = cDir;
				m_wLastAttackTargetID = m_wCommObjectID;
				bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACK, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
					m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
					m_iPlayerStatus, m_cPlayerName,
					DEF_OBJECTATTACK,
					m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
				m_bCommandAvailable = false;
				m_dwCommandTime = GameClock::GetTimeMS();
			}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTATTACKMOVE:
			if (m_bParalyze) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID);
			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				(bGORet == true) && (sDstOwnerType != 0))
				m_cCommand = DEF_OBJECTSTOP;
			else
			{
				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true);
				// Snoopy: Illusion mvt
				if (m_bIllusionMVT == true)
				{
					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, true);
				}
				if (cDir != 0)
				{
					m_cPlayerDir = cDir;
					m_wLastAttackTargetID = m_wCommObjectID;
					bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACKMOVE, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}

					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
						m_iPlayerStatus, m_cPlayerName,
						m_cCommand, m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
					m_bCommandAvailable = false;
					m_dwCommandTime = GameClock::GetTimeMS();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTGETITEM:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTGETITEM, m_cPlayerDir, 0, 0, 0, 0);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				DEF_OBJECTGETITEM, 0, 0, 0);
			m_bCommandAvailable = false;
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTMAGIC:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTMAGIC, m_cPlayerDir, m_iCastingMagicType, 0, 0, 0);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_iPlayerStatus, m_cPlayerName,
				DEF_OBJECTMAGIC, m_iCastingMagicType, 0, 0);
			m_bCommandAvailable = false;
			m_dwCommandTime = GameClock::GetTimeMS();
			m_bIsGetPointingMode = true;
			m_cCommand = DEF_OBJECTSTOP;
			_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
			for (i = 1; i < DEF_MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, "%s!", m_pMagicCfgList[m_iCastingMagicType]->m_cName);
					m_pChatMsgList[i] = new class CMsg(41, cTxt, GameClock::GetTimeMS());
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
					m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i);
					return;
				}
			break;

		default:
			break;
		}
	}
}

void CGame::DrawDialogBox_Bank(short msX, short msY, short msZ, char cLB)
{
	short sX, sY, szX;
	int  i, iTotalLines, iPointerLoc, iLoc;
	double d1, d2, d3;
	char cItemColor, cStr1[64], cStr2[64], cStr3[64];
	bool bFlag = false;

	sX = m_dialogBoxManager.Info(DialogBoxId::Bank).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Bank).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::Bank).sSizeX - 5;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	std::memset(cStr1, 0, sizeof(cStr1));
	std::memset(cStr2, 0, sizeof(cStr2));
	std::memset(cStr3, 0, sizeof(cStr3));
	iLoc = 45;

	switch (m_dialogBoxManager.Info(DialogBoxId::Bank).cMode) {
	case -1:
		PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, RGB(0, 0, 0));//"
		PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, RGB(0, 0, 0));//"
		break;

	case 0:
		for (i = 0; i < m_dialogBoxManager.Info(DialogBoxId::Bank).sV1; i++)
			if ((m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView] != 0) && ((i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView) < DEF_MAXBANKITEMS)) {
				GetItemName(m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView], cStr1, cStr2, cStr3);
				if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i * 15) && (msY <= sY + 124 + i * 15))
				{
					bFlag = true;

					PutAlignedString(sX, sX + szX, sY + 110 + i * 15, cStr1, 255, 255, 255);
					if (m_bIsSpecial)
						PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 0, 255, 50);
					else
						PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 255, 255, 255);

					if (strlen(cStr2) > 0)
					{
						iLoc += 15;
						PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr2, 150, 150, 150);
					}
					if (strlen(cStr3) > 0)
					{
						iLoc += 15;
						PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr3, 150, 150, 150);
					}
					if (m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sLevelLimit != 0 && m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_dwAttribute & 0x00000001)
					{
						iLoc += 15;
						wsprintf(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sLevelLimit);
						PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150);
					}

					if ((m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_wWeight >= 1100))
					{
						iLoc += 15;
						int		_wWeight = 0;
						if (m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_wWeight % 100)				_wWeight = 1;
						wsprintf(G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_wWeight / 100 + _wWeight);

						PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150);
					}

					cItemColor = m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_cItemColor;
					if (cItemColor == 0)
					{
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSprite]->PutSpriteFast(sX + 60, sY + 68, m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSpriteFrame, m_dwCurTime);
					}
					else
					{
						if ((m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
							|| (m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
							|| (m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
						{
							m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSprite]->PutSpriteRGB(sX + 60, sY + 68, m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSpriteFrame,
								m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], m_dwCurTime);
						}
						else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSprite]->PutSpriteRGB(sX + 60, sY + 68, m_pBankList[i + m_dialogBoxManager.Info(DialogBoxId::Bank).sView]->m_sSpriteFrame,
							m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], m_dwCurTime);
					}
				}
				else
				{
					if (m_bIsSpecial)
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, cStr1, 0, 255, 50);
					else
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, cStr1, 0, 0, 0);
				}
			}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXBANKITEMS; i++)
			if (m_pBankList[i] != 0) iTotalLines++;
		if (iTotalLines > m_dialogBoxManager.Info(DialogBoxId::Bank).sV1)
		{
			d1 = (double)m_dialogBoxManager.Info(DialogBoxId::Bank).sView;
			d2 = (double)(iTotalLines - m_dialogBoxManager.Info(DialogBoxId::Bank).sV1);
			d3 = (274.0f * d1) / d2;
			iPointerLoc = (int)d3;
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX + 242, sY + iPointerLoc + 35, 7);
		}
		else iPointerLoc = 0;
		if (cLB != 0 && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::Bank) && iTotalLines > m_dialogBoxManager.Info(DialogBoxId::Bank).sV1) {
			if ((msX >= sX + 230) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY - (sY + 35));
				d2 = (double)(iTotalLines - m_dialogBoxManager.Info(DialogBoxId::Bank).sV1);
				d3 = (d1 * d2) / 274.0f;
				m_dialogBoxManager.Info(DialogBoxId::Bank).sView = (int)(d3 + 0.5);
			}
			else if ((msX >= sX + 230) && (msX <= sX + 260) && (msY > sY + 10) && (msY < sY + 40)) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = 0;
		}
		else m_dialogBoxManager.Info(DialogBoxId::Bank).bIsScrollSelected = false;
		if (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::Bank && msZ != 0)
		{
			if (iTotalLines > 50) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = m_dialogBoxManager.Info(DialogBoxId::Bank).sView - msZ / 30;
			else {//
				if (msZ > 0) m_dialogBoxManager.Info(DialogBoxId::Bank).sView--;
				if (msZ < 0) m_dialogBoxManager.Info(DialogBoxId::Bank).sView++;
			}
			m_DInput.m_sZ = 0;
		}
		if (iTotalLines > m_dialogBoxManager.Info(DialogBoxId::Bank).sV1 && m_dialogBoxManager.Info(DialogBoxId::Bank).sView > iTotalLines - m_dialogBoxManager.Info(DialogBoxId::Bank).sV1) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = iTotalLines - m_dialogBoxManager.Info(DialogBoxId::Bank).sV1;
		if (iTotalLines <= m_dialogBoxManager.Info(DialogBoxId::Bank).sV1) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = 0;
		if (m_dialogBoxManager.Info(DialogBoxId::Bank).sView < 0) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = 0;
		if (bFlag == false)
		{
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_DIALOGBOX_BANK3);
			PutAlignedString(sX, sX + szX, sY + 60, DRAW_DIALOGBOX_BANK4);
			PutAlignedString(sX, sX + szX, sY + 75, DRAW_DIALOGBOX_BANK5);
		}
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::DrawDialogBox_Exchange(short msX, short msY)	(snoopy)											**
**  description			:: paints the trade windows																	**
**********************************************************************************************************************/
void CGame::DrawDialogBox_Exchange(short msX, short msY)
{
	short sX, sY, szX, sXadd;
	uint32_t dwTime = m_dwCurTime;
	char cItemColor, cTxt[120], cTxt2[128];
	char cNameStr[120], cSubStr1[120], cSubStr2[120];
	int iLoc, i;

	sX = m_dialogBoxManager.Info(DialogBoxId::Exchange).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Exchange).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::Exchange).sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWEXCHANGE, sX, sY, 0);
	switch (m_dialogBoxManager.Info(DialogBoxId::Exchange).cMode) {
	case 1: // Not yet confirmed exchange
		PutAlignedString(sX + 80, sX + 180, sY + 38, m_cPlayerName, 35, 55, 35); // my name
		if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
			PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, 35, 55, 35);
		for (i = 0; i < 8; i++) // draw items
		{
			sXadd = (58 * i) + 48; if (i > 3) sXadd += 20;
			if (m_stDialogBoxExchangeInfo[i].sV1 != -1)
			{
				cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
				if (cItemColor == 0)
				{
					m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
				}
				else
				{
					switch (m_stDialogBoxExchangeInfo[i].sV1) {//sV1 : Sprite
					case 1: //  Swds
					case 2: //  Bows
					case 3: //  Shields
					case 15: // Axes hammers
					case 17: // Wands
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
							, m_stDialogBoxExchangeInfo[i].sV2, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
						break;
					default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
						, m_stDialogBoxExchangeInfo[i].sV2, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
						break;
					}
				}
				GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1, cNameStr, cSubStr1, cSubStr2);
				// If pointer over item then show this item data
				if ((msX >= sX + sXadd - 6) && (msX <= sX + sXadd + 42)
					&& (msY >= sY + 61) && (msY <= sY + 200))
				{
					wsprintf(cTxt, "%s", cNameStr);
					if (m_bIsSpecial)
					{
						PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 0, 255, 50);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 0, 255, 50);
					}
					else
					{
						PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 35, 35, 35);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 35, 35, 35);
					}
					iLoc = 0;
					if (strlen(cSubStr1) != 0)
					{
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cSubStr1, 0, 0, 0);
						iLoc += 15;
					}
					if (strlen(cSubStr2) != 0)
					{
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cSubStr2, 0, 0, 0);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV3 != 1) // Item avec Quantity
					{
						if (m_stDialogBoxExchangeInfo[i].sV3 > 1)
						{
							DisplayCommaNumber_G_cTxt(m_stDialogBoxExchangeInfo[i].sV3);
							strcpy(cTxt2, G_cTxt);
						}
						else wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxExchangeInfo[i].sV3);
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt2, 35, 35, 35);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
					{	// Crafting Magins completion fix
						if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
						{
							if ((m_stDialogBoxExchangeInfo[i].sV2 > 5)
								&& (m_stDialogBoxExchangeInfo[i].sV2 < 10))
							{
								wsprintf(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
							}
						}
						else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
						{
							wsprintf(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
						}
						else
						{
							wsprintf(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
						}
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt, 35, 35, 35);
						iLoc += 15;
					}
					if (iLoc < 45) // Endurance
					{
						wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt, 35, 35, 35);
						iLoc += 15;
					}
				}
			}
		}
		if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 == -1))
		{
			PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE9, 55, 25, 25); // Please wait until other player decides
			PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE10, 55, 25, 25);// to exchange. If you want to cancel the
			PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE11, 55, 25, 25);// exchange press the CANCEL button now.
			PutString_SprFont(sX + 220, sY + 310, "Exchange", 15, 15, 15);
		}
		else if ((m_stDialogBoxExchangeInfo[0].sV1 == -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
		{
			PutAlignedString(sX, sX + szX, sY + 205 + 10, DRAW_DIALOGBOX_EXCHANGE12, 55, 25, 25);// Other player offered an item exchange
			PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE13, 55, 25, 25);// Select an item which you want to exc-
			PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE14, 55, 25, 25);// hange with above item, drag it to the
			PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE15, 55, 25, 25);// blank and press the EXCHANGE button.
			PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE16, 55, 25, 25);// And you can also reject an offer by
			PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE17, 55, 25, 25);// pressing the CANCEL button.
			PutString_SprFont(sX + 220, sY + 310, "Exchange", 15, 15, 15);
		}
		else if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
		{
			PutAlignedString(sX, sX + szX, sY + 205 + 10, DRAW_DIALOGBOX_EXCHANGE18, 55, 25, 25);// The preparation for item exchange
			PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE19, 55, 25, 25);// has been finished. Press the EXCHANGE
			PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE20, 55, 25, 25);// button to exchange as above. Press the
			PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE21, 55, 25, 25);// CANCEL button to cancel. Occasionally
			PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE22, 55, 25, 25);// when you press the EXCHANGE button, you
			PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE23, 55, 25, 25);// will not be able to cancel the exchange.
			if ((msX >= sX + 200) && (msX <= sX + 200 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY))
				PutString_SprFont(sX + 220, sY + 310, "Exchange", 6, 6, 20);
			else PutString_SprFont(sX + 220, sY + 310, "Exchange", 0, 0, 7);
		}
		if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)
			&& (m_dialogBoxManager.IsEnabled(DialogBoxId::ConfirmExchange) == false))
			PutString_SprFont(sX + 450, sY + 310, "Cancel", 6, 6, 20);
		else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0, 0, 7);
		break;

	case 2: // You have confirmed the exchange
		PutAlignedString(sX + 80, sX + 180, sY + 38, m_cPlayerName, 35, 55, 35); // my name
		if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
			PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, 35, 55, 35);
		for (i = 0; i < 8; i++) // draw items
		{
			sXadd = (58 * i) + 48; if (i > 3) sXadd += 20;
			if (m_stDialogBoxExchangeInfo[i].sV1 != -1)
			{
				cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
				if (cItemColor == 0)
				{
					m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
				}
				else
				{
					switch (m_stDialogBoxExchangeInfo[i].sV1) {
					case 1: // Swds
					case 2: // Bows
					case 3: // Shields
					case 15: // Axes hammers
					case 17: // Wands
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
							, m_stDialogBoxExchangeInfo[i].sV2, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
						break;
					default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
						, m_stDialogBoxExchangeInfo[i].sV2, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
						break;
					}
				}
				GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1, cNameStr, cSubStr1, cSubStr2);
				// If pointer over item then show this item data
				if ((msX >= sX + sXadd - 6) && (msX <= sX + sXadd + 42)
					&& (msY >= sY + 61) && (msY <= sY + 200))
				{
					wsprintf(cTxt, "%s", cNameStr);
					if (m_bIsSpecial)
					{
						PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 0, 255, 50);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 0, 255, 50);
					}
					else
					{
						PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 35, 35, 35);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 35, 35, 35);
					}
					iLoc = 0;
					if (strlen(cSubStr1) != 0)
					{
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cSubStr1, 0, 0, 0);
						iLoc += 15;
					}
					if (strlen(cSubStr2) != 0)
					{
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cSubStr2, 0, 0, 0);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV3 != 1) // Item avec Quantity
					{
						if (m_stDialogBoxExchangeInfo[i].sV3 > 1)
						{
							DisplayCommaNumber_G_cTxt(m_stDialogBoxExchangeInfo[i].sV3);
							strcpy(cTxt2, G_cTxt);
						}
						else wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxExchangeInfo[i].sV3);
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt2, 35, 35, 35);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
					{	// Crafting Magins completion fix
						if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
						{
							if ((m_stDialogBoxExchangeInfo[i].sV2 > 5)
								&& (m_stDialogBoxExchangeInfo[i].sV2 < 10))
							{
								wsprintf(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
							}
						}
						else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
						{
							wsprintf(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
						}
						else
						{
							wsprintf(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
						}
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt, 35, 35, 35);
						iLoc += 15;
					}
					if (iLoc < 45) // Endurance
					{
						wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);
						PutAlignedString(sX + 16, sX + 155, sY + 235 + iLoc, cTxt, 35, 35, 35);
						iLoc += 15;
					}
				}
			}
		}
		wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE33, m_stDialogBoxExchangeInfo[4].cStr2);
		PutAlignedString(sX, sX + szX, sY + 205 + 10, cTxt, 55, 25, 25);                     // Please wait until %s agrees to
		PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE34, 55, 25, 25);// exchange. The exchange can't be achieved
		PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE35, 55, 25, 25);// unless both people agree.
		PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE36, 55, 25, 25);//  If other player does not decide to exchange
		PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE37, 55, 25, 25);// you can cancel the exchange by pressing the
		PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE38, 55, 25, 25);// CANCEL button. But if other player already
		PutAlignedString(sX, sX + szX, sY + 295 + 10, DRAW_DIALOGBOX_EXCHANGE39, 55, 25, 25);// decided to exchange, you can't cancel anymore

		/*	if ( (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )
				 PutString_SprFont(sX + 450, sY + 310, "Cancel", 6,6,20);
			else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0,0,7);*/
		break;
	}
}

void CGame::DrawDialogBox_GuildMenu(short msX, short msY)
{
	short sX, sY, szX;
	int iAdjX, iAdjY;

	sX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::GuildMenu).sSizeX;

	iAdjX = -13;
	iAdjY = 30;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode) {
	case 0:
		if ((m_iGuildRank == -1) && (m_iCharisma >= 20) && (m_iLevel >= 20)) {
			if ((msX > sX + iAdjX + 80) && (msX < sX + iAdjX + 210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78))
				PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 4, 0, 50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 65, 65, 65);//"

		if (m_iGuildRank == 0) {
			if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99))
				PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 4, 0, 50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 65, 65, 65);//"

		if ((msX > sX + iAdjX + 61) && (msX < sX + iAdjX + 226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120))
			PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 255, 255, 255);//"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 4, 0, 50);//"

		if ((msX > sX + iAdjX + 60) && (msX < sX + iAdjX + 227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139))
			PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 255, 255, 255);//"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 4, 0, 50);//"

		if (m_iGuildRank == 0 && m_iFightzoneNumber == 0) {
			if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
				PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 4, 0, 50);//"

		}
		else if (m_iGuildRank == 0 && m_iFightzoneNumber > 0) {
			if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 216) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
				PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 4, 0, 50);//"

		}
		else if (m_iFightzoneNumber < 0) {
			PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 65, 65, 65);//"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 65, 65, 65);//"

		PutAlignedString(sX, sX + szX, sY + iAdjY + 205, DRAW_DIALOGBOX_GUILDMENU17);//"
		break;

	case 1:
		PutAlignedString(sX + 24, sX + 239, sY + 125, DRAW_DIALOGBOX_GUILDMENU18, 55, 25, 25);//"
		PutString(sX + 75, sY + 144, "____________________", RGB(25, 35, 25));

		if (m_dialogBoxManager.iGetTopDialogBoxIndex() != DialogBoxId::GuildMenu)
			PutString(sX + 75, sY + 140, m_cGuildName, RGB(255, 255, 255), true, false, true);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			if ((strcmp(m_cGuildName, "NONE") == 0) || (strlen(m_cGuildName) == 0)) {
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button
			}
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);//Create Highlight Button
		}
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);//Red Cancel Button
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);//Gray Cancel Button
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU19, 55, 25, 25);//"
		break;
	case 3:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU20, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 140, m_cGuildName, 55, 25, 25);
		PutAlignedString(sX, sX + szX, sY + 144, "____________________", 25, 35, 25);
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU21, 55, 25, 25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 4:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU22, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU23, 55, 25, 25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 5:
		PutAlignedString(sX, sX + szX, sY + 90, DRAW_DIALOGBOX_GUILDMENU24);
		PutAlignedString(sX, sX + szX, sY + 105, m_cGuildName, 35, 35, 35);
		PutAlignedString(sX, sX + szX, sY + 109, "____________________", 0, 0, 0);
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU25);//"
		PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU26);//"
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU27);//"
		PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_GUILDMENU28, 55, 25, 25);//"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	case 6:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU29, 55, 25, 25);//"
		break;
	case 7:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU30, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 8:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU31, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 9:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60, DRAW_DIALOGBOX_GUILDMENuint32_t);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75, DRAW_DIALOGBOX_GUILDMENU33);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU34);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU35);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU36);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 10:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU37, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 11:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60, DRAW_DIALOGBOX_GUILDMENU38);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75, DRAW_DIALOGBOX_GUILDMENU39);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU40);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU41);//
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU42);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 12:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU43, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 13:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 40, DRAW_DIALOGBOX_GUILDMENU44);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 55, DRAW_DIALOGBOX_GUILDMENU45);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 70, DRAW_DIALOGBOX_GUILDMENU46);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU47);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 100, DRAW_DIALOGBOX_GUILDMENU48);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 115, DRAW_DIALOGBOX_GUILDMENU49);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU50);//"

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
			PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
			PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
			PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
			PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
			PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
			PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
			PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(4, 0, 50));

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
			PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(255, 255, 255));
		else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(4, 0, 50));

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 14:
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU66, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU67, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU68, 55, 25, 25);//
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 15:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU69, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU70, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 16:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU71, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU72, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 17:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU73, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 18:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU74, 55, 25, 25);//"
		break;

	case 19:
		if (m_iFightzoneNumber > 0)
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET, 0, 0, 0, 0, 0);
		m_dialogBoxManager.Info(DialogBoxId::GuildMenu).cMode = 0;
		break;

	case 20:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU75, 55, 25, 25);//"
		PutString(sX + 75, sY + 144, "____________________", RGB(25, 35, 25));
		PutString(sX + 75, sY + 140, m_cGuildName, RGB(255, 255, 255), false, 2);
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 21:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 95, DRAW_DIALOGBOX_GUILDMENU76, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 110, DRAW_DIALOGBOX_GUILDMENU77, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 135, DRAW_DIALOGBOX_GUILDMENU78, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 150, DRAW_DIALOGBOX_GUILDMENU79, 55, 25, 25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 165, DRAW_DIALOGBOX_GUILDMENU80, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 22:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU81, 55, 25, 25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

void CGame::DrawDialogBox_GuildOperation(short msX, short msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildOperation).sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stGuildOpList[0].cOpMode) {
	case 1:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION1);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION2);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION3);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION4);
		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION5, 55, 25, 25);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 2:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION6);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION7);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION8);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION9);
		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION10, 55, 25, 25);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 3:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION11);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION12);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION13);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 4:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION14);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION15);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION16);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 5:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION17);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION18);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION19);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION20);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 6:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION21);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION22);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION23);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 7:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION24);
		//PutString(sX + 60, sY + 65, m_stGuildOpList[0].cName, RGB(35,35,35);
		//PutString(sX + 60, sY + 69, "____________________", RGB(0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION25);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION26);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION27);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

void CGame::DrawDialogBox_Party(short msX, short msY)
{
	short sX, sY, szX;
	int  i, iNth;
	sX = m_dialogBoxManager.Info(DialogBoxId::Party).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Party).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::Party).sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 3);

	switch (m_dialogBoxManager.Info(DialogBoxId::Party).cMode) {
	case 0:
		if (m_iPartyStatus == 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100))
				PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 4, 0, 50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 65, 65, 65);//"

		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120))
				PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 4, 0, 50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 65, 65, 65);//"

		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140))
				PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 4, 0, 50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 65, 65, 65);//"


		switch (m_iPartyStatus) {
		case 0:
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY10);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY11);//"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY12);//"
			break;

		case 1:
		case 2:
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY13);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY14);//"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY15);//"
			break;
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
		break;

	case 1: //
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY16, m_dialogBoxManager.Info(DialogBoxId::Party).cStr);
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY17);//"join the party. You can"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY18);//"share the experience by"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY19);//"the ratio of level if"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY20);//"you join the party."
		PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY21);//"Would you like to join party?"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY22);//"Click the character which"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY23);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY24);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 3:
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY26, m_dialogBoxManager.Info(DialogBoxId::Party).cStr);//"
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY27);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY28);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY29);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY30);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 4:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY31);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY32);//"

		iNth = 0;
		for (i = 0; i <= DEF_MAXPARTYMEMBERS; i++)
			if (strlen(m_stPartyMemberNameList[i].cName) != 0) {
				wsprintf(G_cTxt, "%s", m_stPartyMemberNameList[i].cName);
				PutAlignedString(sX + 17, sX + 270, sY + 140 + 15 * (iNth), G_cTxt);
				iNth++;
			}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 5:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY33);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY34);//"
		break;

	case 6:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY35);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 7:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY36);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY37);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY38);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY39);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 8:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY40);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY41);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY42);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY43);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY44);//"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY45);//"


		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 9:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY46);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY47);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY48);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY49);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY50);//"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY51);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 10:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY52);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY53);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY54);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 11: //
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY55);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	}
}

void CGame::DrawDialogBox_Quest(int msX, int msY)
{
	short sX, sY, szX;
	char cTxt[120], cTemp[21];

	sX = m_dialogBoxManager.Info(DialogBoxId::Quest).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Quest).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::Quest).sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 4);

	switch (m_dialogBoxManager.Info(DialogBoxId::Quest).cMode) {
	case 1:
		switch (m_stQuest.sQuestType) {
		case 0:
			PutAlignedString(sX, sX + szX, sY + 50 + 115 - 30, DRAW_DIALOGBOX_QUEST1, 55, 25, 25); // " You are not on a quest."
			break;

		case 1:	//  Hunt
			if (m_stQuest.bIsQuestCompleted == false)
				PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST2, 55, 25, 25); // "You are on a monster conquering quest."
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST3, 55, 25, 25); // "You accomplished the monster conquering quest."

			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, "Rest Monster : %d", m_stQuest.sCurrentCount); // Snoopy: "Rest Monster : %s"
			PutAlignedString(sX, sX + szX, sY + 50 + 20, cTxt, 55, 25, 25);  // m_stQuest.sCurrentCount

			std::memset(cTemp, 0, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
			case 5:
			case 6:
			case 7: break;
			}
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST5, cTemp); // "Client: %s"
			PutAlignedString(sX, sX + szX, sY + 50 + 45, cTxt, 55, 25, 25);

			std::memset(cTemp, 0, sizeof(cTemp));
			GetNpcName(m_stQuest.sTargetType, cTemp);
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, NPC_TALK_HANDLER16, m_stQuest.sTargetCount, cTemp);
			PutAlignedString(sX, sX + szX, sY + 50 + 60, cTxt, 55, 25, 25);

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0)
			{
				strcpy(cTxt, DRAW_DIALOGBOX_QUEST31); // "Location : Anywhere"
				PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);
			}
			else
			{
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp); // "Map : %s"
				PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);

				if (m_stQuest.sX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange); // "Position: %d, %d Range: %d block"
					PutAlignedString(sX, sX + szX, sY + 50 + 90, cTxt, 55, 25, 25);
				}
			}

			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution); // "Contribution: %d"
			PutAlignedString(sX, sX + szX, sY + 50 + 105, cTxt, 55, 25, 25);
			break;

		case 7: //
			if (m_stQuest.bIsQuestCompleted == false)
				PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST26, 55, 25, 25);
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST27, 55, 25, 25);

			std::memset(cTemp, 0, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
			case 5:
			case 6:
			case 7: break;
			}
			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST29, cTemp);
			PutAlignedString(sX, sX + szX, sY + 50 + 45, cTxt, 55, 25, 25);

			PutAlignedString(sX, sX + szX, sY + 50 + 60, DRAW_DIALOGBOX_QUEST30, 55, 25, 25);

			std::memset(cTxt, 0, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, DRAW_DIALOGBOX_QUEST31);
				PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);
			}
			else {
				std::memset(cTemp, 0, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp);
				PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);

				if (m_stQuest.sX != 0) {
					std::memset(cTxt, 0, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);
					PutAlignedString(sX, sX + szX, sY + 50 + 90, cTxt, 55, 25, 25);
				}
			}

			std::memset(cTxt, 0, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution);//" %dPoint"
			PutAlignedString(sX, sX + szX, sY + 50 + 105, cTxt, 55, 25, 25);
			break;
		}
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 50 + 115 - 30, DRAW_DIALOGBOX_QUEST35, 55, 25, 25);
		break;
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}

void CGame::DrawDialogBox_SellorRepairItem(short msX, short msY)
{
	short sX, sY;
	uint32_t dwTime = m_dwCurTime;
	char cItemID, cItemColor, cTxt[120], cTemp[120], cStr2[120], cStr3[120];

	sX = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).cMode) {
	case 1:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

		cItemID = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1;

		cItemColor = m_pItemList[cItemID]->m_cItemColor;
		if (cItemColor == 0)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
				m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else
		{
			switch (m_pItemList[cItemID]->m_sSprite) {
			case 1: // Swds
			case 2: // Bows
			case 3: // Shields
			case 15: // Axes hammers
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
					, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				break;
			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
				, m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				break;
			}
		}
		std::memset(cTemp, 0, sizeof(cTemp));
		std::memset(cStr2, 0, sizeof(cStr2));
		std::memset(cStr3, 0, sizeof(cStr3));

		GetItemName(m_pItemList[cItemID]->m_cName, m_pItemList[cItemID]->m_dwAttribute, cTemp, cStr2, cStr3);
		if (m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV4 == 1) strcpy(cTxt, cTemp);
		else wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV4, cTemp);

		if (m_bIsSpecial)
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0, 255, 50);
			PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 0, 255, 50);
		}
		else
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45, 25, 25);
			PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 45, 25, 25);
		}

		wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV2);
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45, 25, 25));
		wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM3, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV3);
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45, 25, 25));
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM4, RGB(45, 25, 25));

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 39);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 38);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 2:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);
		cItemID = m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV1;
		cItemColor = m_pItemList[cItemID]->m_cItemColor; // v1.4
		if (cItemColor == 0)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
				m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else
		{
			switch (m_pItemList[cItemID]->m_sSprite) {
			case 1: // Swds
			case 2: // Bows
			case 3: // Shields
			case 15: // Axes hammers
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
					, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				break;

			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
				, m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				break;
			}
		}
		std::memset(cTemp, 0, sizeof(cTemp));
		std::memset(cStr2, 0, sizeof(cStr2));
		std::memset(cStr3, 0, sizeof(cStr3));
		GetItemName(m_pItemList[cItemID], cTemp, cStr2, cStr3);
		wsprintf(cTxt, "%s", cTemp);
		//		PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
		//		PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		if (m_bIsSpecial)
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0, 255, 50);
			PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 0, 255, 50);
		}
		else
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45, 25, 25);
			PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 45, 25, 25);
		}
		wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV2);
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45, 25, 25));
		wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM6, m_dialogBoxManager.Info(DialogBoxId::SellOrRepair).sV3);
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45, 25, 25));
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM7, RGB(45, 25, 25));

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 43);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 42);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 3:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM8, RGB(45, 25, 25));//"
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45, 25, 25));//"
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45, 25, 25));//"
		break;

	case 4:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);

		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM11, RGB(45, 25, 25));//"
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45, 25, 25));//"
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45, 25, 25));//"
		break;
	}
}


void CGame::DrawDialogBox_SkillDlg(short msX, short msY, short msZ, char cLB)
{
	int i, iLoc, iAdjX, iAdjY;
	char cTemp[120], cTemp2[120];
	short sX, sY, szX;
	char cStr1[64], cStr2[64], cStr3[64];
	uint32_t dwTime = m_dwCurTime;

	iAdjX = 5;
	iAdjY = 8;

	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1: // Alchemy waiting incredients
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] != 0)
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX + iAdjX + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY + iAdjY + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
		}
		else
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		}

		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);

		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
			PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16, 16, 30);
		else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);

		break;

	case 2: // Alchemy, creating a potion
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] != 0) {
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX + iAdjX + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY + iAdjY + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
		}
		else
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);

		PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20, 6, 6);


		if ((dwTime - m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1) > 1000)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = dwTime;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]++;
		}

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] >= 5)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_CREATEPORTION, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
			PlaySound('E', 42, 0);
		}
		break;

	case 3: // Manuf: Choose what you want to create
		sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
		sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		szX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		PutString(sX + iAdjX + 44, sY + iAdjY + 38, "Name", RGB(0, 0, 0));
		PutString(sX + iAdjX + 171, sY + iAdjY + 38, "Max.Skill", RGB(0, 0, 0));

		iLoc = 0;
		for (i = 0; i < 13; i++)
			if (m_pDispBuildItemList[i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView] != 0) {

				std::memset(cTemp, 0, sizeof(cTemp));
				GetItemName(m_pDispBuildItemList[i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView]->m_cName, 0, cStr1, cStr2, cStr3);
				wsprintf(cTemp, "%s", cStr1);
				std::memset(cTemp2, 0, sizeof(cTemp2));
				wsprintf(cTemp2, "%d%%", m_pDispBuildItemList[i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView]->m_iMaxSkill);

				if ((msX >= sX + 30) && (msX <= sX + 180) && (msY >= sY + iAdjY + 55 + iLoc * 15) && (msY <= sY + iAdjY + 69 + iLoc * 15))
				{
					PutString(sX + 30, sY + iAdjY + 55 + iLoc * 15, cTemp, RGB(255, 255, 255));
					PutString(sX + 190, sY + iAdjY + 55 + iLoc * 15, cTemp2, RGB(255, 255, 255));
				}
				else
				{
					if (m_pDispBuildItemList[i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView]->m_bBuildEnabled == true)
					{
						PutString(sX + 30, sY + iAdjY + 55 + iLoc * 15, cTemp, RGB(34, 30, 120));
						PutString(sX + 190, sY + iAdjY + 55 + iLoc * 15, cTemp2, RGB(34, 30, 120));
					}
					else
					{
						PutString(sX + 30, sY + iAdjY + 55 + iLoc * 15, cTemp, RGB(45, 25, 25));
						PutString(sX + 190, sY + iAdjY + 55 + iLoc * 15, cTemp2, RGB(45, 25, 25));
					}
				}

				iLoc++;
			}
		if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView >= 1) && (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView - 1] != 0))
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 210, 23, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 210, 23, 5, 5, 5, dwTime);

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView + 13] != 0)
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 230, 24, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 230, 24, 5, 5, 5, dwTime);

		if ((cLB != 0) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::Manufacture)) {
			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 210) && (msY <= sY + iAdjY + 230)) {
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView--;
			}

			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 230) && (msY <= sY + iAdjY + 250)) {
				if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView + 13] != 0)
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView++;
			}
		}
		if ((msZ != 0) && (m_dialogBoxManager.iGetTopDialogBoxIndex() == DialogBoxId::Manufacture)) {
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView - msZ / 60;
			m_DInput.m_sZ = 0;
		}
		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView + 12] == 0)
		{
			while (1)
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView--;
				if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView < 1) break;
				if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView + 12] != 0) break;
			}
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView < 0) m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView = 0;

		PutAlignedString(sX, sX + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX, sY + 265, DRAW_DIALOGBOX_SKILLDLG2, 55, 25, 25);//" List of items which you can make with"
		PutAlignedString(sX, sX + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX, sY + 280, DRAW_DIALOGBOX_SKILLDLG3, 55, 25, 25);//"your current skill. The items you can"
		PutAlignedString(sX, sX + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX, sY + 295, DRAW_DIALOGBOX_SKILLDLG4, 55, 25, 25);//"make now with your current stuff will"
		PutAlignedString(sX, sX + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX, sY + 310, DRAW_DIALOGBOX_SKILLDLG5, 55, 25, 25);//"be displayed in blue. "
		PutAlignedString(sX, sX + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX, sY + 340, DRAW_DIALOGBOX_SKILLDLG6, 55, 25, 25);//"Select an item you want to manufacture."
		break;

	case 4: // Manuf: Waiting for incredients
		sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
		sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		szX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sSizeX;
		iAdjX = -1;
		iAdjY = -7;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
			m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprFrame, dwTime);

		std::memset(cTemp, 0, sizeof(cTemp));
		GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, RGB(255, 255, 255));

		wsprintf(cTemp, DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
			, m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSkillLimit
			, m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iMaxSkill);
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 2 * 15, cTemp, RGB(45, 25, 25));
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 3 * 15 + 5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45, 25, 25));//"Ingredients Needed:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[1] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[1] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[2] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[2] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[3] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[3] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[4] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[4] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[5] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[5] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[6] != 0) {
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[6] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(150, 150, 150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bBuildEnabled == true)
		{
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 100 + 180, 2, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);

			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG15, 55, 25, 25);//" Click MANUFACTURE button after"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 245 + 75, DRAW_DIALOGBOX_SKILLDLG16, 55, 25, 25);//"dragging ingredients in the blanks"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 260 + 75, DRAW_DIALOGBOX_SKILLDLG17, 55, 25, 25);//"to manufacture above item."

			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
				PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
			else PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);


			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] == 1)
					PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 6, 6, 20);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 10, 10, 10);
			}
			else {
				if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] == 1)
					PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 0, 0, 7);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 10, 10, 10);
			}
		}
		else {
			PutAlignedString(sX, sX + szX, sY + iAdjY + 200 + 75, DRAW_DIALOGBOX_SKILLDLG18, 55, 25, 25);//"There are not enough ingredients to"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 215 + 75, DRAW_DIALOGBOX_SKILLDLG19, 55, 25, 25);//"manufacture. Needed materials are"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG20, 55, 25, 25);//"displayed in grey."
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
				PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
			else PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);
		}
		break;

	case 5: // Manuf: in progress
		sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
		sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
			m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprFrame, dwTime);

		std::memset(cTemp, 0, sizeof(cTemp));
		GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, RGB(255, 255, 255));

		wsprintf(cTemp, DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
			, m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSkillLimit, m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iMaxSkill);//"��ų ����: %d/%d"
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 2 * 15, cTemp, RGB(45, 25, 25));
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 3 * 15 + 5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45, 25, 25));//"Ingredients Needed:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[1] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[1] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[2] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[2] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[3] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[3] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[4] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[4] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[5] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[5] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iElementCount[6] != 0)
		{
			GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3);
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bElementFlag[6] == true)
				PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(45, 25, 25));
			else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, RGB(120, 120, 120));
			iLoc++;
		}

		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 100 + 180, 2, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180,
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);

		PutString(sX + iAdjX + 33, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG29, RGB(55, 25, 25));//" Manufacturing the items...."
		PutString(sX + iAdjX + 33, sY + iAdjY + 245 + 75, DRAW_DIALOGBOX_SKILLDLG30, RGB(55, 25, 25));//"Please wait until manufacture finishes."

		if ((dwTime - m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1) > 1000)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = dwTime;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1]++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] >= 7) m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 7;
		}

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] == 4)
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_BUILDITEM, 0, 0, 0, 0, m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cName);
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1]++;
		}
		break;

	case 6: // Manuf: Done
		sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
		sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
			m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_iSprFrame, dwTime);

		std::memset(cTemp, 0, sizeof(cTemp));
		GetItemName(m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);

		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, RGB(255, 255, 255));

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[2] == 1) {
			PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 200 - 45, DRAW_DIALOGBOX_SKILLDLG31, RGB(55, 25, 25));//" Success in manufacture!"

			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == DEF_ITEMTYPE_MATERIAL) {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG32, m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[3]);//"The purity of product is %d%%."
				PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 215 - 45, G_cTxt, RGB(55, 25, 25));
			}
			else {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG33, (int)m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[3] + 100);//"The completion of product is %d%%."
				PutString(sX + iAdjX + 33, sY + iAdjY + 215 - 45, G_cTxt, RGB(55, 25, 25));
			}
		}
		else {
			PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 200, DRAW_DIALOGBOX_SKILLDLG34, RGB(55, 25, 25));//"Failed on manufacture."
		}

		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
			PutString_SprFont(sX + iAdjX + 35, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
		else PutString_SprFont(sX + iAdjX + 35, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);
		break;


	case 7: // Crafting, wait for incredients
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] != 0)
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX + iAdjX + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY + iAdjY + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
		}
		else
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 40 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 115 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
			PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16, 16, 30);
		else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);
		break;

	case 8: // Crafting in progress
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] != 0)
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX + iAdjX + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY + iAdjY + (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] - (rand() % (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] * 2)));
		}
		else
		{
			sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
			sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + (1 - (rand() % 3)) + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 40 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 115 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1)
		{
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_sSpriteFrame, dwTime);
			if ((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20, 6, 6);

		if ((dwTime - m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1) > 1000)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = dwTime;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1]++;
		}
		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] >= 5)//m_pDispCraftItemList
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CRAFTITEM, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Manufacture);
			PlaySound('E', 42, 0);
		}
		break;
	}
}

void CGame::bItemDrop_Character()
{
	ItemEquipHandler((char)m_stMCursor.sSelectedObjectID);
}

void CGame::bItemDrop_Inventory(short msX, short msY)
{
	short sX, sY, dX, dY;
	char  cTxt[120];
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stMCursor.sSelectedObjectID] == 0) return;
	if ((m_bSkillUsingStatus == true) && (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true))
	{
		AddEventList(BITEMDROP_INVENTORY1, 10);
		return;
	}
	if (m_bIsItemDisabled[m_stMCursor.sSelectedObjectID] == true) return;
	sY = m_dialogBoxManager.Info(DialogBoxId::Inventory).sY;
	sX = m_dialogBoxManager.Info(DialogBoxId::Inventory).sX;
	dX = msX - sX - 32 - m_stMCursor.sDistX;
	dY = msY - sY - 44 - m_stMCursor.sDistY;
	if (dY < -10) dY = -10;
	if (dX < 0)   dX = 0;
	if (dX > 170) dX = 170;
	if (dY > 95) dY = 95;

	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sX = dX;
	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sY = dY;

	short sTmpSpr, sTmpSprFrm;
	sTmpSpr = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite;
	sTmpSprFrm = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame;

	char cItemID;
	if (m_bShiftPressed)
	{
		for (int i = 0; i < DEF_MAXITEMS; i++)
		{
			if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1)
			{
				cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
				if (m_pItemList[cItemID] != 0 && memcmp(m_pItemList[cItemID]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, 20) == 0)
				{
					m_pItemList[cItemID]->m_sX = dX;
					m_pItemList[cItemID]->m_sY = dY;
					bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemID, dX, dY, 0, 0);
				}
			}
		}
	}
	else bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, (char)(m_stMCursor.sSelectedObjectID), dX, dY, 0, 0);

	if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
	{
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
		else PlaySound('E', 29, 0);

		// Remove Angelic Stats
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
			&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
		{
			char cItemID = m_stMCursor.sSelectedObjectID;
			if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{
				m_iAngelicStr = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{
				m_iAngelicDex = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{
				m_iAngelicInt = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{
				m_iAngelicMag = 0;
			}
		}
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
		m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
		m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
	}
}

void CGame::bItemDrop_SellList(short msX, short msY)
{
	int i;
	char cItemID;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	for (i = 0; i < DEF_MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex == cItemID)
		{
			AddEventList(BITEMDROP_SELLLIST1, 10);
			return;
		}
	if (strcmp(m_pItemList[cItemID]->m_cName, "Gold") == 0) {
		AddEventList(BITEMDROP_SELLLIST2, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		std::memset(G_cTxt, 0, sizeof(G_cTxt));
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
		wsprintf(G_cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);
		AddEventList(G_cTxt, 10);
		return;
	}

	if (((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1001;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = cItemID;
		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		m_bIsItemDisabled[cItemID] = true;
	}
	else
	{
		for (i = 0; i < DEF_MAXSELLLIST; i++)
			if (m_stSellItemList[i].iIndex == -1)
			{
				m_stSellItemList[i].iIndex = cItemID;
				m_stSellItemList[i].iAmount = 1;
				m_bIsItemDisabled[cItemID] = true;
				return;
			}
		AddEventList(BITEMDROP_SELLLIST3, 10);
	}
}

void CGame::bItemDrop_ItemUpgrade()
{
	char cItemID;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE) return;

	switch (m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).cMode) {
	case 1:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = true;
		PlaySound('E', 29, 0);
		break;

	case 6:
		m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1] = false;
		m_dialogBoxManager.Info(DialogBoxId::ItemUpgrade).sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = true;
		PlaySound('E', 29, 0);
		break;
	}
}

void CGame::bItemDrop_Bank(short msX, short msY)
{
	m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1 = m_stMCursor.sSelectedObjectID;
	if (m_cCommand < 0) return;
	if (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1] == 0) return;
	if (m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1] == true) return;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) && ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropConfirm) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (((m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cItemType == DEF_ITEMTYPE_ARROW)) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_dwCount > 1))
	{
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sX = msX - 140;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = msY - 70;
		if (m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY < 0) m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sY = 0;

		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV1 = m_sPlayerX + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV2 = m_sPlayerY + 1;
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV3 = 1002;// NPC
		m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).sV4 = m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1;

		std::memset(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr, 0, sizeof(m_dialogBoxManager.Info(DialogBoxId::ItemDropExternal).cStr));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::ItemDropExternal, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_dwCount, 0);
	}
	else
	{
		if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS - 1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
		else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1, 1, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV5, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV6, m_pItemList[m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV1]->m_cName, m_dialogBoxManager.Info(DialogBoxId::GiveItem).sV4); //v1.4
	}
}

void CGame::bItemDrop_SkillDialog()
{
	int iConsumeNum;
	char cItemID;

	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true)
		&& ((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{
			iConsumeNum = 0;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE))
		{
		}
		else return;

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10);
		break;

	case 4:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{
			iConsumeNum = 0;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == cItemID) iConsumeNum++;
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

		// Crafting
	case 7:
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE)			// Merien Stone
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)		// Necks XXXMagins
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)		// stones
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_MATERIAL))	// XXXwares
		{
		}
		else return;

		if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		else if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 == -1)
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{
			}
			else m_bIsItemDisabled[cItemID] = true;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

	default:
		break;
	}
}

// Slates Item Drag&Drop - Diuuude
void CGame::bItemDrop_Slates()
{
	char cItemID;
	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_dialogBoxManager.IsEnabled(DialogBoxId::ItemDropExternal) == true) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_dialogBoxManager.IsEnabled(DialogBoxId::NpcActionQuery) == true) &&
		((m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 1) || (m_dialogBoxManager.Info(DialogBoxId::NpcActionQuery).cMode == 2))) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_dialogBoxManager.IsEnabled(DialogBoxId::SellOrRepair) == true) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::Slates).cMode) {
	case 1:
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && (m_pItemList[cItemID]->m_sSpriteFrame >= 151) && (m_pItemList[cItemID]->m_sSpriteFrame <= 154)) {
			char cItemIDText[20];
			switch (m_pItemList[cItemID]->m_sSpriteFrame) {
			case 151:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV1 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 152:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV2 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 153:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV3 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			case 154:
				if (m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 == -1) {
					m_bIsItemDisabled[cItemID] = true;
					m_dialogBoxManager.Info(DialogBoxId::Slates).sV4 = cItemID;
					wsprintf(cItemIDText, "Item ID : %d", cItemID);
					AddEventList(cItemIDText, 10);
				}
				break;
			}
		}
		break;

	default:
		break;
	}
}

void CGame::DlgBoxClick_Bank(short msX, short msY)
{
	int i;
	short sX, sY;


	sX = m_dialogBoxManager.Info(DialogBoxId::Bank).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Bank).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::Bank).cMode) {
	case -1:
		break;

	case 0:
		for (i = 0; i < m_dialogBoxManager.Info(DialogBoxId::Bank).sV1; i++)
			if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i * 15) && (msY <= sY + 124 + i * 15)) {
				if ((m_pBankList[m_dialogBoxManager.Info(DialogBoxId::Bank).sView + i] != 0) && ((m_dialogBoxManager.Info(DialogBoxId::Bank).sView + i) < DEF_MAXBANKITEMS)) {
					if (_iGetTotalItemNum() >= 50) {
						AddEventList(DLGBOX_CLICK_BANK1, 10);
						return;
					}
					bSendCommand(MSGID_REQUEST_RETRIEVEITEM, 0, 0, (m_dialogBoxManager.Info(DialogBoxId::Bank).sView + i), 0, 0, 0);
					m_dialogBoxManager.Info(DialogBoxId::Bank).cMode = -1;
					PlaySound('E', 14, 5);
				}
				return;
			}

		break;
	}
}

void CGame::DlgBoxClick_Fish(short msX, short msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::Fishing).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Fishing).sY;

	switch (m_dialogBoxManager.Info(DialogBoxId::Fishing).cMode) {
	case 0:
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETFISHTHISTIME, 0, 0, 0, 0, 0);
			AddEventList(DLGBOX_CLICK_FISH1, 10);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::Fishing);

			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_SkillDlg(short msX, short msY)
{
	int i, iAdjX, iAdjY;
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::Manufacture).sY;

	iAdjX = 5;
	iAdjY = 8;


	switch (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode) {
	case 1:
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
		{
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 2;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = m_dwCurTime;
			PlaySound('E', 14, 5);
			AddEventList(DLGBOX_CLICK_SKILLDLG1, 10); // "Mixing a potion..."
			PlaySound('E', 41, 0);
		}
		break;
		// Crafting
	case 7:
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
		{
			DebugLog("Tag1 DlgBoxClick_SkillDlg");
			if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 == -1)
			{
				AddEventList(DLGBOX_CLICK_SKILLDLG2, 10); // "There is not enough crafting materials. Please put in more materials."
				PlaySound('E', 14, 5);
			}
			else
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 8;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = m_dwCurTime;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 1;
				PlaySound('E', 14, 5);
				AddEventList(DLGBOX_CLICK_SKILLDLG3, 10); // "Crafting the item in progress"
				PlaySound('E', 51, 0);
			}
		}
		break;

	case 3:
		for (i = 0; i < 13; i++)
			if (m_pDispBuildItemList[i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView] != 0)
			{
				if ((msX >= sX + iAdjX + 44) && (msX <= sX + iAdjX + 135 + 44) && (msY >= sY + iAdjY + 55 + i * 15) && (msY <= sY + iAdjY + 55 + 14 + i * 15)) {
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 4;
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = i + m_dialogBoxManager.Info(DialogBoxId::Manufacture).sView;
					PlaySound('E', 14, 5);
				}
			}
		break;

	case 4:
		iAdjX = -1;
		iAdjY = -7;
		if (m_pDispBuildItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0]]->m_bBuildEnabled == true)
		{
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				// Back
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 3;
				PlaySound('E', 14, 5);

				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] = false;

				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = 0;
			}

			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
			{	// Manufacture
				if (m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] == 1)
				{
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 5;
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
					m_dialogBoxManager.Info(DialogBoxId::Manufacture).dwT1 = m_dwCurTime;
					PlaySound('E', 14, 5);
					PlaySound('E', 44, 0);
				}
			}
		}
		else
		{
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) 	// Back
			{
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 3;
				PlaySound('E', 14, 5);

				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] = false;
				if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] != 0))
					m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] = false;

				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
				m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = 0;
			}
		}
		break;

	case 6:
		iAdjX = -1;
		iAdjY = -7;
		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
			// Back
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cMode = 3;
			PlaySound('E', 14, 5);

			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1] = false;
			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2] = false;
			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3] = false;
			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4] = false;
			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5] = false;
			if ((m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 != -1) && (m_pItemList[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] != 0))
				m_bIsItemDisabled[m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6] = false;

			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV1 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV2 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV3 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV4 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV5 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).sV6 = -1;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[0] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[1] = 0;
			m_dialogBoxManager.Info(DialogBoxId::Manufacture).cStr[4] = 0;
		}
		break;
	}
}

void CGame::ResponseTeleportList(char* pData)
{
	int i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	const auto* header = hb::net::PacketCast<hb::net::PacketResponseTeleportListHeader>(
		pData, sizeof(hb::net::PacketResponseTeleportListHeader));
	if (!header) return;
	const auto* entries = reinterpret_cast<const hb::net::PacketResponseTeleportListEntry*>(
		pData + sizeof(hb::net::PacketResponseTeleportListHeader));
	m_iTeleportMapCount = header->count;
	for (i = 0; i < m_iTeleportMapCount; i++)
	{
		m_stTeleportList[i].iIndex = entries[i].index;
		std::memset(m_stTeleportList[i].mapname, 0, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, entries[i].map_name, 10);
		m_stTeleportList[i].iX = entries[i].x;
		m_stTeleportList[i].iY = entries[i].y;
		m_stTeleportList[i].iCost = entries[i].cost;
	}
}

void CGame::ResponseChargedTeleport(char* pData)
{
	short sRejectReason = 0;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseChargedTeleport>(
		pData, sizeof(hb::net::PacketResponseChargedTeleport));
	if (!pkt) return;
	sRejectReason = pkt->reason;

#ifdef _DEBUG
	AddEventList("charged teleport ?", 10);
#endif

	switch (sRejectReason) {
	case 1:
		AddEventList(RESPONSE_CHARGED_TELEPORT1, 10);
		break;
	case 2:
		AddEventList(RESPONSE_CHARGED_TELEPORT2, 10);
		break;
	case 3:
		AddEventList(RESPONSE_CHARGED_TELEPORT3, 10);
		break;
	case 4:
		AddEventList(RESPONSE_CHARGED_TELEPORT4, 10);
		break;
	case 5:
		AddEventList(RESPONSE_CHARGED_TELEPORT5, 10);
		break;
	case 6:
		AddEventList(RESPONSE_CHARGED_TELEPORT6, 10);
		break;
	default:
		AddEventList(RESPONSE_CHARGED_TELEPORT7, 10);
	}
}

void CGame::NotifyMsg_CannotGiveItem(char* pData)
{
	char cName[21], cTxt[256];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotGiveItem>(
		pData, sizeof(hb::net::PacketNotifyCannotGiveItem));
	if (!pkt) return;
	const auto wItemIndex = pkt->item_index;
	const auto iAmount = static_cast<int>(pkt->amount);
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex], cStr1, cStr2, cStr3);
	if (iAmount == 1) wsprintf(cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM2, cStr1, cName);
	else wsprintf(cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM1, iAmount, cStr1, cName);


	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_DropItemFin_CountChanged(char* pData)
{
	char cTxt[256];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDropItemFinCountChanged>(
		pData, sizeof(hb::net::PacketNotifyDropItemFinCountChanged));
	if (!pkt) return;
	const auto wItemIndex = pkt->item_index;
	const auto iAmount = static_cast<int>(pkt->amount);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
	wsprintf(cTxt, NOTIFYMSG_THROW_ITEM1, iAmount, cStr1);

	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotJoinMoreGuildsMan(char* pData)
{
	char cName[12], cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotJoinMoreGuildsMan>(
		pData, sizeof(hb::net::PacketNotifyCannotJoinMoreGuildsMan));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);

	wsprintf(cTxt, NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN1, cName);
	AddEventList(cTxt, 10);
	AddEventList(NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN2, 10);
}



void CGame::NotifyMsg_DismissGuildsMan(char* pData)
{
	char cName[12], cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDismissGuildsMan>(
		pData, sizeof(hb::net::PacketNotifyDismissGuildsMan));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);

	if (memcmp(m_cPlayerName, cName, 10) != 0) {
		wsprintf(cTxt, NOTIFYMSG_DISMISS_GUILDMAN1, cName);
		AddEventList(cTxt, 10);
	}
	ClearGuildNameList();
}

void CGame::NotifyMsg_CannotRating(char* pData)
{
	char cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotRating>(
		pData, sizeof(hb::net::PacketNotifyCannotRating));
	if (!pkt) return;
	const auto wTime = pkt->time_left;

	if (wTime == 0) wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING1, wTime * 3);
	else wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING2, wTime * 3);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotRepairItem(char* pData)
{
	char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotRepairItem>(
		pData, sizeof(hb::net::PacketNotifyCannotRepairItem));
	if (!pkt) return;
	const auto wV1 = pkt->item_index;
	const auto wV2 = pkt->reason;
	std::memset(cStr1, 0, sizeof(cStr1));
	std::memset(cStr2, 0, sizeof(cStr2));
	std::memset(cStr3, 0, sizeof(cStr3));
	GetItemName(m_pItemList[wV1], cStr1, cStr2, cStr3);

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM1, cStr1);
		AddEventList(cTxt, 10);
		break;
	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM2, cStr1);
		AddEventList(cTxt, 10);
		break;
	}
	m_bIsItemDisabled[wV1] = false;
}

void CGame::NotifyMsg_CannotSellItem(char* pData)
{
	char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCannotSellItem>(
		pData, sizeof(hb::net::PacketNotifyCannotSellItem));
	if (!pkt) return;
	const auto wV1 = pkt->item_index;
	const auto wV2 = pkt->reason;

	std::memset(cStr1, 0, sizeof(cStr1));
	std::memset(cStr2, 0, sizeof(cStr2));
	std::memset(cStr3, 0, sizeof(cStr3));
	GetItemName(m_pItemList[wV1], cStr1, cStr2, cStr3);

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM1, cStr1);//"
		AddEventList(cTxt, 10);
		break;

	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);//"
		AddEventList(cTxt, 10);
		break;

	case 3:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM3, cStr1);//"
		AddEventList(cTxt, 10);
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM4, 10);//"
		break;

	case 4:
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM5, 10); // "
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM6, 10); // "
		break;
	}
	m_bIsItemDisabled[wV1] = false;
}

void CGame::NotifyMsg_Charisma(char* pData)
{
	int  iPrevChar;
	char cTxt[120];

	iPrevChar = m_iCharisma;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyCharisma>(
		pData, sizeof(hb::net::PacketNotifyCharisma));
	if (!pkt) return;
	m_iCharisma = static_cast<int>(pkt->charisma);

	if (m_iCharisma > iPrevChar)
	{
		wsprintf(cTxt, NOTIFYMSG_CHARISMA_UP, m_iCharisma - iPrevChar);//"
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else
	{
		wsprintf(cTxt, NOTIFYMSG_CHARISMA_DOWN, iPrevChar - m_iCharisma);//"
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_DropItemFin_EraseItem(char* pData)
{
	int iAmount;
	short  sItemIndex;
	char   cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyDropItemFinEraseItem>(
		pData, sizeof(hb::net::PacketNotifyDropItemFinEraseItem));
	if (!pkt) return;
	sItemIndex = static_cast<short>(pkt->item_index);
	iAmount = static_cast<int>(pkt->amount);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	std::memset(cTxt, 0, sizeof(cTxt));
	if (m_bIsItemEquipped[sItemIndex] == true)
	{
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);
		m_sItemEquipmentStatus[m_pItemList[sItemIndex]->m_cEquipPos] = -1;
		m_bIsItemEquipped[sItemIndex] = false;
	}
	if (m_iHP > 0)
	{
		wsprintf(cTxt, NOTIFYMSG_THROW_ITEM2, cStr1);
	}
	else
	{
		if (iAmount < 2)
			wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM3, cStr1); // "You dropped a %s."
		else // Snoopy fix
		{
			wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM5, cStr1); // "You dropped %s."
		}
	}
	AddEventList(cTxt, 10);
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}


void CGame::NotifyMsg_EnemyKillReward(char* pData)
{
	DWORD iExp;
	short sGuildRank;
	char cName[12], cGuildName[24], cTxt[120];
	int   iEnemyKillCount, iWarContribution;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyEnemyKillReward>(
		pData, sizeof(hb::net::PacketNotifyEnemyKillReward));
	if (!pkt) return;

	std::memset(cName, 0, sizeof(cName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	iExp = pkt->exp;
	iEnemyKillCount = static_cast<int>(pkt->kill_count);
	memcpy(cName, pkt->killer_name, 10);
	memcpy(cGuildName, pkt->killer_guild, 20);
	sGuildRank = pkt->killer_rank;
	iWarContribution = pkt->war_contribution;

	if (iWarContribution > m_iWarContribution)
	{
		wsprintf(G_cTxt, "%s +%d!", m_pGameMsgList[21]->m_pMsg, iWarContribution - m_iWarContribution);
		SetTopMsg(G_cTxt, 5);
	}
	else if (iWarContribution < m_iWarContribution)
	{
	}
	m_iWarContribution = iWarContribution;

	if (sGuildRank == -1)
	{
		wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD1, cName);
		AddEventList(cTxt, 10);
	}
	else
	{
		wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD2, cName, cGuildName); // Fixed by Snoopy
		AddEventList(cTxt, 10);
	}

	/*	if( m_iExp != iExp ) // removed by snoopy because too much msg hide victim's name
		{	if (m_iExp > iExp) wsprintf(cTxt, EXP_DECREASED,m_iExp - iExp);
			else wsprintf(cTxt, EXP_INCREASED,iExp - m_iExp);
			AddEventList(cTxt, 10);
		}*/

	if (m_iEnemyKillCount != iEnemyKillCount)
	{
		if (m_iEnemyKillCount > iEnemyKillCount)
		{
			wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD5, m_iEnemyKillCount - iEnemyKillCount);
			AddEventList(cTxt, 10);
		}
		else
		{
			wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD6, iEnemyKillCount - m_iEnemyKillCount);
			AddEventList(cTxt, 10);
		}
	}

	if (iExp >= 0) m_iExp = iExp;
	if (iEnemyKillCount >= 0) m_iEnemyKillCount = iEnemyKillCount;
	PlaySound('E', 23, 0);

	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
	for (int i = 1; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] == 0) {
			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, "Enemy Kill!");
			m_pChatMsgList[i] = new class CMsg(23, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = 0;
			}
			break;
		}
	}
	CreateScreenShot();
}

void CGame::NotifyMsg_EventFishMode(char* pData)
{
	short sSprite, sSpriteFrame;
	char cName[21];
	WORD wPrice;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyEventFishMode>(
		pData, sizeof(hb::net::PacketNotifyEventFishMode));
	if (!pkt) return;

	wPrice = pkt->price;
	sSprite = static_cast<short>(pkt->sprite);
	sSpriteFrame = static_cast<short>(pkt->sprite_frame);

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Fishing, 0, 0, wPrice, cName);
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sV3 = sSprite;
	m_dialogBoxManager.Info(DialogBoxId::Fishing).sV4 = sSpriteFrame;

	AddEventList(NOTIFYMSG_EVENTFISHMODE1, 10);
}

void CGame::NotifyMsg_Exp(char* pData)
{
	DWORD iPrevExp;
	char cTxt[120];

	iPrevExp = m_iExp;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyExp>(
		pData, sizeof(hb::net::PacketNotifyExp));
	if (!pkt) return;
	m_iExp = static_cast<int>(pkt->exp);

	if (m_iExp > iPrevExp)
	{
		wsprintf(cTxt, EXP_INCREASED, m_iExp - iPrevExp);
		AddEventList(cTxt, 10);
	}
	else
	{
		wsprintf(cTxt, EXP_DECREASED, iPrevExp - m_iExp);
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_ForceDisconn(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyForceDisconn>(
		pData, sizeof(hb::net::PacketNotifyForceDisconn));
	if (!pkt) return;
	const auto wpCount = pkt->seconds;
	m_bForceDisconn = true;
	//m_cLogOutCount = (char)*wpCount;
	if (m_bIsProgramActive)
	{
		if (m_cLogOutCount < 0 || m_cLogOutCount > 5) m_cLogOutCount = 5;
		AddEventList(NOTIFYMSG_FORCE_DISCONN1, 10);
	}
	else
	{
		delete m_pGSock;
		m_pGSock = 0;
		m_bEscPressed = false;
		AudioManager::Get().StopSound(SoundType::Effect, 38);
		AudioManager::Get().StopMusic();
		if (strlen(G_cCmdLineTokenA) != 0)
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
}

void CGame::NotifyMsg_GiveItemFin_CountChanged(char* pData)
{
	char cName[21], cTxt[256];
	WORD wItemIndex;
	int iAmount;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGiveItemFinCountChanged>(
		pData, sizeof(hb::net::PacketNotifyGiveItemFinCountChanged));
	if (!pkt) return;
	wItemIndex = pkt->item_index;
	iAmount = static_cast<int>(pkt->amount);

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
	if (iAmount == 1) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED1, cStr1, cName);
	wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED2, iAmount, cStr1, cName);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_GiveItemFin_EraseItem(char* pData)
{
	int iAmount;
	short  sItemIndex;
	char cName[21], cTxt[250];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGiveItemFinEraseItem>(
		pData, sizeof(hb::net::PacketNotifyGiveItemFinEraseItem));
	if (!pkt) return;
	sItemIndex = static_cast<short>(pkt->item_index);
	iAmount = static_cast<int>(pkt->amount);

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex]->m_cName, m_pItemList[sItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == true) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		// v1.42
		m_sItemEquipmentStatus[m_pItemList[sItemIndex]->m_cEquipPos] = -1;
		m_bIsItemEquipped[sItemIndex] = false;
	}
	if (strlen(cName) == 0) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM2, iAmount, cStr1);
	else {
		if (strcmp(cName, "Howard") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM3, iAmount, cStr1);
		else if (strcmp(cName, "William") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM4, iAmount, cStr1);
		else if (strcmp(cName, "Kennedy") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM5, iAmount, cStr1);
		else if (strcmp(cName, "Tom") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM7, iAmount, cStr1);
		else wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM8, iAmount, cStr1, cName);
	}
	AddEventList(cTxt, 10);
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_GlobalAttackMode(char* pData)
{
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyGlobalAttackMode>(
		pData, sizeof(hb::net::PacketNotifyGlobalAttackMode));
	if (!pkt) return;
	switch (pkt->mode) {
	case 0:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE1, 10);
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE2, 10);
		break;

	case 1:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE3, 10);
		break;
	}
}


void CGame::NotifyMsg_HP(char* pData)
{
	int iPrevHP;
	char cTxt[120];

	iPrevHP = m_iHP;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyHP>(
		pData, sizeof(hb::net::PacketNotifyHP));
	if (!pkt) return;
	m_iHP = static_cast<int>(pkt->hp);
	m_iHungerStatus = static_cast<int>(pkt->hunger);

	if (m_iHP > iPrevHP)
	{
		if ((m_iHP - iPrevHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_UP, m_iHP - iPrevHP);
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else
	{
		if ((m_cLogOutCount > 0) && (m_bForceDisconn == false))
		{
			m_cLogOutCount = -1;
			AddEventList(NOTIFYMSG_HP2, 10);
		}
		m_dwDamagedTime = GameClock::GetTimeMS();
		if (m_iHP < 20) AddEventList(NOTIFYMSG_HP3, 10);
		if ((iPrevHP - m_iHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_DOWN, iPrevHP - m_iHP);
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_Hunger(char* pData)
{
	char cHLv;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyHunger>(
		pData, sizeof(hb::net::PacketNotifyHunger));
	if (!pkt) return;
	m_iHungerStatus = pkt->hunger;

	cHLv = m_iHungerStatus;
	if ((cHLv <= 40) && (cHLv > 30)) AddEventList(NOTIFYMSG_HUNGER1, 10);//"
	if ((cHLv <= 25) && (cHLv > 20)) AddEventList(NOTIFYMSG_HUNGER2, 10);//"
	if ((cHLv <= 20) && (cHLv > 15)) AddEventList(NOTIFYMSG_HUNGER3, 10);//"
	if ((cHLv <= 15) && (cHLv > 10)) AddEventList(NOTIFYMSG_HUNGER4, 10);//"
	if ((cHLv <= 10) && (cHLv >= 0)) AddEventList(NOTIFYMSG_HUNGER5, 10);//"
}

void CGame::NotifyMsg_ItemColorChange(char* pData)
{
	short sItemIndex, sItemColor;
	char cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemColorChange>(
		pData, sizeof(hb::net::PacketNotifyItemColorChange));
	if (!pkt) return;
	sItemIndex = static_cast<short>(pkt->item_index);
	sItemColor = static_cast<short>(pkt->item_color);

	if (m_pItemList[sItemIndex] != 0) {
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);
		if (sItemColor != -1) {
			m_pItemList[sItemIndex]->m_cItemColor = (char)sItemColor;
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE1, cStr1);
			AddEventList(cTxt, 10);
		}
		else {
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE2, cStr1);
			AddEventList(cTxt, 10);
		}
	}
}

void CGame::NotifyMsg_ItemDepleted_EraseItem(char* pData)
{
	short  sItemIndex;
	bool   bIsUseItemResult;
	char   cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemDepletedEraseItem>(
		pData, sizeof(hb::net::PacketNotifyItemDepletedEraseItem));
	if (!pkt) return;
	sItemIndex = static_cast<short>(pkt->item_index);
	bIsUseItemResult = (pkt->use_result != 0);

	std::memset(cTxt, 0, sizeof(cTxt));

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == true) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		// v1.42
		m_sItemEquipmentStatus[m_pItemList[sItemIndex]->m_cEquipPos] = -1;
		m_bIsItemEquipped[sItemIndex] = false;
	}

	std::memset(cTxt, 0, sizeof(cTxt));
	if ((m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM2, cStr1);
	}
	else {
		if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) {
			if (bIsUseItemResult == true) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);
			}
		}
		else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) {
			if (bIsUseItemResult == true) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM4, cStr1);
				if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
					PlaySound('C', 19, 0);
				if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
					PlaySound('C', 20, 0);
			}
		}
		else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
			if (bIsUseItemResult == true) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);
			}
		}
		else {
			if (bIsUseItemResult == true) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM6, cStr1);
				PlaySound('E', 10, 0);
			}
		}
	}
	AddEventList(cTxt, 10);

	if (bIsUseItemResult == true) 	m_bItemUsingStatus = false;
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_ItemLifeSpanEnd(char* pData)
{
	short sEquipPos, sItemIndex;
	char cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemLifeSpanEnd>(
		pData, sizeof(hb::net::PacketNotifyItemLifeSpanEnd));
	if (!pkt) return;
	sEquipPos = static_cast<short>(pkt->equip_pos);
	sItemIndex = static_cast<short>(pkt->item_index);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);
	wsprintf(cTxt, NOTIFYMSG_ITEMLIFE_SPANEND1, cStr1);
	AddEventList(cTxt, 10);
	m_sItemEquipmentStatus[m_pItemList[sItemIndex]->m_cEquipPos] = -1;
	m_bIsItemEquipped[sItemIndex] = false;
	m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;

	PlaySound('E', 10, 0);
}

void CGame::NotifyMsg_ItemObtained(char* pData)
{
	int i, j;
	uint32_t dwCount, dwAttribute;
	char  cName[21], cItemType, cEquipPos;
	bool  bIsEquipped;
	short sSprite, sSpriteFrame, sLevelLimit, sSpecialEV2;
	char  cTxt[120], cGenderLimit, cItemColor;
	uint16_t wWeight, wCurLifeSpan;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemObtained>(
		pData, sizeof(hb::net::PacketNotifyItemObtained));
	if (!pkt) return;

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);
	dwCount = pkt->count;
	cItemType = static_cast<char>(pkt->item_type);
	cEquipPos = static_cast<char>(pkt->equip_pos);
	bIsEquipped = (pkt->is_equipped != 0);
	sLevelLimit = static_cast<short>(pkt->level_limit);
	cGenderLimit = static_cast<char>(pkt->gender_limit);
	wCurLifeSpan = pkt->cur_lifespan;
	wWeight = pkt->weight;
	sSprite = static_cast<short>(pkt->sprite);
	sSpriteFrame = static_cast<short>(pkt->sprite_frame);
	cItemColor = static_cast<char>(pkt->item_color);
	sSpecialEV2 = static_cast<short>(pkt->spec_value2);
	dwAttribute = pkt->attribute;
	/*
	bIsCustomMade = (bool)*cp;
	cp++;
	*/

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);

	std::memset(cTxt, 0, sizeof(cTxt));
	if (dwCount == 1) wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED2, cStr1);
	else wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED1, dwCount, cStr1);

	AddEventList(cTxt, 10);

	PlaySound('E', 20, 0);

	// Clear the item from the ground at the player's position
	m_pMapData->bSetItem(m_sPlayerX, m_sPlayerY, 0, 0, 0, false);

	if ((cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW))
	{
		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
			{
				m_pItemList[i]->m_dwCount += dwCount;
				m_bIsItemDisabled[i] = false;
				return;
			}
	}

	short nX, nY;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
		{
			nX = m_pItemList[i]->m_sX;
			nY = m_pItemList[i]->m_sY;
			break;
		}
		else
		{
			nX = 40;
			nY = 30;
		}
	}


	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] == 0)
		{
			m_pItemList[i] = new class CItem;
			memcpy(m_pItemList[i]->m_cName, cName, 20);
			m_pItemList[i]->m_dwCount = dwCount;
			//m_pItemList[i]->m_sX      =	40;
			//m_pItemList[i]->m_sY      =	30;
			m_pItemList[i]->m_sX = nX;
			m_pItemList[i]->m_sY = nY;
			bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, i, nX, nY, 0, 0);
			m_pItemList[i]->m_cItemType = cItemType;
			m_pItemList[i]->m_cEquipPos = cEquipPos;
			m_bIsItemDisabled[i] = false;

			m_bIsItemEquipped[i] = false;
			m_pItemList[i]->m_sLevelLimit = sLevelLimit;
			m_pItemList[i]->m_cGenderLimit = cGenderLimit;
			m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
			m_pItemList[i]->m_wWeight = wWeight;
			m_pItemList[i]->m_sSprite = sSprite;
			m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
			m_pItemList[i]->m_cItemColor = cItemColor;
			m_pItemList[i]->m_sItemSpecEffectValue2 = sSpecialEV2; // v1.41
			m_pItemList[i]->m_dwAttribute = dwAttribute;
			//m_pItemList[i]->m_bIsCustomMade = bIsCustomMade;

			_bCheckBuildItemStatus();

			for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_cItemOrder[j] == -1) {
					m_cItemOrder[j] = i;
					return;
				}
			return;
		}
}

void CGame::NotifyMsg_ItemPurchased(char* pData)
{
	int i, j;
	uint32_t dwCount;
	char  cName[21], cItemType, cEquipPos, cGenderLimit;
	bool  bIsEquipped;
	short sSprite, sSpriteFrame, sLevelLimit;
	uint16_t wCost, wWeight, wCurLifeSpan;
	char  cTxt[120], cItemColor;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemPurchased>(
		pData, sizeof(hb::net::PacketNotifyItemPurchased));
	if (!pkt) return;

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);
	dwCount = pkt->count;
	cItemType = static_cast<char>(pkt->item_type);
	cEquipPos = static_cast<char>(pkt->equip_pos);
	bIsEquipped = (pkt->is_equipped != 0);
	sLevelLimit = static_cast<short>(pkt->level_limit);
	cGenderLimit = static_cast<char>(pkt->gender_limit);
	wCurLifeSpan = pkt->cur_lifespan;
	wWeight = pkt->weight;
	sSprite = static_cast<short>(pkt->sprite);
	sSpriteFrame = static_cast<short>(pkt->sprite_frame);
	cItemColor = static_cast<char>(pkt->item_color);
	wCost = pkt->cost;
	std::memset(cTxt, 0, sizeof(cTxt));
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, 0, cStr1, cStr2, cStr3);
	wsprintf(cTxt, NOTIFYMSG_ITEMPURCHASED, cStr1, wCost);
	AddEventList(cTxt, 10);

	if ((cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW))
	{
		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
			{
				m_pItemList[i]->m_dwCount += dwCount;
				return;
			}
	}

	short nX, nY;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
		{
			nX = m_pItemList[i]->m_sX;
			nY = m_pItemList[i]->m_sY;
			break;
		}
		else
		{
			nX = 40;
			nY = 30;
		}
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pItemList[i] == 0)
		{
			m_pItemList[i] = new class CItem;
			memcpy(m_pItemList[i]->m_cName, cName, 20);
			m_pItemList[i]->m_dwCount = dwCount;
			//m_pItemList[i]->m_sX           = 40;
			//m_pItemList[i]->m_sY           = 30;
			m_pItemList[i]->m_sX = nX;
			m_pItemList[i]->m_sY = nY;
			bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, i, nX, nY, 0, 0);
			m_pItemList[i]->m_cItemType = cItemType;
			m_pItemList[i]->m_cEquipPos = cEquipPos;
			m_bIsItemDisabled[i] = false;
			m_bIsItemEquipped[i] = false;
			m_pItemList[i]->m_sLevelLimit = sLevelLimit;
			m_pItemList[i]->m_cGenderLimit = cGenderLimit;
			m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
			m_pItemList[i]->m_wWeight = wWeight;
			m_pItemList[i]->m_sSprite = sSprite;
			m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
			m_pItemList[i]->m_cItemColor = cItemColor;    // v1.4

			// fixed v1.11
			for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_cItemOrder[j] == -1) {
					m_cItemOrder[j] = i;
					return;
				}

			return;
		}
}

void CGame::NotifyMsg_ItemReleased(char* pData)
{
	short sEquipPos, sItemIndex;
	char cTxt[120];

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemReleased>(
		pData, sizeof(hb::net::PacketNotifyItemReleased));
	if (!pkt) return;
	sEquipPos = static_cast<short>(pkt->equip_pos);
	sItemIndex = static_cast<short>(pkt->item_index);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);
	wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(cTxt, 10);
	m_bIsItemEquipped[sItemIndex] = false;
	m_sItemEquipmentStatus[m_pItemList[sItemIndex]->m_cEquipPos] = -1;

	if (memcmp(m_pItemList[sItemIndex]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
	else PlaySound('E', 29, 0);
}

void CGame::NotifyMsg_ItemRepaired(char* pData)
{
	char cTxt[120];
	DWORD dwItemID, dwLife;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemRepaired>(
		pData, sizeof(hb::net::PacketNotifyItemRepaired));
	if (!pkt) return;
	dwItemID = pkt->item_id;
	dwLife = pkt->life;

	m_pItemList[dwItemID]->m_wCurLifeSpan = (WORD)dwLife;
	m_bIsItemDisabled[dwItemID] = false;
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[dwItemID], cStr1, cStr2, cStr3);

	wsprintf(cTxt, NOTIFYMSG_ITEMREPAIRED1, cStr1);

	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_ItemToBank(char* pData)
{
	char cIndex;
	DWORD dwCount, dwAttribute;
	char  cName[21], cItemType, cEquipPos, cGenderLimit, cItemColor;
	bool  bIsEquipped;
	short sSprite, sSpriteFrame, sLevelLimit, sItemEffectValue2, sItemSpecEffectValue2;
	WORD wWeight, wCurLifeSpan;
	char  cTxt[120];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyItemToBank>(
		pData, sizeof(hb::net::PacketNotifyItemToBank));
	if (!pkt) return;

	cIndex = static_cast<char>(pkt->bank_index);
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 20);
	dwCount = pkt->count;
	cItemType = static_cast<char>(pkt->item_type);
	cEquipPos = static_cast<char>(pkt->equip_pos);
	bIsEquipped = (pkt->is_equipped != 0);
	sLevelLimit = static_cast<short>(pkt->level_limit);
	cGenderLimit = static_cast<char>(pkt->gender_limit);
	wCurLifeSpan = pkt->cur_lifespan;
	wWeight = pkt->weight;
	sSprite = static_cast<short>(pkt->sprite);
	sSpriteFrame = static_cast<short>(pkt->sprite_frame);
	cItemColor = static_cast<char>(pkt->item_color);
	sItemEffectValue2 = static_cast<short>(pkt->item_effect_value2);
	dwAttribute = pkt->attribute;
	sItemSpecEffectValue2 = static_cast<short>(pkt->spec_effect_value2);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);


	if (m_pBankList[cIndex] == 0) {
		m_pBankList[cIndex] = new class CItem;

		memcpy(m_pBankList[cIndex]->m_cName, cName, 20);
		m_pBankList[cIndex]->m_dwCount = dwCount;

		m_pBankList[cIndex]->m_cItemType = cItemType;
		m_pBankList[cIndex]->m_cEquipPos = cEquipPos;

		m_pBankList[cIndex]->m_sLevelLimit = sLevelLimit;
		m_pBankList[cIndex]->m_cGenderLimit = cGenderLimit;
		m_pBankList[cIndex]->m_wCurLifeSpan = wCurLifeSpan;
		m_pBankList[cIndex]->m_wWeight = wWeight;
		m_pBankList[cIndex]->m_sSprite = sSprite;
		m_pBankList[cIndex]->m_sSpriteFrame = sSpriteFrame;
		m_pBankList[cIndex]->m_cItemColor = cItemColor;
		m_pBankList[cIndex]->m_sItemEffectValue2 = sItemEffectValue2;
		m_pBankList[cIndex]->m_dwAttribute = dwAttribute;
		m_pBankList[cIndex]->m_sItemSpecEffectValue2 = sItemSpecEffectValue2;

		std::memset(cTxt, 0, sizeof(cTxt));
		if (dwCount == 1) wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK3, cStr1);
		else wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK2, dwCount, cStr1);

		if (m_dialogBoxManager.IsEnabled(DialogBoxId::Bank) == true) m_dialogBoxManager.Info(DialogBoxId::Bank).sView = DEF_MAXBANKITEMS - 12;
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_Killed(char* pData)
{
	char cAttackerName[21];
	m_bCommandAvailable = false;
	m_cCommand = DEF_OBJECTSTOP;
	m_iHP = 0;
	m_cCommand = -1;
	// Restart
	m_bItemUsingStatus = false;
	ClearSkillUsingStatus();
	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyKilled>(
		pData, sizeof(hb::net::PacketNotifyKilled));
	if (!pkt) return;
	memcpy(cAttackerName, pkt->attacker_name, 20);
	/*	if (strlen(cAttackerName) == 0) // removed in v2.20 (bug?) Many servers send the info themselves.
			AddEventList(NOTIFYMSG_KILLED1, 10);
		else
		{	wsprintf(G_cTxt, NOTIFYMSG_KILLED2, cAttackerName);
			AddEventList(G_cTxt, 10);
		}*/
		// Snoopy: reduced 3 lines -> 2 lines
	AddEventList(NOTIFYMSG_KILLED1, 10);
	AddEventList(NOTIFYMSG_KILLED3, 10);
	//AddEventList(NOTIFYMSG_KILLED4, 10);//"Log Out
}

// This msg is sent by server when lvl-up
void CGame::NotifyMsg_LevelUp(char* pData)
{
	int i, iPrevLevel;
	char cTxt[120];

	iPrevLevel = m_iLevel;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyLevelUp>(
		pData, sizeof(hb::net::PacketNotifyLevelUp));
	if (!pkt) return;

	m_iLevel = pkt->level;
	m_iStr = pkt->str;
	m_iVit = pkt->vit;
	m_iDex = pkt->dex;
	m_iInt = pkt->intel;
	m_iMag = pkt->mag;
	m_iCharisma = pkt->chr;

	// CLEROTH - LU
	m_iLU_Point = m_iLevel * 3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;

	wsprintf(cTxt, NOTIFYMSG_LEVELUP1, m_iLevel);// "Level up!!! Level %d!"
	AddEventList(cTxt, 10);

	switch (m_sPlayerType) {
	case 1:
	case 2:
	case 3:
		PlaySound('C', 21, 0);
		break;

	case 4:
	case 5:
	case 6:
		PlaySound('C', 22, 0);
		break;
	}

	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == 0) {
			std::memset(cTxt, 0, sizeof(cTxt));
			strcpy(cTxt, "Level up!");
			m_pChatMsgList[i] = new class CMsg(23, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = 0;
			}
			return;
		}
}

// CLEROTH - LU
void CGame::NotifyMsg_SettingSuccess(char* pData)
{
	int iPrevLevel;
	char cTxt[120];
	iPrevLevel = m_iLevel;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyLevelUp>(
		pData, sizeof(hb::net::PacketNotifyLevelUp));
	if (!pkt) return;
	m_iLevel = pkt->level;
	m_iStr = pkt->str;
	m_iVit = pkt->vit;
	m_iDex = pkt->dex;
	m_iInt = pkt->intel;
	m_iMag = pkt->mag;
	m_iCharisma = pkt->chr;
	wsprintf(cTxt, "Your stat has been changed.");
	AddEventList(cTxt, 10);
	// CLEROTH - LU
	m_iLU_Point = m_iLevel * 3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
}

void CGame::NotifyMsg_MagicEffectOff(char* pData)
{
	short  sMagicType, sMagicEffect;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMagicEffect>(
		pData, sizeof(hb::net::PacketNotifyMagicEffect));
	if (!pkt) return;
	sMagicType = static_cast<short>(pkt->magic_type);
	sMagicEffect = static_cast<short>(pkt->effect);
	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		switch (sMagicEffect) {
		case 1: // "Protection from arrows has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF1, 10);
			break;
		case 2:	// "Protection from magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF2, 10);
			break;
		case 3:	// "Defense shield effect has vanished."
		case 4:	// "Defense shield effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF3, 10);
			break;
		case 5:	// "Absolute Magic Protection has been vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF14, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1:	// "Hold person magic effect has vanished."
			m_bParalyze = false;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF4, 10);
			break;

		case 2:	// "Paralysis magic effect has vanished."
			m_bParalyze = false;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF5, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1:	// "Invisibility magic effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF6, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:	// "Language confuse magic effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF7, 10);
			break;
		case 2:	// "Confusion magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF8, 10);
			m_bIsConfusion = false;
			break;
		case 3:	// "Illusion magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF9, 10);
			m_iIlusionOwnerH = 0;
			break;
		case 4:	// "At last, you gather your senses." // snoopy
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF15, 10);
			m_bIllusionMVT = false;
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		if (m_bIsPoisoned) AddEventList(NOTIFYMSG_MAGICEFFECT_OFF10, 10);
		m_bIsPoisoned = false;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF11, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF12, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_OFF13, 10);
		break;
	}
}

void CGame::NotifyMsg_MagicEffectOn(char* pData)
{
	short  sMagicType, sMagicEffect, sOwnerH;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMagicEffect>(
		pData, sizeof(hb::net::PacketNotifyMagicEffect));
	if (!pkt) return;
	sMagicType = static_cast<short>(pkt->magic_type);
	sMagicEffect = static_cast<short>(pkt->effect);
	sOwnerH = static_cast<short>(pkt->owner);
	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		switch (sMagicEffect) {
		case 1: // "You are completely protected from arrows!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON1, 10);
			break;
		case 2: // "You are protected from magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON2, 10);
			break;
		case 3: // "Defense ratio increased by a magic shield!"
		case 4: // "Defense ratio increased by a magic shield!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON3, 10);
			break;
		case 5: // "You are completely protected from magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON14, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1: // "You were bounded by a Hold Person spell! Unable to move!"
			m_bParalyze = true;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON4, 10);
			break;
		case 2: // "You were bounded by a Paralysis spell! Unable to move!"
			m_bParalyze = true;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON5, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1: // "You are now invisible, no one can see you!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON6, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:	// Confuse Language "No one understands you because of language confusion magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON7, 10);
			break;

		case 2: // Confusion "Confusion magic casted, impossible to determine player allegience."
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON8, 10);
			m_bIsConfusion = true;
			break;

		case 3:	// Illusion "Illusion magic casted, impossible to tell who is who!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON9, 10);
			_SetIlusionEffect(sOwnerH);
			break;

		case 4:	// IllusionMouvement "You are thrown into confusion, and you are flustered yourself." // snoopy
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON15, 10);
			m_bIllusionMVT = true;
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON10, 10);
		m_bIsPoisoned = true;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON11, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON12, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON13, 10);
		break;
	}
}

void CGame::NotifyMsg_MagicStudyFail(char* pData)
{
	char cMagicNum, cName[31], cFailCode;
	char cTxt[120];
	int iCost, iReqInt, iReqStr;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMagicStudyFail>(
		pData, sizeof(hb::net::PacketNotifyMagicStudyFail));
	if (!pkt) return;
	cFailCode = static_cast<char>(pkt->result);
	cMagicNum = static_cast<char>(pkt->magic_id);
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->magic_name, 30);
	iCost = pkt->cost;
	iReqInt = pkt->req_int;
	/*	// Snoopy: remove special CLEROTH's feature
		ip = (int *)cp;
		iReqStr = *ip;
		cp += 4;
		// CLEROTH
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL4, cName, iCost, iReqInt, iReqStr);
		AddEventList(cTxt, 10);*/

	if (iCost > 0)
	{
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL1, cName);
		AddEventList(cTxt, 10);
	}
	else
	{
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL2, cName);
		AddEventList(cTxt, 10);
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL3, iReqInt);
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_MagicStudySuccess(char* pData)
{
	char cMagicNum, cName[31];
	char cTxt[120];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMagicStudySuccess>(
		pData, sizeof(hb::net::PacketNotifyMagicStudySuccess));
	if (!pkt) return;
	cMagicNum = static_cast<char>(pkt->magic_id);
	m_cMagicMastery[cMagicNum] = 1;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->magic_name, 30);
	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_SUCCESS1, cName);
	AddEventList(cTxt, 10);
	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_MP(char* pData)
{
	int iPrevMP;
	char cTxt[120];
	iPrevMP = m_iMP;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyMP>(
		pData, sizeof(hb::net::PacketNotifyMP));
	if (!pkt) return;
	m_iMP = static_cast<int>(pkt->mp);
	if (abs(m_iMP - iPrevMP) < 10) return;
	if (m_iMP > iPrevMP)
	{
		wsprintf(cTxt, NOTIFYMSG_MP_UP, m_iMP - iPrevMP);//"MP�
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else
	{
		wsprintf(cTxt, NOTIFYMSG_MP_DOWN, iPrevMP - m_iMP);//"MP�
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_NewGuildsMan(char* pData)
{
	char cName[12], cTxt[120];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyNewGuildsMan>(
		pData, sizeof(hb::net::PacketNotifyNewGuildsMan));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	wsprintf(cTxt, NOTIFYMSG_NEW_GUILDMAN1, cName);
	AddEventList(cTxt, 10);
	ClearGuildNameList();
}

void CGame::NotifyMsg_PKcaptured(char* pData)
{
	DWORD iExp, iRewardGold;
	int     iPKcount, iLevel;
	char cTxt[120], cName[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPKcaptured>(
		pData, sizeof(hb::net::PacketNotifyPKcaptured));
	if (!pkt) return;
	iPKcount = pkt->pk_count;
	iLevel = pkt->victim_pk_count;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->victim_name, 10);
	iRewardGold = pkt->reward_gold;
	iExp = pkt->exp;
	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED1, iLevel, cName, iPKcount);
	AddEventList(cTxt, 10);
	wsprintf(cTxt, EXP_INCREASED, iExp - m_iExp);
	AddEventList(cTxt, 10);
	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED3, iExp - m_iExp);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_PKpenalty(char* pData)
{
	DWORD iExp;
	int     iPKcount, iStr, iVit, iDex, iInt, iMag, iChr;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPKpenalty>(
		pData, sizeof(hb::net::PacketNotifyPKpenalty));
	if (!pkt) return;
	iExp = pkt->exp;
	iStr = pkt->str;
	iVit = pkt->vit;
	iDex = pkt->dex;
	iInt = pkt->intel;
	iMag = pkt->mag;
	iChr = pkt->chr;
	iPKcount = pkt->pk_count;
	wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY1, iPKcount);
	AddEventList(G_cTxt, 10);
	if (m_iExp > iExp)
	{
		wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY2, m_iExp - iExp);
		AddEventList(G_cTxt, 10);
	}
	m_iExp = iExp;
	m_iStr = iStr;
	m_iVit = iVit;
	m_iDex = iDex;
	m_iInt = iInt;
	m_iMag = iMag;
	m_iCharisma = iChr;
	m_iPKCount = iPKcount;
}

void CGame::NotifyMsg_PlayerShutUp(char* pData)
{
	char cName[12];
	WORD wTime;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPlayerShutUp>(
		pData, sizeof(hb::net::PacketNotifyPlayerShutUp));
	if (!pkt) return;
	wTime = pkt->time;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	if (memcmp(m_cPlayerName, cName, 10) == 0)
		wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP1, wTime);
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP2, cName, wTime);

	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_PlayerStatus(bool bOnGame, char* pData)
{
	char cName[12], cMapName[12];
	uint16_t dx = 1, dy = 1;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyPlayerStatus>(
		pData, sizeof(hb::net::PacketNotifyPlayerStatus));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	std::memset(cMapName, 0, sizeof(cMapName));
	memcpy(cMapName, pkt->map_name, 10);
	dx = pkt->x;
	dy = pkt->y;
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	if (bOnGame == true) {
		if (strlen(cMapName) == 0)
			wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS1, cName);
		else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS2, cName, cMapName, dx, dy);
	}
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS3, cName);
	AddEventList(G_cTxt, 10);
}


void CGame::NotifyMsg_QuestReward(char* pData)
{
	short sWho, sFlag;
	char cRewardName[21], cTxt[120];
	int iAmount, iIndex, iPreCon;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyQuestReward>(
		pData, sizeof(hb::net::PacketNotifyQuestReward));
	if (!pkt) return;
	sWho = pkt->who;
	sFlag = pkt->flag;
	iAmount = pkt->amount;
	std::memset(cRewardName, 0, sizeof(cRewardName));
	memcpy(cRewardName, pkt->reward_name, 20);
	iPreCon = m_iContribution;
	m_iContribution = pkt->contribution;

	if (sFlag == 1)
	{
		m_stQuest.sWho = 0;
		m_stQuest.sQuestType = 0;
		m_stQuest.sContribution = 0;
		m_stQuest.sTargetType = 0;
		m_stQuest.sTargetCount = 0;
		m_stQuest.sX = 0;
		m_stQuest.sY = 0;
		m_stQuest.sRange = 0;
		m_stQuest.sCurrentCount = 0;
		m_stQuest.bIsQuestCompleted = false;
		std::memset(m_stQuest.cTargetName, 0, sizeof(m_stQuest.cTargetName));
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, 0, sWho + 110, 0);
		iIndex = m_dialogBoxManager.Info(DialogBoxId::NpcTalk).sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
		std::memset(cTxt, 0, sizeof(cTxt));
		if (memcmp(cRewardName, "����ġ", 6) == 0)
		{
			if (iAmount > 0) wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD1, iAmount);
		}
		else
		{
			wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD2, iAmount, cRewardName);
		}
		m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
		iIndex++;
		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
		std::memset(cTxt, 0, sizeof(cTxt));
		if (iPreCon < m_iContribution)
			wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD3, m_iContribution - iPreCon);
		else wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD4, iPreCon - m_iContribution);

		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
	}
	else m_dialogBoxManager.EnableDialogBox(DialogBoxId::NpcTalk, 0, sWho + 120, 0);
}

void CGame::NotifyMsg_RatingPlayer(char* pData)
{//int * ip;
	char cName[12];
	uint16_t cValue;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyRatingPlayer>(
		pData, sizeof(hb::net::PacketNotifyRatingPlayer));
	if (!pkt) return;
	cValue = pkt->result;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	//	ip = (int *)cp;
	//	m_iRating = *ip;
	std::memset(G_cTxt, 0, sizeof(G_cTxt));
	if (memcmp(m_cPlayerName, cName, 10) == 0)
	{
		if (cValue == 1)
		{
			strcpy(G_cTxt, NOTIFYMSG_RATING_PLAYER1);
			PlaySound('E', 23, 0);
		}
	}
	else
	{
		if (cValue == 1)
			wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER2, cName);
		else wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER3, cName);
	}
	AddEventList(G_cTxt, 10);
}


void CGame::NotifyMsg_ServerChange(char* pData)
{
	char cWorldServerAddr[16];
	int iWorldServerPort;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyServerChange>(
		pData, sizeof(hb::net::PacketNotifyServerChange));
	if (!pkt) return;

	std::memset(m_cMapName, 0, sizeof(m_cMapName));
	std::memset(m_cMapMessage, 0, sizeof(m_cMapMessage));
	std::memset(cWorldServerAddr, 0, sizeof(cWorldServerAddr));

	memcpy(m_cMapName, pkt->map_name, 10);
	memcpy(cWorldServerAddr, pkt->log_server_addr, 15);
	iWorldServerPort = pkt->log_server_port;
	if (m_pGSock != 0)
	{
		delete m_pGSock;
		m_pGSock = 0;
	}
	if (m_pLSock != 0)
	{
		delete m_pLSock;
		m_pLSock = 0;
	}
	m_pLSock = new class XSocket(DEF_SOCKETBLOCKLIMIT);
	m_pLSock->bConnect(m_cLogServerAddr, iWorldServerPort);
	m_pLSock->bInitBufferSize(30000);

	m_bIsPoisoned = false;

	ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
	m_dwConnectMode = MSGID_REQUEST_ENTERGAME;
	//m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW; //Gateway
	m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW_TOWLSBUTMLS;
	std::memset(m_cMsg, 0, sizeof(m_cMsg));
	strcpy(m_cMsg, "55");
}

void CGame::NotifyMsg_SetItemCount(char* pData)
{
	short  sItemIndex;
	uint32_t dwCount;
	bool   bIsItemUseResponse;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySetItemCount>(
		pData, sizeof(hb::net::PacketNotifySetItemCount));
	if (!pkt) return;
	sItemIndex = static_cast<short>(pkt->item_index);
	dwCount = pkt->count;
	bIsItemUseResponse = (pkt->notify != 0);
	if (m_pItemList[sItemIndex] != 0)
	{
		m_pItemList[sItemIndex]->m_dwCount = dwCount;
		if (bIsItemUseResponse == true) m_bIsItemDisabled[sItemIndex] = false;
	}
}

void CGame::NotifyMsg_ShowMap(char* pData)
{
	WORD w1, w2;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyShowMap>(
		pData, sizeof(hb::net::PacketNotifyShowMap));
	if (!pkt) return;
	w1 = pkt->map_id;
	w2 = pkt->map_type;
	if (w2 == 0) AddEventList(NOTIFYMSG_SHOW_MAP1, 10);
	else m_dialogBoxManager.EnableDialogBox(DialogBoxId::Map, 0, w1, w2 - 1);
}

void CGame::NotifyMsg_Skill(char* pData)
{
	short sSkillIndex, sValue;
	char cTxt[120];
	int i;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySkill>(
		pData, sizeof(hb::net::PacketNotifySkill));
	if (!pkt) return;
	sSkillIndex = static_cast<short>(pkt->skill_index);
	sValue = static_cast<short>(pkt->skill_value);
	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
	if (m_pSkillCfgList[sSkillIndex]->m_iLevel < sValue)
	{
		wsprintf(cTxt, NOTIFYMSG_SKILL1, m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
		AddEventList(cTxt, 10);
		PlaySound('E', 23, 0);
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s +%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
				m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
				if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				break;
			}
	}
	else if (m_pSkillCfgList[sSkillIndex]->m_iLevel > sValue) {
		wsprintf(cTxt, NOTIFYMSG_SKILL2, m_pSkillCfgList[sSkillIndex]->m_cName, m_pSkillCfgList[sSkillIndex]->m_iLevel - sValue);
		AddEventList(cTxt, 10);
		PlaySound('E', 24, 0);
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s -%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
				m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
				if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				break;
			}
	}
	m_pSkillCfgList[sSkillIndex]->m_iLevel = sValue;
	m_cSkillMastery[sSkillIndex] = (unsigned char)sValue;
}


void CGame::NotifyMsg_SkillTrainSuccess(char* pData)
{
	char cSkillNum, cSkillLevel;
	char cTemp[120];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySkillTrainSuccess>(
		pData, sizeof(hb::net::PacketNotifySkillTrainSuccess));
	if (!pkt) return;
	cSkillNum = static_cast<char>(pkt->skill_num);
	cSkillLevel = static_cast<char>(pkt->skill_level);
	std::memset(cTemp, 0, sizeof(cTemp));
	wsprintf(cTemp, NOTIFYMSG_SKILL_TRAIN_SUCCESS1, m_pSkillCfgList[cSkillNum]->m_cName, cSkillLevel);
	AddEventList(cTemp, 10);
	m_pSkillCfgList[cSkillNum]->m_iLevel = cSkillLevel;
	m_cSkillMastery[cSkillNum] = (unsigned char)cSkillLevel;
	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_SkillUsingEnd(char* pData)
{
	WORD wResult;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySkillUsingEnd>(
		pData, sizeof(hb::net::PacketNotifySkillUsingEnd));
	if (!pkt) return;
	wResult = pkt->result;
	switch (wResult) {
	case 0:
		AddEventList(NOTIFYMSG_SKILL_USINGEND1, 10);
		break;
	case 1:
		AddEventList(NOTIFYMSG_SKILL_USINGEND2, 10);
		break;
	}
	m_bSkillUsingStatus = false;
}

void CGame::NotifyMsg_SP(char* pData)
{
	int iPrevSP;
	iPrevSP = m_iSP;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifySP>(
		pData, sizeof(hb::net::PacketNotifySP));
	if (!pkt) return;
	m_iSP = static_cast<int>(pkt->sp);
	if (abs(m_iSP - iPrevSP) < 10) return;
	if (m_iSP > iPrevSP)
	{
		wsprintf(G_cTxt, NOTIFYMSG_SP_UP, m_iSP - iPrevSP);
		AddEventList(G_cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else
	{
		wsprintf(G_cTxt, NOTIFYMSG_SP_DOWN, iPrevSP - m_iSP);
		AddEventList(G_cTxt, 10);
	}
}

void CGame::NotifyMsg_TotalUsers(char* pData)
{
	int iTotal;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyTotalUsers>(
		pData, sizeof(hb::net::PacketNotifyTotalUsers));
	if (!pkt) return;
	iTotal = pkt->total;
	wsprintf(G_cTxt, NOTIFYMSG_TOTAL_USER1, iTotal);
	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_WhisperMode(bool bActive, char* pData)
{
	char cName[12];
	const auto* pkt = hb::net::PacketCast<hb::net::PacketNotifyWhisperMode>(
		pData, sizeof(hb::net::PacketNotifyWhisperMode));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, 10);
	if (bActive == true)
	{
		wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE1, cName);
		if (m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] != 0) {
			delete m_pWhisperMsg[DEF_MAXWHISPERMSG - 1];
			m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] = 0;
		}
		for (int i = DEF_MAXWHISPERMSG - 2; i >= 0; i--) {
			m_pWhisperMsg[i + 1] = m_pWhisperMsg[i];
			m_pWhisperMsg[i] = 0;
		}
		m_pWhisperMsg[0] = new class CMsg(0, cName, 0);
		m_cWhisperIndex = 0;
	}
	else wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE2, cName);

	AddEventList(G_cTxt, 10);
}

void CGame::_Draw_OnLogin(char* pAccount, char* pPassword, int msX, int msY, int iFrame)
{
	bool bFlag = true;
	uint32_t dwTime = GameClock::GetTimeMS();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0 + SCREENX, 0 + SCREENY, 0, true);
	DrawVersion();

	if ((iFrame >= 15) && (iFrame <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(39 + SCREENX, 121 + SCREENY, 2, true);
	else if (iFrame > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 39 + SCREENX, 121 + SCREENY, 2, true);

	if (m_cCurFocus != 1) {
		if (CMisc::bCheckValidName(pAccount) != false)
			PutString2(180 + SCREENX, 162 + SCREENY, pAccount, 200, 200, 200);
		else PutString2(180 + SCREENX, 162 + SCREENY, pAccount, 200, 100, 100);
	}
	if ((CMisc::bCheckValidName(pAccount) == false) || (strlen(pAccount) == 0)) bFlag = false;

	if (m_cCurFocus != 2) {
		if ((CMisc::bCheckValidString(pPassword) != false))
			PutString(180 + SCREENX, 185 + SCREENY, pPassword, RGB(200, 200, 200), true, 1);
		else PutString(180 + SCREENX, 185 + SCREENY, pPassword, RGB(200, 100, 100), true, 1);
	}
	if ((CMisc::bCheckValidString(pPassword) == false) || (strlen(pPassword) == 0)) bFlag = false;

	if (m_cCurFocus == 1)
		ShowReceivedString();
	else
		if (m_cCurFocus == 2)
			ShowReceivedString(true);

	if (bFlag == true)
	{
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 80 + SCREENX, 282 + SCREENY, 3, true);
	}
	if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256 + SCREENX, 282 + SCREENY, 4, true);
	if ((m_bIsHideLocalCursor != true) && (msX != 0) && (msY != 0)) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	}
}

void CGame::ShowEventList(uint32_t dwTime)
{
	int i;
	int baseY = EVENTLIST2_BASE_Y;
	m_DDraw._GetBackBufferDC();
	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory[i].dwTime) < 5000)
		{
			switch (m_stEventHistory[i].cColor) {
			case 0:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(225, 225, 225), false, 1, true);
				break;
			case 1:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(130, 255, 130), false, 1, true);
				break;
			case 2:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(255, 130, 130), false, 1, true);
				break;
			case 3:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(130, 130, 255), false, 1, true);
				break;
			case 4:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(230, 230, 130), false, 1, true);
				break;
			case 10:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(180, 255, 180), false, 1, true);
				break;
			case 20:
				PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, RGB(150, 150, 170), false, 1, true);
				break;
			}
		}

	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory2[i].dwTime) < 5000)
		{
			switch (m_stEventHistory2[i].cColor) {
			case 0:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(225, 225, 225), false, 1, true);
				break;
			case 1:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(130, 255, 130), false, 1, true);
				break;
			case 2:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(255, 130, 130), false, 1, true);
				break;
			case 3:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(130, 130, 255), false, 1, true);
				break;
			case 4:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(230, 230, 130), false, 1, true);
				break;
			case 10:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(180, 255, 180), false, 1, true);
				break;
			case 20:
				PutString(10, baseY + i * 15, m_stEventHistory2[i].cTxt, RGB(150, 150, 170), false, 1, true);
				break;
			}
		}
	if (m_bSkillUsingStatus == true)
	{
		PutString(440 - 29, 440 - 52, SHOW_EVENT_LIST1, RGB(235, 235, 235), false, 1, true);
	}
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::RequestTeleportAndWaitData()
{	// Snoopy: removed that, Noob Dungeon is now at farm...
	/*if (strcmp(m_cMapName, "aresden") == 0)
	{	if ( ((m_sPlayerX == 188) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 107))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}
	if (strcmp(m_cMapName, "elvine") == 0)
	{	if ( ((m_sPlayerX == 218) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 111))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}*/
	bSendCommand(MSGID_REQUEST_TELEPORT, 0, 0, 0, 0, 0, 0);
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
}

void CGame::InitDataResponseHandler(char* pData)
{
	int i;
	short sX, sY;
	const char* cp;
	char cMapFileName[32], cTxt[120], cPreCurLocation[12];
	bool  bIsObserverMode;
	HANDLE hFile;
	uint32_t dwFileSize;

	std::memset(cPreCurLocation, 0, sizeof(cPreCurLocation));
	m_bParalyze = false;
	m_pMapData->Init();

	m_sMonsterID = 0;
	m_dwMonsterEventTime = 0;

	m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::SaleMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CityHallMenu);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Bank);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::MagicShop);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Map);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcActionQuery);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::NpcTalk);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::SellOrRepair);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildHallMenu); // Gail's diag

	m_cCommand = DEF_OBJECTSTOP;
	//m_bCommandAvailable = true;
	m_cCommandCount = 0;
	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1;
	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;
	m_bIsTeleportRequested = false;
	m_bIsConfusion = false;
	m_bSkillUsingStatus = false;

	m_bItemUsingStatus = false;

	m_cRestartCount = -1;
	m_dwRestartCountTime = 0;

	for (i = 0; i < DEF_MAXEFFECTS; i++)
	{
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];
		m_pEffectList[i] = 0;
	}

	for (i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
	{
		m_stWhetherObject[i].sX = 0;
		m_stWhetherObject[i].sBX = 0;
		m_stWhetherObject[i].sY = 0;
		m_stWhetherObject[i].cStep = 0;
	}

	for (i = 0; i < DEF_MAXGUILDNAMES; i++)
	{
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		std::memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		std::memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = 0;
	}

	const auto* pkt = hb::net::PacketCast<hb::net::PacketResponseInitDataHeader>(
		pData, sizeof(hb::net::PacketResponseInitDataHeader));
	if (!pkt) return;
	m_sPlayerObjectID = pkt->player_object_id;
	sX = pkt->pivot_x;
	sY = pkt->pivot_y;
	m_sPlayerType = pkt->player_type;
	m_sPlayerAppr1 = pkt->appr1;
	m_sPlayerAppr2 = pkt->appr2;
	m_sPlayerAppr3 = pkt->appr3;
	m_sPlayerAppr4 = pkt->appr4;
	m_iPlayerApprColor = pkt->appr_color;
	m_iPlayerStatus = pkt->status;

	//Snoopy MIM fix
	if ((m_iPlayerStatus & 0x00200000) == 0x00200000)
	{
		m_bIllusionMVT = true;
	}
	else
	{
		m_bIllusionMVT = false;
	}
	std::memset(m_cMapName, 0, sizeof(m_cMapName));
	std::memset(m_cMapMessage, 0, sizeof(m_cMapMessage));
	memcpy(m_cMapName, pkt->map_name, sizeof(pkt->map_name));
	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	if (m_cMapIndex < 0)
	{
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX = -1;
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY = -1;
	}
	else
	{
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeX = 128;
		m_dialogBoxManager.Info(DialogBoxId::GuideMap).sSizeY = 128;
	}

	strcpy(cPreCurLocation, m_cCurLocation);
	std::memset(m_cCurLocation, 0, sizeof(m_cCurLocation));
	memcpy(m_cCurLocation, pkt->cur_location, sizeof(pkt->cur_location));

	G_cSpriteAlphaDegree = static_cast<char>(pkt->sprite_alpha);

	m_cWhetherStatus = static_cast<char>(pkt->weather_status);
	switch (G_cSpriteAlphaDegree) { //Snoopy:  Xmas bulbs
		// Will be sent by server if DayTime is 3 (and a snowy weather)
	case 1:	m_bIsXmas = false; break;
	case 2: m_bIsXmas = false; break;
	case 3: // Snoopy Special night with chrismas bulbs
		if (m_cWhetherStatus > 3) m_bIsXmas = true;
		else m_bIsXmas = false;
		G_cSpriteAlphaDegree = 2;
		break;
	}
	m_iContribution = pkt->contribution;
	//	m_iContributionPrice = 0;
	bIsObserverMode = pkt->observer_mode != 0;
	//	m_iRating = pkt->rating;
	m_iHP = pkt->hp;
	m_cDiscount = static_cast<char>(pkt->discount);

	cp = reinterpret_cast<const char*>(pData) + sizeof(hb::net::PacketResponseInitDataHeader);

	if (m_cWhetherStatus != 0)
		SetWhetherStatus(true, m_cWhetherStatus);
	else SetWhetherStatus(false, m_cWhetherStatus);

	std::memset(cMapFileName, 0, sizeof(cMapFileName));
	strcat(cMapFileName, "mapdata\\");
	// CLEROTH - MW MAPS
	if (memcmp(m_cMapName, "defaultmw", 9) == 0)
	{
		strcat(cMapFileName, "mw\\defaultmw");
	}
	else
	{
		strcat(cMapFileName, m_cMapName);
	}

	strcat(cMapFileName, ".amd");
	m_pMapData->OpenMapDataFile(cMapFileName);

	m_pMapData->m_sPivotX = sX;
	m_pMapData->m_sPivotY = sY;

	m_sPlayerX = sX + 19;
	m_sPlayerY = sY + 17;

	m_cPlayerDir = 5;

	if (bIsObserverMode == false)
	{
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
			m_iPlayerStatus, m_cPlayerName,
			DEF_OBJECTSTOP, 0, 0, 0);
	}

	//m_sViewDstX = m_sViewPointX = (sX + VIEW_CENTER_TILE_X) * 32 - 16;
	//m_sViewDstY = m_sViewPointY = (sY + VIEW_CENTER_TILE_Y + 1) * 32 - 16;
	m_sViewDstX = m_sViewPointX = (m_sPlayerX - VIEW_CENTER_TILE_X) * 32;
	m_sViewDstY = m_sViewPointY = (m_sPlayerY - (VIEW_CENTER_TILE_Y + 1)) * 32;
	_ReadMapData(sX + 7, sY + 8, cp);
	m_bIsRedrawPDBGS = true;
	// ------------------------------------------------------------------------+
	wsprintf(cTxt, INITDATA_RESPONSE_HANDLER1, m_cMapMessage);
	AddEventList(cTxt, 10);

	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sX = 150;
	m_dialogBoxManager.Info(DialogBoxId::WarningBattleArea).sY = 130;

	if ((memcmp(m_cCurLocation, "middleland", 10) == 0)
		|| (memcmp(m_cCurLocation, "dglv2", 5) == 0)
		|| (memcmp(m_cCurLocation, "middled1n", 9) == 0))
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::WarningBattleArea, 0, 0, 0);

	// Snoopy: removed for v351 compatibility. Maybe usefull later...
	/*	bool bPrevSafe, bNowSafe;
		if( memcmp( cPreCurLocation, m_cLocation, 3 ) == 0 )
			bPrevSafe = true;
		else bPrevSafe = false;

		if( memcmp( m_cCurLocation, m_cLocation, 3 ) == 0 )
			bNowSafe = true;
		else bNowSafe = false;

		if( memcmp( m_cCurLocation, "2nd", 3 ) == 0 ) bNowSafe = true;
		if( m_iPKCount != 0 ) bNowSafe = false;

		if( bPrevSafe )
		{	if( bNowSafe == false ) SetTopMsg(DEF_MSG_DANGERZONE, 5);
		}else
		{	if( bNowSafe ) SetTopMsg(DEF_MSG_SAFEZONE, 5);
		}*/

		// ------------------------------------------------------------------------+

	ChangeGameMode(DEF_GAMEMODE_ONMAINGAME);

	//v1.41
	if ((m_sPlayerAppr2 & 0xF000) != 0)
		m_bIsCombatMode = true;
	else m_bIsCombatMode = false;

	//v1.42
	if (m_bIsFirstConn == true)
	{
		m_bIsFirstConn = false;
		hFile = CreateFile("contents\\contents1000.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		if (hFile == INVALID_HANDLE_VALUE)
			dwFileSize = 0;
		else
		{
			dwFileSize = GetFileSize(hFile, 0);
			CloseHandle(hFile);
		}
		bSendCommand(MSGID_REQUEST_NOTICEMENT, 0, 0, (int)dwFileSize, 0, 0, 0);
	}
	//cp += 2;
}

void CGame::MotionEventHandler(char* pData)
{
	WORD wEventType, wObjectID;
	short sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sV1, sV2, sV3, sPrevAppr2;
	int iStatus;
	char cDir, cName[12];
	int iApprColor, iLoc;
	char    cTxt[120];
	int i;
	std::memset(cName, 0, sizeof(cName));
	sX = -1;
	sY = -1;
	sV1 = sV2 = sV3 = 0;
	iApprColor = 0;
	iStatus = 0;
	iLoc = 0;
	cDir = 0;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wEventType = header->msg_type;

	const auto* baseId = hb::net::PacketCast<hb::net::PacketEventMotionBaseId>(pData, sizeof(hb::net::PacketEventMotionBaseId));
	if (!baseId) return;
	wObjectID = baseId->object_id;

	if (wObjectID < 30000)
	{
		if (wObjectID < 10000) 	// Player
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionPlayer>(pData, sizeof(hb::net::PacketEventMotionPlayer));
			if (!pkt) return;
			sX = pkt->x;
			sY = pkt->y;
			sType = pkt->type;
			cDir = static_cast<char>(pkt->dir);
			memcpy(cName, pkt->name, sizeof(pkt->name));
			sAppr1 = pkt->appr1;
			sAppr2 = pkt->appr2;
			sAppr3 = pkt->appr3;
			sAppr4 = pkt->appr4;
			iApprColor = pkt->appr_color;
			iStatus = pkt->status;
			iLoc = pkt->loc;
		}
		else 	// Npc or mob
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionNpc>(pData, sizeof(hb::net::PacketEventMotionNpc));
			if (!pkt) return;
			sX = pkt->x;
			sY = pkt->y;
			sType = pkt->type;
			cDir = static_cast<char>(pkt->dir);
			memcpy(cName, pkt->name, sizeof(pkt->name));
			sAppr1 = sAppr3 = sAppr4 = 0;
			sAppr2 = pkt->appr2;
			iStatus = pkt->status;
			iLoc = pkt->loc;
		}
	}
	else
	{
		switch (wEventType) {
		case DEF_OBJECTMOVE:
		case DEF_OBJECTRUN:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionDirOnly>(pData, sizeof(hb::net::PacketEventMotionDirOnly));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sX = -1;
			sY = -1;
		}
		break;

		case DEF_OBJECTMAGIC:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDAMAGEMOVE:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionShort>(pData, sizeof(hb::net::PacketEventMotionShort));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1; // Damage or 0
			sV2 = pkt->v2;
			sX = -1;
			sY = -1;
		}
		break;

		case DEF_OBJECTDYING:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionMove>(pData, sizeof(hb::net::PacketEventMotionMove));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1;
			sV2 = pkt->v2;
			sX = pkt->x;
			sY = pkt->y;
		}
		break;

		case DEF_OBJECTATTACK:
		case DEF_OBJECTATTACKMOVE:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionAttack>(pData, sizeof(hb::net::PacketEventMotionAttack));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
			sV1 = pkt->v1;
			sV2 = pkt->v2;
			sV3 = pkt->v3;
		}
		break;

		default:
		{
			const auto* pkt = hb::net::PacketCast<hb::net::PacketEventMotionDirOnly>(pData, sizeof(hb::net::PacketEventMotionDirOnly));
			if (!pkt) return;
			cDir = static_cast<char>(pkt->dir);
		}
		break;
		}
	}

	if ((wEventType == DEF_OBJECTNULLACTION) && (memcmp(cName, m_cPlayerName, 10) == 0))
	{
		m_sPlayerType = sType;
		m_sPlayerAppr1 = sAppr1;
		sPrevAppr2 = m_sPlayerAppr2;
		m_sPlayerAppr2 = sAppr2;
		m_sPlayerAppr3 = sAppr3;
		m_sPlayerAppr4 = sAppr4;
		m_iPlayerApprColor = iApprColor;
		m_iPlayerStatus = iStatus;
		if ((sPrevAppr2 & 0xF000) == 0)
		{
			if ((sAppr2 & 0xF000) != 0)
			{
				AddEventList(MOTION_EVENT_HANDLER1, 10);
				m_bIsCombatMode = true;
			}
		}
		else
		{
			if ((sAppr2 & 0xF000) == 0)
			{
				AddEventList(MOTION_EVENT_HANDLER2, 10);
				m_bIsCombatMode = false;
			}
		}
		if (m_cCommand != DEF_OBJECTRUN) m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);
	}
	else m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);

	switch (wEventType) {
	case DEF_OBJECTMAGIC: // Casting
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s!", m_pMagicCfgList[sV1]->m_cName);
				m_pChatMsgList[i] = new class CMsg(41, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTDYING:
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				if (sV1 > 0)
					wsprintf(cTxt, "-%dPts!", sV1);
				else strcpy(cTxt, "Critical!");
				int iFontType;
				if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
				else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
				else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;
				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTDAMAGE:
	case DEF_OBJECTDAMAGEMOVE:
		if (memcmp(cName, m_cPlayerName, 10) == 0)
		{
			m_bIsGetPointingMode = false;
			m_iPointCommandType = -1;
			m_stMCursor.sCursorFrame = 0;
			ClearSkillUsingStatus();
		}
		_RemoveChatMsgListByObjectID(static_cast<uint16_t>(wObjectID - 30000));

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				if (sV1 != 0)
				{
					if (sV1 > 0)
						wsprintf(cTxt, "-%dPts", sV1);
					else strcpy(cTxt, "Critical!");
					int iFontType;
					if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
					else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
					else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				}
				else
				{
					strcpy(cTxt, " * Failed! *");
					m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
					PlaySound('C', 17, 0);
				}
				m_pChatMsgList[i]->m_iObjectID = static_cast<uint16_t>(wObjectID - 30000);
				if (m_pMapData->bSetChatMsgOwner(static_cast<uint16_t>(wObjectID - 30000), -10, -10, i) == false)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
				return;
			}
		break;

	case DEF_OBJECTATTACK:
	case DEF_OBJECTATTACKMOVE:
		if (wObjectID == m_sPlayerObjectID + 30000)
		{
			if (m_pMagicCfgList[sV3] != 0)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				wsprintf(cTxt, "%s", m_pMagicCfgList[sV3]->m_cName);
				AddEventList(cTxt, 10);
			}
		}
		break;
	}
}


void CGame::DrawDialogBox_Commander(int msX, int msY) // Snoopy: Fixed for 351
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint32_t dwTime = G_dwGlobalTime;
	double dV1, dV2, dV3;
	int i, tX, tY;
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("middleland", 3);
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans); // Main image
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 15, false, m_bDialogTrans);

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode) {
	case 0: // Main dlg
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 3, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 340, 2, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 340, 30, dwTime); // Btn TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime); // btn ?
		//PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"
		PutAlignedString(sX, sX + szX, sY + 37, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 17, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER2, 255, 255, 255);//"Middleland teleport position set"
		}
		else if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER3, 255, 255, 255);//"Teleport to the selected area"
		}
		else if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 46 + 100)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 340, 16, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER4, 255, 255, 255);//"Recall warfare units"
		}
		else if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 46 + 150)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 340, 24, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER5, 255, 255, 255);//"Middleland construction building set"
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER6, 255, 255, 255);//"Commander's duty help"
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);// Map
		break;

	case 1: // Set TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime); //btn <-
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);  //btn ?
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER7); // "Click and select the teleport location."

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER8, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER9, 255, 255, 255);
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);

		if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272)) // shows TP posit on map following the mouse
		{
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 42, false, true);
		}
		break;

	case 2: // Use TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);       // Btn TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime); // Btn <-
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);  // Btn ?
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER10); // "Teleport to the selected area"

		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER11, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER12, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER13, 255, 255, 255);
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);
		break;

	case 3: // Choose summon
		if ((m_bCitizen == true) && (m_bAresden == true))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 6, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 5, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 7, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 35, dwTime);
		}
		else if ((m_bCitizen == true) && (m_bAresden == false))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 9, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 8, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 7, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 35, dwTime);
		}
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER14); // "Recall warfare units"

		wsprintf(G_cTxt, "%s %d", DRAW_DIALOGBOX_COMMANDER15, m_iConstructionPoint);
		PutAlignedString(sX, sX + 323, sY + 190, G_cTxt);

		if ((m_bCitizen == true) && (m_bAresden == true))
		{
			if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 3000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 11, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER16, 255, 255, 255);//"�(Battle Golem)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER17, 255, 255, 255);//"3000"
			}
			else if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 2000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 10, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER18, 255, 255, 255);//"(Temple Knight)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER19, 255, 255, 255);//"2000"
			}
			else if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 12, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER20, 255, 255, 255);//"(Light War Beetle)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER21, 255, 255, 255);//" 1000"
			}
			else if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 5000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 29, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER22, 255, 255, 255);//"(Catapult)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER23, 255, 255, 255);// 1500"
			}
			else if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 140) && (msY < sY + 160))
			{
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER24, 255, 255, 255);
			}
			else if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 160) && (msY < sY + 175))
			{
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER25, 255, 255, 255);
			}
			else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER26, 255, 255, 255);
			}
			else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER27, 255, 255, 255); //"Warfare units recall related help"
			}
		}
		else if ((m_bCitizen == true) && (m_bAresden == false))
		{
			if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 3000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 14, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER28, 255, 255, 255);//"(God's Hand Knight Cavalry)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER29, 255, 255, 255);//"3000"
			}
			else if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45)
				&& (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 2000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 13, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER30, 255, 255, 255);//"�(God's Hand Knight)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER31, 255, 255, 255);//"2000"
			}
			else if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 1000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 12, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER32, 255, 255, 255);//"(Light War Beetle)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER33, 255, 255, 255);//" 1000"
			}
			else if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
			{
				if (m_iConstructionPoint >= 5000)
				{
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 29, dwTime);
				}
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER34, 255, 255, 255);//"(Catapult)"
				PutString2(msX + 20, msY + 50, DRAW_DIALOGBOX_COMMANDER35, 255, 255, 255);//" 1500"
			}
			else if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 140) && (msY < sY + 160))
			{
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER36, 255, 255, 255);
			}
			else if ((msX >= sX + 20) && (msX <= sX + 380) && (msY > sY + 160) && (msY < sY + 175))
			{
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER37, 255, 255, 255);
			}
			else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER38, 255, 255, 255);

			}
			else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER39, 255, 255, 255);
			}
		}
		PutAlignedString(sX, sX + 323, sY + 80, DRAW_DIALOGBOX_COMMANDER40);
		PutAlignedString(sX, sX + 323, sY + 95, DRAW_DIALOGBOX_COMMANDER41);
		PutAlignedString(sX, sX + 323, sY + 110, DRAW_DIALOGBOX_COMMANDER42);

		switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).sV1) {
		case 0:
			PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_COMMANDER43, 255, 255, 255);//"Guard Mode"
			PutAlignedString(sX, sX + 323, sY + 160, DRAW_DIALOGBOX_COMMANDER44, 4, 0, 50);//"Hold Mode"
			break;
		case 1:
			PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_COMMANDER43, 4, 0, 50);//"Guard Mode"
			PutAlignedString(sX, sX + 323, sY + 160, DRAW_DIALOGBOX_COMMANDER44, 255, 255, 255);//"Hold Mode"
			break;
		}
		break;

	case 4: // Set Construction point
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER47); // "Select the construction area and click."

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER48, 255, 255, 255); // "Returns to commander's main menu"
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_COMMANDER49, 255, 255, 255); // "Construction area set related help"
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21);
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272)) // shows posit on map following the mouse
		{
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 41, false, true);
		}
		break;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode) {
	case 0: // Main
	case 1: // Set TP
	case 2: // Use TP
	case 4: // Set construc
		szX = 0;
		szY = 0;
		MapSzX = 0;
		MapSzY = 0;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{
			szX = 279;
			szY = 280;
			MapSzX = 524;
			MapSzY = 524;
		}
		if (szX != 0)
		{
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
				if (m_stCrusadeStructureInfo[i].cType != 0)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_stCrusadeStructureInfo[i].sX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_stCrusadeStructureInfo[i].sY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					switch (m_stCrusadeStructureInfo[i].cType) {
					case 38:
						if (m_stCrusadeStructureInfo[i].cSide == 1)
							DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 39, false, true); // Base
						else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 37, false, true);
						break;
					case 36:
					case 37:
					case 39:
						if (m_stCrusadeStructureInfo[i].cSide == 1)
							DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 38, false, true); // Base
						else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 36, false, true);
						break;
					case 42:
						DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
						break;
					}
				}
			if (m_iTeleportLocX != -1)
			{
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				if ((m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode == 1) && (tY >= 30) && (tY <= 494)) // Place the TP
				{
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
				}
				else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
			}
			if ((m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode != 2) && (m_iConstructLocX != -1))
			{
				dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 41, false, true); // Contr pt
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{
				dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
			}
		}
		if (m_dialogBoxManager.Info(DialogBoxId::CrusadeCommander).cMode != 3)
		{
			if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
				&& (msY >= sY + 60) && (msY <= sY + 60 + 272)) // Draw mouse coordinates
			{
				dV1 = (double)(msX - (sX + 15));
				dV2 = (double)MapSzX;//(752.0f);
				dV3 = (dV2 * dV1) / szX;//280.0f;
				tX = (int)dV3;
				dV1 = (double)(msY - (sY + 60));
				dV2 = (double)MapSzX;//(680.0f);
				dV3 = (dV2 * dV1) / szY;//253.0f;
				tY = (int)dV3;
				if (tX < 30) tX = 30;
				if (tY < 30) tY = 30;
				if (tX > MapSzX - 30) tX = MapSzX - 30;
				if (tY > MapSzY - 30) tY = MapSzY - 30;
				wsprintf(G_cTxt, "%d,%d", tX, tY);
				PutString_SprFont3(msX + 10, msY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
			}
		}
		break;
	}
}

void CGame::DrawDialogBox_Constructor(int msX, int msY) // Snoopy: Fixed for 351
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint32_t dwTime = G_dwGlobalTime;
	double dV1, dV2, dV3;
	int tX, tY;
	char cMapName[12];
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans); // Main image
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 16, false, m_bDialogTrans);

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode) {
	case 0: // Main dlg
		if (m_iConstructLocX != -1)
		{
			std::memset(cMapName, 0, sizeof(cMapName));
			GetOfficialMapName(m_cConstructMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_CONSTRUCTOR1, cMapName, m_iConstructLocX, m_iConstructLocY);
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);
		}
		else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR2); //"Construction unavailable: Unable to construct"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans); // Map

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 24, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 30, dwTime);

		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);

		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR3, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR4, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR5, 255, 255, 255);
		}
		break;

	case 1: // Select building
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR6); //"Select war building"
		PutAlignedString(sX, sX + 323, sY + 80, DRAW_DIALOGBOX_CONSTRUCTOR7); //"Constructs the war building here."
		PutAlignedString(sX, sX + 323, sY + 95, DRAW_DIALOGBOX_CONSTRUCTOR8); //"Press the building icon and"
		PutAlignedString(sX, sX + 323, sY + 110, DRAW_DIALOGBOX_CONSTRUCTOR9); //"the base will be formed and slowly finished"
		PutAlignedString(sX, sX + 323, sY + 125, DRAW_DIALOGBOX_CONSTRUCTOR10);//"Attack the building with Pickaxe."
		PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_CONSTRUCTOR11);//"Building is not activated"
		PutAlignedString(sX, sX + 323, sY + 155, DRAW_DIALOGBOX_CONSTRUCTOR12);//"while constructing."

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 27, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 33, dwTime);

		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 28, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 34, dwTime);

		if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 26, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 32, dwTime);

		if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 25, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 31, dwTime);

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 322, 19, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 322, 20, dwTime);

		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 322, 18, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 322, 4, dwTime);

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR13, 255, 255, 255);//"(Mana Collector)"
		}
		else if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 50 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR14, 255, 255, 255);//"(Detector)"
		}
		else if ((msX >= sX + 20 + 100) && (msX <= sX + 20 + 100 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR15, 255, 255, 255);//"(Arrow Guard Tower)"
		}
		else if ((msX >= sX + 20 + 150) && (msX <= sX + 20 + 150 + 45) && (msY >= sY + 220) && (msY <= sY + 220 + 50))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR16, 255, 255, 255);//(Cannon Guard Tower)"
		}
		else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR17, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR18, 255, 255, 255);
		}
		break;

	case 2: // Teleport
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR19); //"Teleport to position that commander pointed"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans); // map

		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);

		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

		if ((msX >= sX + 20 + 50) && (msX <= sX + 20 + 46 + 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR20, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR21, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_CONSTRUCTOR22, 255, 255, 255);
		}
		break;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode) {
	case 0: // Main dlg
	case 2: // TP
		szX = 0;
		szY = 0;
		MapSzX = 0;
		MapSzY = 0;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{
			szX = 279;
			szY = 280;
			MapSzX = 524;
			MapSzY = 524;
		}
		if (szX != 0)
		{
			for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
				if (m_stCrusadeStructureInfo[i].cType == 42)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_stCrusadeStructureInfo[i].sX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_stCrusadeStructureInfo[i].sY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					switch (m_stCrusadeStructureInfo[i].cType) {
					case 42:
						DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
						break;
					}
				}
			if (m_iTeleportLocX != -1)
			{
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
			}
			if ((m_dialogBoxManager.Info(DialogBoxId::CrusadeConstructor).cMode != 2) && (m_iConstructLocX != -1))
			{
				dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 41, false, true); // Contr pt
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{
				dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
			}
		}
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272))  // Draw mouse coordinates
		{
			dV1 = (double)(msX - (sX + 15));
			dV2 = (double)MapSzX;//(752.0f);
			dV3 = (dV2 * dV1) / szX;//280.0f;
			tX = (int)dV3;
			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)MapSzX;//(680.0f);
			dV3 = (dV2 * dV1) / szY;//253.0f;
			tY = (int)dV3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > MapSzX - 30) tX = MapSzX - 30;
			if (tY > MapSzY - 30) tY = MapSzY - 30;
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
		}
		break;
	}
}

void CGame::DrawDialogBox_Soldier(int msX, int msY) // Snoopy: Fixed for 351
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint32_t dwTime = G_dwGlobalTime;
	char cMapName[120];
	double dV1, dV2, dV3;
	int tX, tY;
	sX = m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 17, false, m_bDialogTrans); // Crusade Soldier Menu Text

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).cMode) {
	case 0: // Main dlg, Map
		if (m_iTeleportLocX != -1)
		{
			std::memset(cMapName, 0, sizeof(cMapName));
			GetOfficialMapName(m_cTeleportMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_SOLDIER1, cMapName, m_iTeleportLocX, m_iTeleportLocY);
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);					// "Teleport position: %s near %d, %d"
		}
		else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER2); //"Teleport position is not set."

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 15, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 1, dwTime);

		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_SOLDIER3, 255, 255, 255); // "Teleport to position that commander pointed"
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_SOLDIER4, 255, 255, 255); // "Help for soldier"
		}
		break;

	case 1: // TP now
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER5); // "Teleport to position that commander pointed"
		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 15, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 1, dwTime);

		if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74 - 50, sY + 340, 19, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74 - 50, sY + 340, 20, dwTime);

		if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

		if ((msX >= sX + 20) && (msX <= sX + 20 + 46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_SOLDIER6, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74 - 50) && (msX <= sX + 20 + 46 + 150 + 74 - 50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_SOLDIER7, 255, 255, 255);
		}
		else if ((msX >= sX + 20 + 150 + 74) && (msX <= sX + 20 + 46 + 150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{
			PutString2(msX + 20, msY + 35, DRAW_DIALOGBOX_SOLDIER8, 255, 255, 255);//"Help for teleport"
		}
		break;
	}

	switch (m_dialogBoxManager.Info(DialogBoxId::CrusadeSoldier).cMode) {
	case 0: // Main
	case 1: // TP
		szX = 0;
		szY = 0;
		MapSzX = 0;
		MapSzY = 0;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{
			szX = 279;
			szY = 280;	  // Fix for ML
			MapSzX = 524; // Fix for ML
			MapSzY = 524; // Fix for ML
		}
		if (szX != 0)
		{
			for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
				if (m_stCrusadeStructureInfo[i].cType == 42)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_stCrusadeStructureInfo[i].sX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_stCrusadeStructureInfo[i].sY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					switch (m_stCrusadeStructureInfo[i].cType) {
					case 42:
						DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
						break;
					}
				}
			if (m_iTeleportLocX != -1)
			{
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{
				dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2 * (double)szX) / dV1;
				tX = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2 * (double)szY) / dV1;
				tY = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
			}
		}
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272))  // Draw mouse coordinates
		{
			dV1 = (double)(msX - (sX + 15));
			dV2 = (double)MapSzX;//(752.0f);
			dV3 = (dV2 * dV1) / szX;//280.0f;
			tX = (int)dV3;
			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)MapSzX;//(680.0f);
			dV3 = (dV2 * dV1) / szY;//253.0f;
			tY = (int)dV3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > MapSzX - 30) tX = MapSzX - 30;
			if (tY > MapSzY - 30) tY = MapSzY - 30;
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
		}
		break;
	}
}

void CGame::GrandMagicResult(char* pMapName, int iV1, int iV2, int iV3, int iV4, int iHP1, int iHP2, int iHP3, int iHP4)
{
	int i, iTxtIdx = 0;
	char cTemp[120];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	for (i = 0; i < 92; i++)
		if (m_pGameMsgList[i] == 0) return;

	if (strcmp(pMapName, "aresden") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[2]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[3]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0) {
			if ((m_bCitizen == true) && (m_bAresden == false))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[59]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[60]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[61]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[62]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if ((m_bCitizen == true) && (m_bAresden == true))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[69]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[70]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[71]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[72]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[73]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[74]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else PlaySound('E', 25, 0, 0);
		}
		else
		{
			if (iV1 != 0)
			{
				if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[63]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[64]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[65]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[75]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[76]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[77]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[78]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[79]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[80]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[81]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[82]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[66]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[67]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[68]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[83]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[84]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[85]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[86]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[87]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[88]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[89]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[90]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[7]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[8]->m_pMsg, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		std::memset(cTemp, 0, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0) {
			if ((m_bCitizen == true) && (m_bAresden == true))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[59]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[60]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[61]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[62]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if ((m_bCitizen == true) && (m_bAresden == false))
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[69]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[70]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[71]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[72]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[73]->m_pMsg, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[74]->m_pMsg, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else PlaySound('E', 25, 0, 0);
		}
		else
		{
			if (iV1 != 0) {
				if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[63]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[64]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[65]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[75]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[76]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[77]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[78]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[79]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[80]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[81]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[82]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if ((m_bCitizen == true) && (m_bAresden == true))
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[66]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[67]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[68]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((m_bCitizen == true) && (m_bAresden == false))
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[83]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[84]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[85]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[86]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[87]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[88]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[89]->m_pMsg, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, m_pGameMsgList[90]->m_pMsg, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}

	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
}

LONG CGame::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)
{
	HKEY hkey;
	LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);
	if (retval == ERROR_SUCCESS)
	{
		long datasize = MAX_PATH;
		TCHAR data[MAX_PATH];
		RegQueryValue(hkey, 0, data, &datasize);
		lstrcpy(retdata, data);
		RegCloseKey(hkey);
	}
	return retval;
}

void CGame::GoHomepage()
{
	LPCTSTR	url;
	url = MSG_HOMEPAGE;
	int		showcmd = SW_SHOW;
	char	key[MAX_PATH + MAX_PATH];
	SendMessage(G_hWnd, WM_ACTIVATEAPP, 0, 0);
	// First try ShellExecute()
	HINSTANCE result = ShellExecute(0, "open", url, 0, 0, showcmd);

	// If it failed, get the .htm regkey and lookup the program
	if ((UINT)result <= HINSTANCE_ERROR)
	{
		if (GetRegKey(HKEY_CLASSES_ROOT, ".htm", key) == ERROR_SUCCESS)
		{
			lstrcat(key, "\\shell\\open\\command");

			if (GetRegKey(HKEY_CLASSES_ROOT, key, key) == ERROR_SUCCESS)
			{
				char* pos;
				pos = strstr(key, "\"%1\"");
				if (pos == 0)					// No quotes found
				{
					pos = strstr(key, "%1");			// Check for %1, without quotes
					if (pos == 0)				// No parameter at all...
						pos = key + lstrlen(key) - 1;
					else *pos = '\0';				// Remove the parameter
				}
				else    *pos = '\0';				// Remove the parameter
				lstrcat(pos, " ");
				lstrcat(pos, url);
				result = (HINSTANCE)WinExec(key, showcmd);
			}
		}
	}
}

// num : 1 - F2, 2 - F3
void CGame::UseShortCut(int num)
{
	int index;
	if (num < 4) index = num;
	else index = num + 7;
	if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
	if (m_bCtrlPressed == true)
	{
		if (m_sRecentShortCut == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else
		{
			m_sShortCut[num] = m_sRecentShortCut;
			if (m_sShortCut[num] < 100)
			{
				if (m_pItemList[m_sShortCut[num]] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				char cStr1[64], cStr2[64], cStr3[64];
				std::memset(cStr1, 0, sizeof(cStr1));
				std::memset(cStr2, 0, sizeof(cStr2));
				std::memset(cStr3, 0, sizeof(cStr3));

				GetItemName(m_pItemList[m_sShortCut[num]], cStr1, cStr2, cStr3);
				wsprintf(G_cTxt, MSG_SHORTCUT4, cStr1, cStr2, cStr3, index);// (%s %s %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
			else if (m_sShortCut[num] >= 100)
			{
				if (m_pMagicCfgList[m_sShortCut[num] - 100] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				wsprintf(G_cTxt, MSG_SHORTCUT5, m_pMagicCfgList[m_sShortCut[num] - 100]->m_cName, index);// %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
		}
	}
	else
	{
		if (m_sShortCut[num] == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else if (m_sShortCut[num] < 100)
		{
			ItemEquipHandler((char)m_sShortCut[num]);
		}
		else if (m_sShortCut[num] >= 100) UseMagic(m_sShortCut[num] - 100);
	}
}

int CGame::iGetManaCost(int iMagicNo)
{
	int i, iManaSave, iManaCost;
	iManaSave = 0;
	if (iMagicNo < 0 || iMagicNo >= 100) return 1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_pItemList[i] == 0) continue;
		if (m_bIsItemEquipped[i] == true)
		{
			if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS10)") == 0)		iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS20)") == 0)		iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS30-LLF)") == 0) iManaSave += 30;
			else if (strcmp(m_pItemList[i]->m_cName, "WizMagicWand(MS10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "WizMagicWand(MS20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS10)") == 0) iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "DarkMageMagicStaff") == 0)	iManaSave += 25;
			else if (strcmp(m_pItemList[i]->m_cName, "DarkMageMagicStaffW") == 0) iManaSave += 25;
			else if (strcmp(m_pItemList[i]->m_cName, "DarkMageMagicWand") == 0)	iManaSave += 28;
			else if (strcmp(m_pItemList[i]->m_cName, "NecklaceOfLiche") == 0)   	iManaSave += 15;
			// Snoopy: v351 wands
			else if (strcmp(m_pItemList[i]->m_cName, "DarkMageTempleWand") == 0)	iManaSave += 28;
			else if (strcmp(m_pItemList[i]->m_cName, "BerserkWand(MS.20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "BerserkWand(MS.10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "KlonessWand(MS.20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "KlonessWand(MS.10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "ResurWand(MS.20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "ResurWand(MS.10)") == 0)	iManaSave += 10;
			// Centuu: v382 necks
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS12)") == 0) iManaSave += 12;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS14)") == 0) iManaSave += 14;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS16)") == 0) iManaSave += 16;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS18)") == 0) iManaSave += 18;
		}
	}
	// Snoopy: MS max = 80%
	if (iManaSave > 80) iManaSave = 80;
	iManaCost = m_pMagicCfgList[iMagicNo]->m_sValue1;
	if (m_bIsSafeAttackMode) iManaCost += (iManaCost / 2) - (iManaCost / 10);
	if (iManaSave > 0)
	{
		double dV1 = (double)iManaSave;
		double dV2 = (double)(dV1 / 100.0f);
		double dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;
	}
	if (iManaCost < 1) iManaCost = 1;
	return iManaCost;
}

void CGame::UseMagic(int iMagicNo)
{
	if (iMagicNo < 0 || iMagicNo >= 100) return;
	if ((m_cMagicMastery[iMagicNo] == 0) || (m_pMagicCfgList[iMagicNo] == 0)) return;

	// Casting
	if (m_iHP <= 0) return;
	if (m_bIsGetPointingMode == true) return;
	if (iGetManaCost(iMagicNo) > m_iMP) return;
	if (_bIsItemOnHand() == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC1, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC2, 10);
		return;
	}
	if ((m_sPlayerAppr2 & 0xF000) == 0) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, 0, 0, 0, 0, 0);
	m_cCommand = DEF_OBJECTMAGIC;
	m_iCastingMagicType = iMagicNo;
	m_sMagicShortCut = iMagicNo;
	m_sRecentShortCut = iMagicNo + 100;
	m_iPointCommandType = iMagicNo + 100;
	//m_bIsGetPointingMode = true;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Magic);
}


void CGame::ReleaseEquipHandler(char cEquipPos)
{
	char cStr1[64], cStr2[64], cStr3[64];
	if (m_sItemEquipmentStatus[cEquipPos] < 0) return;
	// Remove Angelic Stats
	if ((cEquipPos >= 11)
		&& (m_pItemList[m_sItemEquipmentStatus[cEquipPos]]->m_cItemType == 1))
	{
		char cItemID = m_sItemEquipmentStatus[cEquipPos];
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{
			m_iAngelicStr = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{
			m_iAngelicDex = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{
			m_iAngelicInt = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{
			m_iAngelicMag = 0;
		}
	}

	GetItemName(m_pItemList[m_sItemEquipmentStatus[cEquipPos]], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(G_cTxt, 10);
	m_bIsItemEquipped[m_sItemEquipmentStatus[cEquipPos]] = false;
	m_sItemEquipmentStatus[cEquipPos] = -1;
}

void CGame::ItemEquipHandler(char cItemID)
{
	if (bCheckItemOperationEnabled(cItemID) == false) return;
	if (m_bIsItemEquipped[cItemID] == true) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE)
	{
		AddEventList(BITEMDROP_CHARACTER3, 10);//"The item is not available."
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		AddEventList(BITEMDROP_CHARACTER1, 10); //"The item is exhausted. Fix it to use it."
		return;
	}
	if (m_pItemList[cItemID]->m_wWeight / 100 > m_iStr + m_iAngelicStr)
	{
		AddEventList(BITEMDROP_CHARACTER2, 10);
		return;
	}
	if (((m_pItemList[cItemID]->m_dwAttribute & 0x00000001) == 0) && (m_pItemList[cItemID]->m_sLevelLimit > m_iLevel))
	{
		AddEventList(BITEMDROP_CHARACTER4, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(BITEMDROP_CHARACTER5, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_cGenderLimit != 0)
	{
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			if (m_pItemList[cItemID]->m_cGenderLimit != 1)
			{
				AddEventList(BITEMDROP_CHARACTER6, 10);
				return;
			}
			break;
		case 4:
		case 5:
		case 6:
			if (m_pItemList[cItemID]->m_cGenderLimit != 2)
			{
				AddEventList(BITEMDROP_CHARACTER7, 10);
				return;
			}
			break;
		}
	}

	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EQUIPITEM, 0, cItemID, 0, 0, 0);
	m_sRecentShortCut = cItemID;
	ReleaseEquipHandler(m_pItemList[cItemID]->m_cEquipPos);
	switch (m_pItemList[cItemID]->m_cEquipPos) {
	case DEF_EQUIPPOS_HEAD:
	case DEF_EQUIPPOS_BODY:
	case DEF_EQUIPPOS_ARMS:
	case DEF_EQUIPPOS_PANTS:
	case DEF_EQUIPPOS_BOOTS:
	case DEF_EQUIPPOS_BACK:
		ReleaseEquipHandler(DEF_EQUIPPOS_FULLBODY);
		break;
	case DEF_EQUIPPOS_FULLBODY:
		ReleaseEquipHandler(DEF_EQUIPPOS_HEAD);
		ReleaseEquipHandler(DEF_EQUIPPOS_BODY);
		ReleaseEquipHandler(DEF_EQUIPPOS_ARMS);
		ReleaseEquipHandler(DEF_EQUIPPOS_PANTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BOOTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BACK);
		break;
	case DEF_EQUIPPOS_LHAND:
	case DEF_EQUIPPOS_RHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_TWOHAND);
		break;
	case DEF_EQUIPPOS_TWOHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_RHAND);
		ReleaseEquipHandler(DEF_EQUIPPOS_LHAND);
		break;
	}

	m_sItemEquipmentStatus[m_pItemList[cItemID]->m_cEquipPos] = cItemID;
	m_bIsItemEquipped[cItemID] = true;

	// Add Angelic Stats
	if ((m_pItemList[cItemID]->m_cItemType == 1)
		&& (m_pItemList[cItemID]->m_cEquipPos >= 11))
	{
		int iAngelValue = 0;
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicStr = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicDex = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicInt = 1 + iAngelValue;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicMag = 1 + iAngelValue;
		}
	}

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, BITEMDROP_CHARACTER9, cStr1);
	AddEventList(G_cTxt, 10);
	PlaySound('E', 28, 0);
}

/*********************************************************************************************************************
**  void CheckActiveAura(short sX, short sY, DWORD dwTime, short sOwnerType)( initially Cleroth fixed by Snoopy )	**
**  description			: Generates special auras around players													**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura(short sX, short sY, uint32_t dwTime, short sOwnerType)
{	// Used at the beginning of character drawing
	// DefenseShield
	if ((_tmp_iStatus & 0x02000000) != 0)
		//m_pEffectSpr[80]->PutTransSprite(sX+75, sY+107, _tmp_iEffectFrame%17, dwTime);
		m_pEffectSpr[80]->PutTransSprite50(sX + 75, sY + 107, _tmp_iEffectFrame % 17, dwTime);

	// Protection From Magic
	if ((_tmp_iStatus & 0x04000000) != 0)
		//m_pEffectSpr[79]->PutTransSprite(sX+101, sY+135, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[79]->PutTransSprite70(sX + 101, sY + 135, _tmp_iEffectFrame % 15, dwTime);

	// Protection From Arrow
	if ((_tmp_iStatus & 0x08000000) != 0)
		//m_pEffectSpr[72]->PutTransSprite(sX, sY+35, _tmp_iEffectFrame%30, dwTime);
		m_pEffectSpr[72]->PutTransSprite70(sX, sY + 35, _tmp_iEffectFrame % 30, dwTime);

	// Illusion
	if ((_tmp_iStatus & 0x01000000) != 0)
		//m_pEffectSpr[73]->PutTransSprite(sX+125, sY+95, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[73]->PutTransSprite70(sX + 125, sY + 130 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, dwTime);

	// Illusion movement
	if ((_tmp_iStatus & 0x00200000) != 0)
		//m_pEffectSpr[151]->PutTransSprite(sX+90, sY+55, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[151]->PutTransSprite70(sX + 90, sY + 90 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, dwTime);

	// Slate red  (HP)  Flame au sol
	if ((_tmp_iStatus & 0x00400000) != 0)
		//m_pEffectSpr[149]->PutTransSprite(sX+90, sY+120, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[149]->PutTransSprite70(sX + 90, sY + 120, _tmp_iEffectFrame % 15, dwTime);

	// Slate Blue (Mana) Bleu au sol
	if ((_tmp_iStatus & 0x00800000) != 0)
		//m_pEffectSpr[150]->PutTransSprite(sX+1, sY+26, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[150]->PutTransSprite70(sX + 1, sY + 26, _tmp_iEffectFrame % 15, dwTime);

	// Slate Green (XP) Mauve au sol
	if ((_tmp_iStatus & 0x00010000) != 0)
		//m_pEffectSpr[148]->PutTransSprite(sX, sY+32, _tmp_iEffectFrame%23, dwTime);
		m_pEffectSpr[148]->PutTransSprite70(sX, sY + 32, _tmp_iEffectFrame % 23, dwTime);

	// Hero Flag (Heldenian)  Flameches d'entangle
	if ((_tmp_iStatus & 0x00020000) != 0)
		//m_pEffectSpr[87]->PutTransSprite(sX+53, sY+54, _tmp_iEffectFrame%29, dwTime);
		m_pEffectSpr[87]->PutTransSprite70(sX + 53, sY + 54, _tmp_iEffectFrame % 29, dwTime);
}

/*********************************************************************************************************************
**  void CheckActiveAura2(short sX, short sY, DWORD dwTime,  _tmp_sOwnerType) ( initially Cleroth fixed by Snoopy )	**
**  description			: Generates poison aura around players. This one should be use later...						**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura2(short sX, short sY, uint32_t dwTime, short sOwnerType)
{	// Poison
	if ((_tmp_iStatus & 0x80) != 0)
		//m_pEffectSpr[81]->PutTransSprite(sX+115, sY+85, _tmp_iEffectFrame%21, dwTime);
		m_pEffectSpr[81]->PutTransSprite70(sX + 115, sY + 120 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 21, dwTime);
	//	_iAttackerHeight[]
}

// 3.51 Level Up Dialog - Changes stats Using Majestic points - Diuuude
void CGame::DrawDialogBox_ChangeStatsMajestic(short msX, short msY)
{
	short sX, sY, szX;
	uint32_t dwTime = m_dwCurTime;
	char cTxt[120];
	int iStats;
	sX = m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX + 16, sY + 100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING14);
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING15);

	// Majestic Points Left - Display in green if > 0
	PutString(sX + 20, sY + 85, DRAW_DIALOGBOX_LEVELUP_SETTING16, RGB(0, 0, 0));
	wsprintf(cTxt, "%d", m_iGizonItemUpgradeLeft);
	if (m_iGizonItemUpgradeLeft > 0)
	{
		PutString(sX + 73, sY + 102, cTxt, RGB(0, 255, 0));
	}
	else
	{
		PutString(sX + 73, sY + 102, cTxt, RGB(0, 0, 0));
	}
	// Display only MouseOver Button for - (+ is disabled)
	// Strength
	PutString(sX + 24, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING4, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iStr);
	PutString(sX + 109, sY + 125, cTxt, RGB(25, 35, 25));
	iStats = m_iStr + m_cLU_Str;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iStr)
	{
		PutString(sX + 162, sY + 125, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 125, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 127, 6, dwTime);

	// Vitality
	PutString(sX + 24, sY + 144, DRAW_DIALOGBOX_LEVELUP_SETTING5, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iVit);
	PutString(sX + 109, sY + 144, cTxt, RGB(25, 35, 25));
	iStats = m_iVit + m_cLU_Vit;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iVit)
	{
		PutString(sX + 162, sY + 144, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 144, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 146, 6, dwTime);

	// Dexterity
	PutString(sX + 24, sY + 163, DRAW_DIALOGBOX_LEVELUP_SETTING6, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iDex);
	PutString(sX + 109, sY + 163, cTxt, RGB(25, 35, 25));
	iStats = m_iDex + m_cLU_Dex;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iDex)
	{
		PutString(sX + 162, sY + 163, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 163, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 165, 6, dwTime);

	// Intelligence
	PutString(sX + 24, sY + 182, DRAW_DIALOGBOX_LEVELUP_SETTING7, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iInt);
	PutString(sX + 109, sY + 182, cTxt, RGB(25, 35, 25));
	iStats = m_iInt + m_cLU_Int;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iInt)
	{
		PutString(sX + 162, sY + 182, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 182, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 184, 6, dwTime);

	// Magic
	PutString(sX + 24, sY + 201, DRAW_DIALOGBOX_LEVELUP_SETTING8, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iMag);
	PutString(sX + 109, sY + 201, cTxt, RGB(25, 35, 25));
	iStats = m_iMag + m_cLU_Mag;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iMag)
	{
		PutString(sX + 162, sY + 201, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 201, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 203, 6, dwTime);

	// Charisma
	PutString(sX + 24, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING9, RGB(5, 5, 5));
	wsprintf(cTxt, "%d", m_iCharisma);
	PutString(sX + 109, sY + 220, cTxt, RGB(25, 35, 25));
	iStats = m_iCharisma + m_cLU_Char;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iCharisma)
	{
		PutString(sX + 162, sY + 220, cTxt, RGB(255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 220, cTxt, RGB(25, 35, 25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 222, 6, dwTime);

	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 17);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 16);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}


// 3.51 LevelUp Box - Change stats using Majestic - Diuuude
void CGame::DlgBoxClick_ChangeStatsMajestic(short msX, short msY)
{
	short sX, sY;

	sX = m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::ChangeStatsMajestic).sY;

	if ((cStateChange1 != 0) || (cStateChange2 != 0) || (cStateChange3 != 0)) {
		// Strength UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 127) && (msY <= sY + 133) && (m_cLU_Str < 0))
		{
			if (cStateChange1 == DEF_STR)
			{
				cStateChange1 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_STR)
			{
				cStateChange2 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_STR)
			{
				cStateChange3 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Vitality UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 146) && (msY <= sY + 152) && (m_cLU_Vit < 0)) {
			if (cStateChange1 == DEF_VIT)
			{
				cStateChange1 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_VIT)
			{
				cStateChange2 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_VIT)
			{
				cStateChange3 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Dexterity UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 165) && (msY <= sY + 171) && (m_cLU_Dex < 0)) {
			if (cStateChange1 == DEF_DEX) {
				cStateChange1 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_DEX) {
				cStateChange2 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_DEX) {
				cStateChange3 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Intelligence UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 184) && (msY <= sY + 190) && (m_cLU_Int < 0)) {
			if (cStateChange1 == DEF_INT) {
				cStateChange1 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_INT) {
				cStateChange2 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_INT) {
				cStateChange3 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Magic UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 203) && (msY <= sY + 209) && (m_cLU_Mag < 0)) {
			if (cStateChange1 == DEF_MAG) {
				cStateChange1 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_MAG) {
				cStateChange2 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_MAG) {
				cStateChange3 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Charisma UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 222) && (msY <= sY + 228) && (m_cLU_Char < 0)) {
			if (cStateChange1 == DEF_CHR) {
				cStateChange1 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_CHR) {
				cStateChange2 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_CHR) {
				cStateChange3 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}
	}

	if ((cStateChange1 == 0) || (cStateChange2 == 0) || (cStateChange3 == 0) && (m_iGizonItemUpgradeLeft > 0))
	{	// Strength DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133) && (m_iStr > 10))
		{
			if (cStateChange1 == 0)
			{
				cStateChange1 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0)
			{
				cStateChange2 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}
			else
			{
				cStateChange3 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Vitality DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152) && (m_iVit > 10)) {
			if (cStateChange1 == 0) {
				cStateChange1 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0) {
				cStateChange2 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			else {
				cStateChange3 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Dexterity DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171) && (m_iDex > 10)) {
			if (cStateChange1 == 0) {
				cStateChange1 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0) {
				cStateChange2 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			else {
				cStateChange3 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Intelligence DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190) && (m_iInt > 10))
		{
			if (cStateChange1 == 0)
			{
				cStateChange1 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0)
			{
				cStateChange2 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}
			else
			{
				cStateChange3 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Magic DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209) && (m_iMag > 10)) {
			if (cStateChange1 == 0) {
				cStateChange1 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0) {
				cStateChange2 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			else {
				cStateChange3 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Charisma DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228) && (m_iCharisma > 10)) {
			if (cStateChange1 == 0) {
				cStateChange1 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0) {
				cStateChange2 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			else {
				cStateChange3 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}
	}
	else
	{
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Send command to HG - Diuuude
			bSendCommand(MSGID_STATECHANGEPOINT, 0, 0, 0, 0, 0, 0);
			m_dialogBoxManager.DisableDialogBox(DialogBoxId::ChangeStatsMajestic);
			PlaySound('E', 14, 5);
		}
	}
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		m_dialogBoxManager.DisableDialogBox(DialogBoxId::ChangeStatsMajestic);
		PlaySound('E', 14, 5);
	}
}

void CGame::DrawAngel(int iSprite, short sX, short sY, char cFrame, uint32_t dwTime)
{
	switch (_tmp_cDir)
	{
	case 1:
	case 2:
	case 7:
	case 8:
		sX -= 30;
		break;
	}
	if ((_tmp_iStatus & 0x10) != 0)
	{
		if ((_tmp_iStatus & 0x1000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + iSprite]->PutTransSprite(sX, sY, cFrame, dwTime);  //AngelicPendant(STR)
		else if ((_tmp_iStatus & 0x2000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 1) + iSprite]->PutTransSprite(sX, sY, cFrame, dwTime); //AngelicPendant(DEX)
		else if ((_tmp_iStatus & 0x4000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 2) + iSprite]->PutTransSprite(sX, sY - 15, cFrame, dwTime);//AngelicPendant(INT)
		else if ((_tmp_iStatus & 0x8000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 3) + iSprite]->PutTransSprite(sX, sY - 15, cFrame, dwTime);//AngelicPendant(MAG)
	}
	else
	{
		if ((_tmp_iStatus & 0x1000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime);  //AngelicPendant(STR)
		else if ((_tmp_iStatus & 0x2000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 1) + iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime); //AngelicPendant(DEX)
		else if ((_tmp_iStatus & 0x4000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 2) + iSprite]->PutSpriteFast(sX, sY - 15, cFrame, dwTime);//AngelicPendant(INT)
		else if ((_tmp_iStatus & 0x8000) != 0)
			m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 3) + iSprite]->PutSpriteFast(sX, sY - 15, cFrame, dwTime);//AngelicPendant(MAG)
	}

}
/*********************************************************************************************************************
**  int CGame::bHasHeroSet( short m_sAppr3, short m_sAppr3, char OwnerType)		( Snoopy )							**
**  description			:: check weather the object (is character) is using a hero set (1:war, 2:mage)				**
**********************************************************************************************************************/
int CGame::bHasHeroSet(short Appr3, short Appr4, char OwnerType)
{
	char cArmor, cLeg, cBerk, cHat;
	cArmor = (Appr3 & 0xF000) >> 12;
	cLeg = (Appr3 & 0x0F00) >> 8;
	cHat = (Appr3 & 0x00F0) >> 4;
	cBerk = Appr3 & 0x000F;
	switch (OwnerType) {
	case 1:
	case 2:
	case 3:
		if ((cArmor == 8) && (cLeg == 5) && (cHat == 9) && (cBerk == 3)) return (1); // Warr elv M
		if ((cArmor == 9) && (cLeg == 6) && (cHat == 10) && (cBerk == 4)) return (1); // Warr ares M
		if ((cArmor == 10) && (cLeg == 5) && (cHat == 11) && (cBerk == 3)) return (2); // Mage elv M
		if ((cArmor == 11) && (cLeg == 6) && (cHat == 12) && (cBerk == 4)) return (2); // Mage ares M
		break;
	case 4:
	case 5:
	case 6: // fixed
		if ((cArmor == 9) && (cLeg == 6) && (cHat == 9) && (cBerk == 4)) return (1); //warr elv W
		if ((cArmor == 10) && (cLeg == 7) && (cHat == 10) && (cBerk == 5)) return (1); //warr ares W
		if ((cArmor == 11) && (cLeg == 6) && (cHat == 11) && (cBerk == 4)) return (2); //mage elv W
		if ((cArmor == 12) && (cLeg == 7) && (cHat == 12) && (cBerk == 5)) return (2); //mage ares W
		break;
	}
	return 0;
}
/*********************************************************************************************************************
**  void ShowHeldenianVictory( short sSide)				( Snoopy )													**
**  description			: Shows the Heldenian's End window															**
**********************************************************************************************************************/
void CGame::ShowHeldenianVictory(short sSide)
{
	int i, iPlayerSide;
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::Text);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (m_bCitizen == false) iPlayerSide = 0;
	else if (m_bAresden == true) iPlayerSide = 1;
	else if (m_bAresden == false) iPlayerSide = 2;
	switch (sSide) {
	case 0:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in a tie.", 0);
		break;
	case 1:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in favor of Aresden.", 0);
		break;
	case 2:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
		m_pMsgTextList[1] = new class CMsg(0, " ", 0);
		m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
		m_pMsgTextList[3] = new class CMsg(0, "in favor of Elvine.", 0);
		break;
	}
	m_pMsgTextList[4] = new class CMsg(0, " ", 0);

	if (((iPlayerSide != 1) && (iPlayerSide != 2))   // Player not a normal citizen
		|| (sSide == 0))								// or no winner
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[5] = new class CMsg(0, " ", 0);
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, " ", 0);
		m_pMsgTextList[8] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (sSide == iPlayerSide)
		{
			PlaySound('E', 23, 0, 0);
			PlaySound('C', 21, 0, 0);
			PlaySound('C', 22, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "Congratulation.", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As cityzen of victory,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You will recieve a reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "      ", 0);
		}
		else
		{
			PlaySound('E', 24, 0, 0);
			PlaySound('C', 12, 0, 0);
			PlaySound('C', 13, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "To our regret", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As cityzen of defeat,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You cannot recieve any reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "     ", 0);
		}
	}
	for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	m_dialogBoxManager.EnableDialogBox(DialogBoxId::Text, 0, 0, 0);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeCommander);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeConstructor);
	m_dialogBoxManager.DisableDialogBox(DialogBoxId::CrusadeSoldier);
}

/*********************************************************************************************************************
**  void 	ResponseHeldenianTeleportList(char *pData)									(  Snoopy )					**
**  description			: Gail's TP																					**
**********************************************************************************************************************/
void CGame::ResponseHeldenianTeleportList(char* pData)
{
	int i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	const auto* header = hb::net::PacketCast<hb::net::PacketResponseTeleportListHeader>(
		pData, sizeof(hb::net::PacketResponseTeleportListHeader));
	if (!header) return;
	const auto* entries = reinterpret_cast<const hb::net::PacketResponseTeleportListEntry*>(
		pData + sizeof(hb::net::PacketResponseTeleportListHeader));
	m_iTeleportMapCount = header->count;
	for (i = 0; i < m_iTeleportMapCount; i++)
	{
		m_stTeleportList[i].iIndex = entries[i].index;
		std::memset(m_stTeleportList[i].mapname, 0, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, entries[i].map_name, 10);
		m_stTeleportList[i].iX = entries[i].x;
		m_stTeleportList[i].iY = entries[i].y;
		m_stTeleportList[i].iCost = entries[i].cost;
	}
}

/*********************************************************************************************************************
**  void DrawDialogBox_CMDHallMenu(short msX, short msY)			( Snoopy )										**
**  description			: Draw the diag																				**
**********************************************************************************************************************/
void CGame::DrawDialogBox_CMDHallMenu(short msX, short msY)
{
	short sX, sY, szX;
	char cTxt[120];
	sX = m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sY;
	szX = m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sSizeX;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode) {
	case 0: // initial diag
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
			PutAlignedString(sX, sX + szX, sY + 70, "Teleport to Battle Field", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 70, "Teleport to Battle Field", 4, 0, 50);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
			PutAlignedString(sX, sX + szX, sY + 95, "Hire a soldier", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 95, "Hire a soldier", 4, 0, 50);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
			PutAlignedString(sX, sX + szX, sY + 120, "Taking Flags", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 120, "Taking Flags", 4, 0, 50);
		// Angels
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170))
			PutAlignedString(sX, sX + szX, sY + 145, "Receive a Tutelary Angel", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 145, "Receive a Tutelary Angel", 4, 0, 50);
		break;

	case 1: // TP diag
		if (m_iTeleportMapCount > 0)
		{	//PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_CITYHALL_MENU69, 55,25,25); // "Teleporting to dungeon level 2."
			//PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU70, 55,25,25); // "5000Gold is required"
			//PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU71, 55,25,25); //
			//PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU72, 55,25,25);//
			PutString2(sX + 35, sY + 250, DRAW_DIALOGBOX_CITYHALL_MENU72_1, 55, 25, 25);//"Civilians cannot go some area."
			for (int i = 0; i < m_iTeleportMapCount; i++)
			{
				std::memset(cTxt, 0, sizeof(cTxt));
				GetOfficialMapName(m_stTeleportList[i].mapname, cTxt);
				wsprintf(G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost);
				if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i * 15) && (msY <= sY + 144 + i * 15))
					PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, 250, 250, 0);
			}
		}
		else if (m_iTeleportMapCount == -1)
		{
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, 55, 25, 25);//"Now it's searching for possible area"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, 55, 25, 25);//"to teleport."
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU75, 55, 25, 25);//"Please wait for a moment."
		}
		else
		{
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU76, 55, 25, 25);//"There is no area that you can teleport."
		}
		break;

	case 2: // Soldier diag
		PutAlignedString(sX, sX + szX, sY + 45, "You will hire a soldier by summon points", 255, 255, 255);
		if ((m_iConstructionPoint >= 2000) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
				PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 65, 65, 65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
				PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 65, 65, 65);

		if ((m_iConstructionPoint >= 1500) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
				PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 65, 65, 65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 171))
				PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 65, 65, 65);

		if ((m_iConstructionPoint >= 4000) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195))
				PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 65, 65, 65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
		{
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220))
				PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 4, 0, 50);
		}
		else PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 65, 65, 65);

		PutAlignedString(sX, sX + szX, sY + 220, "You should join a guild to hire soldiers.", 4, 0, 50);
		wsprintf(G_cTxt, "Summon points : %d", m_iConstructionPoint);
		PutAlignedString(sX, sX + szX, sY + 250, G_cTxt, 4, 0, 50);
		PutAlignedString(sX, sX + szX, sY + 280, "Maximum summon points : 12000 points.", 4, 0, 50);
		PutAlignedString(sX, sX + szX, sY + 300, "Maximum hiring number : 5 ", 4, 0, 50);
		break;

	case 3: // Hire a Flag Diag
		PutAlignedString(sX, sX + szX, sY + 45, "You may acquire Flags with EK points.", 4, 0, 50);
		PutAlignedString(sX, sX + szX, sY + 70, "Price is 10 EK per Flag.", 4, 0, 50);
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 140) && (msY <= sY + 165))
			PutAlignedString(sX, sX + szX, sY + 140, "Take a Flag", 255, 255, 255);
		else
			PutAlignedString(sX, sX + szX, sY + 140, "Take a Flag", 250, 250, 0);
		break;

	case 4: // Tutelar Angel Diag
		PutAlignedString(sX, sX + szX, sY + 45, "5 magesty points will be deducted", 4, 0, 50);
		PutAlignedString(sX, sX + szX, sY + 80, "upon receiving the Pendant of Tutelary Angel.", 4, 0, 50);
		PutAlignedString(sX, sX + szX, sY + 105, "Would you like to receive the Tutelary Angel?", 4, 0, 50);
		wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);// "Item upgrade point : %d"
		PutAlignedString(sX, sX + szX, sY + 140, G_cTxt, 0, 0, 0);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 175) && (msY < sY + 200)
			&& (m_iGizonItemUpgradeLeft > 4))
			PutAlignedString(sX, sX + szX, sY + 175, "Tutelary Angel (STR) will be handed out.", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 175, "Tutelary Angel (STR) will be handed out.", 250, 250, 0);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 200) && (msY < sY + 225)
			&& (m_iGizonItemUpgradeLeft > 4))
			PutAlignedString(sX, sX + szX, sY + 200, "Tutelary Angel (DEX) will be handed out.", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 200, "Tutelary Angel (DEX) will be handed out.", 250, 250, 0);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 225) && (msY < sY + 250)
			&& (m_iGizonItemUpgradeLeft > 4))
			PutAlignedString(sX, sX + szX, sY + 225, "Tutelary Angel (INT) will be handed out.", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 225, "Tutelary Angel (INT) will be handed out.", 250, 250, 0);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 250) && (msY < sY + 275)
			&& (m_iGizonItemUpgradeLeft > 4))
			PutAlignedString(sX, sX + szX, sY + 250, "Tutelary Angel (MAG) will be handed out.", 255, 255, 255);
		else PutAlignedString(sX, sX + szX, sY + 250, "Tutelary Angel (MAG) will be handed out.", 250, 250, 0);

		break;
	}
}

/*********************************************************************************************************************
**  void DlgBoxClick_CMDHallMenu(short msX, short msY)			( Snoopy )											**
**  description			: Response of the player if he accepts resurection or not									**
**********************************************************************************************************************/
void CGame::DlgBoxClick_CMDHallMenu(short msX, short msY)
{
	short sX, sY;
	sX = m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sX;
	sY = m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).sY;
	switch (m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode) {
	case 0: // initial diag
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode = 1; // TP diag
			m_iTeleportMapCount = -1;
			bSendCommand(MSGID_REQUEST_HELDENIAN_TP_LIST, 0, 0, 0, 0, 0, 0);
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode = 2; // Soldier Diag
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			/*&& (m_iEnemyKillCount >= 3)*/)
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode = 3; // Flag Diag
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			/*&& (m_iEnemyKillCount >= 3)*/)
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode = 3; // Flag Diag
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170)
			/*&& (m_iGizonItemUpgradeLeft >= 5)*/)
		{
			m_dialogBoxManager.Info(DialogBoxId::GuildHallMenu).cMode = 4; // Flag Diag
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // TP now
		if (m_iTeleportMapCount > 0)
		{
			for (int i = 0; i < m_iTeleportMapCount; i++)
			{
				if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i * 15) && (msY <= sY + 144 + i * 15))
				{
					bSendCommand(MSGID_REQUEST_HELDENIAN_TP, 0, 0, m_stTeleportList[i].iIndex, 0, 0, 0);
					m_dialogBoxManager.DisableDialogBox(DialogBoxId::GuildHallMenu);
					return;
				}
			}
		}
		break;

	case 2: // Buy a soldier scroll
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 70) && (msY < sY + 95)
			&& (m_iConstructionPoint >= 2000) && (m_bIsCrusadeMode == false)) // Sorceress
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 875, 1, 2, 3, 4, "Gail", 5);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 95) && (msY < sY + 120)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false)) // ATK
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 876, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			&& (m_iConstructionPoint >= 1500) && (m_bIsCrusadeMode == false)) // Elf
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 877, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 145) && (msY < sY + 170)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false)) // DSK
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 878, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 170) && (msY < sY + 195)
			&& (m_iConstructionPoint >= 4000) && (m_bIsCrusadeMode == false)) // HBT
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 879, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 195) && (msY < sY + 220)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false)) // Barbarian
		{
			bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 880, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 3: // Buy a Flag
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 140) && (msY <= sY + 165)
			&& (m_iEnemyKillCount >= 3))
		{
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETOCCUPYFLAG, 0, 0, 0, 0, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 4: // Buy an Angel
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 175) && (msY <= sY + 200)
			&& (m_iGizonItemUpgradeLeft >= 5))
		{
			bSendCommand(DEF_REQUEST_ANGEL, 0, 0, 1, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 200) && (msY <= sY + 225)
			&& (m_iGizonItemUpgradeLeft >= 5))
		{
			bSendCommand(DEF_REQUEST_ANGEL, 0, 0, 2, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 225) && (msY <= sY + 250)
			&& (m_iGizonItemUpgradeLeft >= 5))
		{
			bSendCommand(DEF_REQUEST_ANGEL, 0, 0, 3, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 250) && (msY <= sY + 275)
			&& (m_iGizonItemUpgradeLeft >= 5))
		{
			bSendCommand(DEF_REQUEST_ANGEL, 0, 0, 4, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}

		break;
	}
}
/*********************************************************************************************************************
**  bool DKGlare(int iWeaponIndex, int iWeaponIndex, int *iWeaponGlare)	( Snoopy )									**
**  description			: test glowing condition for DK set															**
**********************************************************************************************************************/
void CGame::DKGlare(int iWeaponColor, int iWeaponIndex, int* iWeaponGlare)
{
	if (iWeaponColor != 9) return;
	if (((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64 * 14) && (iWeaponIndex < DEF_SPRID_WEAPON_M + 64 * 14 + 56)) //msw3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64 * 14) && (iWeaponIndex < DEF_SPRID_WEAPON_W + 64 * 14 + 56))) //wsw3
	{
		*iWeaponGlare = 3;
	}
	else if (((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64 * 37) && (iWeaponIndex < DEF_SPRID_WEAPON_M + 64 * 37 + 56)) //MStaff3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64 * 37) && (iWeaponIndex < DEF_SPRID_WEAPON_W + 64 * 37 + 56)))//WStaff3
	{
		*iWeaponGlare = 2;
	}
}
/*********************************************************************************************************************
**  void DrawDruncncity()	( Snoopy )																				**
**  description			: 	Placeholder for Druncncity effects (nota: bubbles already coded)						**
**********************************************************************************************************************/
void CGame::DrawDruncncity()
{	//DebugLog("druncncity");
}

/*********************************************************************************************************************
**  void CGame::Abaddon_corpse(int sX, int sY);		( Snoopy )														**
**  description			: Placeholder for abaddon's death lightnings												**
**********************************************************************************************************************/
void CGame::Abaddon_corpse(int sX, int sY)
{
	int ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir, ir, 1);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir + 2, ir, 2);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir, ir, 1);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir + 2, ir, 2);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir, ir, 1);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir, ir, 1);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir, ir, 1);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir, ir, 1);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir - 2, ir + 2, 2);

	for (int x = sX - 50; x <= sX + 100; x += rand() % 35)
		for (int y = sY - 30; y <= sY + 50; y += rand() % 45)
		{
			ir = (rand() % 20) - 10;
			_DrawThunderEffect(x, 0, x, y, ir, ir, 2);
		}
}

/*********************************************************************************************************************
**  void DebugLog(char * cStr)			( Snoopy )																	**
**  description			: writes data into "Debug.txt"																**
**********************************************************************************************************************/
void CGame::DebugLog(char* cStr)
{
	FILE* pFile;
	char cBuffer[512];
	SYSTEMTIME SysTime;
	pFile = fopen("Debug.txt", "at");
	if (pFile == 0) return;
	std::memset(cBuffer, 0, sizeof(cBuffer));
	GetLocalTime(&SysTime);
	wsprintf(cBuffer, "(%4d:%2d:%2d_%2d:%2d:%2d) - ", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
	strcat(cBuffer, cStr);
	strcat(cBuffer, "\n");
	fwrite(cBuffer, 1, strlen(cBuffer), pFile);
	fclose(pFile);
}

/*********************************************************************************************************************
**  void DebugLog(char * cStr)	( Snoopy )															**
**  description			: 															**
**********************************************************************************************************************/

//50Cent - Repair All
void CGame::NotifyMsg_RepairAllPrices(char* pData)
{
	int i;

	totalPrice = 0;
	const auto* header = hb::net::PacketCast<hb::net::PacketNotifyRepairAllPricesHeader>(
		pData, sizeof(hb::net::PacketNotifyRepairAllPricesHeader));
	if (!header) return;
	const auto* entries = reinterpret_cast<const hb::net::PacketNotifyRepairAllPricesEntry*>(
		pData + sizeof(hb::net::PacketNotifyRepairAllPricesHeader));
	totalItemRepair = header->total;

	for (i = 0; i < totalItemRepair; i++)
	{
		m_stRepairAll[i].index = entries[i].index;
		m_stRepairAll[i].price = entries[i].price;

		totalPrice += m_stRepairAll[i].price;
	}
	if (totalItemRepair == 0)
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::RepairAll, 1, 0, 0);
	else
		m_dialogBoxManager.EnableDialogBox(DialogBoxId::RepairAll, 0, 0, 0);
}